package brito.com.multitenancy001.controlplane.api.admin.accounts;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.shared.api.error.ApiException;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/admin/accounts")
@RequiredArgsConstructor
@Slf4j
public class ControlPlaneAccountController {

    private final AccountLifecycleService accountLifecycleService;

    private static final int DEFAULT_PAGE_SIZE = 20;
    private static final int MAX_PAGE_SIZE = 100;

    private Pageable pageableOrDefault(Pageable pageable) {
        if (pageable == null) {
            return PageRequest.of(0, DEFAULT_PAGE_SIZE);
        }
        int page = Math.max(0, pageable.getPageNumber());
        int size = pageable.getPageSize();

        if (size <= 0) size = DEFAULT_PAGE_SIZE;
        if (size > MAX_PAGE_SIZE) size = MAX_PAGE_SIZE;

        return PageRequest.of(page, size, pageable.getSort());
    }

    @GetMapping("/count/active")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Long> countActiveAccounts() {
        return ResponseEntity.ok(accountLifecycleService.countActiveAccounts());
    }

    @GetMapping("/latest")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Page<AccountResponse>> listAccountsLatest(Pageable pageable) {
        Pageable p = pageableOrDefault(pageable);
        return ResponseEntity.ok(accountLifecycleService.listAccountsLatest(p));
    }

    @GetMapping("/by-slug/{slug}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountResponse> getBySlugIgnoreCase(@PathVariable String slug) {
        return ResponseEntity.ok(accountLifecycleService.getAccountBySlugIgnoreCase(slug));
    }

    @GetMapping("/by-status/{status}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Page<AccountResponse>> listByStatus(@PathVariable AccountStatus status, Pageable pageable) {
        Pageable p = pageableOrDefault(pageable);
        return ResponseEntity.ok(accountLifecycleService.listAccountsByStatus(status, p));
    }

    @GetMapping("/created-between")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Page<AccountResponse>> listCreatedBetween(
            @RequestParam("start") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime start,
            @RequestParam("end") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime end,
            Pageable pageable
    ) {
        Pageable p = pageableOrDefault(pageable);
        return ResponseEntity.ok(accountLifecycleService.listAccountsCreatedBetween(start, end, p));
    }

    @GetMapping("/search")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Page<AccountResponse>> searchByDisplayName(
            @RequestParam("term") String term,
            @RequestParam("page") int page,
            @RequestParam("size") int size
    ) {
        if (page < 0) page = 0;

        if (size <= 0) {
            throw new ApiException("INVALID_PAGINATION", "size deve ser > 0", 400);
        }
        if (size > MAX_PAGE_SIZE) {
            throw new ApiException("INVALID_PAGINATION", "size máximo é " + MAX_PAGE_SIZE, 400);
        }

        Pageable p = PageRequest.of(page, size);
        return ResponseEntity.ok(accountLifecycleService.searchAccountsByDisplayName(term, p));
    }

    @GetMapping
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountResponse>> listAccounts() {
        log.info("Listando todas as contas");
        return ResponseEntity.ok(accountLifecycleService.listAccounts());
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountResponse> getAccount(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.getAccount(id));
    }

    @GetMapping("/{id}/details")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountAdminDetailsResponse> getAccountDetails(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.getAccountAdminDetails(id));
    }

    @GetMapping("/{id}/users")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountTenantUserSummaryResponse>> listUsersByAccount(@PathVariable Long id) {
        log.info("Listando Usuários por conta");
        return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, false));
    }

    @GetMapping("/{id}/users/active")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountTenantUserSummaryResponse>> listActiveUsersByAccount(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, true));
    }

    @PatchMapping("/{id}/status")
    @PreAuthorize("hasAnyAuthority('CP_TENANT_SUSPEND','CP_TENANT_ACTIVATE')")
    public ResponseEntity<AccountStatusChangeResponse> changeAccountStatus(
            @PathVariable Long id,
            @Valid @RequestBody AccountStatusChangeRequest accountStatusChangeRequest
    ) {
        return ResponseEntity.ok(accountLifecycleService.changeAccountStatus(id, accountStatusChangeRequest));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('CP_TENANT_DELETE')")
    public ResponseEntity<Void> softDeleteAccount(@PathVariable Long id) {
        accountLifecycleService.softDeleteAccount(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('CP_TENANT_ACTIVATE')")
    public ResponseEntity<Void> restoreAccount(@PathVariable Long id) {
        accountLifecycleService.restoreAccount(id);
        return ResponseEntity.noContent().build();
    }
    
 // =========================================================
 // ✅ NOVOS ENDPOINTS (usar queries do AccountRepository)
 // =========================================================

 @GetMapping("/count/by-status/{status}")
 @PreAuthorize("hasAuthority('CP_TENANT_READ')")
 public ResponseEntity<Long> countByStatus(@PathVariable AccountStatus status) {
     return ResponseEntity.ok(accountLifecycleService.countAccountsByStatus(status));
 }

 @GetMapping("/by-statuses")
 @PreAuthorize("hasAuthority('CP_TENANT_READ')")
 public ResponseEntity<List<AccountResponse>> listByStatuses(
         @RequestParam("statuses") List<AccountStatus> statuses
 ) {
     return ResponseEntity.ok(accountLifecycleService.listAccountsByStatuses(statuses));
 }

 /**
  * Ex.: /api/admin/accounts/expired-trials
  * Ex.: /api/admin/accounts/expired-trials?date=2026-01-18T10:00:00&status=FREE_TRIAL
  */
 @GetMapping("/expired-trials")
 @PreAuthorize("hasAuthority('CP_TENANT_READ')")
 public ResponseEntity<List<AccountResponse>> listExpiredTrials(
         @RequestParam(value = "date", required = false)
         @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime date,

         @RequestParam(value = "status", required = false) AccountStatus status
 ) {
     return ResponseEntity.ok(accountLifecycleService.listExpiredTrials(date, status));
 }

 /**
  * Ex.: /api/admin/accounts/overdue
  * Ex.: /api/admin/accounts/overdue?today=2026-01-18T10:00:00&status=ACTIVE
  */
 @GetMapping("/overdue")
 @PreAuthorize("hasAuthority('CP_TENANT_READ')")
 public ResponseEntity<List<AccountResponse>> listOverdue(
         @RequestParam(value = "today", required = false)
         @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime today,

         @RequestParam(value = "status", required = false) AccountStatus status
 ) {
     return ResponseEntity.ok(accountLifecycleService.listOverdueAccounts(today, status));
 }

}
package brito.com.multitenancy001.controlplane.api.admin.auth;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.application.ControlPlaneAuthService;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/auth")
@RequiredArgsConstructor
public class ControlPlaneAuthController {

    private final ControlPlaneAuthService controlPlaneAuthService;

    @PostMapping("/login")
    public ResponseEntity<JwtResponse> loginControlPlaneUser(
            @Valid @RequestBody ControlPlaneAdminLoginRequest request
    ) {
        JwtResponse response = controlPlaneAuthService.loginControlPlaneUser(request);
        return ResponseEntity.ok(response);
    }
}
package brito.com.multitenancy001.controlplane.api.admin.billing;

import brito.com.multitenancy001.controlplane.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.application.billing.ControlPLanePaymentService;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;
import jakarta.validation.Valid;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/admin/billing/payments")
@RequiredArgsConstructor
@Validated
public class ControlPlanePaymentController {

    private final ControlPLanePaymentService controlPlanePaymentService;

    // =========================================================
    // ADMIN / CROSS-TENANT
    // =========================================================

    @PostMapping("/by-account/{accountId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> processPaymentForAccount(
            @PathVariable Long accountId,
            @Valid @RequestBody AdminPaymentRequest body
    ) {
        // Garante que o accountId do path manda (evita inconsistência)
        AdminPaymentRequest adminPaymentRequest = new AdminPaymentRequest(
                accountId,
                body.amount(),
                body.paymentMethod(),
                body.paymentGateway(),
                body.description()
        );

        PaymentResponse response = controlPlanePaymentService.processPaymentForAccount(adminPaymentRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/by-account/{accountId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getPaymentsByAccountAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByAccount(accountId));
    }

    @GetMapping("/by-account/{accountId}/active")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<Boolean> hasActivePaymentAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentService.hasActivePayment(accountId));
    }

    @PostMapping("/{paymentId}/complete-manual")
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> completeManually(@PathVariable Long paymentId) {
        return ResponseEntity.ok(controlPlanePaymentService.completePaymentManually(paymentId));
    }

    @PostMapping("/{paymentId}/refund")
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> refund(
            @PathVariable Long paymentId,
            @Valid @RequestBody RefundRequest refundRequest
    ) {
        PaymentResponse response =
                controlPlanePaymentService.refundPayment(paymentId, refundRequest.amount(), refundRequest.reason());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/revenue")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<BigDecimal> getRevenue(
            @RequestParam("start")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam("end")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getTotalRevenue(startDate, endDate));
    }

    public record RefundRequest(
            @DecimalMin(value = "0.01", message = "amount deve ser > 0 quando informado")
            BigDecimal amount,

            @NotBlank(message = "reason é obrigatório")
            String reason
    ) {}
    
 // =========================================================
 // ✅ NOVOS ENDPOINTS (usar métodos do PaymentRepository)
 // =========================================================

 @GetMapping("/by-account/{accountId}/exists/{paymentId}")
 @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
 public ResponseEntity<Boolean> existsByIdAndAccountId(
         @PathVariable Long accountId,
         @PathVariable Long paymentId
 ) {
     return ResponseEntity.ok(controlPlanePaymentService.paymentExistsForAccount(paymentId, accountId));
 }

 @GetMapping("/by-account/{accountId}/status/{status}")
 @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
 public ResponseEntity<List<PaymentResponse>> getPaymentsByAccountAndStatus(
         @PathVariable Long accountId,
         @PathVariable PaymentStatus status
 ) {
     return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByAccountAndStatus(accountId, status));
 }

 @GetMapping("/by-transaction/{transactionId}")
 @PreAuthorize("hasAuthority('CP_BILLING_READ')")
 public ResponseEntity<PaymentResponse> getByTransactionId(@PathVariable String transactionId) {
     return ResponseEntity.ok(controlPlanePaymentService.getPaymentByTransactionId(transactionId));
 }

 @GetMapping("/exists/by-transaction/{transactionId}")
 @PreAuthorize("hasAuthority('CP_BILLING_READ')")
 public ResponseEntity<Boolean> existsByTransactionId(@PathVariable String transactionId) {
     return ResponseEntity.ok(controlPlanePaymentService.existsByTransactionId(transactionId));
 }

 @GetMapping("/valid-until-before")
 @PreAuthorize("hasAuthority('CP_BILLING_READ')")
 public ResponseEntity<List<PaymentResponse>> listByValidUntilBeforeAndStatus(
         @RequestParam("date")
         @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime date,
         @RequestParam("status") PaymentStatus status
 ) {
     return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByValidUntilBeforeAndStatus(date, status));
 }

 @GetMapping("/by-account/{accountId}/completed")
 @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
 public ResponseEntity<List<PaymentResponse>> getCompletedPaymentsByAccount(@PathVariable Long accountId) {
     return ResponseEntity.ok(controlPlanePaymentService.getCompletedPaymentsByAccount(accountId));
 }

 @GetMapping("/period")
 @PreAuthorize("hasAuthority('CP_BILLING_READ')")
 public ResponseEntity<List<PaymentResponse>> listPaymentsInPeriod(
         @RequestParam("start")
         @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
         @RequestParam("end")
         @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate
 ) {
     return ResponseEntity.ok(controlPlanePaymentService.getPaymentsInPeriod(startDate, endDate));
 }

    
    
}
package brito.com.multitenancy001.controlplane.api.admin.me;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneChangeMyPasswordRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneMeResponse;
import brito.com.multitenancy001.controlplane.application.user.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/me")
@RequiredArgsConstructor
public class ControlPlaneMeController {

    private final ControlPlaneUserService controlPlaneUserService;

    // ✅ usado pelo front mesmo quando mustChangePassword=true
    @GetMapping
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<ControlPlaneMeResponse> me() {
        return ResponseEntity.ok(controlPlaneUserService.getMe());
    }

    // ✅ autenticado: qualquer user CP pode trocar a própria senha
    @PatchMapping("/password")
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<Void> changeMyPassword(@Valid @RequestBody ControlPlaneChangeMyPasswordRequest request) {
        controlPlaneUserService.changeMyPassword(request);
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.controlplane.api.admin.users;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserPermissionsUpdateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserUpdateRequest;
import brito.com.multitenancy001.controlplane.application.user.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/controlplane-users")
@RequiredArgsConstructor
public class ControlPlaneUserController {

    private final ControlPlaneUserService controlPlaneUserService;

    @PostMapping
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> createControlPlaneUser(
            @Valid @RequestBody ControlPlaneUserCreateRequest request
    ) {
        ControlPlaneUserDetailsResponse response = controlPlaneUserService.createControlPlaneUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listControlPlaneUsers() {
        return ResponseEntity.ok(controlPlaneUserService.listControlPlaneUsers());
    }

    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getControlPlaneUser(userId));
    }

    /**
     * ✅ Update geral:
     * - name/email/role/username/permissions (se você decidir aceitar tudo aqui)
     * - Service faz as barreiras:
     *   - bloqueia update se builtInUser =true
     *   - bloqueia rename para username reservado
     *   - bloqueia alterar permissions se não for OWNER (e bloqueia se builtInUser =true)
     */
    @PatchMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUser(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserUpdateRequest request
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUser(userId, request));
    }

    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUserStatus(
            @PathVariable Long userId,
            @RequestParam boolean active
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUserStatus(userId, active));
    }

    /**
     * ✅ Endpoint dedicado para permissions:
     * - Service faz as barreiras:
     *   - bloqueia se builtInUser =true
     *   - só OWNER pode
     */
    @PatchMapping("/{userId}/permissions")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUserPermissions(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserPermissionsUpdateRequest request
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUserPermissions(userId, request));
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_DELETE')")
    public ResponseEntity<Void> deleteControlPlaneUser(@PathVariable Long userId) {
        controlPlaneUserService.softDeleteControlPlaneUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> restoreControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.restoreControlPlaneUser(userId));
    }
    
    
    @PatchMapping("/{userId}/reset-password")
    @PreAuthorize("hasAuthority('CP_USER_PASSWORD_RESET')")
    public ResponseEntity<Void> resetPassword(
            @PathVariable Long userId,
            @Valid @RequestBody brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserPasswordResetRequest request
    ) {
        controlPlaneUserService.resetControlPlaneUserPassword(userId, request);
        return ResponseEntity.noContent().build();
    }


}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.TaxIdType;
import java.time.LocalDateTime;

public record AccountAdminDetailsResponse(

    // Identificação
    Long id,
    String displayName,
    String slug,
    String schemaName,
    String status,

    // Dados legais (sempre em conjunto)
    TaxIdType taxIdType,
    String taxIdNumber,

    // Datas
    LocalDateTime createdAt,
    LocalDateTime trialEndDate,
    LocalDateTime paymentDueDate,
    LocalDateTime deletedAt,

    // Flags calculadas
    boolean inTrial,
    boolean trialExpired,
    long trialDaysRemaining,

    // Admin da conta
    ControlPlaneAdminUserSummaryResponse admin,

    // Indicadores
    long totalControlPlaneUsers,
    boolean active
) {

   
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import java.time.LocalDateTime;

public record AccountResponse(
        Long id,
        String displayName,
        String slug,
        String schemaName,
        String status,
        String accountType,
        String subscriptionPlan,
        LocalDateTime createdAt,
        LocalDateTime trialEndDate,
        ControlPlaneAdminUserSummaryResponse platformAdmin
) {}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public record AccountStatusChangeRequest(
		@NotNull(message = "status é obrigatório")
        AccountStatus status,
        @Size(max = 255, message = "reason deve ter no máximo 255 caracteres")
        String reason
) {    }
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import java.time.LocalDateTime;

public record AccountStatusChangeResponse(
        Long id,
        String status,
        String previousStatus,
        LocalDateTime effectiveAt,
        String tenantSchema,
        SideEffects sideEffects
) {
    public record SideEffects(
            boolean tenantUsersUpdated,
            String action,     // "SUSPEND_BY_ACCOUNT" | "UNSUSPEND_BY_ACCOUNT" | "CANCELLED" | "NONE"
            int tenantUsersCount
    ) {}
}
package brito.com.multitenancy001.controlplane.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record ControlPlaneAdminLoginRequest(
	    @NotBlank String username,
	    @NotBlank String password
	) {}package brito.com.multitenancy001.controlplane.api.dto.billing;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record AdminPaymentRequest(

        @NotNull
        Long accountId,

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotBlank
        String paymentMethod,

        @NotBlank
        String paymentGateway,

        String description
) {}
package brito.com.multitenancy001.controlplane.api.dto.billing;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record PaymentRequest(

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotBlank
        String paymentMethod,

        @NotBlank
        String paymentGateway,

        String description
) {}
package brito.com.multitenancy001.controlplane.api.dto.billing;



import java.math.BigDecimal;
import java.time.LocalDateTime;

public record PaymentResponse(
	    Long id,
	    Long accountId,
	    BigDecimal amount,
	    LocalDateTime paymentDate,
	    LocalDateTime validUntil,
	    String status,
	    String transactionId,
	    String paymentMethod,
	    String paymentGateway,
	    String description,
	    LocalDateTime createdAt,
	    LocalDateTime updatedAt
	) {}

package brito.com.multitenancy001.controlplane.api.dto.signup;

import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import brito.com.multitenancy001.controlplane.domain.account.TaxIdType;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record SignupRequest(

    @NotBlank(message = "Nome da empresa é obrigatório")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    String displayName,

    @NotBlank(message = "Email da empresa é obrigatório")
    @Email(message = "Email inválido")
    String loginEmail,

    @NotNull(message = "Tipo de documento é obrigatório (CPF ou CNPJ)")
    TaxIdType taxIdType,

    @NotBlank(message = "Número do documento é obrigatório")
    String taxIdNumber,

    @NotBlank(message = "Senha é obrigatória")
    @Pattern(
        regexp = ValidationPatterns.PASSWORD_PATTERN,
        message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas e números"
    )
    String password,

    @NotBlank(message = "Confirmação de senha é obrigatória")
    String confirmPassword
) 
	{
		   @AssertTrue(message = "As senhas não coincidem")
		   public boolean isPasswordMatching() {
		      if (password == null || confirmPassword == null) return true; // deixa @NotBlank fazer o trabalho
		      return password.equals(confirmPassword);
		   }
}
package brito.com.multitenancy001.controlplane.api.dto.users;

public record ControlPlaneAdminUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {
   
}
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record ControlPlaneChangeMyPasswordRequest(

        @NotBlank(message = "Senha atual é obrigatória")
        @Size(min = 8, max = 72, message = "Senha atual deve ter entre 8 e 72 caracteres")
        String currentPassword,

        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, max = 72, message = "Nova senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar senha é obrigatório")
        @Size(min = 8, max = 72, message = "Confirmar senha deve ter entre 8 e 72 caracteres")
        String confirmPassword
) {}
package brito.com.multitenancy001.controlplane.api.dto.users;

import java.util.List;

public record ControlPlaneMeResponse(
        Long userId,
        String username,
        String email,
        String roleAuthority,
        Long accountId,
        boolean mustChangePassword,
        List<String> authorities
) {}
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.List;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

@Builder
public record ControlPlaneUserCreateRequest(
    
    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String name,
    
    @NotBlank(message = "Username é obrigatório")
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inválido...")
    @Size(min = 3, max = 50, message = "Username deve ter entre 3 e 50 caracteres")
    String username,

 
    
    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email inválido")
    @Size(max = 150, message = "Email não pode exceder 150 caracteres")
    String email,
    
    @NotBlank(message = "Senha é obrigatória")
    @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, 
             message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais")
    String password,
    
    @NotNull(message = "Role é obrigatória")
    ControlPlaneRole role,

    
    List<String> permissions,
    

    @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, 
             message = "Telefone inválido")
    @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
    String phone,
    
    @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
    String avatarUrl
    
) {
    
    public ControlPlaneUserCreateRequest {
        if (phone != null) {
            phone = phone.trim();
        }
        if (avatarUrl != null) {
            avatarUrl = avatarUrl.trim();
        }
    }
}package brito.com.multitenancy001.controlplane.api.dto.users;



import java.time.LocalDateTime;
import java.util.List;

public record ControlPlaneUserDetailsResponse(
    Long id,
    String username,
    String name,
    String email,
    String role,
    boolean suspendedByAccount,
    boolean suspendedByAdmin,
    LocalDateTime createdAt,
    LocalDateTime updatedAt,
    Long accountId,
    List<String> permissions
) {
    public ControlPlaneUserDetailsResponse {
        if (permissions == null) {
            permissions = List.of();
        }
    }
}package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record ControlPlaneUserPasswordResetRequest(

        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, max = 72, message = "Senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar senha é obrigatório")
        @Size(min = 8, max = 72, message = "Confirmar senha deve ter entre 8 e 72 caracteres")
        String confirmPassword

) {}
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Pattern;

import java.util.List;

public record ControlPlaneUserPermissionsUpdateRequest(

        @NotEmpty(message = "Lista de permissões não pode ser vazia")
        List<
            @Pattern(
                regexp = "^CP_[A-Z0-9_]+$",
                message = "Permissões de ControlPlane devem começar com CP_"
            )
            String
        > permissions
) {}
package brito.com.multitenancy001.controlplane.api.dto.users;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

import java.util.List;

public record ControlPlaneUserUpdateRequest(

        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email deve ter no máximo 150 caracteres")
        String email,

        // opcional: só pode alterar se NÃO for builtIn user (validado no service)
        @Pattern(
                regexp = ValidationPatterns.USERNAME_PATTERN,
                message = "Username inválido"
        )
        @Size(min = 3, max = 100, message = "Username deve ter entre 3 e 100 caracteres")
        String username,

        // opcional: troca de role (policy no service)
        ControlPlaneRole role,

        // opcional: só OWNER pode enviar e não pode ser builtIn user (policy no service)
        List<
            @Pattern(
                regexp = "^CP_[A-Z0-9_]+$",
                message = "Permissões de ControlPlane devem começar com CP_"
            )
            String
        > permissions
) {}
package brito.com.multitenancy001.controlplane.api.dto.users.summary;

public record AccountTenantUserSummaryResponse(
        Long id,
        Long accountId,
        String name,
        String username,
        String email,
        String role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}
package brito.com.multitenancy001.controlplane.api.mapper;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.time.AppClock;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

@Component
public class AccountAdminDetailsApiMapper {

    private final AppClock appClock;
    private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;

    public AccountAdminDetailsApiMapper(AppClock appClock, ControlPlaneUserApiMapper controlPlaneUserApiMapper) {
        this.appClock = appClock;
        this.controlPlaneUserApiMapper = controlPlaneUserApiMapper;
    }

    public AccountAdminDetailsResponse toResponse(Account account, ControlPlaneUser admin, long totalUsers) {
        LocalDateTime now = appClock.now();
        LocalDate today = now.toLocalDate();
        LocalDate end = account.getTrialEndDate() != null ? account.getTrialEndDate().toLocalDate() : null;

        boolean inTrial = account.getTrialEndDate() != null && now.isBefore(account.getTrialEndDate());
        boolean trialExpired = account.getTrialEndDate() != null && now.isAfter(account.getTrialEndDate());

        long trialDaysRemaining = 0;
        if (inTrial && end != null) {
            trialDaysRemaining = ChronoUnit.DAYS.between(today, end);
        }

        return new AccountAdminDetailsResponse(
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getSchemaName(),
                account.getStatus().name(),

                account.getTaxIdType(),
                account.getTaxIdNumber(),

                account.getCreatedAt(),
                account.getTrialEndDate(),
                account.getPaymentDueDate(),
                account.getDeletedAt(),

                inTrial,
                trialExpired,
                trialDaysRemaining,

                admin != null ? controlPlaneUserApiMapper.toAdminSummary(admin) : null,

                totalUsers,
                account.isActive(now) // ✅ agora clock-aware
        );
    }
}
package brito.com.multitenancy001.controlplane.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class AccountApiMapper {

    private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;

    public AccountResponse toResponse(Account account) {
        return new AccountResponse(
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getSchemaName(),
                account.getStatus().name(),
                account.getType().name(),
                account.getSubscriptionPlan().name(), // NOVO
                account.getCreatedAt(),
                account.getTrialEndDate(),
                null
        );
    }

    public AccountResponse toResponse(Account account, ControlPlaneUser adminUser) {
        ControlPlaneAdminUserSummaryResponse adminResponse =
                adminUser != null ? controlPlaneUserApiMapper.toAdminSummary(adminUser) : null;

        return new AccountResponse(
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getSchemaName(),
                account.getStatus().name(),
                account.getType().name(),
                account.getSubscriptionPlan().name(), // NOVO
                account.getCreatedAt(),
                account.getTrialEndDate(),
                adminResponse
        );
    }
}
package brito.com.multitenancy001.controlplane.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;

@Component
public class AccountUserApiMapper {

    public AccountTenantUserSummaryResponse toAccountUserSummary(UserSummaryData user) {

        boolean enabled =
                !user.deleted()
                && !user.suspendedByAccount()
                && !user.suspendedByAdmin();

        return new AccountTenantUserSummaryResponse(
                user.id(),
                user.accountId(),
                user.name(),
                user.username(),
                user.email(),
                user.role(),
                user.suspendedByAccount(),
                user.suspendedByAdmin(),
                enabled
        );
    }
}
package brito.com.multitenancy001.controlplane.api.mapper;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.time.AppClock;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
public class ControlPlaneUserApiMapper {

    private final AppClock appClock;

    public ControlPlaneUserApiMapper(AppClock appClock) {
        this.appClock = appClock;
    }

    public ControlPlaneAdminUserSummaryResponse toAdminSummary(ControlPlaneUser user) {
        LocalDateTime now = appClock.now();
        boolean enabled = user.isEnabledForLogin(now);

        return new ControlPlaneAdminUserSummaryResponse(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                enabled
        );
    }
}
package brito.com.multitenancy001.controlplane.api.publicsignup;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/signup")
@RequiredArgsConstructor
public class AccountSignupController {

    private final AccountLifecycleService accountLifecycleService;

    @PostMapping
    public ResponseEntity<AccountResponse> signup(@Valid @RequestBody SignupRequest signupRequest) {
        AccountResponse response = accountLifecycleService.createAccount(signupRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}
package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import brito.com.multitenancy001.controlplane.persistence.account.AccountEntitlementsRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsProvisioningService {

    private final AccountEntitlementsRepository entitlementsRepository;

    @Transactional(transactionManager = "publicTransactionManager")
    public void ensureDefaultEntitlementsForTenant(Account account) {
        if (account == null || account.getId() == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "Conta é obrigatória", 400);
        }

        if (account.isBuiltInAccount()) {
            // BUILTIN não tem entitlements
            return;
        }

        if (entitlementsRepository.existsById(account.getId())) {
            return;
        }

        AccountEntitlements ent = AccountEntitlements.builder()
                .account(account)
                .maxUsers(5)
                .maxProducts(100)
                .maxStorageMb(100)
                .build();

        entitlementsRepository.save(ent);
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.mapper.AccountAdminDetailsApiMapper;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountLifecycleService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final AccountAdminDetailsApiMapper accountAdminDetailsApiMapper;
    private final AccountApiMapper accountApiMapper;
    private final PublicExecutor publicExecutor;
    private final AccountRepository accountRepository;
    private final AccountOnboardingService accountOnboardingService;
    private final AccountStatusService accountStatusService;
    private final AccountTenantUserService accountTenantUserService;

    // =========================================================
    // 1) ONBOARDING / SIGNUP
    // =========================================================

    public AccountResponse createAccount(SignupRequest signupRequest) {
        return accountOnboardingService.createAccount(signupRequest);
    }

    // =========================================================
    // 2) CONSULTAS EXISTENTES
    // =========================================================

    @Transactional(readOnly = true)
    public List<AccountResponse> listAccounts() {
        return publicExecutor.run(() ->
                accountRepository.findAllByDeletedFalse()
                        .stream()
                        .map(accountApiMapper::toResponse)
                        .toList()
        );
    }

    @Transactional(readOnly = true)
    public AccountResponse getAccount(Long accountId) {
        return publicExecutor.run(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
            return accountApiMapper.toResponse(account);
        });
    }

    @Transactional(readOnly = true)
    public AccountAdminDetailsResponse getAccountAdminDetails(Long accountId) {
        return publicExecutor.run(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            long totalUsers = controlPlaneUserRepository.countByAccountIdAndDeletedFalse(accountId);

            return accountAdminDetailsApiMapper.toResponse(account, null, totalUsers);
        });
    }

    // =========================================================
    // 3) STATUS / SOFT DELETE / RESTORE (EXISTENTES)
    // =========================================================

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        return accountStatusService.changeAccountStatus(accountId, req);
    }

    public void softDeleteAccount(Long accountId) {
        accountStatusService.softDeleteAccount(accountId);
    }

    public void restoreAccount(Long accountId) {
        accountStatusService.restoreAccount(accountId);
    }

    public List<AccountTenantUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyActive) {
        return accountTenantUserService.listTenantUsers(accountId, onlyActive);
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        accountTenantUserService.setUserSuspendedByAdmin(accountId, userId, suspended);
    }

    // =========================================================
    // ✅ 4) NOVAS CONSULTAS ADMIN (PAGINAÇÃO + LIMITES)
    // =========================================================

    private static final int DEFAULT_PAGE_SIZE = 20;
    private static final int MAX_PAGE_SIZE = 100;
    private static final long MAX_CREATED_BETWEEN_DAYS = 90;

    private Pageable normalizePageable(Pageable pageable) {
        if (pageable == null) {
            return PageRequest.of(0, DEFAULT_PAGE_SIZE);
        }

        int page = Math.max(0, pageable.getPageNumber());
        int size = pageable.getPageSize();

        if (size <= 0) size = DEFAULT_PAGE_SIZE;
        if (size > MAX_PAGE_SIZE) size = MAX_PAGE_SIZE;

        return PageRequest.of(page, size, pageable.getSort());
    }

    private void assertValidCreatedBetweenRange(LocalDateTime start, LocalDateTime end) {
        if (start == null || end == null) {
            throw new ApiException("INVALID_DATE_RANGE", "start e end são obrigatórios", 400);
        }
        if (end.isBefore(start)) {
            throw new ApiException("INVALID_DATE_RANGE", "end deve ser >= start", 400);
        }

        long days = Duration.between(start, end).toDays();
        if (days > MAX_CREATED_BETWEEN_DAYS) {
            throw new ApiException(
                    "DATE_RANGE_TOO_LARGE",
                    "Intervalo máximo permitido é de " + MAX_CREATED_BETWEEN_DAYS + " dias",
                    400
            );
        }
    }

    @Transactional(readOnly = true)
    public long countActiveAccounts() {
        return publicExecutor.run(accountRepository::countActiveAccounts);
    }

    @Transactional(readOnly = true)
    public Page<AccountResponse> listAccountsLatest(Pageable pageable) {
        Pageable p = normalizePageable(pageable);

        return publicExecutor.run(() ->
                accountRepository.findByDeletedFalseOrderByCreatedAtDesc(p)
                        .map(accountApiMapper::toResponse)
        );
    }

    @Transactional(readOnly = true)
    public AccountResponse getAccountBySlugIgnoreCase(String slug) {
        if (slug == null || slug.isBlank()) {
            throw new ApiException("INVALID_SLUG", "slug é obrigatório", 400);
        }

        return publicExecutor.run(() -> {
            Account account = accountRepository.findBySlugAndDeletedFalseIgnoreCase(slug.trim())
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
            return accountApiMapper.toResponse(account);
        });
    }

    @Transactional(readOnly = true)
    public Page<AccountResponse> listAccountsByStatus(AccountStatus status, Pageable pageable) {
        if (status == null) {
            throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
        }

        Pageable p = normalizePageable(pageable);

        return publicExecutor.run(() ->
                accountRepository.findByStatusAndDeletedFalse(status, p)
                        .map(accountApiMapper::toResponse)
        );
    }

    @Transactional(readOnly = true)
    public Page<AccountResponse> listAccountsCreatedBetween(LocalDateTime start, LocalDateTime end, Pageable pageable) {
        assertValidCreatedBetweenRange(start, end);

        Pageable p = normalizePageable(pageable);

        return publicExecutor.run(() ->
                accountRepository.findAccountsCreatedBetween(start, end, p)
                        .map(accountApiMapper::toResponse)
        );
    }

    @Transactional(readOnly = true)
    public Page<AccountResponse> searchAccountsByDisplayName(String term, Pageable pageable) {
        if (term == null || term.isBlank()) {
            throw new ApiException("INVALID_SEARCH", "term é obrigatório", 400);
        }

        Pageable p = normalizePageable(pageable);

        return publicExecutor.run(() ->
                accountRepository.searchByDisplayName(term.trim(), p)
                        .map(accountApiMapper::toResponse)
        );
    }
    
    
 // =========================================================
 // ✅ 5) QUERIES ADMIN (usar métodos do AccountRepository)
 // =========================================================

 @Transactional(readOnly = true)
 public long countAccountsByStatus(AccountStatus status) {
     if (status == null) {
         throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
     }
     return publicExecutor.run(() -> accountRepository.countByStatusAndDeletedFalse(status));
 }

 @Transactional(readOnly = true)
 public List<AccountResponse> listAccountsByStatuses(List<AccountStatus> statuses) {
     if (statuses == null || statuses.isEmpty()) {
         throw new ApiException("INVALID_STATUS_LIST", "statuses é obrigatório", 400);
     }

     return publicExecutor.run(() ->
             accountRepository.findByStatuses(statuses).stream()
                     .map(accountApiMapper::toResponse)
                     .toList()
     );
 }

 @Transactional(readOnly = true)
 public List<AccountResponse> listExpiredTrials(LocalDateTime date, AccountStatus status) {
     // defaults seguros
     LocalDateTime d = (date != null ? date : LocalDateTime.now());
     AccountStatus st = (status != null ? status : AccountStatus.FREE_TRIAL);

     return publicExecutor.run(() ->
             accountRepository.findExpiredTrials(d, st).stream()
                     .map(accountApiMapper::toResponse)
                     .toList()
     );
 }

 @Transactional(readOnly = true)
 public List<AccountResponse> listOverdueAccounts(LocalDateTime today, AccountStatus status) {
     // defaults seguros
     LocalDateTime t = (today != null ? today : LocalDateTime.now());
     AccountStatus st = (status != null ? status : AccountStatus.ACTIVE);

     return publicExecutor.run(() ->
             accountRepository.findOverdueAccounts(st, t).stream()
                     .map(accountApiMapper::toResponse)
                     .toList()
     );
 }

}
package brito.com.multitenancy001.controlplane.application;

import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.tenant.TenantProvisioningBridge;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserAdminBridge;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import brito.com.multitenancy001.shared.executor.TxExecutor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountOnboardingService {

    private final AccountApiMapper accountApiMapper;
    private final PublicExecutor publicExecutor;
    private final TxExecutor txExecutor;
    private final PublicAccountCreationService publicAccountCreationService;
    private final TenantProvisioningBridge tenantProvisioningBridge;
    private final TenantUserAdminBridge tenantUserAdminBridge;
    private final AccountRepository accountRepository;

    public AccountResponse createAccount(SignupRequest signupRequest) {
        validateSignupRequest(signupRequest);

        log.info("Tentando criar conta");

        Account account = txExecutor.publicTx(() ->
            publicExecutor.run(() -> publicAccountCreationService.createAccountFromSignup(signupRequest))
        );

        tenantProvisioningBridge.ensureSchemaExistsAndMigrate(account.getSchemaName());

        tenantUserAdminBridge.createTenantOwner(
            account.getSchemaName(),
            account.getId(),
            signupRequest.loginEmail(),
            signupRequest.password()
        );

        log.info("✅ Account criada | accountId={} | schemaName={} | slug={}",
                account.getId(), account.getSchemaName(), account.getSlug());

        return accountApiMapper.toResponse(account);
    }

    private void validateSignupRequest(SignupRequest signupRequest) {
    	
    	if (accountRepository.existsByTaxCountryCodeAndTaxIdTypeAndTaxIdNumberAndDeletedFalse(
    	        "BR", signupRequest.taxIdType(), signupRequest.taxIdNumber()
    	)) {
    	    throw new ApiException("DOC_ALREADY_REGISTERED", "Documento já cadastrado na plataforma", 409);
    	}

    	
        if (!StringUtils.hasText(signupRequest.displayName())) {
            throw new ApiException("INVALID_COMPANY_NAME", "Nome da empresa é obrigatório", 400);
        }

        if (!StringUtils.hasText(signupRequest.loginEmail())) {
            throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
        }

        if (!signupRequest.loginEmail().contains("@")) {
            throw new ApiException("INVALID_EMAIL", "Email inválido", 400);
        }

        if (signupRequest.taxIdType() == null) {
            throw new ApiException("INVALID_COMPANY_DOC_TYPE", "Tipo de documento é obrigatório", 400);
        }

        if (!StringUtils.hasText(signupRequest.taxIdNumber())) {
            throw new ApiException("INVALID_COMPANY_DOC_NUMBER", "Número do documento é obrigatório", 400);
        }

        if (!StringUtils.hasText(signupRequest.password()) || !StringUtils.hasText(signupRequest.confirmPassword())) {
            throw new ApiException("INVALID_PASSWORD", "Senha e confirmação são obrigatórias", 400);
        }

        if (!signupRequest.password().equals(signupRequest.confirmPassword())) {
            throw new ApiException("PASSWORD_MISMATCH", "As senhas não coincidem", 400);
        }

        if (accountRepository.existsByLoginEmailAndDeletedFalse(signupRequest.loginEmail())) {
            throw new ApiException("EMAIL_ALREADY_REGISTERED", "Email já cadastrado na plataforma", 409);
        }

        if (accountRepository.existsByTaxIdTypeAndTaxIdNumberAndDeletedFalse(
                signupRequest.taxIdType(), signupRequest.taxIdNumber()
        )) {
            throw new ApiException("DOC_ALREADY_REGISTERED", "Documento já cadastrado na plataforma", 409);
        }
    }
}
package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserAdminBridge;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import brito.com.multitenancy001.shared.executor.TxExecutor;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountStatusService {

    private final PublicExecutor publicExecutor;
    private final TxExecutor txExecutor;
    private final AccountRepository accountRepository;
    private final TenantUserAdminBridge tenantUserAdminBridge;
    private final AppClock appClock;

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        return txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = accountRepository.findById(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            AccountStatus previous = account.getStatus();

            account.setStatus(req.status());
            if (req.status() == AccountStatus.ACTIVE) {
                account.setDeletedAt(null);
            }
            accountRepository.save(account);

            int affected = 0;
            boolean applied = false;
            String action = "NONE";

            if (req.status() == AccountStatus.SUSPENDED) {
                affected = suspendTenantUsersByAccount(account);
                applied = true;
                action = "SUSPEND_BY_ACCOUNT";
            } else if (req.status() == AccountStatus.ACTIVE) {
                affected = unsuspendTenantUsersByAccount(account);
                applied = true;
                action = "UNSUSPEND_BY_ACCOUNT";
            } else if (req.status() == AccountStatus.CANCELLED) {
                affected = cancelAccount(account);
                applied = true;
                action = "CANCELLED";
            }

            return buildStatusChangeResponse(account, previous, applied, action, affected);
        }));
    }

    protected int suspendTenantUsersByAccount(Account account) {
        return tenantUserAdminBridge.suspendAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    protected int unsuspendTenantUsersByAccount(Account account) {
        return tenantUserAdminBridge.unsuspendAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    private int cancelAccount(Account account) {
        txExecutor.publicRequiresNew(() -> publicExecutor.run(() -> {
            account.setDeletedAt(appClock.now());
            accountRepository.save(account);
            return null;
        }));

        return tenantUserAdminBridge.softDeleteAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    private void softDeleteTenantUsers(Long accountId) {
        Account account = txExecutor.publicReadOnlyTx(() ->
                publicExecutor.run(() -> getAccountByIdRaw(accountId))
        );
        tenantUserAdminBridge.softDeleteAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    private void restoreTenantUsers(Long accountId) {
        Account account = txExecutor.publicReadOnlyTx(() ->
                publicExecutor.run(() -> getAccountByIdRaw(accountId))
        );
        tenantUserAdminBridge.restoreAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    public void softDeleteAccount(Long accountId) {
        txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isBuiltInAccount()) {
                throw new ApiException("BUILTIN_ACCOUNT_PROTECTED",
                        "Não é permitido excluir contas do sistema", 403);
            }

            account.softDelete(appClock.now());
            accountRepository.save(account);

            softDeleteTenantUsers(accountId);

            return null;
        }));
    }

    public void restoreAccount(Long accountId) {
        txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isBuiltInAccount() && account.isDeleted()) {
                throw new ApiException("BUILTIN_ACCOUNT_PROTECTED",
                        "Contas do sistema não podem ser restauradas via este endpoint", 403);
            }

            account.restore();
            accountRepository.save(account);

            restoreTenantUsers(accountId);

            return null;
        }));
    }

    private Account getAccountByIdRaw(Long accountId) {
        return accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
    }

    private AccountStatusChangeResponse buildStatusChangeResponse(
            Account account,
            AccountStatus previous,
            boolean tenantUsersUpdated,
            String action,
            int count
    ) {
        return new AccountStatusChangeResponse(
                account.getId(),
                account.getStatus().name(),
                previous.name(),
                appClock.now(),
                account.getSchemaName(),
                new AccountStatusChangeResponse.SideEffects(tenantUsersUpdated, action, count)
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.mapper.AccountUserApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserAdminBridge;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountTenantUserService {

    private final PublicExecutor publicExecutor;
    private final AccountRepository accountRepository;
    private final TenantUserAdminBridge tenantUserAdminBridge;
    private final AccountUserApiMapper accountUserApiMapper;

    public List<AccountTenantUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyActive) {

        Account account = publicExecutor.run(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );

        List<UserSummaryData> data = tenantUserAdminBridge
                .listUserSummaries(account.getSchemaName(), account.getId(), onlyActive);

        return data.stream()
                .map(accountUserApiMapper::toAccountUserSummary)
                .toList();
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {

        Account account = publicExecutor.run(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );

        tenantUserAdminBridge.setSuspendedByAdmin(account.getSchemaName(), account.getId(), userId, suspended);
    }
}
package brito.com.multitenancy001.controlplane.application.billing;

import brito.com.multitenancy001.controlplane.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.billing.ControlPlanePaymentRepository;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ControlPLanePaymentService {

    private final AccountRepository accountRepository;
    private final ControlPlanePaymentRepository paymentRepository;
    private final SecurityUtils securityUtils;
    private final AppClock appClock;
    
    
@Scheduled(cron = "${app.payment.check-cron:0 0 0 * * *}")
public void checkPayments() {
    log.info("Iniciando verificação de pagamentos...");
    LocalDateTime now = appClock.now();

    // Trials expirados
    List<Account> expiredTrials =
            accountRepository.findExpiredTrials(now, AccountStatus.FREE_TRIAL);

    for (Account account : expiredTrials) {
        if (account.getStatus() != AccountStatus.SUSPENDED) {
            suspendAccount(account, "Trial expirado");
        }
    }

    // Pagamentos vencidos
    List<Account> overdueAccounts =
            accountRepository.findOverdueAccounts(AccountStatus.ACTIVE, now);

    for (Account account : overdueAccounts) {
        if (account.getStatus() != AccountStatus.SUSPENDED) {
            suspendAccount(account, "Pagamento atrasado");
        }
    }

    checkExpiredPendingPayments(now);
}

    
    
    

    private void suspendAccount(Account account, String reason) {
        account.setStatus(AccountStatus.SUSPENDED);
        accountRepository.save(account);
        sendSuspensionEmail(account, reason);
    }

    private void checkExpiredPendingPayments(LocalDateTime now) {
        LocalDateTime thirtyMinutesAgo = now.minusMinutes(30);

        List<Payment> expiredPayments = paymentRepository.findByStatusAndCreatedAtBefore(
                PaymentStatus.PENDING, thirtyMinutesAgo
        );

        for (Payment payment : expiredPayments) {
            payment.setStatus(PaymentStatus.EXPIRED);
            paymentRepository.save(payment);
        }
    }

    @Transactional
    public PaymentResponse processPaymentForAccount(AdminPaymentRequest adminPaymentRequest) {

        if (adminPaymentRequest.accountId() == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        }

        Account account = accountRepository.findById(adminPaymentRequest.accountId())
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

        LocalDateTime now = appClock.now();
        validatePayment(account, adminPaymentRequest.amount(), now);

        Payment payment = Payment.builder()
                .account(account)
                .amount(adminPaymentRequest.amount())
                .paymentMethod(adminPaymentRequest.paymentMethod())
                .paymentGateway(adminPaymentRequest.paymentGateway())
                .description(adminPaymentRequest.description())
                .status(PaymentStatus.PENDING)
                .paymentDate(now)
                .build();

        payment = paymentRepository.save(payment);

        boolean ok = processWithPaymentGateway(
                payment,
                new PaymentRequest(
                        adminPaymentRequest.amount(),
                        adminPaymentRequest.paymentMethod(),
                        adminPaymentRequest.paymentGateway(),
                        adminPaymentRequest.description()
                )
        );

        if (ok) {
            completePayment(payment, account, now);
            return mapToResponse(payment);
        }

        failPayment(payment, "Falha no processamento do pagamento");
        throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
    }

    @Transactional
    public PaymentResponse processPaymentForMyAccount(PaymentRequest paymentRequest) {
        Long accountId = securityUtils.getCurrentAccountId();
        Account account = findAccountOrThrow(accountId);

        LocalDateTime now = appClock.now();
        validatePayment(account, paymentRequest.amount(), now);

        Payment payment = Payment.builder()
                .account(account)
                .amount(paymentRequest.amount())
                .paymentMethod(paymentRequest.paymentMethod())
                .paymentGateway(paymentRequest.paymentGateway())
                .description(paymentRequest.description())
                .status(PaymentStatus.PENDING)
                .paymentDate(now)
                .build();

        payment = paymentRepository.save(payment);

        boolean ok = processWithPaymentGateway(payment, paymentRequest);

        if (ok) {
            completePayment(payment, account, now);
            return mapToResponse(payment);
        }

        failPayment(payment, "Falha no processamento do pagamento");
        throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentByIdForMyAccount(Long paymentId) {
        Long accountId = securityUtils.getCurrentAccountId();

        Payment payment = paymentRepository.findByIdAndAccountId(paymentId, accountId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByMyAccount() {
        Long accountId = securityUtils.getCurrentAccountId();
        return getPaymentsByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public boolean hasActivePaymentMyAccount() {
        Long accountId = securityUtils.getCurrentAccountId();
        return hasActivePayment(accountId);
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByAccount(Long accountId) {
        return paymentRepository.findByAccountId(accountId).stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public boolean hasActivePayment(Long accountId) {
        return paymentRepository.findActivePayment(accountId, appClock.now()).isPresent();
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentById(Long paymentId) {
        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));
        return mapToResponse(payment);
    }

    @Transactional
    public PaymentResponse completePaymentManually(Long paymentId) {

        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        if (payment.getStatus() != PaymentStatus.PENDING) {
            throw new ApiException("INVALID_PAYMENT_STATUS", "Pagamento não está pendente", 409);
        }

        LocalDateTime now = appClock.now();
        completePayment(payment, payment.getAccount(), now);
        return mapToResponse(payment);
    }

    @Transactional
    public PaymentResponse refundPayment(Long paymentId, BigDecimal amount, String reason) {

        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        LocalDateTime now = appClock.now();

        if (!payment.canBeRefunded(now)) {
            throw new ApiException("PAYMENT_NOT_REFUNDABLE", "Pagamento não pode ser reembolsado", 409);
        }

        if (amount == null) {
            payment.refundFully(now, reason);
        } else {
            payment.refundPartially(now, amount, reason);
        }

        paymentRepository.save(payment);
        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    public BigDecimal getTotalRevenue(LocalDateTime startDate, LocalDateTime endDate) {
        List<Object[]> revenueByAccount = paymentRepository.getRevenueByAccount(startDate, endDate);

        return revenueByAccount.stream()
                .map(obj -> (BigDecimal) obj[1])
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /*
     * ========================================================= PRIVATE HELPERS
     * =========================================================
     */

    private Account findAccountOrThrow(Long accountId) {
        return accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
    }

    private void completePayment(Payment payment, Account account, LocalDateTime now) {
        payment.markAsCompleted(now);
        paymentRepository.save(payment);

        account.setStatus(AccountStatus.ACTIVE);
        account.setPaymentDueDate(calculateNextDueDate(payment.getValidUntil(), now));
        accountRepository.save(account);

        sendPaymentConfirmationEmail(account, payment);
    }

    private void failPayment(Payment payment, String reason) {
        payment.markAsFailed(reason);
        paymentRepository.save(payment);
    }

    private void validatePayment(Account account, BigDecimal amount, LocalDateTime now) {

        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new ApiException("INVALID_AMOUNT", "Valor do pagamento inválido", 400);
        }

        if (account.isDeleted()) {
            throw new ApiException("ACCOUNT_DELETED", "Conta deletada", 410);
        }
        
        if (account.isBuiltInAccount()) {
            throw new ApiException("BUILTIN ACCOUNT_NO_BILLING", "Conta BUILTIN não possui billing", 409);
        }
 

        Optional<Payment> activePayment = paymentRepository.findActivePayment(account.getId(), now);

        if (activePayment.isPresent()) {
            throw new ApiException("PAYMENT_ALREADY_EXISTS", "Já existe um pagamento ativo para esta conta", 409);
        }
    }
    
    
 // =========================================================
 // ✅ QUERIES / HELPERS para usar métodos do PaymentRepository
 // =========================================================

 @Transactional(readOnly = true)
 public boolean paymentExistsForAccount(Long paymentId, Long accountId) {
     if (paymentId == null) {
         throw new ApiException("PAYMENT_ID_REQUIRED", "paymentId é obrigatório", 400);
     }
     if (accountId == null) {
         throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
     }
     return paymentRepository.existsByIdAndAccountId(paymentId, accountId);
 }

 @Transactional(readOnly = true)
 public List<PaymentResponse> getPaymentsByAccountAndStatus(Long accountId, PaymentStatus status) {
     if (accountId == null) {
         throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
     }
     if (status == null) {
         throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
     }

     return paymentRepository.findByAccountIdAndStatus(accountId, status).stream()
             .map(this::mapToResponse)
             .toList();
 }

 @Transactional(readOnly = true)
 public PaymentResponse getPaymentByTransactionId(String transactionId) {
     if (transactionId == null || transactionId.isBlank()) {
         throw new ApiException("INVALID_TRANSACTION_ID", "transactionId é obrigatório", 400);
     }

     Payment payment = paymentRepository.findByTransactionId(transactionId.trim())
             .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

     return mapToResponse(payment);
 }

 @Transactional(readOnly = true)
 public boolean existsByTransactionId(String transactionId) {
     if (transactionId == null || transactionId.isBlank()) {
         throw new ApiException("INVALID_TRANSACTION_ID", "transactionId é obrigatório", 400);
     }
     return paymentRepository.existsByTransactionId(transactionId.trim());
 }

 @Transactional(readOnly = true)
 public List<PaymentResponse> getPaymentsByValidUntilBeforeAndStatus(LocalDateTime date, PaymentStatus status) {
     if (date == null) {
         throw new ApiException("INVALID_DATE", "date é obrigatório", 400);
     }
     if (status == null) {
         throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
     }

     return paymentRepository.findByValidUntilBeforeAndStatus(date, status).stream()
             .map(this::mapToResponse)
             .toList();
 }

 @Transactional(readOnly = true)
 public List<PaymentResponse> getCompletedPaymentsByAccount(Long accountId) {
     if (accountId == null) {
         throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
     }

     return paymentRepository.findCompletedPaymentsByAccount(accountId).stream()
             .map(this::mapToResponse)
             .toList();
 }

 @Transactional(readOnly = true)
 public List<PaymentResponse> getPaymentsInPeriod(LocalDateTime startDate, LocalDateTime endDate) {
     if (startDate == null || endDate == null) {
         throw new ApiException("INVALID_DATE_RANGE", "startDate e endDate são obrigatórios", 400);
     }
     if (endDate.isBefore(startDate)) {
         throw new ApiException("INVALID_DATE_RANGE", "endDate deve ser >= startDate", 400);
     }

     return paymentRepository.findPaymentsInPeriod(startDate, endDate).stream()
             .map(this::mapToResponse)
             .toList();
 }


   

    private void sendSuspensionEmail(Account account, String reason) {
        log.info("Enviando email de suspensão para: {}", account.getLoginEmail());
    }

    private void sendPaymentConfirmationEmail(Account account, Payment payment) {
        log.info("Enviando confirmação de pagamento para: {}", account.getLoginEmail());
    }

    private LocalDateTime calculateNextDueDate(LocalDateTime validUntil, LocalDateTime now) {
        return validUntil != null ? validUntil : now.plusMonths(1);
    }

    private boolean processWithPaymentGateway(Payment payment, PaymentRequest paymentRequest) {

        log.info("Processando pagamento com gateway: {}", paymentRequest.paymentGateway());

        try {
            Thread.sleep(1000);
            return Math.random() < 0.9;

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Erro ao processar pagamento no gateway", e);
            return false;
        }
    }
    
    private PaymentResponse mapToResponse(Payment payment) {
        return new PaymentResponse(
                payment.getId(),
                payment.getAccount().getId(),
                payment.getAmount(),
                payment.getPaymentDate(),
                payment.getValidUntil(),
                payment.getStatus().name(),
                payment.getTransactionId(),
                payment.getPaymentMethod(),
                payment.getPaymentGateway(),
                payment.getDescription(),
                payment.getCreatedAt(),
                payment.getUpdatedAt()
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlaneAuthService {

    private static final String DEFAULT_SCHEMA = "public";

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final ControlPlaneUserRepository controlPlaneUserRepository;

    public JwtResponse loginControlPlaneUser(ControlPlaneAdminLoginRequest req) {

        TenantContext.clear();

        // 1) busca user (public)
        ControlPlaneUser user = controlPlaneUserRepository
                .findByUsernameAndDeletedFalse(req.username())
                .orElseThrow(() -> new ApiException(
                        "USER_NOT_FOUND",
                        "Usuário de plataforma não encontrado",
                        404
                ));

        // 2) regra: suspenso por conta -> bloqueia
        if (user.isSuspendedByAccount()) {
            throw new ApiException("ACCESS_DENIED", "Usuário não autorizado", 403);
        }

        // 3) autentica de fato (senha)
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(req.username(), req.password())
        );

        // ✅ IMPORTANTE:
        // Não bloquear must_change_password no login.
        // O bloqueio de rotas deve acontecer no MustChangePasswordFilter,
        // permitindo apenas /api/admin/me/password.

        // 4) tokens
        String accessToken = jwtTokenProvider.generateControlPlaneToken(
                authentication,
                user.getAccount().getId(),
                DEFAULT_SCHEMA
        );

        String refreshToken = jwtTokenProvider.generateRefreshToken(
                user.getUsername(),
                DEFAULT_SCHEMA
        );

        return new JwtResponse(
                accessToken,
                refreshToken,
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getRole().name(),
                user.getAccount().getId(),
                DEFAULT_SCHEMA
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import brito.com.multitenancy001.controlplane.domain.account.AccountOrigin;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.AccountType;
import brito.com.multitenancy001.controlplane.domain.account.SubscriptionPlan;
import brito.com.multitenancy001.controlplane.persistence.account.AccountEntitlementsRepository;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.domain.DomainException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "publicTransactionManager")
public class PublicAccountCreationService {

	private final AccountRepository accountRepository;
	private final AccountEntitlementsRepository entitlementsRepository;
	private final AppClock appClock;

	public Account createAccountFromSignup(SignupRequest signupRequest) {
		TenantContext.clear();

		int maxAttempts = 5;
		for (int attempt = 1; attempt <= maxAttempts; attempt++) {
			String slug = generateSlug(signupRequest.displayName());
			String schemaName = generateSchemaName(signupRequest.displayName());

			try {
				LocalDateTime now = appClock.now();

				Account account = new Account();
				account.setType(AccountType.TENANT);
				account.setOrigin(AccountOrigin.ADMIN); // ✅ novo
				account.setDisplayName(signupRequest.displayName());
				account.setSlug(slug);
				account.setSchemaName(schemaName);

				account.setLoginEmail(signupRequest.loginEmail());
				account.setTaxIdType(signupRequest.taxIdType());
				account.setTaxIdNumber(signupRequest.taxIdNumber());

				account.setTrialEndDate(now.plusDays(30));
				account.setStatus(AccountStatus.FREE_TRIAL);

				account.setSubscriptionPlan(SubscriptionPlan.FREE);

				account.setCountry("Brasil");
				account.setTimezone("America/Sao_Paulo");
				account.setLocale("pt_BR");
				account.setCurrency("BRL");
				
				if (account.getType() == AccountType.PLATFORM && accountRepository.existsByTypeAndDeletedFalse(AccountType.PLATFORM)) {
				    throw new DomainException("Only one PLATFORM account is allowed");
				}


				Account saved = accountRepository.save(account);

				// ✅ Entitlements só para TENANT
				AccountEntitlements ent = AccountEntitlements.builder().account(saved).maxUsers(5).maxProducts(100)
						.maxStorageMb(100).build();

				entitlementsRepository.save(ent);

				return saved;

			} catch (DataIntegrityViolationException e) {
				if (!isSlugOrSchemaUniqueViolation(e))
					throw e;
				log.warn("⚠️ Colisão (tentativa {}/{}) | slug={} | schemaName={}", attempt, maxAttempts, slug, schemaName);
			}
		}

		throw new ApiException("ACCOUNT_CREATE_FAILED",
				"Não foi possível criar conta (colisão de identificadores). Tente novamente.", 409);
	}

	private String generateSlug(String name) {
		String base = (name == null ? "conta" : name.toLowerCase()).replaceAll("[^a-z0-9]+", "-").replaceAll("(^-|-$)",
				"");

		String slug = base;
		int i = 1;

		while (accountRepository.findBySlugAndDeletedFalse(slug).isPresent()) {
			slug = base + "-" + (i++);
		}
		return slug;
	}

	private String generateSchemaName(String name) {
		String base = (name == null ? "tenant" : name.toLowerCase()).replaceAll("[^a-z0-9]", "_");
		return "tenant_" + base + "_" + UUID.randomUUID().toString().substring(0, 8);
	}

	private boolean isSlugOrSchemaUniqueViolation(Throwable e) {
		Throwable t = e;
		while (t.getCause() != null)
			t = t.getCause();
		String msg = (t.getMessage() == null) ? "" : t.getMessage().toLowerCase();

		return msg.contains("ux_accounts_slug_active")
		        || msg.contains("uk_accounts_slug")
		        || msg.contains("uk_accounts_schema_name")
		        || msg.contains("accounts_slug_key")
		        || msg.contains("accounts_schema_name_key")
		        || msg.contains("ux_accounts_login_email_active")
		        || msg.contains("login_email");
	}
}
package brito.com.multitenancy001.controlplane.application.user;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneMeResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserPermissionsUpdateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserUpdateRequest;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUserOrigin;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.EnumSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

@Service
@Transactional
@RequiredArgsConstructor
public class ControlPlaneUserService {

	private final ControlPlaneUserRepository controlPlaneUserRepository;
	private final AccountRepository accountRepository;
	private final PasswordEncoder passwordEncoder;
	private final AppClock appClock;
	private final SecurityUtils securityUtils;

	private static final Set<String> RESERVED_USERNAMES = Set.of("superadmin", "billing", "support", "operator");

	private Account getControlPlaneAccount() {
		TenantContext.clear(); // PUBLIC
		return accountRepository.findBySlugAndDeletedFalse("controlplane")
				.orElseThrow(() -> new ApiException("CONTROLPLANE_ACCOUNT_NOT_FOUND",
						"Conta controlplane não encontrada. Rode a migration V4__insert_controlplane_account.sql",
						500));
	}

	private static final Set<ControlPlaneRole> OWNER_CAN_CREATE = EnumSet.of(ControlPlaneRole.CONTROLPLANE_SUPPORT,
			ControlPlaneRole.CONTROLPLANE_OPERATOR, ControlPlaneRole.CONTROLPLANE_BILLING_MANAGER);

	private static final Set<ControlPlaneRole> SUPPORT_CAN_CREATE = EnumSet.of(ControlPlaneRole.CONTROLPLANE_OPERATOR);

	private void assertCanCreateRole(ControlPlaneRole creatorRole, ControlPlaneRole targetRole) {
		if (creatorRole == null) {
			throw new ApiException("FORBIDDEN", "Role do criador não encontrada", 403);
		}
		if (targetRole == null) {
			throw new ApiException("INVALID_ROLE", "Role alvo é obrigatória", 400);
		}

		if (creatorRole == ControlPlaneRole.CONTROLPLANE_OWNER) {
			if (targetRole == ControlPlaneRole.CONTROLPLANE_OWNER) {
				throw new ApiException("FORBIDDEN", "CONTROLPLANE_OWNER não pode criar outro CONTROLPLANE_OWNER", 403);
			}
			if (!OWNER_CAN_CREATE.contains(targetRole)) {
				throw new ApiException("FORBIDDEN", "CONTROLPLANE_OWNER não pode criar a role: " + targetRole, 403);
			}
			return;
		}

		if (creatorRole == ControlPlaneRole.CONTROLPLANE_SUPPORT) {
			if (targetRole == ControlPlaneRole.CONTROLPLANE_SUPPORT) {
				throw new ApiException("FORBIDDEN", "CONTROLPLANE_SUPPORT não pode criar outro CONTROLPLANE_SUPPORT",
						403);
			}
			if (!SUPPORT_CAN_CREATE.contains(targetRole)) {
				throw new ApiException("FORBIDDEN", "CONTROLPLANE_SUPPORT não pode criar a role: " + targetRole, 403);
			}
			return;
		}

		throw new ApiException("FORBIDDEN", "Sua role não pode criar usuários de plataforma", 403);
	}

	// =========================
	// ✅ GUARDS
	// =========================

	private String normalizeUsername(String username) {
		return username == null ? null : username.trim().toLowerCase(Locale.ROOT);
	}

	private void assertNotBuiltInUserReadonly(ControlPlaneUser controlPlaneUser, String action) {
		if (controlPlaneUser.isBuiltInUser()) {
			throw new ApiException("SYSTEM_USER_READONLY",
					"Usuário padrão do sistema é readonly e não pode sofrer ação: " + action, 409);
		}
	}

	private void assertReservedUsernameOnlyAllowedForBuiltInUsers(String username, boolean isBuiltInUser) {
		if (username == null)
			return;
		String u = normalizeUsername(username);
		if (RESERVED_USERNAMES.contains(u) && !isBuiltInUser) {
			throw new ApiException("RESERVED_USERNAME", "Username reservado do sistema: " + u, 409);
		}
	}

	private void assertOwnerOnly(String action) {
		ControlPlaneRole role = securityUtils.getCurrentControlPlaneRole();
		if (role != ControlPlaneRole.CONTROLPLANE_OWNER) {
			throw new ApiException("FORBIDDEN", "Apenas CONTROLPLANE_OWNER pode executar: " + action, 403);
		}
	}

	private void assertNotSelfTarget(Long targetUserId, String action) {
		Long meId = securityUtils.getCurrentUserId();
		if (meId != null && targetUserId != null && meId.equals(targetUserId)) {
			throw new ApiException("FORBIDDEN", "Você não pode executar esta ação em si mesmo: " + action, 409);
		}
	}

	private ControlPlaneUser loadActiveUserOr404(Long userId, Long accountId) {
		return controlPlaneUserRepository.findActiveByIdAndAccountId(userId, accountId)
				.orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));
	}

	// =========================
	// CREATE
	// =========================

	public ControlPlaneUserDetailsResponse createControlPlaneUser(ControlPlaneUserCreateRequest req) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();

		if (req.username() == null || req.username().isBlank()) {
			throw new ApiException("INVALID_USERNAME", "Username é obrigatório", 400);
		}
		if (!req.username().matches(ValidationPatterns.USERNAME_PATTERN)) {
			throw new ApiException("INVALID_USERNAME", "Username inválido", 400);
		}

		if (req.password() == null || req.password().isBlank()) {
			throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);
		}

		String username = normalizeUsername(req.username());

		assertReservedUsernameOnlyAllowedForBuiltInUsers(username, false);

		ControlPlaneRole roleEnum = req.role();

		ControlPlaneRole creatorRole = securityUtils.getCurrentControlPlaneRole();
		assertCanCreateRole(creatorRole, roleEnum);

		if (req.permissions() != null && !req.permissions().isEmpty()
				&& creatorRole != ControlPlaneRole.CONTROLPLANE_OWNER) {
			throw new ApiException("FORBIDDEN", "Apenas CONTROLPLANE_OWNER pode definir permissions explícitas", 403);
		}

		String email = (req.email() == null) ? null : req.email().trim();
		if (email == null || email.isBlank()) {
		    throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
		}

		if (controlPlaneUserRepository.existsActiveByUsernameIgnoreCase(controlPlaneAccount.getId(), username)) {
			throw new ApiException("USERNAME_ALREADY_EXISTS", "Username já existe", 409);
		}
		
		
		if (controlPlaneUserRepository.existsActiveByEmailIgnoreCase(controlPlaneAccount.getId(), email)) {
		    throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já existe", 409);
		}


		LinkedHashSet<String> normalizedPermissions = new LinkedHashSet<>();
		if (req.permissions() != null && !req.permissions().isEmpty()) {
			try {
				normalizedPermissions = PermissionScopeValidator.normalizeControlPlane(req.permissions());
			} catch (IllegalArgumentException e) {
				throw new ApiException("INVALID_PERMISSION", e.getMessage(), 400);
			}
		}

		ControlPlaneUser user = ControlPlaneUser.builder()
		        .name(req.name())
		        .username(username)
		        .email(email)
		        .password(passwordEncoder.encode(req.password()))
		        .role(roleEnum)
		        .account(controlPlaneAccount)
		        .origin(ControlPlaneUserOrigin.ADMIN)
		        .suspendedByAccount(false)
		        .suspendedByAdmin(false)
		        .permissions(normalizedPermissions)
		        .phone(req.phone())
		        .avatarUrl(req.avatarUrl())
		        .build();


		return mapToResponse(controlPlaneUserRepository.save(user));
	}

	// =========================
	// READ
	// =========================

	@Transactional(readOnly = true)
	public List<ControlPlaneUserDetailsResponse> listControlPlaneUsers() {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();
		return controlPlaneUserRepository.findActiveByAccountId(controlPlaneAccount.getId()).stream()
				.map(this::mapToResponse).toList();

	}

	@Transactional(readOnly = true)
	public ControlPlaneUserDetailsResponse getControlPlaneUser(Long userId) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();
		ControlPlaneUser user = loadActiveUserOr404(userId, controlPlaneAccount.getId());
		return mapToResponse(user);
	}

	// =========================
	// UPDATE
	// =========================

	public ControlPlaneUserDetailsResponse updateControlPlaneUser(Long userId, ControlPlaneUserUpdateRequest req) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();

		ControlPlaneUser user = loadActiveUserOr404(userId, controlPlaneAccount.getId());

		assertNotBuiltInUserReadonly(user, "UPDATE_USER");

		if (req.name() != null && !req.name().isBlank()) {
			user.setName(req.name().trim());
		}

		if (req.email() != null) {
			String newEmail = req.email().trim();

			if (newEmail.isBlank()) {
				throw new ApiException("INVALID_EMAIL", "Email inválido", 400);
			}

			if (user.getEmail() == null || !newEmail.equalsIgnoreCase(user.getEmail())) {
				boolean existsOther = controlPlaneUserRepository
						.existsOtherActiveByEmailIgnoreCase(controlPlaneAccount.getId(), newEmail, user.getId());
				if (existsOther) {
					throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já existe", 409);
				}
				user.setEmail(newEmail);
			}
		}

		if (req.username() != null && !req.username().isBlank()) {
			String newUsername = normalizeUsername(req.username());

			if (!newUsername.matches(ValidationPatterns.USERNAME_PATTERN)) {
				throw new ApiException("INVALID_USERNAME", "Username inválido", 400);
			}

			assertReservedUsernameOnlyAllowedForBuiltInUsers(newUsername, user.isBuiltInUser());

			if (!newUsername.equalsIgnoreCase(user.getUsername())) {
				boolean existsOther = controlPlaneUserRepository
						.existsOtherActiveByUsernameIgnoreCase(controlPlaneAccount.getId(), newUsername, user.getId());
				if (existsOther) {
					throw new ApiException("USERNAME_ALREADY_EXISTS", "Username já existe", 409);
				}

				user.setUsername(newUsername);
			}
		}

		if (req.role() != null) {
			assertOwnerOnly("UPDATE_ROLE");
			user.setRole(req.role());
		}

		if (req.permissions() != null) {
			assertOwnerOnly("UPDATE_PERMISSIONS");

			LinkedHashSet<String> normalized;
			try {
				normalized = PermissionScopeValidator.normalizeControlPlane(req.permissions());
			} catch (IllegalArgumentException e) {
				throw new ApiException("INVALID_PERMISSION", e.getMessage(), 400);
			}
			user.setPermissions(normalized);
		}

		return mapToResponse(controlPlaneUserRepository.save(user));
	}

	public ControlPlaneUserDetailsResponse updateControlPlaneUserPermissions(Long userId,
			ControlPlaneUserPermissionsUpdateRequest req) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();

		ControlPlaneUser user = loadActiveUserOr404(userId, controlPlaneAccount.getId());

		assertNotBuiltInUserReadonly(user, "UPDATE_PERMISSIONS");
		assertOwnerOnly("UPDATE_PERMISSIONS");

		LinkedHashSet<String> normalized;
		try {
			normalized = PermissionScopeValidator.normalizeControlPlane(req.permissions());
		} catch (IllegalArgumentException e) {
			throw new ApiException("INVALID_PERMISSION", e.getMessage(), 400);
		}

		user.setPermissions(normalized);
		return mapToResponse(controlPlaneUserRepository.save(user));
	}

	// =========================
	// STATUS / DELETE / RESTORE
	// =========================

	public ControlPlaneUserDetailsResponse updateControlPlaneUserStatus(Long userId, boolean active) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();

		ControlPlaneUser user = loadActiveUserOr404(userId, controlPlaneAccount.getId());

		assertNotBuiltInUserReadonly(user, "UPDATE_STATUS");
		assertOwnerOnly("UPDATE_STATUS");

		assertNotSelfTarget(userId, "UPDATE_STATUS");

		user.setSuspendedByAdmin(!active);
		return mapToResponse(controlPlaneUserRepository.save(user));
	}

	public void softDeleteControlPlaneUser(Long userId) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();

		ControlPlaneUser user = loadActiveUserOr404(userId, controlPlaneAccount.getId());

		assertNotBuiltInUserReadonly(user, "DELETE");
		assertOwnerOnly("DELETE");

		assertNotSelfTarget(userId, "DELETE");

		if (user.getRole() == ControlPlaneRole.CONTROLPLANE_OWNER) {
			throw new ApiException("OWNER_DELETE_BLOCKED", "Não é permitido remover CONTROLPLANE_OWNER", 409);
		}

		LocalDateTime now = appClock.now();
		user.softDelete(now);
		controlPlaneUserRepository.save(user);
	}

	public ControlPlaneUserDetailsResponse restoreControlPlaneUser(Long userId) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();

		assertOwnerOnly("RESTORE");

		ControlPlaneUser user = loadUserAnyStatusOr404(userId, controlPlaneAccount.getId());

		if (!user.isDeleted()) {
			throw new ApiException("USER_NOT_DELETED", "Usuário não está removido", 409);
		}

		assertRestoreNoActiveCollision(controlPlaneAccount, user);

		user.restore();
		user.setSuspendedByAdmin(false);
		user.setSuspendedByAccount(false);

		assertReservedUsernameOnlyAllowedForBuiltInUsers(user.getUsername(), user.isBuiltInUser());

		return mapToResponse(controlPlaneUserRepository.save(user));
	}

	public void resetControlPlaneUserPassword(Long targetUserId,
			brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserPasswordResetRequest req) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();

		if (req == null) {
			throw new ApiException("INVALID_REQUEST", "Request inválido", 400);
		}
		if (req.newPassword() == null || req.newPassword().isBlank()) {
			throw new ApiException("INVALID_PASSWORD", "Nova senha é obrigatória", 400);
		}
		if (!req.newPassword().equals(req.confirmPassword())) {
			throw new ApiException("PASSWORD_MISMATCH", "Senha e confirmação não conferem", 400);
		}

		assertOwnerOnly("RESET_PASSWORD");
		assertNotSelfTarget(targetUserId, "RESET_PASSWORD");

		ControlPlaneUser superAdmin = controlPlaneUserRepository.findActiveSuperAdmin(controlPlaneAccount.getId())

				.orElseThrow(() -> new ApiException("SUPERADMIN_NOT_FOUND",
						"Superadmin não encontrado. Rode a seed V5__insert_controlplane_users.sql", 500));

		if (superAdmin.getId().equals(targetUserId)) {
			throw new ApiException("SUPERADMIN_CANNOT_RESET_SELF", "Superadmin não pode resetar a própria senha", 409);
		}

		ControlPlaneUser target = controlPlaneUserRepository
				.findActiveByIdAndAccountId(targetUserId, controlPlaneAccount.getId())
				.orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

		if (target.getRole() == ControlPlaneRole.CONTROLPLANE_OWNER) {
			throw new ApiException("OWNER_PASSWORD_RESET_BLOCKED",
					"Não é permitido resetar senha de CONTROLPLANE_OWNER", 409);
		}

		target.setPassword(passwordEncoder.encode(req.newPassword()));
		target.setMustChangePassword(true);
		target.setPasswordChangedAt(appClock.now());

		target.setFailedLoginAttempts(0);
		target.setLockedUntil(null);
		target.setPasswordResetToken(null);
		target.setPasswordResetExpires(null);

		controlPlaneUserRepository.save(target);
	}

	public void changeMyPassword(
			brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneChangeMyPasswordRequest req) {
		TenantContext.clear();
		Account controlPlaneAccount = getControlPlaneAccount();

		if (req == null) {
			throw new ApiException("INVALID_REQUEST", "Request inválido", 400);
		}
		if (req.newPassword() == null || req.newPassword().isBlank()) {
			throw new ApiException("INVALID_PASSWORD", "Nova senha é obrigatória", 400);
		}
		if (!req.newPassword().equals(req.confirmPassword())) {
			throw new ApiException("PASSWORD_MISMATCH", "Senha e confirmação não conferem", 400);
		}

		Long meId = securityUtils.getCurrentUserId();
		if (meId == null) {
			throw new ApiException("UNAUTHORIZED", "Usuário não autenticado", 401);
		}

		ControlPlaneUser me = controlPlaneUserRepository.findActiveByIdAndAccountId(meId, controlPlaneAccount.getId())
				.orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

		if (me.isDeleted()) {
			throw new ApiException("USER_DELETED", "Usuário removido", 409);
		}
		if (me.isSuspendedByAccount() || me.isSuspendedByAdmin()) {
			throw new ApiException("ACCESS_DENIED", "Usuário não autorizado", 403);
		}

		if (!passwordEncoder.matches(req.currentPassword(), me.getPassword())) {
			throw new ApiException("INVALID_CURRENT_PASSWORD", "Senha atual inválida", 400);
		}

		if (passwordEncoder.matches(req.newPassword(), me.getPassword())) {
			throw new ApiException("PASSWORD_REUSE", "Nova senha não pode ser igual à senha atual", 400);
		}

		me.setPassword(passwordEncoder.encode(req.newPassword()));
		me.setMustChangePassword(false);
		me.setPasswordChangedAt(appClock.now());

		me.setFailedLoginAttempts(0);
		me.setLockedUntil(null);
		me.setPasswordResetToken(null);
		me.setPasswordResetExpires(null);

		controlPlaneUserRepository.save(me);
	}

	private void assertRestoreNoActiveCollision(Account account, ControlPlaneUser deletedUser) {
		// username
		if (deletedUser.getUsername() != null && !deletedUser.getUsername().isBlank()) {
			boolean existsOther = controlPlaneUserRepository.existsOtherActiveByUsernameIgnoreCase(account.getId(),
					deletedUser.getUsername(), deletedUser.getId());
			if (existsOther) {
				throw new ApiException("USERNAME_ALREADY_EXISTS", "Não é possível restaurar: username já está em uso",
						409);
			}
		}

		// email
		if (deletedUser.getEmail() != null && !deletedUser.getEmail().isBlank()) {
			boolean existsOther = controlPlaneUserRepository.existsOtherActiveByEmailIgnoreCase(account.getId(),
					deletedUser.getEmail(), deletedUser.getId());
			if (existsOther) {
				throw new ApiException("EMAIL_ALREADY_EXISTS", "Não é possível restaurar: email já está em uso", 409);
			}
		}
	}

	@Transactional(readOnly = true)
	public ControlPlaneMeResponse getMe() {
		TenantContext.clear();

		Authentication auth = SecurityContextHolder.getContext().getAuthentication();
		if (auth == null || !auth.isAuthenticated()) {
			throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
		}

		Object principal = auth.getPrincipal();
		if (!(principal instanceof AuthenticatedUserContext ctx)) {
			throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
		}

		List<String> authorities = (ctx.getAuthorities() == null) ? List.of()
				: ctx.getAuthorities().stream().map(a -> a.getAuthority()).sorted().toList();

		return new ControlPlaneMeResponse(ctx.getUserId(), ctx.getUsername(), ctx.getEmail(), ctx.getRoleAuthority(),
				ctx.getAccountId(), ctx.isMustChangePassword(), authorities);
	}

	private ControlPlaneUser loadUserAnyStatusOr404(Long userId, Long accountId) {
		return controlPlaneUserRepository.findByIdAndAccountId(userId, accountId)
				.orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));
	}

	private ControlPlaneUserDetailsResponse mapToResponse(ControlPlaneUser user) {
		return new ControlPlaneUserDetailsResponse(user.getId(), user.getUsername(), user.getName(), user.getEmail(),
				user.getRole().name(), user.isSuspendedByAccount(), user.isSuspendedByAdmin(), user.getCreatedAt(),
				user.getUpdatedAt(), user.getAccount().getId(),
				user.getPermissions() == null ? List.of() : user.getPermissions().stream().sorted().toList());
	}
}
package brito.com.multitenancy001.controlplane.domain.account;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.domain.DomainException;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@Entity
@Table(name = "accounts")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Account {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // =========
    // TYPE / ORIGIN
    // =========

    @Enumerated(EnumType.STRING)
    @Column(name = "account_type", nullable = false, length = 20)
    @Builder.Default
    private AccountType type = AccountType.TENANT;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_origin", nullable = false, length = 20)
    @Builder.Default
    private AccountOrigin origin = AccountOrigin.ADMIN;

    // =========
    // CORE IDENTITY
    // =========

    /**
     * Nome de exibição (UI): "Foton Devices", "Sandra Severo", etc.
     */
    @Column(name = "display_name", nullable = false, length = 150)
    private String displayName;

    /**
     * Nome legal (opcional): Razão Social ou Nome completo.
     * Pode ser preenchido depois.
     */
    @Column(name = "legal_name", length = 200)
    private String legalName;

    @Enumerated(EnumType.STRING)
    @Column(name = "legal_entity_type", nullable = false, length = 20)
    @Builder.Default
    private LegalEntityType legalEntityType = LegalEntityType.COMPANY;

    @Column(name = "schema_name", nullable = false, unique = true, length = 100)
    private String schemaName;

    @Column(name = "slug", nullable = false, unique = true, length = 80)
    private String slug;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    @Builder.Default
    private AccountStatus status = AccountStatus.FREE_TRIAL;

    // =========
    // AUDIT (técnico)
    // =========

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // =========
    // BUSINESS DATES
    // =========

    @Column(name = "trial_end_date")
    private LocalDateTime trialEndDate;

    @Column(name = "payment_due_date")
    private LocalDateTime paymentDueDate;

    @Column(name = "next_billing_date")
    private LocalDateTime nextBillingDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "subscription_plan", nullable = false, length = 50)
    @Builder.Default
    private SubscriptionPlan subscriptionPlan = SubscriptionPlan.FREE;

    // =========
    // EMAILS (neutro)
    // =========

    /**
     * Email principal (login / owner contact) do onboarding.
     * (Você pode manter como "loginEmail" mesmo se no futuro login for por CP User.)
     */
    @Column(name = "login_email", nullable = false, length = 150)
    private String loginEmail;

    /**
     * Email para cobrança (opcional).
     * Padrão SaaS moderno: permite financeiro diferente do owner.
     */
    @Column(name = "billing_email", length = 150)
    private String billingEmail;

    // =========
    // TAX ID / DOCUMENT (neutro PF/PJ)
    // =========

    @Enumerated(EnumType.STRING)
    @Column(name = "tax_id_type", length = 20)
    private TaxIdType taxIdType; // opcional: pode ser null

    @Column(name = "tax_id_number", length = 40)
    private String taxIdNumber; // opcional: pode ser null

    @Column(name = "tax_country_code", length = 2, nullable = false)
    @Builder.Default
    private String taxCountryCode = "BR";

    // =========
    // CONTACT DATA
    // =========

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "address", length = 500)
    private String address;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "state", length = 50)
    private String state;

    @Column(name = "country", length = 60, nullable = false)
    @Builder.Default
    private String country = "Brasil";

    // =========
    // LOCALE SETTINGS
    // =========

    @Column(name = "timezone", length = 60, nullable = false)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", length = 20, nullable = false)
    @Builder.Default
    private String locale = "pt_BR";

    @Column(name = "currency", length = 10, nullable = false)
    @Builder.Default
    private String currency = "BRL";

    // =========
    // RELATIONSHIPS
    // =========

    @OneToMany(mappedBy = "account", fetch = FetchType.LAZY, cascade = { CascadeType.PERSIST, CascadeType.MERGE })
    @Builder.Default
    @ToString.Exclude
    private List<ControlPlaneUser> controlPlaneUsers = new ArrayList<>();

    // =========
    // JSON FIELDS
    // =========

    @Column(name = "settings_json", columnDefinition = "TEXT")
    private String settingsJson;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    // =========
    // SOFT DELETE
    // =========

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @PrePersist
    protected void onCreate() {

        if (origin == null) origin = AccountOrigin.ADMIN;

        if (country == null || country.isBlank()) country = "Brasil";
        if (timezone == null || timezone.isBlank()) timezone = "America/Sao_Paulo";
        if (locale == null || locale.isBlank()) locale = "pt_BR";
        if (currency == null || currency.isBlank()) currency = "BRL";
        if (taxCountryCode == null || taxCountryCode.isBlank()) taxCountryCode = "BR";

        // displayName defensivo (se ainda existir "name" em algum builder antigo)
        if (displayName == null || displayName.isBlank()) {
            throw new DomainException("displayName is required");
        }

        // slug
        if (slug == null || slug.isBlank()) {
            slug = displayName.toLowerCase()
                    .replaceAll("[^a-z0-9]+", "-")
                    .replaceAll("(^-|-$)", "");
        }

        // schemaName
        if (schemaName == null || schemaName.isBlank()) {
            schemaName = "tenant_" + slug.replace("-", "_") + "_"
                    + UUID.randomUUID().toString().substring(0, 8);
        }

        // Normalização leve de email
        if (loginEmail != null) loginEmail = loginEmail.trim().toLowerCase();
        if (billingEmail != null && !billingEmail.isBlank()) billingEmail = billingEmail.trim().toLowerCase();
        if (billingEmail != null && billingEmail.isBlank()) billingEmail = null;

        // Normalização doc (recomendação: guardar só dígitos)
        if (taxIdNumber != null) {
            taxIdNumber = taxIdNumber.replaceAll("\\D+", "");
            if (taxIdNumber.isBlank()) taxIdNumber = null;
        }

        // coerência: se um vem, o outro deve vir
        if ((taxIdType == null) != (taxIdNumber == null)) {
            throw new DomainException("taxIdType and taxIdNumber must be provided together");
        }

        if (isBuiltInAccount()) {
            applyBuiltInDefaults();
        }
    }

    // =========================
    // Semântica / helpers
    // =========================

    public boolean isTenantAccount() {
        return type == AccountType.TENANT;
    }

    public boolean isPlatformAccount() {
        return type == AccountType.PLATFORM;
    }

    public boolean isBuiltInAccount() {
        return origin == AccountOrigin.BUILT_IN;
    }

    public boolean isDeleted() {
        return deleted || deletedAt != null;
    }

    public boolean isTrialActive(LocalDateTime now) {
        return status == AccountStatus.FREE_TRIAL
                && trialEndDate != null
                && now != null
                && trialEndDate.isAfter(now);
    }

    public boolean isActive(LocalDateTime now) {
        if (isDeleted()) return false;
        if (isBuiltInAccount()) return true;
        return status == AccountStatus.ACTIVE || (status == AccountStatus.FREE_TRIAL && isTrialActive(now));
    }

    public boolean isPaymentOverdue(LocalDateTime now) {
        return paymentDueDate != null && now != null && paymentDueDate.isBefore(now);
    }

    public long getDaysRemainingInTrial(LocalDateTime now) {
        if (now == null) return 0;
        if (!isTrialActive(now)) return 0;
        return ChronoUnit.DAYS.between(now.toLocalDate(), trialEndDate.toLocalDate());
    }

    public void softDelete(LocalDateTime now) {
        if (deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        if (isBuiltInAccount()) {
            throw new DomainException("BUILT_IN account cannot be deleted");
        }

        deleted = true;
        deletedAt = now;
        status = AccountStatus.CANCELLED;
    }

    public void restore() {
        if (!deleted) return;

        deleted = false;
        deletedAt = null;
        status = AccountStatus.ACTIVE;

        if (isBuiltInAccount()) {
            applyBuiltInDefaults();
        }
    }

    // =========================
    // Regras de domínio: BUILT_IN governa restrições
    // =========================

    public void setSubscriptionPlan(SubscriptionPlan plan) {
        if (plan == null) throw new DomainException("subscriptionPlan is required");
        if (isBuiltInAccount() && plan != SubscriptionPlan.BUILT_IN_PLAN) {
            throw new DomainException("BUILT_IN account must use BUILT_IN_PLAN");
        }
        subscriptionPlan = plan;
    }

    public void setStatus(AccountStatus newStatus) {
        if (newStatus == null) throw new DomainException("status is required");
        if (isBuiltInAccount() && newStatus != AccountStatus.ACTIVE) {
            throw new DomainException("BUILT_IN account must be ACTIVE");
        }
        status = newStatus;
    }

    public void setTrialEndDate(LocalDateTime newTrialEndDate) {
        if (isBuiltInAccount() && newTrialEndDate != null) {
            throw new DomainException("BUILT_IN account must not have trialEndDate");
        }
        trialEndDate = newTrialEndDate;
    }

    public void setPaymentDueDate(LocalDateTime newPaymentDueDate) {
        if (isBuiltInAccount() && newPaymentDueDate != null) {
            throw new DomainException("BUILT_IN account must not have paymentDueDate");
        }
        paymentDueDate = newPaymentDueDate;
    }

    public void setType(AccountType newType) {
        if (newType == null) throw new DomainException("accountType is required");
        type = newType;

        if (origin == AccountOrigin.BUILT_IN && type != AccountType.PLATFORM) {
            throw new DomainException("BUILT_IN account must be PLATFORM");
        }
    }

    public void setOrigin(AccountOrigin newOrigin) {
        if (newOrigin == null) throw new DomainException("accountOrigin is required");
        origin = newOrigin;

        if (origin == AccountOrigin.BUILT_IN) {
            type = AccountType.PLATFORM;
            applyBuiltInDefaults();
        }
    }

    private void applyBuiltInDefaults() {
        subscriptionPlan = SubscriptionPlan.BUILT_IN_PLAN;
        status = AccountStatus.ACTIVE;
        trialEndDate = null;
        paymentDueDate = null;
        nextBillingDate = null;
        deleted = false;
        deletedAt = null;
    }
}
package brito.com.multitenancy001.controlplane.domain.account;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "account_entitlements")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AccountEntitlements {

    @Id
    @Column(name = "account_id")
    private Long accountId;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id")
    private Account account;

    @Column(name = "max_users", nullable = false)
    private Integer maxUsers;

    @Column(name = "max_products", nullable = false)
    private Integer maxProducts;

    @Column(name = "max_storage_mb", nullable = false)
    private Integer maxStorageMb;
}
package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountOrigin {
    BUILT_IN,   // seed / migration
    ADMIN,      // criado via painel por superadmin
    API         // futuro (integração, signup automático, etc)
}
package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountStatus {
    FREE_TRIAL("Trial Gratuito"),
    ACTIVE("Ativa"),
    SUSPENDED("Suspensa"),
    CANCELLED("Cancelada"),
    EXPIRED("Expirada");
    
    private final String description;
    
    AccountStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * Verifica se o status permite operações
     */
    public boolean isOperational() {
        return this == FREE_TRIAL || this == ACTIVE;
    }
    
    /**
     * Verifica se o status está em trial
     */
    public boolean isTrial() {
        return this == FREE_TRIAL;
    }
    
    /**
     * Verifica se o status está ativo
     */
    public boolean isActive() {
        return this == ACTIVE;
    }
    
    /**
     * Verifica se o status está suspenso
     */
    public boolean isSuspended() {
        return this == SUSPENDED;
    }
    
    /**
     * Verifica se o status está cancelado
     */
    public boolean isCancelled() {
        return this == CANCELLED || this == EXPIRED;
    }
}package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountType {
    TENANT,
    PLATFORM
}
package brito.com.multitenancy001.controlplane.domain.account;

public enum LegalEntityType {
    INDIVIDUAL,   // pessoa física
    COMPANY       // pessoa jurídica
}
package brito.com.multitenancy001.controlplane.domain.account;

public enum SubscriptionPlan {
    FREE,
    PRO,
    ENTERPRISE,

    /**
     * Plano interno do sistema (Control Plane).
     * BUILTIN != cliente, não tem trial, não tem billing, não tem entitlements.
     */
    BUILT_IN_PLAN
}
package brito.com.multitenancy001.controlplane.domain.account;

import lombok.Getter;

@Getter
public enum TaxIdType {
    CPF,
    CNPJ;

   
    }
package brito.com.multitenancy001.controlplane.domain.billing;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "payments", indexes = {
    @Index(name = "idx_payment_account", columnList = "account_id"),
    @Index(name = "idx_payment_status", columnList = "status"),
    @Index(name = "idx_payment_date", columnList = "payment_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    // ✅ NEGÓCIO
    @Column(name = "payment_date", nullable = false)
    private LocalDateTime paymentDate;

    // ✅ NEGÓCIO
    @Column(name = "valid_until")
    private LocalDateTime validUntil;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private PaymentStatus status = PaymentStatus.PENDING;

    @Column(name = "transaction_id", unique = true, length = 100)
    private String transactionId;

    @Column(name = "payment_method", length = 50)
    private String paymentMethod;

    @Column(name = "payment_gateway", length = 50)
    private String paymentGateway;

    @Column(name = "currency", length = 3, nullable = false)
    @Builder.Default
    private String currency = "BRL";

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    @Column(name = "invoice_url", columnDefinition = "TEXT")
    private String invoiceUrl;

    @Column(name = "receipt_url", columnDefinition = "TEXT")
    private String receiptUrl;

    // ✅ AUDITORIA (técnico)
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // ✅ NEGÓCIO
    @Column(name = "refunded_at")
    private LocalDateTime refundedAt;

    @Column(name = "refund_amount", precision = 10, scale = 2)
    private BigDecimal refundAmount;

    @Column(name = "refund_reason", length = 500)
    private String refundReason;

    @PrePersist
    protected void onCreate() {
        if (this.transactionId == null) {
            this.transactionId = "PAY_" + UUID.randomUUID().toString()
                    .replace("-", "")
                    .substring(0, 16)
                    .toUpperCase();
        }

        // ⚠️ NÃO setar tempo aqui. paymentDate deve vir do service com Clock.
        if (this.paymentDate == null) {
            throw new IllegalStateException("paymentDate deve ser definido pela aplicação (Clock/AppClock).");
        }

        // Se já está completed e não veio validUntil, calcula baseado no paymentDate (determinístico)
        if (this.status == PaymentStatus.COMPLETED && this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    private LocalDateTime calculateDefaultValidUntil(LocalDateTime baseDate) {
        return baseDate.plusDays(30);
    }

    // ---------------------------
    // Transições de estado (domínio)
    // ---------------------------

    /** Use quando o pagamento é marcado como concluído no "agora" do app. */
    public void markAsCompleted(LocalDateTime now) {
        this.status = PaymentStatus.COMPLETED;

        // Se paymentDate ainda não foi setado, seta com o "agora" vindo de fora (Clock/AppClock)
        if (this.paymentDate == null) {
            this.paymentDate = now;
        }

        if (this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    /** Mantido por compatibilidade: exige que paymentDate já tenha sido definido externamente. */
    public void markAsCompleted() {
        this.status = PaymentStatus.COMPLETED;
        if (this.paymentDate == null) {
            throw new IllegalStateException("paymentDate deve ser definido antes de marcar como COMPLETED.");
        }
        if (this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    public void markAsFailed(String reason) {
        this.status = PaymentStatus.FAILED;
        if (this.metadataJson == null) {
            this.metadataJson = "{\"failure_reason\":\"" + reason + "\"}";
        }
    }

    public void refundPartially(LocalDateTime now, BigDecimal amount, String reason) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0 || amount.compareTo(this.amount) > 0) {
            throw new IllegalArgumentException("Valor de reembolso inválido");
        }
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento não pode ser reembolsado");
        }

        this.refundAmount = amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }

    public void refundFully(LocalDateTime now, String reason) {
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento não pode ser reembolsado");
        }

        this.refundAmount = this.amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }

    // ---------------------------
    // Regras (parametrizadas por "agora")
    // ---------------------------

    public boolean isActive(LocalDateTime now) {
        return this.status == PaymentStatus.COMPLETED
                && (this.validUntil == null || this.validUntil.isAfter(now));
    }

    public boolean canBeRefunded(LocalDateTime now) {
        if (this.status != PaymentStatus.COMPLETED) return false;
        if (this.refundedAt != null) return false;
        if (this.paymentDate == null) return false;

        // Exemplo original: até 90 dias após paymentDate (regra determinística)
        // (equivalente a: paymentDate.isAfter(now.minusDays(90)))
        return this.paymentDate.isAfter(now.minusDays(90));
    }
}
package brito.com.multitenancy001.controlplane.domain.billing;



public enum PaymentStatus {
    PENDING("Pendente"),
    COMPLETED("Concluído"),
    FAILED("Falhou"),
    REFUNDED("Reembolsado"),
    CANCELLED("Cancelado"),
    EXPIRED("Expirado");
    
    private final String description;
    
    PaymentStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * Verifica se o status indica pagamento bem-sucedido
     */
    public boolean isSuccessful() {
        return this == COMPLETED;
    }
    
    /**
     * Verifica se o status indica pagamento finalizado (não pendente)
     */
    public boolean isFinal() {
        return this != PENDING;
    }
    
    /**
     * Converte string para PaymentStatus
     */
    public static PaymentStatus fromString(String status) {
        if (status == null) {
            return PENDING;
        }
        try {
            return PaymentStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            return PENDING;
        }
    }
}package brito.com.multitenancy001.controlplane.domain.user;

import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(name = "controlplane_users")

@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
@ToString(exclude = { "account", "password" })
public class ControlPlaneUser {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "user_origin", nullable = false, length = 20)
    @Builder.Default
    private ControlPlaneUserOrigin origin = ControlPlaneUserOrigin.ADMIN;

    public boolean isBuiltInUser() {
        return this.origin == ControlPlaneUserOrigin.BUILT_IN;
    }

    

    @Column(nullable = false, length = 100)
    private String name;

    @Column(name = "username", nullable = false, length = 100)
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inválido.")
    private String username;

    @Column(name = "password", nullable = false, length = 255)
    private String password;

    @Column(name = "email", nullable = false, length = 150)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 50)
    private ControlPlaneRole role;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;
    
  
    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    // 🔐 SEGURANÇA
    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts", nullable = false)
    @Builder.Default
    private int failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    // ✅ ESTES CAMPOS EXISTEM NA MIGRATION
    @Column(name = "timezone", nullable=false,length = 60)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", nullable=false,length = 20)
    @Builder.Default
    private String locale = "pt_BR";

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    // 🧾 AUDITORIA
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
        name = "controlplane_user_permissions",
        schema = "public",
        joinColumns = @JoinColumn(name = "user_id")
    )
    @Column(name = "permission", nullable = false, length = 120)
    @Builder.Default
    private Set<String> permissions = new LinkedHashSet<>();

    
    @PrePersist
    @PreUpdate
    private void normalizePermissions() {
        // garante Set não nulo
        if (permissions == null) permissions = new LinkedHashSet<>();

        // normaliza prefixo/trim e bloqueia TEN_ no controlplane
        permissions = PermissionScopeValidator.normalizeControlPlane(permissions);
    }

  
    

    // ✅ se lockedUntil estiver no futuro: lock
    public boolean isAccountNonLocked(LocalDateTime now) {
        return lockedUntil == null || !lockedUntil.isAfter(now);
    }

    // ✅ enabled “puro” (não deletado / não suspenso)
    public boolean isEnabledForLogin() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    // ✅ decisão final de login (enabled + lock)
    public boolean isEnabledForLogin(LocalDateTime now) {
        return isEnabledForLogin() && isAccountNonLocked(now);
    }

 public void softDelete(LocalDateTime now) {
    if (isBuiltInUser()) {
        throw new IllegalStateException("SYSTEM_USER_READONLY");
    }
    if (deleted) return;

    deleted = true;
    deletedAt = now;

    // (opcional) se você quer garantir que não faça login após delete:
    suspendedByAccount = true;
    suspendedByAdmin = true;

    // ✅ Estratégia A: NÃO altera username/email
}



    public void restore() {
        this.deleted = false;
        this.deletedAt = null;
        this.suspendedByAccount = false;
        this.suspendedByAdmin = false;
    }
}
package brito.com.multitenancy001.controlplane.domain.user;

public enum ControlPlaneUserOrigin {
    BUILT_IN,
    ADMIN,
    API
}
package brito.com.multitenancy001.controlplane.persistence.account;

import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AccountEntitlementsRepository extends JpaRepository<AccountEntitlements, Long> {
}
package brito.com.multitenancy001.controlplane.persistence.account;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.AccountType;
import brito.com.multitenancy001.controlplane.domain.account.TaxIdType;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
	
	boolean existsByTaxCountryCodeAndTaxIdTypeAndTaxIdNumberAndDeletedFalse(
	        String taxCountryCode, TaxIdType taxIdType, String taxIdNumber
	);


    boolean existsByTypeAndDeletedFalse(AccountType type);

    boolean existsByLoginEmailAndDeletedFalse(String loginEmail);

    boolean existsByTaxIdTypeAndTaxIdNumberAndDeletedFalse(TaxIdType taxIdType, String taxIdNumber);

    List<Account> findAllByDeletedFalse();

    Optional<Account> findBySlugAndDeletedFalse(String slug);

    Optional<Account> findBySlugAndDeletedFalseIgnoreCase(String slug);

    Optional<Account> findByIdAndDeletedFalse(Long id);

    List<Account> findByStatus(AccountStatus status);

    List<Account> findByPaymentDueDateBefore(LocalDateTime date);

    @Query("SELECT a FROM Account a WHERE a.trialEndDate <= :date AND a.status = :status")
    List<Account> findExpiredTrials(@Param("date") LocalDateTime date, @Param("status") AccountStatus status);

    @Query("SELECT a FROM Account a WHERE a.status = :status AND a.paymentDueDate < :today")
    List<Account> findOverdueAccounts(@Param("status") AccountStatus status, @Param("today") LocalDateTime today);

    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.status IN :statuses")
    List<Account> findByStatuses(@Param("statuses") List<AccountStatus> statuses);

    // =========================================================
    // ADMIN (mantendo os nomes que seu service chama)
    // =========================================================

    @Query("SELECT COUNT(a) FROM Account a WHERE a.deleted = false AND a.status = :status")
    long countByStatusAndDeletedFalse(@Param("status") AccountStatus status);

    // ✅ para manter compatível com AccountLifecycleService.countActiveAccounts()
    default long countActiveAccounts() {
        return countByStatusAndDeletedFalse(AccountStatus.ACTIVE);
    }

    Page<Account> findByDeletedFalseOrderByCreatedAtDesc(Pageable pageable);

    Page<Account> findByStatusAndDeletedFalse(AccountStatus status, Pageable pageable);

    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.createdAt BETWEEN :start AND :end")
    Page<Account> findAccountsCreatedBetween(@Param("start") LocalDateTime start,
                                             @Param("end") LocalDateTime end,
                                             Pageable pageable);

    // ✅ para manter compatível com AccountLifecycleService.searchAccountsByName()
    // agora busca em displayName e também em legalName
    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND (
            LOWER(a.displayName) LIKE LOWER(CONCAT('%', :term, '%'))
            OR (a.legalName IS NOT NULL AND LOWER(a.legalName) LIKE LOWER(CONCAT('%', :term, '%')))
          )
    """)
    Page<Account> searchByDisplayName(@Param("term") String term, Pageable pageable);
}
package brito.com.multitenancy001.controlplane.persistence.billing;



import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlanePaymentRepository extends JpaRepository<Payment, Long> {
	
	Optional<Payment> findByIdAndAccountId(Long id, Long accountId);
	
	boolean existsByIdAndAccountId(Long id, Long accountId);

    
    List<Payment> findByAccountId(Long accountId);
    
    List<Payment> findByAccountIdAndStatus(Long accountId, PaymentStatus status);
    
    Page<Payment> findByAccountId(Long accountId, Pageable pageable);
    
    Optional<Payment> findByTransactionId(String transactionId);
    
    List<Payment> findByStatus(PaymentStatus status);
    
    List<Payment> findByStatusAndCreatedAtBefore(PaymentStatus status, LocalDateTime date);
    
    List<Payment> findByValidUntilBeforeAndStatus(LocalDateTime date, PaymentStatus status);
    
    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' ORDER BY p.paymentDate DESC")
    List<Payment> findCompletedPaymentsByAccount(@Param("accountId") Long accountId);
    
    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.validUntil > :now AND p.status = 'COMPLETED'")
    Optional<Payment> findActivePayment(@Param("accountId") Long accountId, @Param("now") LocalDateTime now);
    
    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalPaidInPeriod(@Param("accountId") Long accountId, 
                                   @Param("startDate") LocalDateTime startDate, 
                                   @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT COUNT(p) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED'")
    Long countCompletedPayments(@Param("accountId") Long accountId);
    
    @Query("SELECT p FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate")
    List<Payment> findPaymentsInPeriod(@Param("startDate") LocalDateTime startDate, 
                                      @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT p.account.id, SUM(p.amount) FROM Payment p WHERE p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate GROUP BY p.account.id")
    List<Object[]> getRevenueByAccount(@Param("startDate") LocalDateTime startDate, 
                                      @Param("endDate") LocalDateTime endDate);
    
    boolean existsByTransactionId(String transactionId);
}package brito.com.multitenancy001.controlplane.persistence.user;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlaneUserRepository extends JpaRepository<ControlPlaneUser, Long> {

	@Query("SELECT u FROM ControlPlaneUser u WHERE u.account.id = :accountId AND u.deleted = false")
	List<ControlPlaneUser> findActiveByAccountId(@Param("accountId") Long accountId);

	
    @Query("SELECT u FROM ControlPlaneUser u WHERE u.id = :id AND u.account.id = :accountId AND u.deleted = false")
    Optional<ControlPlaneUser> findActiveByIdAndAccountId(@Param("id") Long id, @Param("accountId") Long accountId);
    
    
    
    @Query("""
    	    SELECT u
    	      FROM ControlPlaneUser u
    	     WHERE u.account.id = :accountId
    	       AND u.deleted = false
    	       AND lower(u.username) = 'superadmin'
    	""")
    	Optional<ControlPlaneUser> findActiveSuperAdmin(@Param("accountId") Long accountId);


  Optional<ControlPlaneUser> findByUsernameAndAccount_IdAndDeletedFalse(String username, Long accountId);

    long countByAccountIdAndDeletedFalse(Long accountId);

  
    Optional<ControlPlaneUser> findByIdAndAccountId(Long id, Long accountId);

  Optional<ControlPlaneUser> findByUsernameAndDeletedFalse(String username);

  
    // =========================================================
    // ✅ NOVOS: unicidade ativa (deleted=false) e case-insensitive
    // =========================================================

    @Query("""
        SELECT (COUNT(u) > 0)
          FROM ControlPlaneUser u
         WHERE u.account.id = :accountId
           AND u.deleted = false
           AND lower(u.username) = lower(:username)
    """)
    boolean existsActiveByUsernameIgnoreCase(
            @Param("accountId") Long accountId,
            @Param("username") String username
    );

    @Query("""
        SELECT (COUNT(u) > 0)
          FROM ControlPlaneUser u
         WHERE u.account.id = :accountId
           AND u.deleted = false
           AND lower(u.email) = lower(:email)
    """)
    boolean existsActiveByEmailIgnoreCase(
            @Param("accountId") Long accountId,
            @Param("email") String email
    );

    @Query("""
        SELECT (COUNT(u) > 0)
          FROM ControlPlaneUser u
         WHERE u.account.id = :accountId
           AND u.deleted = false
           AND lower(u.username) = lower(:username)
           AND u.id <> :userId
    """)
    boolean existsOtherActiveByUsernameIgnoreCase(
            @Param("accountId") Long accountId,
            @Param("username") String username,
            @Param("userId") Long userId
    );

    @Query("""
        SELECT (COUNT(u) > 0)
          FROM ControlPlaneUser u
         WHERE u.account.id = :accountId
           AND u.deleted = false
           AND lower(u.email) = lower(:email)
           AND u.id <> :userId
    """)
    boolean existsOtherActiveByEmailIgnoreCase(
            @Param("accountId") Long accountId,
            @Param("email") String email,
            @Param("userId") Long userId
    );

    
   

}
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.PermissionAuthority;

public enum ControlPlanePermission implements PermissionAuthority {

    CP_TENANT_READ,
    CP_TENANT_SUSPEND,
    CP_TENANT_ACTIVATE,
    CP_TENANT_DELETE,

    CP_BILLING_READ,
    CP_BILLING_WRITE,

    CP_USER_READ,
    CP_USER_WRITE,
    CP_USER_DELETE,

    // ✅ NOVA (somente superadmin deve ter)
    CP_USER_PASSWORD_RESET;

    @Override
    public String asAuthority() {
        return name();
    }
}
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum ControlPlaneRole implements RoleAuthority {

    CONTROLPLANE_OWNER,
    CONTROLPLANE_BILLING_MANAGER,  
    CONTROLPLANE_SUPPORT,
    CONTROLPLANE_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isControlPlaneOwner() {
        return this == CONTROLPLANE_OWNER;
    }

    public boolean isBillingManager() {
        return this == CONTROLPLANE_BILLING_MANAGER;
    }
}
package brito.com.multitenancy001.controlplane.security;

import java.util.EnumSet;
import java.util.Set;

public final class ControlPlaneRolePermissions {

    private ControlPlaneRolePermissions() {}

    public static Set<ControlPlanePermission> permissionsFor(ControlPlaneRole role) {
        if (role == null) return Set.of();

        return switch (role) {

            // 🔐 Super Admin = todas as permissões da plataforma
            case CONTROLPLANE_OWNER -> EnumSet.allOf(ControlPlanePermission.class);

            case CONTROLPLANE_BILLING_MANAGER -> EnumSet.of(
                    ControlPlanePermission.CP_TENANT_READ,
                    ControlPlanePermission.CP_TENANT_SUSPEND,
                    ControlPlanePermission.CP_TENANT_ACTIVATE,
                    ControlPlanePermission.CP_BILLING_READ,
                    ControlPlanePermission.CP_BILLING_WRITE
                    
            );

            case CONTROLPLANE_SUPPORT -> EnumSet.of(
                    ControlPlanePermission.CP_TENANT_READ,
                    ControlPlanePermission.CP_TENANT_SUSPEND,
                    ControlPlanePermission.CP_TENANT_ACTIVATE,
                    ControlPlanePermission.CP_USER_READ,
                    ControlPlanePermission.CP_USER_WRITE,
                    ControlPlanePermission.CP_USER_PASSWORD_RESET
            );

            case CONTROLPLANE_OPERATOR -> EnumSet.of(
                    ControlPlanePermission.CP_TENANT_READ,
                    ControlPlanePermission.CP_USER_READ
                   
            );
        };
    }
}
package brito.com.multitenancy001.infrastructure.config.time;

import java.time.Clock;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TimeConfig {

    @Bean
    public Clock systemClock() {
        return Clock.systemDefaultZone();
    }
}
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PublicFlywayConfig {

    @Bean
    public Flyway flywayPublic(DataSource dataSource) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas("public")
                .locations("classpath:db/migration/accounts")
                .baselineOnMigrate(true)
                .load();

      
        return flyway;
    }
}
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import org.flywaydb.core.Flyway;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Component
@RequiredArgsConstructor
@Slf4j
public class PublicFlywayRunner implements ApplicationRunner {

	private final Flyway flywayPublic;

	@Override
	public void run(ApplicationArguments args) {

		log.info("🚀 Executando Flyway ACCOUNT (schema public)");
		flywayPublic.migrate();
	}
}
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class PublicSchemaVerifier {
    
    private final JdbcTemplate jdbc;
    
    @EventListener(ApplicationReadyEvent.class)
    public void verifyTables() {
        log.info("🔍 Verificando tabelas criadas pelo Flyway...");
        
        try {
            // Apenas VERIFICA, não cria
            Integer accountsCount = jdbc.queryForObject(
                "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'accounts'", 
                Integer.class
            );
            
            Integer usersCount = jdbc.queryForObject(
            	    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'controlplane_users'",
            	    Integer.class
            	);

            
            log.info("✅ Verificação OK! Tabelas encontradas: accounts={}, controlplane_users={}", accountsCount, usersCount);

        } catch (Exception e) {
            log.error("⚠️ Aviso na verificação: {}", e.getMessage());
        }
    }
}package brito.com.multitenancy001.infrastructure.flyway.tenantschema;

import lombok.RequiredArgsConstructor;
import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;

@Service
@RequiredArgsConstructor
public class TenantSchemaFlywayMigrationService {

    private final DataSource dataSource;

    public void migrateTenantSchema(String schemaName) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas(schemaName)
                .defaultSchema(schemaName) // 🔥 ESSENCIAL
                .createSchemas(false)
                .locations("classpath:db/migration/tenants")
                .baselineOnMigrate(true)
                .load();

        flyway.migrate();
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.extern.slf4j.Slf4j;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

@Slf4j
@Component
public class CurrentTenantSchemaResolver
        implements CurrentTenantIdentifierResolver<String> {

    private static final String DEFAULT_SCHEMA = "public";
    private static final ThreadLocal<String> TENANT_THREAD_LOCAL = new ThreadLocal<>();

    /**
     * Bind do tenant na thread atual.
     * - Se vier vazio/nulo: remove o tenant (fica "sem tenant", e o resolver decide fallback).
     * - Se vier preenchido: seta no ThreadLocal.
     */
    public static void bindTenantToCurrentThread(String tenantId) {
        String previous = TENANT_THREAD_LOCAL.get();

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (StringUtils.hasText(normalized)) {
            TENANT_THREAD_LOCAL.set(normalized);
            if (!normalized.equals(previous)) {
                log.info("🔄 Tenant bindado à thread: {} -> {}", previous, normalized);
            } else {
                log.debug("🔄 Tenant já estava bindado: {}", normalized);
            }
        } else {
            TENANT_THREAD_LOCAL.remove();
            if (previous != null) {
                log.info("🧹 Tenant removido da thread (anterior: {})", previous);
            } else {
                log.debug("🧹 Tenant já estava vazio (nada para remover)");
            }
        }
    }

    /**
     * Retorna o tenant REALMENTE bindado.
     * ✅ Importante: aqui retornamos null quando não há tenant,
     * pra não mascarar estado e facilitar debug.
     */
    public static String resolveBoundTenantOrNull() {
        String t = TENANT_THREAD_LOCAL.get();
        return StringUtils.hasText(t) ? t : null;
    }

    /**
     * Mantém compatibilidade com seu código atual (ex.: logs do provider).
     * Use isso somente quando você quer um fallback explícito para public.
     */
    public static String resolveBoundTenantOrDefault() {
        String t = resolveBoundTenantOrNull();
        return (t != null ? t : DEFAULT_SCHEMA);
    }

    public static void unbindTenantFromCurrentThread() {
        String previous = TENANT_THREAD_LOCAL.get();
        TENANT_THREAD_LOCAL.remove();
        if (previous != null) {
            log.info("🧹 Tenant desbindado da thread (anterior: {})", previous);
        } else {
            log.debug("🧹 Tenant desbindado (já estava vazio)");
        }
    }

    /**
     * O Hibernate sempre precisa de um tenant válido.
     * ✅ Aqui sim a gente aplica fallback para DEFAULT_SCHEMA.
     */
    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenant = resolveBoundTenantOrNull();
        String resolved = (tenant != null ? tenant : DEFAULT_SCHEMA);

        if (log.isDebugEnabled()) {
            log.debug("🏷️ Hibernate resolveu tenant={} (bound={}, default={})",
                    resolved, tenant, DEFAULT_SCHEMA);
        }
        return resolved;
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return false;
    }

    @Override
    public boolean isRoot(String tenantIdentifier) {
        return DEFAULT_SCHEMA.equals(tenantIdentifier);
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.context.TenantContext;

import javax.sql.DataSource;
import java.sql.*;

@Slf4j
@Component
@RequiredArgsConstructor
public class TenantSchemaConnectionProvider
        extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String> {

    private static final long serialVersionUID = 1L;
    private static final String DEFAULT_SCHEMA = TenantContext.PUBLIC_SCHEMA;


    private final DataSource dataSource;

    @Override
    protected DataSource selectAnyDataSource() {
        return dataSource;
    }

    @Override
    protected DataSource selectDataSource(String tenantIdentifier) {
        return dataSource;
    }

    @Override
    public Connection getConnection(String tenantIdentifier) throws SQLException {

    	long threadId = Thread.currentThread().threadId();
    	String threadTenant = TenantContext.getOrDefaultPublic();

        
        
        
        String effectiveTenant = StringUtils.hasText(tenantIdentifier)
                ? tenantIdentifier
                : DEFAULT_SCHEMA;

        if (!StringUtils.hasText(tenantIdentifier)) {
            log.warn("⚠️ [MT] tenantIdentifier vazio → usando DEFAULT ({}) | threadTenant={}",
                    DEFAULT_SCHEMA, threadTenant);
        }

        validateSchemaName(effectiveTenant);

        Connection connection = dataSource.getConnection();

        try (Statement stmt = connection.createStatement()) {

            if (!DEFAULT_SCHEMA.equals(effectiveTenant)) {
                ensureSchemaExists(connection, effectiveTenant);

                String quotedTenant = quoteIdentifier(effectiveTenant);

                String setSearchPath = "SET search_path TO " + quotedTenant + ", public";
                log.info("🎯 [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL={}",
                        threadId, tenantIdentifier, threadTenant, setSearchPath);

                stmt.execute(setSearchPath);

            } else {
                log.info("🏠 [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL=SET search_path TO public;",
                        threadId, tenantIdentifier, threadTenant);

                stmt.execute("SET search_path TO public;");
            }

            return connection;

        } catch (SQLException e) {
            log.error("❌ [MT] Erro configurando conexão | effectiveTenant={}", effectiveTenant, e);
            try { connection.close(); } catch (SQLException ignore) {}
            throw e;
        }
    }

    @Override
    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
        if (connection == null || connection.isClosed()) return;

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("SET search_path TO public;");
        } finally {
            connection.close();
        }
    }

    private void ensureSchemaExists(Connection connection, String schemaName) throws SQLException {
        String quotedSchema = quoteIdentifier(schemaName);

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE SCHEMA IF NOT EXISTS " + quotedSchema);
        }

        try (PreparedStatement ps = connection.prepareStatement(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = ?")) {
            ps.setString(1, schemaName);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    throw new SQLException("Schema " + schemaName + " não encontrado após CREATE");
                }
            }
        }
    }

    private void validateSchemaName(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new IllegalArgumentException("schemaName vazio");
        }
        if (!schemaName.matches("[A-Za-z_][A-Za-z0-9_]*")) {
            throw new IllegalArgumentException("schemaName inválido: " + schemaName);
        }
    }

    private String quoteIdentifier(String identifier) {
        return "\"" + identifier + "\"";
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class TenantSchemaHibernateConfig {

    private final DataSource dataSource;
    private final TenantSchemaConnectionProvider multiTenantConnectionProvider;
    private final CurrentTenantSchemaResolver tenantResolver;

    @Bean(name = "tenantEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        // Entidades do TENANT
        emf.setPackagesToScan("brito.com.multitenancy001.tenant.domain");

        emf.setPersistenceUnitName("TENANT_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);

        // Multi-tenancy por schema
        props.put("hibernate.multiTenancy", "SCHEMA");
        props.put("hibernate.multi_tenant_connection_provider", multiTenantConnectionProvider);
        props.put("hibernate.tenant_identifier_resolver", tenantResolver);

        emf.setJpaPropertyMap(props);
        return emf;
    }

    @Bean(name = "tenantTransactionManager")
    public PlatformTransactionManager tenantTransactionManager(
            @Qualifier("tenantEntityManagerFactory") jakarta.persistence.EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
public class TransactionManagementConfig {
}
package brito.com.multitenancy001.infrastructure.multitenancy.observability;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Aspect
@Component
@Slf4j
public class TenantContextMonitor {
    
	@Around("@within(org.springframework.stereotype.Service)")
	public Object monitorServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
	    String methodName = joinPoint.getSignature().toShortString();

	    String boundTenant = TenantContext.getOrNull();               // null ou tenant real
	    String effectiveTenant = TenantContext.getOrDefaultPublic();  // tenant ou "public"

	    log.debug("🏁 INÍCIO {} - Tenant(bound={}, effective={})", methodName, boundTenant, effectiveTenant);

	    try {
	        Object result = joinPoint.proceed();

	        String boundAfter = TenantContext.getOrNull();
	        String effectiveAfter = TenantContext.getOrDefaultPublic();

	        log.debug("✅ FIM {} - Tenant(bound={}, effective={})", methodName, boundAfter, effectiveAfter);
	        return result;

	    } catch (Exception e) {
	        log.error("❌ ERRO {} - Tenant(bound={}, effective={}) - Erro: {}",
	                methodName, boundTenant, effectiveTenant, e.getMessage());
	        throw e;
	    }
	}

}package brito.com.multitenancy001.infrastructure.persistence;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Persistência do schema PUBLIC (ControlPlane).
 * Usa o EntityManagerFactory default do Spring Boot (bean: "entityManagerFactory")
 * e cria um alias semântico: "publicEntityManagerFactory".
 */
@Configuration
@EnableJpaRepositories(
        basePackages = "brito.com.multitenancy001.controlplane.persistence",
        entityManagerFactoryRef = "publicEntityManagerFactory",
        transactionManagerRef = "publicTransactionManager"
)
public class PublicPersistenceConfig {

    @Bean(name = "publicEntityManagerFactory")
    @Primary
    public EntityManagerFactory publicEntityManagerFactory(
            @Qualifier("entityManagerFactory") EntityManagerFactory emf
    ) {
        return emf;
    }

    @Bean(name = "publicTransactionManager")
    @Primary
    public PlatformTransactionManager publicTransactionManager(
            @Qualifier("publicEntityManagerFactory") EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}
package brito.com.multitenancy001.infrastructure.persistence;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class PublicSchemaHibernateConfig {

    private final DataSource dataSource;

    /**
     * ✅ EMF "default" que o Spring Boot normalmente criaria.
     * Como você criou um EMF manual (tenantEntityManagerFactory),
     * o Boot recuou e NÃO criou mais o entityManagerFactory.
     *
     * Então criamos explicitamente aqui.
     */
    @Bean(name = "entityManagerFactory")
    @Primary
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        // Entidades do PUBLIC (ControlPlane)
        emf.setPackagesToScan("brito.com.multitenancy001.controlplane.domain");

        emf.setPersistenceUnitName("PUBLIC_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);

        // opcional (Postgres): garantir que o default é public
        props.put("hibernate.default_schema", "public");

        emf.setJpaPropertyMap(props);
        return emf;
    }
}
package brito.com.multitenancy001.infrastructure.persistence;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@Configuration
@EnableJpaRepositories(
        basePackages = "brito.com.multitenancy001.tenant.persistence",
        entityManagerFactoryRef = "tenantEntityManagerFactory",
        transactionManagerRef = "tenantTransactionManager"
)
public class TenantPersistenceConfig {
}
package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;

@Getter
public class AuthenticatedUserContext implements UserDetails {

    private static final long serialVersionUID = 1L;

    private final Long userId;
    private final String username;
    private final String email;
    private final String password;
    private final boolean mustChangePassword;

    private final boolean enabled;
    private final boolean accountNonLocked;

    private final Long accountId;
    private final String schemaName;

    // opcional: manter role para debug/claims (NÃO entra em authorities)
    private final String roleAuthority;

    // ✅ permission-only
    private final Collection<? extends GrantedAuthority> authorities;
    
    public boolean isMustChangePassword() {
        return mustChangePassword;
    }
    

    public AuthenticatedUserContext(
            ControlPlaneUser user,
            String schemaName,
            LocalDateTime now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.password = user.getPassword();

        this.accountId = user.getAccount().getId();
        this.schemaName = schemaName;

        this.roleAuthority = user.getRole() != null ? user.getRole().asAuthority() : null;

        this.authorities = authorities;

        this.enabled = user.isEnabledForLogin();
        this.accountNonLocked = user.isAccountNonLocked(now);
        this.mustChangePassword = user.isMustChangePassword();

    }

    public AuthenticatedUserContext(
            TenantUser user,
            String schemaName,
            LocalDateTime now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.password = user.getPassword();

        this.accountId = user.getAccountId();
        this.schemaName = schemaName;

        this.roleAuthority = user.getRole() != null ? user.getRole().asAuthority() : null;

        this.authorities = authorities;

        this.enabled = !user.isDeleted() && !user.isSuspendedByAccount() && !user.isSuspendedByAdmin();
        this.accountNonLocked = user.getLockedUntil() == null || !user.getLockedUntil().isAfter(now);
        this.mustChangePassword = user.isMustChangePassword();

    }

    @Override public Collection<? extends GrantedAuthority> getAuthorities() { return authorities; }
    @Override public String getPassword() { return password; }
    @Override public String getUsername() { return username; }

    @Override public boolean isAccountNonExpired() { return true; }
    @Override public boolean isAccountNonLocked() { return accountNonLocked; }
    @Override public boolean isCredentialsNonExpired() { return true; }
    @Override public boolean isEnabled() { return enabled; }
}
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.infrastructure.security.filter.JwtAuthenticationFilter;
import brito.com.multitenancy001.infrastructure.security.filter.MustChangePasswordFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public MustChangePasswordFilter mustChangePasswordFilter() {
        return new MustChangePasswordFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz

                // =========================
                // 🔓 PUBLIC
                // =========================
                .requestMatchers("/actuator/health").permitAll()

                // =========================
                // 🔓 AUTH CONTROLPLANE (admin)
                // =========================
                .requestMatchers(
                    "/api/admin/auth/login",
                    "/api/admin/auth/refresh"
                ).permitAll()

                // ✅ troca de senha do próprio usuário (precisa estar autenticado)
                .requestMatchers("/api/admin/me/password").authenticated()

                // =========================
                // 🔓 AUTH TENANT
                // =========================
                .requestMatchers(
                    "/api/tenant/auth/login",
                    "/api/tenant/auth/refresh"
                ).permitAll()

                // =========================
                // 🔓 PASSWORD RESET TENANT
                // =========================
                .requestMatchers(
                    "/api/tenant/password/forgot",
                    "/api/tenant/password/reset"
                ).permitAll()

                // =========================
                // 🔓 SIGNUP / CHECKUSER
                // =========================
                .requestMatchers(
                    "/api/accounts/auth/checkuser",
                    "/api/signup"
                ).permitAll()

                // =========================
                // ✅ BOUNDARIES OFICIAIS
                // =========================
                .requestMatchers("/api/admin/**").authenticated()
                .requestMatchers("/api/controlplane/**").authenticated()
                .requestMatchers("/api/tenant/**").authenticated()

                // =========================
                // ❌ Qualquer rota fora disso é erro de arquitetura
                // =========================
                .anyRequest().denyAll()
            );

        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        // ✅ MustChangePassword precisa rodar DEPOIS do JWT filter
        http.addFilterAfter(mustChangePasswordFilter(), JwtAuthenticationFilter.class);

        return http.build();
    }
}
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final MultiContextUserDetailsService multiContextUserDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest httpServletRequest,
            @NonNull HttpServletResponse httpServletResponse,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        boolean bound = false;

        try {
            final String authHeader = httpServletRequest.getHeader("Authorization");

            // "Bearer ..." é esquema HTTP, não é domínio do token
            if (!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            final String jwt = authHeader.substring(7);

            if (!jwtTokenProvider.validateToken(jwt)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            // ✅ agora é claro: authDomain = TENANT/CONTROLPLANE/...
            final String authDomain = jwtTokenProvider.getAuthDomain(jwt);
            final String username = jwtTokenProvider.getUsernameFromToken(jwt);

         // ✅ TRAVA FORTE (403): token tem que bater com a rota
         // Regra: se tokenType == TENANT e path startsWith /api/admin => 403
         if (requiresControlPlane(httpServletRequest) && "TENANT".equals(authDomain)) {
             httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
             return;
         }

         // (opcional mas recomendado) Regra simétrica: token CONTROLPLANE não entra em /api/tenant => 403
         if (requiresTenant(httpServletRequest) && "CONTROLPLANE".equals(authDomain)) {
             httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
             return;
         }

         // Se chegou aqui, o domínio bate com a área
         if (requiresControlPlane(httpServletRequest) && !"CONTROLPLANE".equals(authDomain)) {
             filterChain.doFilter(httpServletRequest, httpServletResponse);
             return;
         }
         if (requiresTenant(httpServletRequest) && !"TENANT".equals(authDomain)) {
             filterChain.doFilter(httpServletRequest, httpServletResponse);
             return;
         }


            // só aceitamos TENANT / CONTROLPLANE aqui
            if (!"TENANT".equals(authDomain) && !"CONTROLPLANE".equals(authDomain)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            if (!StringUtils.hasText(username)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            if (SecurityContextHolder.getContext().getAuthentication() == null) {

                UserDetails userDetails;

                if ("TENANT".equals(authDomain)) {
                    final String tenantSchema = jwtTokenProvider.getTenantSchemaFromToken(jwt);

                    if (!StringUtils.hasText(tenantSchema) || "public".equalsIgnoreCase(tenantSchema)) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    if (!tenantSchema.matches("^[a-zA-Z0-9_]+$")) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    TenantContext.bind(tenantSchema);
                    bound = true;

                    Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
                    if (accountId == null) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    userDetails = multiContextUserDetailsService.loadTenantUser(username, accountId);

                } else { // CONTROLPLANE
                    String context = jwtTokenProvider.getContextFromToken(jwt);
                    if (StringUtils.hasText(context) && !"public".equalsIgnoreCase(context)) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
                    if (accountId == null) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    userDetails = multiContextUserDetailsService.loadControlPlaneUser(username, accountId);
                }

                UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities()
                        );

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(httpServletRequest));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }

            filterChain.doFilter(httpServletRequest, httpServletResponse);

        } finally {
            if (bound) {
                TenantContext.clear();
            }
        }
    }

    private boolean requiresControlPlane(HttpServletRequest httpServletRequest) {
        String path = httpServletRequest.getRequestURI();
        return path.startsWith("/api/admin/") || path.startsWith("/api/controlplane/");
    }

    private boolean requiresTenant(HttpServletRequest httpServletRequest) {
        String path = httpServletRequest.getRequestURI();
        return path.startsWith("/api/tenant/");
    }
}
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Map;

public class MustChangePasswordFilter extends OncePerRequestFilter {

    private static final String CHANGE_PASSWORD_PATH = "/api/admin/me/password";
    private static final String ME_PATH              = "/api/admin/me";

    private static final String LOGIN_PATH   = "/api/admin/auth/login";
    private static final String REFRESH_PATH = "/api/admin/auth/refresh";

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        String method = request.getMethod();
        String path = request.getRequestURI();

        // ✅ libera preflight (CORS)
        if ("OPTIONS".equalsIgnoreCase(method)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera login/refresh
        if (path.startsWith(LOGIN_PATH) || path.startsWith(REFRESH_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera troca de senha
        if (path.startsWith(CHANGE_PASSWORD_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera GET /api/admin/me (para o front exibir estado e mensagem)
        if ("GET".equalsIgnoreCase(method) && path.equals(ME_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        // só aplica no escopo do controlplane (/api/admin/**)
        if (!path.startsWith("/api/admin/")) {
            filterChain.doFilter(request, response);
            return;
        }

        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.isAuthenticated() && auth.getPrincipal() instanceof AuthenticatedUserContext ctx) {

            if (ctx.isMustChangePassword()) {
                response.setStatus(428); // Precondition Required
                response.setContentType(MediaType.APPLICATION_JSON_VALUE);

                Map<String, Object> body = Map.of(
                        "error", "MUST_CHANGE_PASSWORD",
                        "message", "Você precisa alterar a senha antes de continuar.",
                        "status", 428,
                        "details", Map.of(
                                "userId", ctx.getUserId(),
                                "username", ctx.getUsername(),
                                "accountId", ctx.getAccountId()
                        )
                );

                response.getWriter().write(objectMapper.writeValueAsString(body));
                return;
            }
        }

        filterChain.doFilter(request, response);
    }
}
package brito.com.multitenancy001.infrastructure.security.jwt;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.time.AppClock;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtTokenProvider {

    public static final String CLAIM_AUTHORITIES = "authorities";
    public static final String CLAIM_AUTH_DOMAIN = "authDomain"; // <-- NOVO
    public static final String CLAIM_CONTEXT = "context";
    public static final String CLAIM_ACCOUNT_ID = "accountId";
    public static final String CLAIM_USER_ID = "userId";

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private long jwtExpirationInMs;

    @Value("${app.jwt.refresh.expiration}")
    private long refreshExpirationInMs;

    private final AppClock appClock;
    private SecretKey key;

    public JwtTokenProvider(AppClock appClock) {
        this.appClock = appClock;
    }

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            throw new IllegalArgumentException("JWT secret must be at least 256 bits (32 chars)");
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    private Date issuedAt() {
        return Date.from(appClock.instant());
    }

    private Date expiresAtInMs(long ttlMillis) {
        Instant exp = appClock.instant().plusMillis(ttlMillis);
        return Date.from(exp);
    }

    /* =========================
       ACCESS TOKEN - CONTROLPLANE
       ========================= */
    public String generateControlPlaneToken(Authentication authentication, Long accountId, String context) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getUsername())
                .claim(CLAIM_AUTHORITIES, user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim(CLAIM_AUTH_DOMAIN, "CONTROLPLANE") // <-- NOVO
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, user.getUserId())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       ACCESS TOKEN - TENANT
       ========================= */
    public String generateTenantToken(Authentication authentication, Long accountId, String context) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getUsername())
                .claim(CLAIM_AUTHORITIES, user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim(CLAIM_AUTH_DOMAIN, "TENANT") // <-- NOVO
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, user.getUserId())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       REFRESH TOKEN
       ========================= */
    public String generateRefreshToken(String username, String context) {
        return Jwts.builder()
                .subject(username)
                .claim(CLAIM_AUTH_DOMAIN, "REFRESH") // <-- NOVO
                .claim(CLAIM_CONTEXT, context)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(refreshExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       PASSWORD RESET TOKEN
       ========================= */
    public String generatePasswordResetToken(String username, String context, Long accountId) {
        long oneHourMs = 3_600_000L;

        return Jwts.builder()
                .subject(username)
                .claim(CLAIM_AUTH_DOMAIN, "PASSWORD_RESET") // <-- NOVO
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(oneHourMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       LEITURA DE CLAIMS
       ========================= */
    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    public String getUsernameFromToken(String token) {
        return getAllClaimsFromToken(token).getSubject();
    }

    /**
     * Obtém o contexto do token (antigo tenantSchema)
     * Mantém compatibilidade retornando "tenantSchema" se "context" não existir
     */
    public String getContextFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String context = claims.get(CLAIM_CONTEXT, String.class);
        if (context == null) {
            context = claims.get("tenantSchema", String.class);
        }

        String authDomain = getAuthDomain(token);

        if ("TENANT".equals(authDomain) && "public".equalsIgnoreCase(context)) {
            throw new JwtException("Invalid context for TENANT token: public");
        }

        return context;
    }

    public String getTenantSchemaFromToken(String token) {
        return getContextFromToken(token);
    }

    public Long getAccountIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ACCOUNT_ID, Long.class);
    }

    /**
     * ✅ NOVO: authDomain = TENANT/CONTROLPLANE/REFRESH/PASSWORD_RESET
     * ✅ Compatível: se não existir, cai para claim antiga "type"
     */
    public String getAuthDomain(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authDomain = claims.get(CLAIM_AUTH_DOMAIN, String.class);
        if (!StringUtils.hasText(authDomain)) {
            authDomain = claims.get("type", String.class); // compat tokens antigos
        }

        return authDomain;
    }

    // Se você tinha o método getTokenType, mantenha como alias (opcional)
    public String getTokenType(String token) {
        return getAuthDomain(token);
    }

    public Long getUserIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_USER_ID, Long.class);
    }

    public List<String> getAuthoritiesFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authorities = claims.get(CLAIM_AUTHORITIES, String.class);
        if (!StringUtils.hasText(authorities)) {
            authorities = claims.get("roles", String.class); // compat tokens antigos
        }

        return splitCsv(authorities);
    }

    private List<String> splitCsv(String csv) {
        if (!StringUtils.hasText(csv)) return List.of();

        return Arrays.stream(csv.split(","))
                .map(String::trim)
                .filter(StringUtils::hasText)
                .distinct()
                .toList();
    }

    public boolean isTokenExpired(String token) {
        try {
            Claims claims = getAllClaimsFromToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(Date.from(appClock.instant()));
        } catch (Exception e) {
            return true;
        }
    }

    public boolean validateToken(String token) {
        try {
            getAllClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public boolean isControlPlaneToken(String token) {
        return "CONTROLPLANE".equals(getAuthDomain(token));
    }

    public boolean isTenantToken(String token) {
        return "TENANT".equals(getAuthDomain(token));
    }

    public boolean isRefreshToken(String token) {
        return "REFRESH".equals(getAuthDomain(token));
    }

    public boolean isPasswordResetToken(String token) {
        return "PASSWORD_RESET".equals(getAuthDomain(token));
    }

    public boolean isTokenInContext(String token, String expectedContext) {
        String actualContext = getContextFromToken(token);
        return expectedContext.equals(actualContext);
    }

    public boolean isControlPlaneContextToken(String token) {
        String context = getContextFromToken(token);
        return "public".equals(context);
    }
}
package brito.com.multitenancy001.infrastructure.security;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.api.error.ApiException;

@Component
@RequiredArgsConstructor
public class SecurityUtils {
    
    public Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUserId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
    public Long getCurrentAccountId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getAccountId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
    public String getCurrentSchema() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getSchemaName();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
    public String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUsername();
        }
        return authentication != null ? authentication.getName() : null;
    }
    
    public String getCurrentRoleAuthority() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getRoleAuthority(); // ex: "ROLE_CONTROLPLANE_OWNER"
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }

    /**
     * Lê a role do CONTROLPLANE a partir do roleAuthority armazenado no principal.
     * Ex.: "ROLE_CONTROLPLANE_OWNER" -> ControlPlaneRole.CONTROLPLANE_OWNER
     */
    public ControlPlaneRole getCurrentControlPlaneRole() {
        String roleAuthority = getCurrentRoleAuthority();
        if (roleAuthority == null || !roleAuthority.startsWith("ROLE_")) {
            throw new ApiException("FORBIDDEN", "Role inválida no contexto de autenticação", 403);
        }
        String roleName = roleAuthority.substring("ROLE_".length());
        try {
            return ControlPlaneRole.valueOf(roleName);
        } catch (IllegalArgumentException e) {
            throw new ApiException("FORBIDDEN", "Role não reconhecida: " + roleName, 403);
        }
    }
    
    
}package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRolePermissions;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.util.StringUtils;

import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;

public final class AuthoritiesFactory {

    private AuthoritiesFactory() {}

    public static Set<GrantedAuthority> forControlPlane(ControlPlaneUser user) {
        Set<String> merged = new LinkedHashSet<>();

        // defaults da role (enum -> string)
        for (ControlPlanePermission p : ControlPlaneRolePermissions.permissionsFor(user.getRole())) {
            merged.add(p.name());
        }

        // permissions explícitas do banco
        if (user.getPermissions() != null) {
            for (String raw : user.getPermissions()) {
                if (!StringUtils.hasText(raw)) continue;
                merged.add(raw.trim().toUpperCase(Locale.ROOT));
            }
        }

        // normaliza e bloqueia escopo errado (TEN_ dentro do CP, etc.)
        merged = PermissionScopeValidator.normalizeControlPlane(merged);

        Set<GrantedAuthority> authorities = new LinkedHashSet<>();
        for (String perm : merged) {
            authorities.add(new SimpleGrantedAuthority(perm));
        }
        return authorities;
    }

    public static Set<GrantedAuthority> forTenant(TenantUser user) {
        Set<String> merged = new LinkedHashSet<>();

        // ✅ defaults por role (igual sua entidade faz)
        if (user.getRole() != null) {
            for (TenantPermission p : TenantRolePermissions.permissionsFor(user.getRole())) {
                merged.add(p.name());
            }
        }

        // permissions explícitas do banco
        if (user.getPermissions() != null) {
            for (String raw : user.getPermissions()) {
                if (!StringUtils.hasText(raw)) continue;
                merged.add(raw.trim().toUpperCase(Locale.ROOT));
            }
        }

        // ✅ normaliza SEMPRE e bloqueia CP_ dentro do tenant
        merged = PermissionScopeValidator.normalizeTenant(merged);

        Set<GrantedAuthority> authorities = new LinkedHashSet<>();
        for (String perm : merged) {
            authorities.add(new SimpleGrantedAuthority(perm));
        }
        return authorities;
    }
}
package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class MultiContextUserDetailsService implements UserDetailsService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final TenantUserRepository tenantUserRepository;
    private final AppClock appClock;

    private LocalDateTime now() {
        return appClock.now();
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String schemaName = TenantContext.getOrNull();

        if (schemaName == null || "public".equalsIgnoreCase(schemaName)) {
            return loadControlPlaneUser(username);
        }

        LocalDateTime now = now();

        TenantUser user = tenantUserRepository.findByUsernameAndDeletedFalse(username)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado no tenant", 404));

        var authorities = AuthoritiesFactory.forTenant(user);
        return new AuthenticatedUserContext(user, schemaName, now, authorities);
    }

    public UserDetails loadControlPlaneUser(String username, Long accountId) {
        LocalDateTime now = now();

        if (accountId == null) {
            throw new ApiException(
                    "ACCOUNT_REQUIRED",
                    "accountId é obrigatório para autenticar usuário da controlplane",
                    400
            );
        }

        ControlPlaneUser user = controlPlaneUserRepository
                .findByUsernameAndAccount_IdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException(
                        "USER_NOT_FOUND",
                        "Usuário controlplane não encontrado para esta conta",
                        404
                ));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return new AuthenticatedUserContext(user, "public", now, authorities);
    }

    public UserDetails loadControlPlaneUser(String username) {
        LocalDateTime now = now();

        ControlPlaneUser user = controlPlaneUserRepository.findByUsernameAndDeletedFalse(username)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário controlplane não encontrado", 404));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return new AuthenticatedUserContext(user, "public", now, authorities);
    }

    public UserDetails loadTenantUser(String username, Long accountId) {
        String schemaName = TenantContext.getOrNull();
        if (schemaName == null || "public".equalsIgnoreCase(schemaName)) {
            throw new ApiException(
                    "TENANT_CONTEXT_REQUIRED",
                    "TenantContext não está bindado para autenticar usuário tenant",
                    401
            );
        }

        if (accountId == null) {
            throw new ApiException(
                    "ACCOUNT_REQUIRED",
                    "accountId é obrigatório para autenticar usuário tenant",
                    400
            );
        }

        LocalDateTime now = now();

        TenantUser user = tenantUserRepository
                .findByUsernameAndAccountIdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado no tenant", 404));

        var authorities = AuthoritiesFactory.forTenant(user);
        return new AuthenticatedUserContext(user, schemaName, now, authorities);
    }
}
package brito.com.multitenancy001.infrastructure.tenant;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;

@Component
public class TenantExecutor {

    private final TenantSchemaProvisioningService tenantSchemaService;

    public TenantExecutor(TenantSchemaProvisioningService tenantSchemaService) {
        this.tenantSchemaService = tenantSchemaService;
    }

    public <T> T run(String schemaName, Supplier<T> fn) {
        if (schemaName == null || "public".equals(schemaName)) {
            throw new ApiException("TENANT_INVALID", "Tenant inválido", 404);
        }

        // ✅ padronizado: nada de bind/clear manual
        try (TenantContext.Scope ignored = TenantContext.scope(schemaName)) {
            return fn.get();
        }
    }

    public void run(String schemaName, Runnable fn) {
        run(schemaName, () -> { fn.run(); return null; });
    }

    /** Retorna defaultValue se schemaName/tabela não existir (bom p/ side-effects). */
    public <T> T runIfReady(String schemaName, String requiredTable, Supplier<T> fn, T defaultValue) {
        if (schemaName == null || "public".equals(schemaName)) return defaultValue;
        if (!tenantSchemaService.schemaExists(schemaName)) return defaultValue;
        if (requiredTable != null && !tenantSchemaService.tableExists(schemaName, requiredTable)) return defaultValue;
        return run(schemaName, fn);
    }

    /** Lança ApiException se schemaName/tabela não existir (bom p/ endpoints admin). */
    public void assertReadyOrThrow(String schemaName, String requiredTable) {
        if (schemaName == null || "public".equals(schemaName)) {
            throw new ApiException("TENANT_INVALID", "Tenant inválido", 404);
        }
        if (!tenantSchemaService.schemaExists(schemaName)) {
            throw new ApiException("TENANT_SCHEMA_NOT_FOUND", "SchemaName do tenant não existe", 404);
        }
        if (requiredTable != null && !tenantSchemaService.tableExists(schemaName, requiredTable)) {
            throw new ApiException("TENANT_TABLE_NOT_FOUND", "Tabela " + requiredTable + " não existe no tenant", 404);
        }
    }

    public <T> T runOrThrow(String schemaName, String requiredTable, Supplier<T> fn) {
        assertReadyOrThrow(schemaName, requiredTable);
        return run(schemaName, fn);
    }
}
package brito.com.multitenancy001.infrastructure.tenant;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantProvisioningBridge {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public void ensureSchemaExistsAndMigrate(String schemaName) {
        tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(schemaName);
    }
}
package brito.com.multitenancy001.infrastructure.tenant;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.TxExecutor;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.application.username.generator.UsernameGeneratorService;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import brito.com.multitenancy001.tenant.security.TenantRole;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantUserAdminBridge {

    private static final String REQUIRED_TABLE = "tenant_users";

    private final TenantExecutor tenantExecutor;
    private final TxExecutor txExecutor;

    private final TenantUserRepository tenantUserRepository;
    private final UsernameGeneratorService usernameGenerator;
    private final PasswordEncoder passwordEncoder;

    private final AppClock appClock;

    public List<UserSummaryData> listUserSummaries(String schemaName, Long accountId, boolean onlyActive) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantReadOnlyTx(() -> {

                    var users = onlyActive
                            ? tenantUserRepository.findActiveUsersByAccount(accountId)
                            : tenantUserRepository.findByAccountId(accountId);

                    return users.stream()
                            .map(u -> new UserSummaryData(
                                    u.getId(),
                                    u.getAccountId(),
                                    u.getName(),
                                    u.getUsername(),
                                    u.getEmail(),
                                    u.getRole() == null ? null : u.getRole().name(),
                                    u.isSuspendedByAccount(),
                                    u.isSuspendedByAdmin(),
                                    u.isDeleted()
                            ))
                            .toList();
                })
        );
    }

    public TenantUser createTenantOwner(String schemaName, Long accountId, String email, String rawPassword) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantTx(() -> {

                    boolean emailExists = tenantUserRepository.existsByEmailAndAccountId(email, accountId);
                    if (emailExists) {
                        throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já cadastrado nesta conta", 409);
                    }

                    TenantUser u = new TenantUser();
                    u.setAccountId(accountId);
                    u.setName("Administrador");
                    u.setEmail(email);
                    u.setPassword(passwordEncoder.encode(rawPassword));
                    u.setRole(TenantRole.TENANT_OWNER);
                    u.setSuspendedByAccount(false);
                    u.setSuspendedByAdmin(false);

                    
                    u.setTimezone("America/Sao_Paulo");
                    u.setLocale("pt_BR");

                    for (int attempt = 0; attempt < 5; attempt++) {
                        u.setUsername(usernameGenerator.generateFromEmail(email, accountId));
                        try {
                            return tenantUserRepository.save(u);
                        } catch (DataIntegrityViolationException e) {
                            log.warn("Colisão de username ao criar admin. Tentativa {}. accountId={} email={}",
                                    attempt + 1, accountId, email);
                        }
                    }

                    throw new IllegalStateException("Failed to create tenant admin due to repeated username collisions");
                })
        );
    }

    public List<TenantUser> listUsers(String schemaName, Long accountId, boolean onlyActive) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantReadOnlyTx(() -> onlyActive
                        ? tenantUserRepository.findActiveUsersByAccount(accountId)
                        : tenantUserRepository.findByAccountId(accountId)
                )
        );
    }

    public void setSuspendedByAdmin(String schemaName, Long accountId, Long userId, boolean suspended) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        tenantExecutor.run(schemaName, () ->
                txExecutor.tenantTx(() -> {
                    int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
                    if (updated == 0) {
                        throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado ou removido", 404);
                    }
                    return null;
                })
        );
    }

    public int suspendAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName, REQUIRED_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.suspendAllByAccount(accountId)),
                0
        );
    }

    public int unsuspendAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName, REQUIRED_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.unsuspendAllByAccount(accountId)),
                0
        );
    }

    public int softDeleteAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName, REQUIRED_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> {
                    List<TenantUser> users = tenantUserRepository.findByAccountId(accountId);

                    // ✅ congela o "agora" uma vez (consistência)
                    LocalDateTime now = appClock.now();
                    long base = appClock.epochMillis();

                    long seq = 0;
                    for (TenantUser u : users) {
                        if (!u.isDeleted()) {
                            // ✅ sufixo por usuário para evitar colisão de username/email
                            u.softDelete(now, base + (seq++));
                            u.setUpdatedAt(now);
                        }
                    }

                    tenantUserRepository.saveAll(users);
                    return users.size();
                }),
                0
        );
    }

    public int restoreAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName, REQUIRED_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> {
                    List<TenantUser> users = tenantUserRepository.findByAccountId(accountId);

                    LocalDateTime now = appClock.now();

                    for (TenantUser u : users) {
                        if (u.isDeleted()) {
                            u.restore();
                            u.setUpdatedAt(now);
                        }
                    }

                    tenantUserRepository.saveAll(users);
                    return users.size();
                }),
                0
        );
    }
}
package brito.com.multitenancy001;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
//@EnableCaching
@EnableScheduling
public class Multitenancy001Application {

	public static void main(String[] args) {
		SpringApplication.run(Multitenancy001Application.class, args);
	}

}
package brito.com.multitenancy001.shared.account;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import brito.com.multitenancy001.controlplane.persistence.account.AccountEntitlementsRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsService {

    private final AccountEntitlementsRepository entitlementsRepository;

    /**
     * Resolve entitlements efetivos da conta:
     * - PLATFORM => ilimitado
     * - TENANT => lê de account_entitlements
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public AccountEntitlementsSnapshot resolveEffective(Account account) {
        if (account == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "Conta é obrigatória", 400);
        }

        if (account.isBuiltInAccount()) {
            return AccountEntitlementsSnapshot.ofUnlimited();
        }

        AccountEntitlements ent = entitlementsRepository.findById(account.getId())
                .orElseThrow(() -> new ApiException(
                        "ENTITLEMENTS_NOT_FOUND",
                        "Entitlements não encontrados para a conta " + account.getId(),
                        500
                ));

        Integer maxUsers = safePositive(ent.getMaxUsers(), "maxUsers");
        Integer maxProducts = safePositive(ent.getMaxProducts(), "maxProducts");
        Integer maxStorageMb = safePositive(ent.getMaxStorageMb(), "maxStorageMb");

        return AccountEntitlementsSnapshot.ofLimited(maxUsers, maxProducts, maxStorageMb);
    }

    /**
     * Valida quota para criação de usuário.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public boolean canCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        return currentUsers < eff.maxUsers();
    }

    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);

        if (currentUsers >= eff.maxUsers()) {
            throw new ApiException(
                    "QUOTA_MAX_USERS_REACHED",
                    "Limite de usuários atingido para este plano",
                    403
            );
        }
    }

    /**
     * Valida quota para criação de produtos.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanCreateProduct(Account account, long currentProducts) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);

        if (currentProducts >= eff.maxProducts()) {
            throw new ApiException(
                    "QUOTA_MAX_PRODUCTS_REACHED",
                    "Limite de produtos atingido para este plano",
                    403
            );
        }
    }

    /**
     * Valida quota de armazenamento.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanConsumeStorage(Account account, long currentStorageMb, long deltaMb) {
        if (deltaMb < 0) {
            throw new ApiException("INVALID_STORAGE_DELTA", "deltaMb não pode ser negativo", 400);
        }

        AccountEntitlementsSnapshot eff = resolveEffective(account);
        long after = currentStorageMb + deltaMb;

        if (after > eff.maxStorageMb()) {
            throw new ApiException(
                    "QUOTA_MAX_STORAGE_REACHED",
                    "Limite de armazenamento atingido para este plano",
                    403
            );
        }
    }

    // =========================
    // Helpers
    // =========================

    private Integer safePositive(Integer value, String field) {
        if (value == null || value <= 0) {
            throw new ApiException(
                    "INVALID_ENTITLEMENT",
                    "Entitlement inválido: " + field,
                    500
            );
        }
        return value;
    }
}
package brito.com.multitenancy001.shared.account;

public record AccountEntitlementsSnapshot(
        int maxUsers,
        int maxProducts,
        int maxStorageMb,
        boolean unlimited
) {

    public static AccountEntitlementsSnapshot ofUnlimited() {
        return new AccountEntitlementsSnapshot(
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                true
        );
    }

    public static AccountEntitlementsSnapshot ofLimited(int maxUsers, int maxProducts, int maxStorageMb) {
        return new AccountEntitlementsSnapshot(maxUsers, maxProducts, maxStorageMb, false);
    }
}
package brito.com.multitenancy001.shared.account;

import java.time.LocalDateTime;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountResolver {

	private final AccountRepository accountRepository;
	private final AppClock appClock;

	/**
	 * Resolve conta no schema PUBLIC e já valida se existe e se está ativa. Retorna
	 * apenas um snapshot mínimo (sem expor o domínio do controlplane).
	 */
	public AccountSnapshot resolveActiveAccountBySlug(String slug) {
		LocalDateTime now = appClock.now();
		TenantContext.clear(); // garante PUBLIC

		Account account = accountRepository.findBySlugAndDeletedFalse(slug)
				.orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

		if (!account.isActive(now)) {
			throw new ApiException("ACCOUNT_INACTIVE", "Conta inativa", 403);
		}

		return new AccountSnapshot(account.getId(), account.getSchemaName(), account.getStatus().name());
	}
}
package brito.com.multitenancy001.shared.account;

public record AccountSnapshot(
        Long id,
        String schemaName,
        String status
) {}
package brito.com.multitenancy001.shared.api.dto.auth;

public record JwtResponse(
    String accessToken,
    String refreshToken,
    /**
     * HTTP Authorization scheme (ex: "Bearer").
     * NÃO confundir com o "authDomain" do JWT (TENANT/CONTROLPLANE/etc).
     */
    String tokenType,
    Long userId,
    String username,
    String email,
    String role,
    Long accountId,
    String tenantSchema
) {
    public JwtResponse {
        if (tokenType == null || tokenType.isEmpty()) {
            tokenType = "Bearer";
        }
    }

    public JwtResponse(
            String accessToken, String refreshToken,
            Long userId, String username, String email,
            String role, Long accountId, String tenantSchema
    ) {
        this(accessToken, refreshToken, "Bearer",
             userId, username, email, role, accountId, tenantSchema);
    }
}
package brito.com.multitenancy001.shared.api.error;



import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiEnumErrorResponse {
    private LocalDateTime timestamp;
    private String error;
    private String message;
    private String field;
    private String invalidValue;
    private List<String> allowedValues;
}package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
public class ApiErrorResponse {

    private LocalDateTime timestamp;
    private String error;
    private String message;

    // 🔥 novo campo (opcional)
    private List<String> details;
}
package brito.com.multitenancy001.shared.api.error;

import lombok.Getter;

@Getter
public class ApiException extends RuntimeException {

    private static final long serialVersionUID = 1L;
    private final String error;
    private final int status;
    private final Object details;
    private final Object[] allowedValues; // 🔥 NOVO CAMPO

    // Construtor sem allowedValues
    public ApiException(String error, String message, int status) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = null;
        this.allowedValues = null;
    }

    // Construtor com details
    public ApiException(String error, String message, int status, Object details) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = details;
        this.allowedValues = null;
    }

    // 🔥 NOVO CONSTRUTOR com allowedValues
    public ApiException(String error, String message, int status, Object details, Object[] allowedValues) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = details;
        this.allowedValues = allowedValues;
    }

    // Método para obter allowedValues
    public Object[] getAllowedValues() {
        return allowedValues;
    }

    // Método para verificar se tem allowedValues
    public boolean hasAllowedValues() {
        return allowedValues != null && allowedValues.length > 0;
    }
}package brito.com.multitenancy001.shared.api.error;

import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RestControllerAdvice
@RequiredArgsConstructor
@Slf4j
public class GlobalExceptionHandler {

    private final AppClock appClock;

    private LocalDateTime now() {
        return appClock.now();
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleNotReadable(HttpMessageNotReadableException ex) {

        Throwable cause = ex.getCause();

        if (cause instanceof InvalidFormatException ife) {
            Class<?> targetType = ife.getTargetType();

            if (targetType != null && targetType.isEnum()) {
                String fieldName = ife.getPath().isEmpty() ? "status" : ife.getPath().get(0).getFieldName();
                String invalidValue = ife.getValue() != null ? ife.getValue().toString() : "null";

                List<String> allowedValues = Arrays.stream(targetType.getEnumConstants())
                        .map(Object::toString)
                        .toList();

                return ResponseEntity.badRequest().body(
                        ApiEnumErrorResponse.builder()
                                .timestamp(now())
                                .error("INVALID_ENUM")
                                .message("Valor inválido para o campo " + fieldName)
                                .field(fieldName)
                                .invalidValue(invalidValue)
                                .allowedValues(allowedValues)
                                .build()
                );
            }
        }

        return ResponseEntity.badRequest().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INVALID_REQUEST_BODY")
                        .message("Corpo da requisição inválido")
                        .build()
        );
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {

        String errorMessage = ex.getMostSpecificCause() != null ? ex.getMostSpecificCause().getMessage() : ex.getMessage();
        if (!StringUtils.hasText(errorMessage)) errorMessage = "";

        log.debug("DataIntegrityViolationException: {}", errorMessage);

        if (errorMessage.contains("tax_id_number")) {
            String cnpj = extractValue(errorMessage, "tax_id_number");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_NUMBER")
                            .message("Já existe uma conta com o Number: " + cnpj)
                            .field("taxIdNumber")
                            .invalidValue(cnpj)
                            .build()
            );
        }

        if (errorMessage.contains("LoginEmail")) {
            String email = extractValue(errorMessage, "LoginEmail");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_EMAIL")
                            .message("Já existe uma conta com o email " + email)
                            .field("loginEmail")
                            .invalidValue(email)
                            .build()
            );
        }

        if (errorMessage.contains("slug")) {
            String slug = extractValue(errorMessage, "slug");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_SLUG")
                            .message("Já existe uma conta com o slug " + slug)
                            .field("slug")
                            .invalidValue(slug)
                            .build()
            );
        }

        if (errorMessage.contains("schema_name")) {
            String schema = extractValue(errorMessage, "schema_name");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_SCHEMA")
                            .message("Erro interno: schema " + schema + " já existe")
                            .build()
            );
        }

        return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("DUPLICATE_ENTRY")
                        .message("Registro duplicado. Verifique os dados informados.")
                        .build()
        );
    }

    private String extractValue(String message, String fieldName) {
        try {
            // PostgreSQL pt-BR: "Chave (tax_id_number)=(...) já existe."
            Pattern pattern = Pattern.compile("\\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher = pattern.matcher(message);
            if (matcher.find()) return matcher.group(1);

            // Alternativo EN: "Key (tax_id_number)=(...) already exists."
            Pattern pattern2 = Pattern.compile("Key \\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher2 = pattern2.matcher(message);
            if (matcher2.find()) return matcher2.group(1);

        } catch (Exception e) {
            log.debug("Erro ao extrair valor do erro de constraint: {}", e.getMessage());
        }

        return "não identificado";
    }

    @ExceptionHandler(ApiException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleApi(ApiException ex) {
        return ResponseEntity.status(ex.getStatus()).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error(ex.getError())
                        .message(ex.getMessage())
                        .build()
        );
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .toList();

        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(now())
                .error("VALIDATION_ERROR")
                .message("Erro de validação")
                .details(errors)
                .build();

        return ResponseEntity.badRequest().body(errorResponse);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiEnumErrorResponse> handleGeneric(Exception ex) {
        // log só o suficiente (sem stacktrace enorme por padrão)
        log.error("Unhandled exception: {}", ex.getMessage(), ex);

        return ResponseEntity.internalServerError().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INTERNAL_SERVER_ERROR")
                        .message("Erro interno inesperado. Contate o suporte.")
                        .build()
        );
    }
}
package brito.com.multitenancy001.shared.context;

import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.infrastructure.multitenancy.hibernate.CurrentTenantSchemaResolver;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TenantContext {

    public static final String PUBLIC_SCHEMA = "public";

    /**
     * ✅ Retorna o tenant REALMENTE bindado (ou null).
     * Não mascara com "public".
     */
    public static String getOrNull() {
        return CurrentTenantSchemaResolver.resolveBoundTenantOrNull();
    }

    /**
     * ✅ Quando você quer um fallback explícito para public.
     */
    public static String getOrDefaultPublic() {
        String t = getOrNull();
        return (t != null ? t : PUBLIC_SCHEMA);
    }

    public static boolean isPublic() {
        String t = getOrNull();
        return t == null || PUBLIC_SCHEMA.equalsIgnoreCase(t);
    }

    public static void bind(String tenantId) {
    	if (TransactionSynchronizationManager.isActualTransactionActive()) {
    	    throw new IllegalStateException("🔥 TenantContext.bind chamado DENTRO de transação! tenant=" + tenantId);
    	}

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (!StringUtils.hasText(normalized)) {
            CurrentTenantSchemaResolver.bindTenantToCurrentThread(null);
            log.info("🔄 Tenant limpo (sem tenant) | thread={}", Thread.currentThread().threadId());
            return;
        }

        CurrentTenantSchemaResolver.bindTenantToCurrentThread(normalized);
        log.info("🔄 Tenant bindado | thread={} | tenant={}",
                Thread.currentThread().threadId(),
                normalized);
    }

    public static void clear() {
        CurrentTenantSchemaResolver.unbindTenantFromCurrentThread();
        log.info("🧹 Tenant desbindado | thread={}", Thread.currentThread().threadId());
    }

    // ✅ escopo seguro
    public static Scope scope(String tenantId) {
        bind(tenantId);
        return new Scope();
    }

    // ✅ escopo PUBLIC explícito (garante que não ficou tenant pendurado)
    public static Scope publicScope() {
        clear();
        return new Scope();
    }

    public static final class Scope implements AutoCloseable {
        private boolean closed = false;

        private Scope() {}

        @Override
        public void close() {
            if (!closed) {
                TenantContext.clear();
                closed = true;
            }
        }
    }
}
package brito.com.multitenancy001.shared.contracts;

public record UserSummaryData(
        Long id,
        Long accountId,
        String name,
        String username,
        String email,
        String role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted
) {}
package brito.com.multitenancy001.shared.domain;

public class DomainException extends RuntimeException {
    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public DomainException(String message) {
        super(message);
    }
}
package brito.com.multitenancy001.shared.domain.username;

import java.text.Normalizer;
import java.util.Objects;
import java.util.regex.Pattern;

import org.springframework.stereotype.Component;


@Component
public class UsernamePolicy {

	public static final String USERNAME_REGEX = "^[a-z0-9._-]+$";
    public static final int USERNAME_MAX_LENGTH = 100;
    private static final Pattern USERNAME_PATTERN = Pattern.compile("^[a-z0-9._-]+$");

    private static final String FALLBACK_BASE = "user";
    private static final String SEPARATOR = "_";

    public String normalizeBase(String raw) {
        if (raw == null || raw.isBlank()) return FALLBACK_BASE;

        String base = raw.toLowerCase();
        // opcional: remover acentos (se você quiser aplicar em nome também)
        base = Normalizer.normalize(base, Normalizer.Form.NFD).replaceAll("\\p{M}", "");

        base = base.replaceAll("[^a-z0-9._-]", "_")
                   .replaceAll("_{2,}", "_")
                   .replaceAll("^_|_$", "");

        return base.isBlank() ? FALLBACK_BASE : base;
    }

    public boolean isValid(String username) {
        if (username == null) return false;
        if (username.length() < 3 || username.length() > USERNAME_MAX_LENGTH) return false;
        return USERNAME_PATTERN.matcher(username).matches();
    }

    /** Monta base + "_" + suffix respeitando max length, cortando só base */
    public String build(String base, String suffix) {
        Objects.requireNonNull(suffix, "suffix");

        int maxBaseLen = USERNAME_MAX_LENGTH - SEPARATOR.length() - suffix.length();
        if (maxBaseLen <= 0) {
            base = "u";
            maxBaseLen = 1;
        }

        base = normalizeBase(base);

        if (base.length() > maxBaseLen) {
            base = base.substring(0, maxBaseLen).replaceAll("_+$", "");
            if (base.isBlank()) base = "u";
        }

        return base + SEPARATOR + suffix;
    }

    public String extractBase(String username) {
        if (username == null) return FALLBACK_BASE;
        int idx = username.lastIndexOf(SEPARATOR);
        if (idx <= 0) return normalizeBase(username);
        return normalizeBase(username.substring(0, idx));
    }
}
package brito.com.multitenancy001.shared.executor;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Component
public class PublicExecutor {

    public <T> T run(Supplier<T> supplier) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            return supplier.get();
        }
    }

    public void run(Runnable runnable) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            runnable.run();
        }
    }
}
package brito.com.multitenancy001.shared.executor;

import java.util.function.Supplier;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

@Component
public class TxExecutor {

    private final TransactionTemplate publicTx;
    private final TransactionTemplate publicRequiresNew;

    private final TransactionTemplate publicReadOnlyTx;
    private final TransactionTemplate publicRequiresNewReadOnly;

    private final TransactionTemplate tenantTx;
    private final TransactionTemplate tenantRequiresNew;

    private final TransactionTemplate tenantReadOnlyTx;
    private final TransactionTemplate tenantRequiresNewReadOnly;

    public TxExecutor(
            @Qualifier("publicTransactionManager") PlatformTransactionManager publicTm,
            @Qualifier("tenantTransactionManager") PlatformTransactionManager tenantTm
    ) {
        // PUBLIC - REQUIRED
        this.publicTx = new TransactionTemplate(publicTm);
        this.publicTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // PUBLIC - REQUIRES_NEW
        this.publicRequiresNew = new TransactionTemplate(publicTm);
        this.publicRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // PUBLIC - REQUIRED READONLY
        this.publicReadOnlyTx = new TransactionTemplate(publicTm);
        this.publicReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.publicReadOnlyTx.setReadOnly(true);

        // PUBLIC - REQUIRES_NEW READONLY
        this.publicRequiresNewReadOnly = new TransactionTemplate(publicTm);
        this.publicRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.publicRequiresNewReadOnly.setReadOnly(true);

        // TENANT - REQUIRED
        this.tenantTx = new TransactionTemplate(tenantTm);
        this.tenantTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // TENANT - REQUIRES_NEW
        this.tenantRequiresNew = new TransactionTemplate(tenantTm);
        this.tenantRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // TENANT - REQUIRED READONLY
        this.tenantReadOnlyTx = new TransactionTemplate(tenantTm);
        this.tenantReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.tenantReadOnlyTx.setReadOnly(true);

        // TENANT - REQUIRES_NEW READONLY
        this.tenantRequiresNewReadOnly = new TransactionTemplate(tenantTm);
        this.tenantRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.tenantRequiresNewReadOnly.setReadOnly(true);
    }

    // ---------- PUBLIC ----------
    public <T> T publicTx(Supplier<T> fn) {
        return publicTx.execute(status -> fn.get());
    }
    public void publicTx(Runnable fn) {
        publicTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNew(Supplier<T> fn) {
        return publicRequiresNew.execute(status -> fn.get());
    }
    public void publicRequiresNew(Runnable fn) {
        publicRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicReadOnlyTx(Supplier<T> fn) {
        return publicReadOnlyTx.execute(status -> fn.get());
    }
    public void publicReadOnlyTx(Runnable fn) {
        publicReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNewReadOnly(Supplier<T> fn) {
        return publicRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void publicRequiresNewReadOnly(Runnable fn) {
        publicRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }

    // ---------- TENANT ----------
    public <T> T tenantTx(Supplier<T> fn) {
        return tenantTx.execute(status -> fn.get());
    }
    public void tenantTx(Runnable fn) {
        tenantTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNew(Supplier<T> fn) {
        return tenantRequiresNew.execute(status -> fn.get());
    }
    public void tenantRequiresNew(Runnable fn) {
        tenantRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantReadOnlyTx(Supplier<T> fn) {
        return tenantReadOnlyTx.execute(status -> fn.get());
    }
    public void tenantReadOnlyTx(Runnable fn) {
        tenantReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNewReadOnly(Supplier<T> fn) {
        return tenantRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void tenantRequiresNewReadOnly(Runnable fn) {
        tenantRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }
}
package brito.com.multitenancy001.shared.security;

public interface PermissionAuthority {
    String asAuthority(); // ex: "CP_USER_READ" ou "TEN_USER_READ"
}
package brito.com.multitenancy001.shared.security;

import java.util.Collection;
import java.util.LinkedHashSet;

public final class PermissionScopeValidator {

    private PermissionScopeValidator() {}

    public static LinkedHashSet<String> normalizeTenant(Collection<String> perms) {
    	LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;
        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            // bloqueia perm de control plane no tenant
            if (x.startsWith("CP_")) {
                throw new IllegalArgumentException("Permission de Control Plane não é permitida no Tenant: " + x);
            }

            // se não tiver prefixo TEN_, adiciona
            if (!x.startsWith("TEN_")) x = "TEN_" + x;
            out.add(x);
        }
        return out;
    }

    public static LinkedHashSet<String> normalizeControlPlane(Collection<String> perms) {
        LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;
        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            // bloqueia perm de tenant no control plane
            if (x.startsWith("TEN_")) {
                throw new IllegalArgumentException("Permission de Tenant não é permitida no Control Plane: " + x);
            }

            if (!x.startsWith("CP_")) x = "CP_" + x;
            out.add(x);
        }
        return out;
    }
}
package brito.com.multitenancy001.shared.security;

/**
 * Contrato comum para roles da plataforma e do tenant
 * Permite unificação no Spring Security (GrantedAuthority)
 */
public interface RoleAuthority {

    /**
     * Retorna a authority no padrão Spring Security
     *
     */
    String asAuthority();

    /**
     * Helper padrão (opcional)
     */
    default boolean isAdmin() {
        return false;
    }
}
package brito.com.multitenancy001.shared.time;

import java.time.Clock;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;

public interface AppClock {

    Clock clock();

    default Instant instant() {
        return Instant.now(clock());
    }

    default LocalDateTime now() {
        return LocalDateTime.now(clock());
    }

    default ZoneId zone() {
        return clock().getZone();
    }

    default long epochMillis() {
        return instant().toEpochMilli();
    }
}
package brito.com.multitenancy001.shared.time;

import java.time.Clock;
import org.springframework.stereotype.Component;

@Component
public class SystemAppClock implements AppClock {

    private final Clock clock;

    public SystemAppClock(Clock clock) {
        this.clock = clock;
    }

    @Override
    public Clock clock() {
        return clock;
    }
}
package brito.com.multitenancy001.shared.validation; // ou .validation

import brito.com.multitenancy001.shared.domain.username.UsernamePolicy;

/**
 * Padrões de validação reutilizáveis em todo o sistema
 */
public final class ValidationPatterns {
    
    // Username: 3-50 caracteres, letras, números, ponto, underscore, hífen
   // public static final String USERNAME_PATTERN = "^[a-zA-Z0-9._-]{3,50}$";
	
	
	// usado pra facilidar no desenvolvimento
	// Username: 3-50 caracteres, APENAS letras (a-z, A-Z) e números (0-9)
	public static final String USERNAME_PATTERN = UsernamePolicy.USERNAME_REGEX;
    
    // Password: mínimo 8 caracteres, pelo menos 1 letra maiúscula, 1 minúscula e 1 número
   // public static final String PASSWORD_PATTERN = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$";

    
    
 // ⚠️ APENAS PARA TESTE/DEV - NUNCA EM PRODUÇÃO!
    // Password: mínimo 3 caracteres, apenas letras (maiúsculas/minúsculas)
    // Não precisa de números nem caracteres especiais
	  public static final String PASSWORD_PATTERN = "^[a-zA-Z0-9]{3,}$";
    
    
    
    
    
    
    // Email: validação básica (Spring já tem @Email, mas para referência)
    public static final String EMAIL_PATTERN = "^[A-Za-z0-9+_.-]+@(.+)$";
    
    // Nome: apenas letras, espaços e alguns caracteres especiais
    public static final String NAME_PATTERN = "^[a-zA-ZÀ-ÿ\\s'-]{2,100}$";
    
    // Telefone: formato brasileiro
    public static final String PHONE_PATTERN = "^(\\(?\\d{2}\\)?)?\\s?\\d{4,5}-?\\d{4}$";
    
    // CNPJ: formato brasileiro
    public static final String CNPJ_PATTERN = "^\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}$";
    
    // CPF: formato brasileiro
    public static final String CPF_PATTERN = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$";
    
    // CEP: formato brasileiro
    public static final String CEP_PATTERN = "^\\d{5}-\\d{3}$";
    
    // URL: para avatar_url, website, etc.
    public static final String URL_PATTERN = "^(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?$";
    
    // Timezone: formato padrão (America/Sao_Paulo)
    public static final String TIMEZONE_PATTERN = "^[A-Za-z_]+/[A-Za-z_]+$";
    
    // Locale: pt_BR, en_US, etc.
    public static final String LOCALE_PATTERN = "^[a-z]{2}_[A-Z]{2}$";
    
    // Currency: BRL, USD, EUR (3 letras)
    public static final String CURRENCY_PATTERN = "^[A-Z]{3}$";
    
    // Hex color: #FFFFFF ou #FFF
    public static final String COLOR_PATTERN = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
    
    // IP Address
    public static final String IP_PATTERN = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
    
    // UUID
    public static final String UUID_PATTERN = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";
    
    // Permissões: UPPER_CASE_WITH_UNDERSCORE
    public static final String PERMISSION_PATTERN = "^[A-Z_]+$";
    
    private ValidationPatterns() {
        // Construtor privado para classe utilitária
        throw new UnsupportedOperationException("Classe utilitária - não instanciável");
    }
    
    /**
     * Valida se um valor corresponde ao padrão
     */
    public static boolean isValid(String value, String pattern) {
        return value != null && value.matches(pattern);
    }
    
    /**
     * Valida username com mensagem descritiva
     */
    public static void validateUsername(String username) {
        if (username == null || !username.matches(USERNAME_PATTERN)) {
            throw new IllegalArgumentException(
                "Username deve ter 3-50 caracteres e conter apenas: " +
                "letras (a-z, A-Z), números (0-9), ponto (.), underscore (_), hífen (-)"
            );
        }
    }
    
    /**
     * Valida password com mensagem descritiva
     */
    public static void validatePassword(String password) {
        if (password == null || !password.matches(PASSWORD_PATTERN)) {
            throw new IllegalArgumentException(
                "Senha deve ter pelo menos 8 caracteres contendo: " +
                "1 letra maiúscula, 1 letra minúscula e 1 número"
            );
        }
    }
}package brito.com.multitenancy001.tenant.api.controller.auth;

import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.application.auth.TenantAuthService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantAuthController {

    private final TenantAuthService tenantAuthService;

    @PostMapping("/login")
    public ResponseEntity<JwtResponse> loginTenant(@Valid @RequestBody TenantLoginRequest tenantLoginRequest) {
        JwtResponse jwtResponse = tenantAuthService.loginTenant(tenantLoginRequest);
        return ResponseEntity.ok(jwtResponse);
    }
}
package brito.com.multitenancy001.tenant.api.controller.auth;

import brito.com.multitenancy001.tenant.api.dto.auth.ForgotPasswordRequest;
import brito.com.multitenancy001.tenant.api.dto.auth.ResetPasswordRequest;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/password")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantPasswordController {

    private final TenantUserService tenantUserService;

    @PostMapping("/forgot")
    public ResponseEntity<String> forgotPassword(@Valid @RequestBody ForgotPasswordRequest forgotPasswordRequest) {
        tenantUserService.generatePasswordResetToken(forgotPasswordRequest.slug(), forgotPasswordRequest.email());
        return ResponseEntity.ok("Token gerado");
    }

    @PostMapping("/reset")
    public ResponseEntity<String> resetPassword(@Valid @RequestBody ResetPasswordRequest resetPasswordRequest) {
        tenantUserService.resetPasswordWithToken(resetPasswordRequest.token(), resetPasswordRequest.newPassword());
        return ResponseEntity.ok("Senha redefinida com sucesso");
    }
}
package brito.com.multitenancy001.tenant.api.controller.billing;

import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.application.billing.ControlPLanePaymentService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/billing/payments")
@RequiredArgsConstructor
public class TenantPaymentController {

    private final ControlPLanePaymentService paymentService;

    // =========================
    // MY TENANT (SAFE DEFAULT)
    // =========================

    @PostMapping
    @PreAuthorize("hasAuthority('TEN_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> processPayment(@Valid @RequestBody PaymentRequest paymentRequest) {
        PaymentResponse response = paymentService.processPaymentForMyAccount(paymentRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/{paymentId}")
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<PaymentResponse> getById(@PathVariable Long paymentId) {
        return ResponseEntity.ok(paymentService.getPaymentByIdForMyAccount(paymentId));
    }

    @GetMapping
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getMyPayments() {
        return ResponseEntity.ok(paymentService.getPaymentsByMyAccount());
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<Boolean> hasActivePaymentMyAccount() {
        return ResponseEntity.ok(paymentService.hasActivePaymentMyAccount());
    }
}
package brito.com.multitenancy001.tenant.api.controller.categories;

import brito.com.multitenancy001.tenant.application.category.TenantCategoryService;
import brito.com.multitenancy001.tenant.domain.category.Category;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/categories")
@RequiredArgsConstructor
public class TenantCategoryController {

    private final TenantCategoryService tenantCategoryService;

    // ======================
    // READ
    // ======================

    @GetMapping
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Category>> listAll() {
        return ResponseEntity.ok(tenantCategoryService.findAll());
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Category>> listActive() {
        return ResponseEntity.ok(tenantCategoryService.findActive());
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<Category> getById(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.findById(id));
    }

    @GetMapping("/search")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Category>> search(@RequestParam("name") String name) {
        return ResponseEntity.ok(tenantCategoryService.searchByName(name));
    }

    // Admin flags
    @GetMapping("/admin")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Category>> listAdmin(
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        return ResponseEntity.ok(tenantCategoryService.findWithFlags(includeDeleted, includeInactive));
    }

    // ======================
    // WRITE
    // ======================

    @PostMapping
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Category> create(@Valid @RequestBody Category category) {
        Category saved = tenantCategoryService.create(category);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Category> update(@PathVariable Long id, @RequestBody Category category) {
        return ResponseEntity.ok(tenantCategoryService.update(id, category));
    }

    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Category> toggleActive(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.toggleActive(id));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Void> softDelete(@PathVariable Long id) {
        tenantCategoryService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Category> restore(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.restore(id));
    }
}
package brito.com.multitenancy001.tenant.api.controller.categories;

import brito.com.multitenancy001.tenant.application.category.TenantSubcategoryService;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/subcategories")
@RequiredArgsConstructor
public class TenantSubcategoryController {

    private final TenantSubcategoryService tenantSubcategoryService;

    // ======================
    // READ
    // ======================

    @GetMapping
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listAll() {
        return ResponseEntity.ok(tenantSubcategoryService.findAll());
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listActive() {
        return ResponseEntity.ok(tenantSubcategoryService.findActive());
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<Subcategory> getById(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.findById(id));
    }

    // subcategories por categoria (default: somente active + notDeleted)
    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listByCategory(@PathVariable Long categoryId) {
        return ResponseEntity.ok(tenantSubcategoryService.findByCategoryId(categoryId));
    }

    // admin flags (deletados/inativos)
    @GetMapping("/category/{categoryId}/admin")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listByCategoryAdmin(
            @PathVariable Long categoryId,
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        return ResponseEntity.ok(
                tenantSubcategoryService.findByCategoryIdAdmin(categoryId, includeDeleted, includeInactive)
        );
    }

    // ======================
    // WRITE
    // ======================

    // cria subcategoria dentro de uma categoria
    @PostMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Subcategory> create(
            @PathVariable Long categoryId,
            @Valid @RequestBody Subcategory subcategory
    ) {
        Subcategory saved = tenantSubcategoryService.create(categoryId, subcategory);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Subcategory> update(@PathVariable Long id, @RequestBody Subcategory subcategory) {
        return ResponseEntity.ok(tenantSubcategoryService.update(id, subcategory));
    }

    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Subcategory> toggleActive(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.toggleActive(id));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Void> softDelete(@PathVariable Long id) {
        tenantSubcategoryService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Subcategory> restore(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.restore(id));
    }
}
package brito.com.multitenancy001.tenant.api.controller.products;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.api.dto.products.ProductUpsertRequest;
import brito.com.multitenancy001.tenant.api.dto.products.SupplierProductCountResponse;
import brito.com.multitenancy001.tenant.api.mapper.ProductApiMapper;
import brito.com.multitenancy001.tenant.application.product.TenantProductService;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.product.Product;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/tenant/products")
@RequiredArgsConstructor
public class TenantProductController {

    private final ProductApiMapper productApiMapper;
    private final TenantProductService tenantProductService;
    
    
    @GetMapping("/category/{categoryId}/admin")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')") // ou uma permissão mais forte se quiser
    public ResponseEntity<List<ProductResponse>> getProductsByCategoryAdmin(
            @PathVariable Long categoryId,
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        List<Product> products = tenantProductService.findByCategoryId(categoryId, includeDeleted, includeInactive);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }


    // =========================================================
    // READ
    // =========================================================

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<ProductResponse> getById(@PathVariable UUID id) {
        Product product = tenantProductService.findById(id);
        return ResponseEntity.ok(productApiMapper.toResponse(product));
    }

    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByCategory(@PathVariable Long categoryId) {
        List<Product> products = tenantProductService.findByCategoryId(categoryId);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/category/{categoryId}/optional")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByCategoryOptionalSubcategory(
            @PathVariable Long categoryId,
            @RequestParam(value = "subcategoryId", required = false) Long subcategoryId
    ) {
        List<Product> products = tenantProductService.findByCategoryAndOptionalSubcategory(categoryId, subcategoryId);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/subcategory/{subcategoryId}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsBySubcategory(@PathVariable Long subcategoryId) {
        List<Product> products = tenantProductService.findBySubcategoryId(subcategoryId);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/brand/{brand}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByBrand(@PathVariable String brand) {
        List<Product> products = tenantProductService.findByBrand(brand);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getActiveProducts() {
        List<Product> products = tenantProductService.findActiveProducts();
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/name")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByName(@RequestParam("name") String name) {
        List<Product> products = tenantProductService.findByName(name);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/name/paged")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<Page<ProductResponse>> getProductsByNamePaged(
            @RequestParam("name") String name,
            Pageable pageable
    ) {
        Page<Product> page = tenantProductService.findByNamePaged(name, pageable);
        Page<ProductResponse> dtoPage = page.map(productApiMapper::toResponse);
        return ResponseEntity.ok(dtoPage);
    }

    @GetMapping("/price-between")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByPriceBetween(
            @RequestParam("minPrice") BigDecimal minPrice,
            @RequestParam("maxPrice") BigDecimal maxPrice
    ) {
        List<Product> products = tenantProductService.findByPriceBetween(minPrice, maxPrice);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/supplier/{supplierId}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsBySupplier(@PathVariable UUID supplierId) {
        List<Product> products = tenantProductService.findBySupplierId(supplierId);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/filter")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> filterProducts(
            @RequestParam("name") String name,
            @RequestParam("minPrice") BigDecimal minPrice,
            @RequestParam("maxPrice") BigDecimal maxPrice,
            @RequestParam("minStock") Integer minStock,
            @RequestParam("maxStock") Integer maxStock
    ) {
        List<Product> products =
                tenantProductService.findByNameAndPriceAndStock(name, minPrice, maxPrice, minStock, maxStock);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/stats/count-by-supplier")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<SupplierProductCountResponse>> countBySupplier() {
        return ResponseEntity.ok(tenantProductService.countProductsBySupplier());
    }

    @GetMapping("/inventory-value")
    @PreAuthorize("hasAuthority('TEN_INVENTORY_READ')")
    public ResponseEntity<BigDecimal> getTotalInventoryValue() {
        BigDecimal value = tenantProductService.calculateTotalInventoryValue();
        return ResponseEntity.ok(value != null ? value : BigDecimal.ZERO);
    }

    @GetMapping("/low-stock/count")
    @PreAuthorize("hasAuthority('TEN_INVENTORY_READ')")
    public ResponseEntity<Long> countLowStockProducts(@RequestParam(defaultValue = "10") Integer threshold) {
        Long count = tenantProductService.countLowStockProducts(threshold);
        return ResponseEntity.ok(count != null ? count : 0L);
    }

    // =========================================================
    // WRITE
    // =========================================================

    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> toggleActive(@PathVariable UUID id) {
        Product updated = tenantProductService.toggleActive(id);
        return ResponseEntity.ok(productApiMapper.toResponse(updated));
    }

    @PatchMapping("/{id}/cost-price")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> updateCostPrice(
            @PathVariable UUID id,
            @RequestParam BigDecimal costPrice
    ) {
        Product updatedProduct = tenantProductService.updateCostPrice(id, costPrice);
        return ResponseEntity.ok(productApiMapper.toResponse(updatedProduct));
    }

    @PostMapping("/detailed")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> createDetailedProduct(@Valid @RequestBody ProductUpsertRequest req) {

        Product product = new Product();
        product.setName(req.name());
        product.setDescription(req.description());
        product.setSku(req.sku());
        product.setPrice(req.price());
        product.setStockQuantity(req.stockQuantity());
        product.setMinStock(req.minStock());
        product.setMaxStock(req.maxStock());
        product.setCostPrice(req.costPrice());
        product.setBrand(req.brand());
        product.setWeightKg(req.weightKg());
        product.setDimensions(req.dimensions());
        product.setBarcode(req.barcode());
        product.setActive(req.active());

        Category category = new Category();
        category.setId(req.categoryId());
        product.setCategory(category);

        if (req.subcategoryId() != null) {
            Subcategory sub = new Subcategory();
            sub.setId(req.subcategoryId());
            product.setSubcategory(sub);
        }

        if (req.supplierId() != null) {
            Supplier supplier = new Supplier();
            supplier.setId(req.supplierId());
            product.setSupplier(supplier);
        }

        Product savedProduct = tenantProductService.create(product);
        return ResponseEntity.status(HttpStatus.CREATED).body(productApiMapper.toResponse(savedProduct));
    }
}
package brito.com.multitenancy001.tenant.api.controller.suppliers;

import brito.com.multitenancy001.tenant.application.supplier.TenantSupplierService;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/tenant/suppliers")
@RequiredArgsConstructor
public class TenantSupplierController {

    private final TenantSupplierService tenantSupplierService;

    // =========================================================
    // READ (não-deletados)
    // =========================================================

    @GetMapping
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> listAll() {
        return ResponseEntity.ok(tenantSupplierService.findAll());
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> listActive() {
        return ResponseEntity.ok(tenantSupplierService.findActive());
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<Supplier> getById(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.findById(id));
    }

    @GetMapping("/document/{document}")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<Supplier> getByDocument(@PathVariable String document) {
        return ResponseEntity.ok(tenantSupplierService.findByDocument(document));
    }

    @GetMapping("/search")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> searchByName(@RequestParam("name") String name) {
        return ResponseEntity.ok(tenantSupplierService.searchByName(name));
    }

    @GetMapping("/email")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> getByEmail(@RequestParam("email") String email) {
        return ResponseEntity.ok(tenantSupplierService.findByEmail(email));
    }

    // =========================================================
    // WRITE
    // =========================================================

    @PostMapping
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Supplier> create(@Valid @RequestBody Supplier supplier) {
        Supplier saved = tenantSupplierService.create(supplier);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Supplier> update(@PathVariable UUID id, @RequestBody Supplier supplier) {
        Supplier updated = tenantSupplierService.update(id, supplier);
        return ResponseEntity.ok(updated);
    }

    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Supplier> toggleActive(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.toggleActive(id));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Void> softDelete(@PathVariable UUID id) {
        tenantSupplierService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Supplier> restore(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.restore(id));
    }
}
package brito.com.multitenancy001.tenant.api.controller.users.admin;

import brito.com.multitenancy001.tenant.api.dto.users.admin.TenantUserAdminSuspendRequest;
import brito.com.multitenancy001.tenant.application.user.admin.TenantUserAdminService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/admin/users")
@RequiredArgsConstructor
public class TenantUserAdminController {

    private final TenantUserAdminService tenantUserAdminService;

    @PatchMapping("/{userId}/suspend")
    @PreAuthorize("hasAuthority('TEN_USER_SUSPEND')")
    public ResponseEntity<Void> suspendUser(
            @PathVariable Long userId,
            @RequestBody TenantUserAdminSuspendRequest tenantUserAdminSuspendRequest
    ) {
        tenantUserAdminService.setUserSuspendedByAdmin(userId, tenantUserAdminSuspendRequest.suspended());
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.tenant.api.controller.users;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/users")
@RequiredArgsConstructor
public class TenantUserController {

    private final TenantUserService tenantUserService;

    @PatchMapping("/{userId}/transfer-admin")
    @PreAuthorize("hasAuthority('TEN_ROLE_TRANSFER')")
    public ResponseEntity<Void> transferTenantOwner(@PathVariable Long userId) {
        tenantUserService.transferTenantOwner(userId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping
    @PreAuthorize("hasAuthority('TEN_USER_CREATE')")
    public ResponseEntity<TenantUserDetailsResponse> createTenantUser(@Valid @RequestBody TenantUserCreateRequest tenantUserCreateRequest) {
        TenantUserDetailsResponse response = tenantUserService.createTenantUser(tenantUserCreateRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<List<TenantUserSummaryResponse>> listTenantUsers() {
        List<TenantUserSummaryResponse> users = tenantUserService.listTenantUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<List<TenantUserSummaryResponse>> listActiveTenantUsers() {
        List<TenantUserSummaryResponse> users = tenantUserService.listActiveTenantUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<TenantUserDetailsResponse> getTenantUser(@PathVariable Long userId) {
        TenantUserDetailsResponse user = tenantUserService.getTenantUser(userId);
        return ResponseEntity.ok(user);
    }

    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAuthority('TEN_USER_UPDATE')")
    public ResponseEntity<TenantUserSummaryResponse> updateTenantUserStatus(
            @PathVariable Long userId,
            @RequestParam boolean active
    ) {
        TenantUserSummaryResponse response = tenantUserService.updateTenantUserStatus(userId, active);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_DELETE')")
    public ResponseEntity<Void> deleteTenantUser(@PathVariable Long userId) {
        tenantUserService.softDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority('TEN_USER_RESTORE')")
    public ResponseEntity<TenantUserSummaryResponse> restoreTenantUser(@PathVariable Long userId) {
        TenantUserSummaryResponse response = tenantUserService.restoreTenantUser(userId);
        return ResponseEntity.ok(response);
    }

    @PatchMapping("/{userId}/password")
    @PreAuthorize("hasAuthority('TEN_USER_UPDATE')")
    public ResponseEntity<TenantUserSummaryResponse> resetTenantUserPassword(
            @PathVariable Long userId,
            @RequestParam
            @Pattern(
                    regexp = ValidationPatterns.PASSWORD_PATTERN,
                    message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas e números"
            )
            String newPassword
    ) {
        TenantUserSummaryResponse response = tenantUserService.resetTenantUserPassword(userId, newPassword);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{userId}/hard")
    @PreAuthorize("hasAuthority('TEN_USER_DELETE')")
    public ResponseEntity<Void> hardDeleteTenantUser(@PathVariable Long userId) {
        tenantUserService.hardDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ForgotPasswordRequest(
        @NotBlank String slug,
        @NotBlank @Email String email
) {}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record ResetPasswordRequest(
        @NotBlank String token,
        @NotBlank
        @Pattern(
          regexp = ValidationPatterns.PASSWORD_PATTERN,
          message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais"
        )
        String newPassword
) {}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record TenantLoginRequest(
	    @NotBlank String username,
	    @NotBlank String password,
	    @NotBlank String slug
	) {}
package brito.com.multitenancy001.tenant.api.dto.products;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

public record ProductResponse(
        UUID id,
        @NotBlank String name,
        String description,
        String sku,
        @NotNull @PositiveOrZero BigDecimal price,
        @PositiveOrZero Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        BigDecimal profitMargin,

        Long categoryId,
        String categoryName,
        Long subcategoryId,
        String subcategoryName,

        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,

        UUID supplierId,
        String supplierName,

        LocalDateTime createdAt,
        LocalDateTime updatedAt
) {
    public ProductResponse {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }

  
}
package brito.com.multitenancy001.tenant.api.dto.products;

import java.math.BigDecimal;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

// Record para criação/atualização expandido (com Category/Subcategory por ID)
public record ProductUpsertRequest(
     @NotBlank String name,
     String description,
     String sku,
     @NotNull @PositiveOrZero BigDecimal price,
     @PositiveOrZero Integer stockQuantity,
     Integer minStock,
     Integer maxStock,
     BigDecimal costPrice,

     @NotNull Long categoryId,     // ✅ obrigatório
     Long subcategoryId,           // ✅ opcional

     String brand,
     BigDecimal weightKg,
     String dimensions,
     String barcode,
     Boolean active,
     UUID supplierId
) {
    public ProductUpsertRequest {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}
package brito.com.multitenancy001.tenant.api.dto.products;

import java.util.UUID;

public record SupplierProductCountResponse(UUID supplierId, long count) {}
package brito.com.multitenancy001.tenant.api.dto.users.admin;

public record TenantUserAdminSuspendRequest(boolean suspended) {}package brito.com.multitenancy001.tenant.api.dto.users;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.LinkedHashSet;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantRole;

@Builder
public record TenantUserCreateRequest(
    
    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String name,
    
    @NotBlank(message = "Username é obrigatório")
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inválido...")
    @Size(min = 3, max = 50, message = "Username inválido. Use apenas letras, números, . e _")
    String username,

    
    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email inválido")
    @Size(max = 150, message = "Email não pode exceder 150 caracteres")
    String email,
    
    @NotBlank(message = "Senha é obrigatória")
    @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, 
             message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais")
    String password,
    
    @NotNull(message = "Role é obrigatória")
    TenantRole role,
    
    @NotBlank
    @Pattern(
        regexp = "^TEN_[A-Z0-9_]+$",
        message = "Permission must follow TEN_* pattern (e.g. TEN_USER_CREATE)"
    )
    LinkedHashSet<String> permissions,
    
    // 🔹 CAMPOS NOVOS para UserTenant
    @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, 
             message = "Telefone inválido")
    @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
    String phone,
    
    @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
    String avatarUrl
    
) {
    
	public TenantUserCreateRequest {
	    if (name != null) name = name.trim();
	    if (username != null) username = username.trim();
	    if (email != null) email = email.trim();

	    if (phone != null) phone = phone.trim();
	    if (avatarUrl != null) avatarUrl = avatarUrl.trim();
	}

}package brito.com.multitenancy001.tenant.api.dto.users;

public record TenantUserDetailsResponse(
        Long id,
        Long accountId,
        String name,
        String username,
        String email,
        String role,
        String phone,
        String avatarUrl,
        String timezone,
        String locale,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}
package brito.com.multitenancy001.tenant.api.dto.users;

public record TenantUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.domain.product.Product;

@Component
public class ProductApiMapper {

    public ProductResponse toResponse(Product product) {
        return new ProductResponse(
            product.getId(),
            product.getName(),
            product.getDescription(),
            product.getSku(),
            product.getPrice(),
            product.getStockQuantity(),
            product.getMinStock(),
            product.getMaxStock(),
            product.getCostPrice(),
            product.getProfitMargin(),

            product.getCategory() != null ? product.getCategory().getId() : null,
            product.getCategory() != null ? product.getCategory().getName() : null,
            product.getSubcategory() != null ? product.getSubcategory().getId() : null,
            product.getSubcategory() != null ? product.getSubcategory().getName() : null,

            product.getBrand(),
            product.getWeightKg(),
            product.getDimensions(),
            product.getBarcode(),
            product.getActive(),

            product.getSupplier() != null ? product.getSupplier().getId() : null,
            product.getSupplier() != null ? product.getSupplier().getName() : null,

            product.getCreatedAt(),
            product.getUpdatedAt()
        );
    }
}
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;

@Component
public class TenantUserApiMapper {

    public TenantUserSummaryResponse toSummary(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantUserSummaryResponse(
                tenantUser.getId(),
                tenantUser.getUsername(),
                tenantUser.getEmail(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                enabled
        );
    }

    public TenantUserDetailsResponse toDetails(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantUserDetailsResponse(
                tenantUser.getId(),
                tenantUser.getAccountId(),
                tenantUser.getName(),
                tenantUser.getUsername(),
                tenantUser.getEmail(),
                tenantUser.getRole() != null ? tenantUser.getRole().name() : null,
                tenantUser.getPhone(),
                tenantUser.getAvatarUrl(),
                tenantUser.getTimezone(),
                tenantUser.getLocale(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                tenantUser.isDeleted(),
                enabled
        );
    }
}
package brito.com.multitenancy001.tenant.application.auth;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.account.AccountResolver;
import brito.com.multitenancy001.shared.account.AccountSnapshot;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantAuthService {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final AccountResolver accountResolver;

    private final TenantUserRepository tenantUserRepository;

    public JwtResponse loginTenant(TenantLoginRequest tenantLoginRequest) {

        // 1️⃣ PUBLIC — resolve conta
        TenantContext.clear();

        AccountSnapshot account = accountResolver.resolveActiveAccountBySlug(tenantLoginRequest.slug());

        

        // 2️⃣ TENANT — bind correto
        TenantContext.bind(account.schemaName());

        try {
            Authentication authentication =
                    authenticationManager.authenticate(
                            new UsernamePasswordAuthenticationToken(
                                    tenantLoginRequest.username(),
                                    tenantLoginRequest.password()
                            )
                    );

            TenantUser user = tenantUserRepository
                    .findByUsernameAndAccountId(
                            tenantLoginRequest.username(),
                            account.id()
                    )
                    .orElseThrow(() -> new ApiException(
                            "USER_NOT_FOUND",
                            "Usuário não encontrado",
                            404
                    ));


            if (user.isSuspendedByAccount() || user.isDeleted()) {
                throw new ApiException(
                        "USER_INACTIVE",
                        "Usuário inativo",
                        403
                );
            }

            String accessToken = tokenProvider.generateTenantToken(
                    authentication,
                    account.id(),
                    account.schemaName()
            );
            
            
            String refreshToken = tokenProvider.generateRefreshToken(
                    user.getUsername(),
                    account.schemaName()
            );


            return new JwtResponse(
                    accessToken,
                    refreshToken,
                    user.getId(),
                    user.getUsername(),
                    user.getEmail(),
                    user.getRole().name(),
                    account.id(),
                    account.schemaName()
            );

        } finally {
            TenantContext.clear();
        }
    }
}
package brito.com.multitenancy001.tenant.application.category;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.persistence.category.TenantCategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantCategoryService {

    private final TenantCategoryRepository categoryRepository;
    private final AppClock appClock;

    // =========================================================
    // READ
    // =========================================================

    @Transactional(readOnly = true)
    public Category findById(Long id) {
        if (id == null) throw new ApiException("CATEGORY_ID_REQUIRED", "id é obrigatório", 400);

        Category c = categoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (c.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Categoria deletada não pode ser consultada", 404);
        }

        return c;
    }

    @Transactional(readOnly = true)
    public List<Category> findAll() {
        return categoryRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Category> findActive() {
        return categoryRepository.findActiveNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Category> searchByName(String name) {
        if (!StringUtils.hasText(name)) {
            throw new ApiException("CATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }
        return categoryRepository.findNotDeletedByNameContainingIgnoreCase(name.trim());
    }

    @Transactional(readOnly = true)
    public List<Category> findWithFlags(boolean includeDeleted, boolean includeInactive) {
        return categoryRepository.findWithFlags(includeDeleted, includeInactive);
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Category create(Category category) {
        if (category == null) throw new ApiException("CATEGORY_REQUIRED", "payload é obrigatório", 400);
        if (!StringUtils.hasText(category.getName())) {
            throw new ApiException("CATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }

        String name = category.getName().trim();

        // uk_categories_name (global) -> valida para evitar 500
        categoryRepository.findNotDeletedByNameIgnoreCase(name)
                .ifPresent(existing -> {
                    throw new ApiException("CATEGORY_NAME_ALREADY_EXISTS", "Categoria já existe: " + name, 409);
                });

        category.setName(name);
        category.setDeleted(false);
        category.setActive(true);

        return categoryRepository.save(category);
    }

    @Transactional
    public Category update(Long id, Category req) {
        if (id == null) throw new ApiException("CATEGORY_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("CATEGORY_REQUIRED", "payload é obrigatório", 400);

        Category existing = categoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido alterar categoria deletada", 409);
        }

        if (StringUtils.hasText(req.getName())) {
            String newName = req.getName().trim();

            // valida unicidade
            categoryRepository.findNotDeletedByNameIgnoreCase(newName)
                    .ifPresent(other -> {
                        if (!other.getId().equals(id)) {
                            throw new ApiException("CATEGORY_NAME_ALREADY_EXISTS", "Categoria já existe: " + newName, 409);
                        }
                    });

            existing.setName(newName);
        }

        // active é boolean primitivo -> melhor controlar via endpoint específico (toggle)
        return categoryRepository.save(existing);
    }

    @Transactional
    public Category toggleActive(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (category.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido alterar categoria deletada", 409);
        }

        category.setActive(!category.isActive());
        return categoryRepository.save(category);
    }

    @Transactional
    public void softDelete(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        category.softDelete(appClock.now());
        categoryRepository.save(category);
    }

    @Transactional
    public Category restore(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        category.restore();
        return categoryRepository.save(category);
    }
}
package brito.com.multitenancy001.tenant.application.category;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.persistence.category.TenantCategoryRepository;
import brito.com.multitenancy001.tenant.persistence.category.TenantSubcategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantSubcategoryService {

    private final TenantSubcategoryRepository subcategoryRepository;
    private final TenantCategoryRepository categoryRepository;
    private final AppClock appClock;

    // =========================================================
    // READ
    // =========================================================

    @Transactional(readOnly = true)
    public Subcategory findById(Long id) {
        if (id == null) throw new ApiException("SUBCATEGORY_ID_REQUIRED", "id é obrigatório", 400);

        Subcategory s = subcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (s.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Subcategoria deletada não pode ser consultada", 404);
        }

        return s;
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findAll() {
        return subcategoryRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findActive() {
        return subcategoryRepository.findActiveNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findByCategoryId(Long categoryId) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        return subcategoryRepository.findActiveNotDeletedByCategoryId(categoryId);
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findByCategoryIdAdmin(Long categoryId, boolean includeDeleted, boolean includeInactive) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        return subcategoryRepository.findByCategoryWithFlags(categoryId, includeDeleted, includeInactive);
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Subcategory create(Long categoryId, Subcategory req) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        if (req == null) throw new ApiException("SUBCATEGORY_REQUIRED", "payload é obrigatório", 400);
        if (!StringUtils.hasText(req.getName())) {
            throw new ApiException("SUBCATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }

        Category category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + categoryId, 404));

        if (category.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido criar subcategoria em categoria deletada", 409);
        }

        String name = req.getName().trim();

        // uk_subcategories_name_category (category_id, name)
        subcategoryRepository.findNotDeletedByCategoryIdAndNameIgnoreCase(categoryId, name)
                .ifPresent(existing -> {
                    throw new ApiException("SUBCATEGORY_ALREADY_EXISTS",
                            "Subcategoria já existe na categoria " + categoryId + ": " + name, 409);
                });

        Subcategory sub = new Subcategory();
        sub.setCategory(category);
        sub.setName(name);
        sub.setDeleted(false);
        sub.setActive(true);

        return subcategoryRepository.save(sub);
    }

    @Transactional
    public Subcategory update(Long id, Subcategory req) {
        if (id == null) throw new ApiException("SUBCATEGORY_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("SUBCATEGORY_REQUIRED", "payload é obrigatório", 400);

        Subcategory existing = subcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Não é permitido alterar subcategoria deletada", 409);
        }

        if (StringUtils.hasText(req.getName())) {
            String newName = req.getName().trim();
            Long categoryId = existing.getCategory().getId();

            subcategoryRepository.findNotDeletedByCategoryIdAndNameIgnoreCase(categoryId, newName)
                    .ifPresent(other -> {
                        if (!other.getId().equals(id)) {
                            throw new ApiException("SUBCATEGORY_ALREADY_EXISTS",
                                    "Subcategoria já existe na categoria " + categoryId + ": " + newName, 409);
                        }
                    });

            existing.setName(newName);
        }

        return subcategoryRepository.save(existing);
    }

    @Transactional
    public Subcategory toggleActive(Long id) {
        Subcategory sub = subcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (sub.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Não é permitido alterar subcategoria deletada", 409);
        }

        sub.setActive(!sub.isActive());
        return subcategoryRepository.save(sub);
    }

    @Transactional
    public void softDelete(Long id) {
        Subcategory sub = subcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        sub.softDelete(appClock.now());
        subcategoryRepository.save(sub);
    }

    @Transactional
    public Subcategory restore(Long id) {
        Subcategory sub = subcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        sub.restore();
        return subcategoryRepository.save(sub);
    }
}
// ===============================
// ProductService.java
// (corrigido: resolveCategoryAndSubcategory sem duplicação,
//  update limpando subcategory quando vier null,
//  usando findByIdWithCategory pra validar)
// ===============================
package brito.com.multitenancy001.tenant.application.product;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.api.dto.products.SupplierProductCountResponse;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.product.Product;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import brito.com.multitenancy001.tenant.persistence.category.TenantCategoryRepository;
import brito.com.multitenancy001.tenant.persistence.category.TenantSubcategoryRepository;
import brito.com.multitenancy001.tenant.persistence.product.TenantProductRepository;
import brito.com.multitenancy001.tenant.persistence.supplier.TenantSupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProductService {

    private final TenantProductRepository tenantProductRepository;
    private final TenantSupplierRepository supplierRepository;
    private final TenantCategoryRepository categoryRepository;
    private final TenantSubcategoryRepository subcategoryRepository;
    private final AppClock appClock;

    @Transactional(readOnly = true)
    public Page<Product> findAll(Pageable pageable) {
        return tenantProductRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    public Product findById(UUID id) {
        return tenantProductRepository.findById(id)
            .orElseThrow(() -> new ApiException("PRODUCT_NOT_FOUND",
                "Produto não encontrado com ID: " + id, 404));
    }

    @Transactional
    public Product create(Product product) {
        validateProduct(product);

        resolveCategoryAndSubcategory(product);
        resolveSupplier(product);
        validateSubcategoryBelongsToCategory(product);

        return tenantProductRepository.save(product);
    }

    @Transactional
    public Product update(UUID id, Product productDetails) {
        Product existingProduct = findById(id);

        if (StringUtils.hasText(productDetails.getName())) {
            existingProduct.setName(productDetails.getName());
        }

        if (productDetails.getDescription() != null) {
            existingProduct.setDescription(productDetails.getDescription());
        }

        if (StringUtils.hasText(productDetails.getSku())) {
            Optional<Product> productWithSku = tenantProductRepository.findBySku(productDetails.getSku());
            if (productWithSku.isPresent() && !productWithSku.get().getId().equals(id)) {
                throw new ApiException("SKU_ALREADY_EXISTS",
                    "SKU já cadastrado: " + productDetails.getSku(), 409);
            }
            existingProduct.setSku(productDetails.getSku());
        }

        if (productDetails.getPrice() != null) {
            validatePrice(productDetails.getPrice());
            existingProduct.setPrice(productDetails.getPrice());
        }

        if (productDetails.getStockQuantity() != null) {
            existingProduct.setStockQuantity(productDetails.getStockQuantity());
        }

        // ✅ category
        if (productDetails.getCategory() != null && productDetails.getCategory().getId() != null) {
            Category category = categoryRepository.findById(productDetails.getCategory().getId())
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada", 404));
            existingProduct.setCategory(category);
        }

     // ✅ subcategory: só mexe se veio no payload
        if (productDetails.getSubcategory() != null) {
            if (productDetails.getSubcategory().getId() != null) {
                Subcategory sub = subcategoryRepository.findByIdWithCategory(productDetails.getSubcategory().getId())
                        .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada", 404));
                existingProduct.setSubcategory(sub);
            } else {
                // veio "subcategory": {} (ou sem id) => limpa
                existingProduct.setSubcategory(null);
            }
        }



        // ✅ supplier
        if (productDetails.getSupplier() != null && productDetails.getSupplier().getId() != null) {
            Supplier supplier = supplierRepository.findById(productDetails.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND", "Fornecedor não encontrado", 404));
            existingProduct.setSupplier(supplier);
        }

        validateSubcategoryBelongsToCategory(existingProduct);

        return tenantProductRepository.save(existingProduct);
    }

    private void resolveSupplier(Product product) {
        if (product.getSupplier() != null && product.getSupplier().getId() != null) {
            UUID supplierId = product.getSupplier().getId();
            Supplier supplier = supplierRepository.findById(product.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                    "Fornecedor não encontrado com ID: " + supplierId, 404));
            product.setSupplier(supplier);
        }
    }


    private void resolveCategoryAndSubcategory(Product product) {
        // ✅ category obrigatória
        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria é obrigatória", 400);
        }

        Category category = categoryRepository.findById(product.getCategory().getId())
            .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada", 404));
        product.setCategory(category);

        // ✅ subcategory opcional
        if (product.getSubcategory() != null && product.getSubcategory().getId() != null) {
            Subcategory sub = subcategoryRepository.findByIdWithCategory(product.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada", 404));
            product.setSubcategory(sub);
        } else {
            product.setSubcategory(null);
        }
    }

    private void validateSubcategoryBelongsToCategory(Product product) {
        if (product.getSubcategory() == null) return;

        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria é obrigatória", 400);
        }

        if (product.getSubcategory().getCategory() == null
            || product.getSubcategory().getCategory().getId() == null) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria sem categoria associada (cadastro inconsistente)", 409);
        }

        Long subCatCategoryId = product.getSubcategory().getCategory().getId();
        Long productCategoryId = product.getCategory().getId();

        if (!subCatCategoryId.equals(productCategoryId)) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria não pertence à categoria informada", 409);
        }
    }

    // ======= outros métodos =======

    @Transactional(readOnly = true)
    public List<Product> searchProducts(String name, BigDecimal minPrice,
                                        BigDecimal maxPrice, Integer minStock, Integer maxStock) {
        return tenantProductRepository.searchProducts(name, minPrice, maxPrice, minStock, maxStock);
    }


    @Transactional(readOnly = true)
    public List<Product> findLowStock(Integer threshold) {
        return tenantProductRepository.findByStockQuantityLessThan(threshold);
    }

    @Transactional
    public Product updateStock(UUID id, Integer quantityChange) {
        Product product = findById(id);
        if (quantityChange > 0) product.addToStock(quantityChange);
        else if (quantityChange < 0) product.removeFromStock(Math.abs(quantityChange));
        return tenantProductRepository.save(product);
    }

    @Transactional
    public Product updatePrice(UUID id, BigDecimal newPrice) {
        validatePrice(newPrice);
        Product product = findById(id);
        product.updatePrice(newPrice);
        return tenantProductRepository.save(product);
    }

    @Transactional
    public void delete(UUID id) {
        Product product = findById(id);
        product.softDelete(appClock.now());
        tenantProductRepository.save(product);
    }

    private void validateProduct(Product product) {
        if (!StringUtils.hasText(product.getName())) {
            throw new ApiException("PRODUCT_NAME_REQUIRED", "Nome do produto é obrigatório", 400);
        }
        if (product.getPrice() == null) {
            throw new ApiException("PRODUCT_PRICE_REQUIRED", "Preço do produto é obrigatório", 400);
        }
        validatePrice(product.getPrice());

        if (product.getStockQuantity() == null) product.setStockQuantity(0);
        if (product.getStockQuantity() < 0) {
            throw new ApiException("INVALID_STOCK", "Quantidade em estoque não pode ser negativa", 400);
        }
    }

    private void validatePrice(BigDecimal price) {
        if (price == null) throw new ApiException("INVALID_PRICE", "Preço não pode ser nulo", 400);
        if (price.compareTo(BigDecimal.ZERO) < 0) throw new ApiException("INVALID_PRICE", "Preço não pode ser negativo", 400);
        if (price.compareTo(BigDecimal.valueOf(1_000_000)) > 0) {
            throw new ApiException("PRICE_TOO_HIGH", "Preço muito alto. Valor máximo permitido: 1.000.000", 400);
        }
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryId(Long categoryId) {
        if (categoryId == null) {
            throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByCategoryId(categoryId);
    }


    @Transactional(readOnly = true)
    public List<Product> findByBrand(String brand) {
        if (!StringUtils.hasText(brand)) {
            throw new ApiException("INVALID_BRAND", "brand é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByBrandIgnoreCase(brand.trim());
    }



    @Transactional(readOnly = true)
    public List<Product> findActiveProducts() {
        return tenantProductRepository.findByActiveTrueAndDeletedFalse();
    }


    @Transactional
    public Product updateCostPrice(UUID id, BigDecimal costPrice) {
        Product product = findById(id);
        product.updateCostPrice(costPrice);
        return tenantProductRepository.save(product);
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateTotalInventoryValue() {
        return tenantProductRepository.calculateTotalInventoryValue();
    }

    @Transactional(readOnly = true)
    public Long countLowStockProducts(Integer threshold) {
        return tenantProductRepository.countLowStock(threshold);
    }
    
 // =========================================================
 // ✅ QUERIES PARA "DAR USO" AOS MÉTODOS DO ProductRepository
 // =========================================================

    @Transactional(readOnly = true)
    public List<Product> findBySubcategoryId(Long subcategoryId) {
        if (subcategoryId == null) {
            throw new ApiException("SUBCATEGORY_REQUIRED", "subcategoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedBySubcategoryId(subcategoryId);
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryAndOptionalSubcategory(Long categoryId, Long subcategoryId) {
        if (categoryId == null) {
            throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByCategoryAndOptionalSubcategory(categoryId, subcategoryId);
    }


 @Transactional(readOnly = true)
 public List<Product> findByName(String name) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     return tenantProductRepository.findByNameContainingIgnoreCase(name.trim());
 }

 @Transactional(readOnly = true)
 public Page<Product> findByNamePaged(String name, Pageable pageable) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     return tenantProductRepository.findByNameContainingIgnoreCase(name.trim(), pageable);
 }

 @Transactional(readOnly = true)
 public List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice) {
     if (minPrice == null || maxPrice == null) {
         throw new ApiException("INVALID_PRICE_RANGE", "minPrice e maxPrice são obrigatórios", 400);
     }
     if (maxPrice.compareTo(minPrice) < 0) {
         throw new ApiException("INVALID_PRICE_RANGE", "maxPrice deve ser >= minPrice", 400);
     }
     return tenantProductRepository.findByPriceBetween(minPrice, maxPrice);
 }

 @Transactional(readOnly = true)
 public List<Product> findBySupplierId(UUID supplierId) {
     if (supplierId == null) {
         throw new ApiException("SUPPLIER_REQUIRED", "supplierId é obrigatório", 400);
     }
     return tenantProductRepository.findBySupplier_Id(supplierId);
 }

 @Transactional(readOnly = true)
 public List<Product> findByNameAndPriceAndStock(
         String name,
         BigDecimal minPrice,
         BigDecimal maxPrice,
         Integer minStock,
         Integer maxStock
 ) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     if (minPrice == null || maxPrice == null) {
         throw new ApiException("INVALID_PRICE_RANGE", "minPrice e maxPrice são obrigatórios", 400);
     }
     if (maxPrice.compareTo(minPrice) < 0) {
         throw new ApiException("INVALID_PRICE_RANGE", "maxPrice deve ser >= minPrice", 400);
     }
     if (minStock == null || maxStock == null) {
         throw new ApiException("INVALID_STOCK_RANGE", "minStock e maxStock são obrigatórios", 400);
     }
     if (maxStock < minStock) {
         throw new ApiException("INVALID_STOCK_RANGE", "maxStock deve ser >= minStock", 400);
     }

     return tenantProductRepository.findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(
             name.trim(), minPrice, maxPrice, minStock, maxStock
     );
 }

 /**
  * Usa o @Query:
  * SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id
  */
 @Transactional(readOnly = true)
 public List<SupplierProductCountResponse> countProductsBySupplier() {
     List<Object[]> rows = tenantProductRepository.countProductsBySupplier();

     return rows.stream()
             .map(row -> new SupplierProductCountResponse(
                     (UUID) row[0],
                     ((Number) row[1]).longValue()
             ))
             .toList();
 }

 
 @Transactional
 public Product toggleActive(UUID id) {
     Product product = findById(id);

     if (Boolean.TRUE.equals(product.getDeleted())) {
         throw new ApiException("PRODUCT_DELETED", "Não é permitido alterar produto deletado", 409);
     }

     boolean next = !Boolean.TRUE.equals(product.getActive());
     product.setActive(next);

     return tenantProductRepository.save(product);
 }
 
 @Transactional(readOnly = true)
 public List<Product> findByCategoryId(Long categoryId, boolean includeDeleted, boolean includeInactive) {
     if (categoryId == null) {
         throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
     }
     return tenantProductRepository.findByCategoryWithFlags(categoryId, includeDeleted, includeInactive);
 }


 
    
}
package brito.com.multitenancy001.tenant.application.provisioning;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProvisioningService {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public void createSchemaAndMigrate(String schemaName) {
        tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(schemaName);
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.infrastructure.flyway.tenantschema.TenantSchemaFlywayMigrationService;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import brito.com.multitenancy001.tenant.security.TenantRole;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.regex.Pattern;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Slf4j
@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningService {

    private final JdbcTemplate jdbcTemplate;
    private final TenantSchemaFlywayMigrationService tenantSchemaMigrationService;
    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;
    
    
    private static final Pattern SCHEMA_PATTERN = Pattern.compile("^[a-zA-Z0-9_]+$");
    
   

    

    private void validateSchemaNameOrThrow(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new ApiException("INVALID_SCHEMA", "SchemaName inválido", 400);
        }

        String trimmed = schemaName.trim();

        if ("public".equalsIgnoreCase(trimmed)) {
            throw new ApiException("INVALID_SCHEMA", "SchemaName 'public' não é permitido", 400);
        }

        if (!SCHEMA_PATTERN.matcher(trimmed).matches()) {
            throw new ApiException(
                    "INVALID_SCHEMA",
                    "SchemaName inválido: use apenas letras, números e _ (underscore)",
                    400
            );
        }
    }

    

    public boolean schemaExists(String schemaName) {
        if (!StringUtils.hasText(schemaName)) return false;

        String normalized = schemaName.trim();

        if ("public".equalsIgnoreCase(normalized)) return false;

        String sql = "SELECT EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = ?)";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, normalized);
        return Boolean.TRUE.equals(exists);
    }

   

    public boolean tableExists(String schemaName, String tableName) {
        if (!StringUtils.hasText(schemaName) || !StringUtils.hasText(tableName)) return false;

        String sql =
                "SELECT EXISTS(" +
                "  SELECT 1 FROM information_schema.tables " +
                "  WHERE table_schema = ? AND table_name = ?" +
                ")";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, schemaName, tableName);
        return Boolean.TRUE.equals(exists);
    }

    public void ensureSchemaExistsAndMigrate(String schemaName) {
        validateSchemaNameOrThrow(schemaName);

        String normalized = schemaName.trim().toLowerCase();


        if (!schemaExists(normalized)) {
            log.info("📦 Criando schemaName {}", normalized);
            jdbcTemplate.execute("CREATE SCHEMA IF NOT EXISTS \"" + normalized + "\"");
        }

        log.info("🧬 Rodando migrations do tenant: {}", normalized);
        tenantSchemaMigrationService.migrateTenantSchema(normalized);
    }

    /**
     * Deve ser chamado com TenantContext já bindado no schema do tenant
     */
    public TenantUser tenantOwnerBootstrapService(Account account, String username, String email, String rawPassword) {
        String bound = TenantContext.getOrNull();
        if (bound == null || !bound.equals(account.getSchemaName())) {
            throw new ApiException("TENANT_NOT_BOUND", "Tenant não está bindado no schema esperado", 500);
        }

        String normUsername = username == null ? null : username.trim().toLowerCase();
        String normEmail = email == null ? null : email.trim().toLowerCase();

        if (!StringUtils.hasText(normUsername)) {
            throw new ApiException("INVALID_USERNAME", "Username é obrigatório", 400);
        }
        if (!StringUtils.hasText(normEmail)) {
            throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
        }

        boolean existsUser = tenantUserRepository.existsByUsernameAndAccountId(normUsername, account.getId());
        boolean existsEmail = tenantUserRepository.existsByEmailAndAccountId(normEmail, account.getId());

        if (existsUser) throw new ApiException("ADMIN_EXISTS", "Já existe usuário com este username", 409);
        if (existsEmail) throw new ApiException("ADMIN_EXISTS", "Já existe usuário com este email", 409);

        TenantUser admin = TenantUser.builder()
                .accountId(account.getId())
                .name("Administrador")
                .username(normUsername)
                .email(normEmail)
                .password(passwordEncoder.encode(rawPassword))
                .role(TenantRole.TENANT_OWNER)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .timezone(account.getTimezone() != null ? account.getTimezone() : "America/Sao_Paulo")
                .locale(account.getLocale() != null ? account.getLocale() : "pt_BR")
                .build();

        return tenantUserRepository.save(admin);
    }
}
package brito.com.multitenancy001.tenant.application.supplier;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import brito.com.multitenancy001.tenant.persistence.supplier.TenantSupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantSupplierService {

    private final TenantSupplierRepository tenantSupplierRepository;
    private final AppClock appClock;

    // =========================================================
    // READ (por padrão: NÃO retorna deletados)
    // =========================================================

    @Transactional(readOnly = true)
    public Supplier findById(UUID id) {
        if (id == null) throw new ApiException("SUPPLIER_ID_REQUIRED", "id é obrigatório", 400);

        Supplier s = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (s.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Fornecedor deletado não pode ser consultado", 404);
        }

        return s;
    }

    @Transactional(readOnly = true)
    public List<Supplier> findAll() {
        return tenantSupplierRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Supplier> findActive() {
        return tenantSupplierRepository.findActiveNotDeleted();
    }

    @Transactional(readOnly = true)
    public Supplier findByDocument(String document) {
        if (!StringUtils.hasText(document)) {
            throw new ApiException("SUPPLIER_DOCUMENT_REQUIRED", "document é obrigatório", 400);
        }

        String doc = document.trim();

        return tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(doc)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com document: " + doc, 404));
    }

    @Transactional(readOnly = true)
    public List<Supplier> searchByName(String name) {
        if (!StringUtils.hasText(name)) {
            throw new ApiException("SUPPLIER_NAME_REQUIRED", "name é obrigatório", 400);
        }
        return tenantSupplierRepository.findNotDeletedByNameContainingIgnoreCase(name.trim());
    }

    @Transactional(readOnly = true)
    public List<Supplier> findByEmail(String email) {
        if (!StringUtils.hasText(email)) {
            throw new ApiException("SUPPLIER_EMAIL_REQUIRED", "email é obrigatório", 400);
        }
        return tenantSupplierRepository.findNotDeletedByEmail(email.trim());
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Supplier create(Supplier supplier) {
        validateForCreate(supplier);

        // Regra do seu DB: document único quando NOT NULL e deleted=false.
        // Então: se vier document, garantimos unicidade entre não-deletados.
        if (StringUtils.hasText(supplier.getDocument())) {
            String doc = supplier.getDocument().trim();
            Optional<Supplier> existing = tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(doc);
            if (existing.isPresent()) {
                throw new ApiException("SUPPLIER_DOCUMENT_ALREADY_EXISTS",
                        "Já existe fornecedor com document: " + doc, 409);
            }
            supplier.setDocument(doc);
        } else {
            supplier.setDocument(null);
        }

        // defaults
        // (em Supplier você usa boolean primitivo, então já vem false/true; aqui só garantimos coerência)
        supplier.setDeleted(false);
        supplier.setActive(true);

        return tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public Supplier update(UUID id, Supplier req) {
        if (id == null) throw new ApiException("SUPPLIER_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("SUPPLIER_REQUIRED", "payload é obrigatório", 400);

        Supplier existing = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Não é permitido alterar fornecedor deletado", 409);
        }

        // name
        if (StringUtils.hasText(req.getName())) {
            existing.setName(req.getName().trim());
        }

        // contactPerson
        if (req.getContactPerson() != null) {
            existing.setContactPerson(StringUtils.hasText(req.getContactPerson()) ? req.getContactPerson().trim() : null);
        }

        // email
        if (req.getEmail() != null) {
            existing.setEmail(StringUtils.hasText(req.getEmail()) ? req.getEmail().trim() : null);
        }

        // phone
        if (req.getPhone() != null) {
            existing.setPhone(StringUtils.hasText(req.getPhone()) ? req.getPhone().trim() : null);
        }

        // address
        if (req.getAddress() != null) {
            existing.setAddress(StringUtils.hasText(req.getAddress()) ? req.getAddress().trim() : null);
        }

        // document + documentType
        if (req.getDocument() != null) {
            String newDoc = req.getDocument();
            if (StringUtils.hasText(newDoc)) {
                newDoc = newDoc.trim();

                Optional<Supplier> other = tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(newDoc);
                if (other.isPresent() && !other.get().getId().equals(id)) {
                    throw new ApiException("SUPPLIER_DOCUMENT_ALREADY_EXISTS",
                            "Já existe fornecedor com document: " + newDoc, 409);
                }

                existing.setDocument(newDoc);
            } else {
                existing.setDocument(null);
            }
        }

        if (req.getDocumentType() != null) {
            existing.setDocumentType(StringUtils.hasText(req.getDocumentType()) ? req.getDocumentType().trim() : null);
        }

        // website
        if (req.getWebsite() != null) {
            existing.setWebsite(StringUtils.hasText(req.getWebsite()) ? req.getWebsite().trim() : null);
        }

        // paymentTerms
        if (req.getPaymentTerms() != null) {
            existing.setPaymentTerms(StringUtils.hasText(req.getPaymentTerms()) ? req.getPaymentTerms().trim() : null);
        }

        // leadTimeDays
        if (req.getLeadTimeDays() != null) {
            if (req.getLeadTimeDays() < 0) {
                throw new ApiException("INVALID_LEAD_TIME", "leadTimeDays não pode ser negativo", 400);
            }
            existing.setLeadTimeDays(req.getLeadTimeDays());
        }

        // rating
        if (req.getRating() != null) {
            validateRating(req.getRating());
            existing.setRating(req.getRating());
        }

        // notes
        if (req.getNotes() != null) {
            existing.setNotes(StringUtils.hasText(req.getNotes()) ? req.getNotes().trim() : null);
        }

        // active (permitimos atualizar, mas não pode ativar se estiver deletado - já barramos acima)
        // Aqui: só atualiza se o payload tiver sido enviado em algum formato.
        // Como é boolean primitivo, não dá pra saber se "veio" ou não. Então mantemos SEM alterar.
        // Se você quiser controlar ativo via endpoint específico, faça um PATCH /{id}/toggle-active (igual product).

        return tenantSupplierRepository.save(existing);
    }

    @Transactional
    public Supplier toggleActive(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (supplier.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Não é permitido alterar fornecedor deletado", 409);
        }

        supplier.setActive(!supplier.isActive());
        return tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public void softDelete(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        supplier.softDelete(appClock.now());
        tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public Supplier restore(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        supplier.restore();
        return tenantSupplierRepository.save(supplier);
    }

    // =========================================================
    // Validation
    // =========================================================

    private void validateForCreate(Supplier supplier) {
        if (supplier == null) throw new ApiException("SUPPLIER_REQUIRED", "Fornecedor é obrigatório", 400);

        if (!StringUtils.hasText(supplier.getName())) {
            throw new ApiException("SUPPLIER_NAME_REQUIRED", "name é obrigatório", 400);
        }

        supplier.setName(supplier.getName().trim());

        if (supplier.getEmail() != null) {
            supplier.setEmail(StringUtils.hasText(supplier.getEmail()) ? supplier.getEmail().trim() : null);
        }
        if (supplier.getContactPerson() != null) {
            supplier.setContactPerson(StringUtils.hasText(supplier.getContactPerson()) ? supplier.getContactPerson().trim() : null);
        }
        if (supplier.getPhone() != null) {
            supplier.setPhone(StringUtils.hasText(supplier.getPhone()) ? supplier.getPhone().trim() : null);
        }
        if (supplier.getAddress() != null) {
            supplier.setAddress(StringUtils.hasText(supplier.getAddress()) ? supplier.getAddress().trim() : null);
        }
        if (supplier.getDocumentType() != null) {
            supplier.setDocumentType(StringUtils.hasText(supplier.getDocumentType()) ? supplier.getDocumentType().trim() : null);
        }
        if (supplier.getWebsite() != null) {
            supplier.setWebsite(StringUtils.hasText(supplier.getWebsite()) ? supplier.getWebsite().trim() : null);
        }
        if (supplier.getPaymentTerms() != null) {
            supplier.setPaymentTerms(StringUtils.hasText(supplier.getPaymentTerms()) ? supplier.getPaymentTerms().trim() : null);
        }
        if (supplier.getNotes() != null) {
            supplier.setNotes(StringUtils.hasText(supplier.getNotes()) ? supplier.getNotes().trim() : null);
        }

        if (supplier.getLeadTimeDays() != null && supplier.getLeadTimeDays() < 0) {
            throw new ApiException("INVALID_LEAD_TIME", "leadTimeDays não pode ser negativo", 400);
        }

        if (supplier.getRating() != null) {
            validateRating(supplier.getRating());
        }
    }

    private void validateRating(BigDecimal rating) {
        // rating NUMERIC(3,2) -> vai até 9.99
        if (rating.compareTo(BigDecimal.ZERO) < 0) {
            throw new ApiException("INVALID_RATING", "rating não pode ser negativo", 400);
        }
        if (rating.compareTo(new BigDecimal("9.99")) > 0) {
            throw new ApiException("INVALID_RATING", "rating máximo é 9.99", 400);
        }
    }
}
package brito.com.multitenancy001.tenant.application.user.admin;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.application.user.TenantUserTxService;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantUserAdminService {

    private final TenantUserTxService tenantUserTxService;
    private final SecurityUtils securityUtils;

    private void runInTenant(String schema, Runnable action) {
        TenantContext.bind(schema);
        try {
            action.run();
        } finally {
            TenantContext.clear();
        }
    }

    public void setUserSuspendedByAdmin(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () ->
                tenantUserTxService.setSuspendedByAdmin(userId, accountId, suspended)
        );
    }
}
package brito.com.multitenancy001.tenant.application.user;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.account.AccountResolver;
import brito.com.multitenancy001.shared.account.AccountSnapshot;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.LinkedHashSet;
import java.util.List;
import java.util.concurrent.Callable;

@Service
@RequiredArgsConstructor
public class TenantUserService {

    private final TenantUserApiMapper tenantUserApiMapper;

    private final TenantUserTxService tenantUserTxService;
    private final AccountResolver accountResolver;
    private final JwtTokenProvider jwtTokenProvider;
    private final SecurityUtils securityUtils;
    private final AppClock appClock;


    // ===== helpers =====
    private <T> T runInTenant(String schema, Callable<T> action) {
        TenantContext.bind(schema);
        try {
            return action.call();
        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            TenantContext.clear();
        }
    }

    private void runInTenant(String schema, Runnable action) {
        TenantContext.bind(schema);
        try {
            action.run();
        } finally {
            TenantContext.clear();
        }
    }

    // =========================================================
    // CONTROLLER METHODS
    // =========================================================

    public void transferTenantOwner(Long toUserId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long fromUserId = securityUtils.getCurrentUserId();

        runInTenant(schema, () ->
                tenantUserTxService.transferTenantOwnerRole(accountId, fromUserId, toUserId)
        );
    }

    public TenantUserDetailsResponse createTenantUser(TenantUserCreateRequest tenantUserCreateRequest) {
    Long accountId = securityUtils.getCurrentAccountId();
    String schema = securityUtils.getCurrentSchema();

  

    String name = tenantUserCreateRequest.name().trim();
    String username = tenantUserCreateRequest.username().trim().toLowerCase();
    String email = tenantUserCreateRequest.email().trim().toLowerCase();


    final LinkedHashSet<String> perms =
            (tenantUserCreateRequest.permissions() == null || tenantUserCreateRequest.permissions().isEmpty())
                    ? null
                    : new LinkedHashSet<>(tenantUserCreateRequest.permissions());

    return runInTenant(schema, () -> {
    	TenantUser created = tenantUserTxService.createTenantUser(
    	        accountId,
    	        name,                             // já trimado
    	        username,
    	        email,
    	        tenantUserCreateRequest.password(),
    	        tenantUserCreateRequest.role(),
    	        tenantUserCreateRequest.phone(),
    	        tenantUserCreateRequest.avatarUrl(),
    	        perms
    	);


        return tenantUserApiMapper.toDetails(created);
    });
}


    public List<TenantUserSummaryResponse> listTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () ->
                tenantUserTxService.listUsers(accountId)
                        .stream()
                        .map(tenantUserApiMapper::toSummary)
                        .toList()
        );
    }

    public List<TenantUserSummaryResponse> listActiveTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () ->
                tenantUserTxService.listActiveUsers(accountId)
                        .stream()
                        .map(tenantUserApiMapper::toSummary)
                        .toList()
        );
    }

    public TenantUserDetailsResponse getTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> {
            TenantUser user = tenantUserTxService.getUser(userId, accountId);
            return tenantUserApiMapper.toDetails(user);
        });
    }

    public TenantUserSummaryResponse updateTenantUserStatus(Long userId, boolean active) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> {
            TenantUser updated = tenantUserTxService.updateStatus(userId, accountId, active);
            return tenantUserApiMapper.toSummary(updated);
        });
    }

    public void softDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () -> tenantUserTxService.softDelete(userId, accountId));
    }

    public TenantUserSummaryResponse restoreTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> {
            TenantUser restored = tenantUserTxService.restore(userId, accountId);
            return tenantUserApiMapper.toSummary(restored);
        });
    }

    public TenantUserSummaryResponse resetTenantUserPassword(Long userId, String newPassword) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> {
            TenantUser updated = tenantUserTxService.resetPassword(userId, accountId, newPassword);
            return tenantUserApiMapper.toSummary(updated);
        });
    }

    public void hardDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () -> tenantUserTxService.hardDelete(userId, accountId));
    }

    // =========================================================
    // PASSWORD RESET (PUBLIC -> TENANT)
    // =========================================================

    public String generatePasswordResetToken(String slug, String usernameOrEmail) {
        if (!StringUtils.hasText(slug)) throw new ApiException("INVALID_SLUG", "Slug é obrigatório", 400);
        if (!StringUtils.hasText(usernameOrEmail)) throw new ApiException("INVALID_LOGIN", "Username/Email é obrigatório", 400);

        AccountSnapshot account = accountResolver.resolveActiveAccountBySlug(slug);

        return runInTenant(account.schemaName(), () -> {
            TenantUser user = tenantUserTxService.getUserByUsernameOrEmail(usernameOrEmail, account.id());

            if (user.isDeleted() || user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
                throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
            }

            String token = jwtTokenProvider.generatePasswordResetToken(
                    user.getUsername(),
                    account.schemaName(),
                    account.id()
            );

            user.setPasswordResetToken(token);
            user.setPasswordResetExpires(appClock.now().plusHours(1));
            tenantUserTxService.save(user);

            return token;
        });
    }

    public void resetPasswordWithToken(String token, String newPassword) {
        if (!StringUtils.hasText(token)) throw new ApiException("INVALID_TOKEN", "Token inválido", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException("INVALID_PASSWORD", "Nova senha é obrigatória", 400);

        String schema = jwtTokenProvider.getTenantSchemaFromToken(token);
        Long accountId = jwtTokenProvider.getAccountIdFromToken(token);
        String username = jwtTokenProvider.getUsernameFromToken(token);

        runInTenant(schema, () ->
                tenantUserTxService.resetPasswordWithToken(accountId, username, token, newPassword)
        );
    }

    // =========================================================
    // MY PROFILE (agora existe no TxService)
    // =========================================================

    public TenantUserDetailsResponse updateMyProfile(String name, String phone, String locale, String timezone) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long userId = securityUtils.getCurrentUserId();

        return runInTenant(schema, () -> {
            TenantUser updated = tenantUserTxService.updateProfile(
                    userId,
                    accountId,
                    name,
                    phone,
                    locale,
                    timezone,
                    appClock.now()

            );
            return tenantUserApiMapper.toDetails(updated);
        });
    }
}
package brito.com.multitenancy001.tenant.application.user;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import brito.com.multitenancy001.tenant.security.TenantRole;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "tenantTransactionManager")
public class TenantUserTxService {

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;

    private LocalDateTime now() {
        return appClock.now();
    }

    // =========================
    // CREATE
    // =========================
    public TenantUser createTenantUser(
            Long accountId,
            String name,
            String username,
            String email,
            String rawPassword,
            TenantRole roleEnum,
            String phone,
            String avatarUrl,
            LinkedHashSet<String> permissions
    ) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);

        if (!StringUtils.hasText(name)) throw new ApiException("INVALID_NAME", "Nome obrigatório", 400);
        if (!StringUtils.hasText(username)) throw new ApiException("INVALID_USERNAME", "Username obrigatório", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email obrigatório", 400);

        if (!StringUtils.hasText(rawPassword) || !rawPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inválida", 400);
        }

        String usernameNew = username.trim().toLowerCase();
        String emailNew = email.trim().toLowerCase();

        if (tenantUserRepository.existsByUsernameAndAccountId(usernameNew, accountId)) {
            throw new ApiException("USERNAME_ALREADY_EXISTS", "Username já existe nesta conta", 409);
        }
        if (tenantUserRepository.existsByEmailAndAccountId(emailNew, accountId)) {
            throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já existe nesta conta", 409);
        }

        // ✅ normaliza e valida permissions AQUI (fonte de verdade)
        final LinkedHashSet<String> normalizedPermissions;
        try {
            normalizedPermissions = PermissionScopeValidator.normalizeTenant(
                    permissions == null ? new LinkedHashSet<>() : permissions
            );
        } catch (IllegalArgumentException e1) {
            throw new ApiException("INVALID_PERMISSION", e1.getMessage(), 400);
        }

        TenantUser user = TenantUser.builder()
                .accountId(accountId)
                .name(name.trim())
                .username(usernameNew)
                .email(emailNew)
                .password(passwordEncoder.encode(rawPassword))
                .role(roleEnum)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .phone(phone)
                .avatarUrl(avatarUrl)
                .timezone("America/Sao_Paulo")
                .locale("pt_BR")
                .build();

        // ✅ Se trouxe permissions válidas e não vazias, respeita.
        // Se veio vazio/null: deixa o @PrePersist do entity aplicar defaults por role.
        if (!normalizedPermissions.isEmpty()) {
            user.setPermissions(new LinkedHashSet<>(normalizedPermissions));
        }

        return tenantUserRepository.save(user);
    }

    public TenantUser setSuspendedByAdmin(Long userId, Long accountId, boolean suspended) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_DELETED", "Usuário está deletado", 409);

        LocalDateTime now = now();
        user.setSuspendedByAdmin(suspended);
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

@Transactional(readOnly = true)
public TenantUser getUserByUsernameOrEmail(String usernameOrEmail, Long accountId) {
    if (accountId == null) {
        throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);
    }
    if (!StringUtils.hasText(usernameOrEmail)) {
        throw new ApiException("INVALID_LOGIN", "Username/Email é obrigatório", 400);
    }

    String login = usernameOrEmail.trim().toLowerCase();

    if (login.contains("@")) {
        // ✅ usa o método que estava “só interface”
        TenantUser user = tenantUserRepository.findByEmailAndAccountId(login, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_DELETED", "Usuário está deletado", 409);
        }
        return user;
    }

    // ✅ username: já filtra deleted
    return tenantUserRepository.findByUsernameAndAccountIdAndDeletedFalse(login, accountId)
            .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));
}


    
    public TenantUser updateUserEmail(Long userId, Long accountId, String newEmail) {
        if (userId == null) throw new ApiException("USER_REQUIRED", "UserId obrigatório", 400);
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);
        if (!StringUtils.hasText(newEmail)) throw new ApiException("INVALID_EMAIL", "Email obrigatório", 400);

        String emailNew = newEmail.trim().toLowerCase();

        TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        // ✅ usa o método que estava “só interface”
        if (tenantUserRepository.existsByEmailAndAccountIdAndIdNot(emailNew, accountId, userId)) {
            throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já existe nesta conta", 409);
        }

        LocalDateTime now = now();
        user.setEmail(emailNew);
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    
    
    

    public TenantUser updateProfile(
            Long userId,
            Long accountId,
            String name,
            String phone,
            String locale,
            String timezone,
            LocalDateTime nowParam
    ) {
        if (userId == null) throw new ApiException("USER_REQUIRED", "UserId obrigatório", 400);
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);

        TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (StringUtils.hasText(name)) user.setName(name.trim());
        if (phone != null) user.setPhone(phone);
        if (StringUtils.hasText(locale)) user.setLocale(locale.trim());
        if (StringUtils.hasText(timezone)) user.setTimezone(timezone.trim());

        LocalDateTime now = (nowParam != null ? nowParam : now());
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    @Transactional(transactionManager = "tenantTransactionManager")
    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
        if (updated == 0) {
            throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado ou removido", 404);
        }
    }

    // =========================
    // LIST / GET
    // =========================
    @Transactional(readOnly = true)
    public List<TenantUser> listUsers(Long accountId) {
        return tenantUserRepository.findByAccountIdAndDeletedFalse(accountId);
    }

    @Transactional(readOnly = true)
    public List<TenantUser> listActiveUsers(Long accountId) {
        return tenantUserRepository.findActiveUsersByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public TenantUser getUser(Long userId, Long accountId) {
        return tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));
    }

    @Transactional(readOnly = true)
    public TenantUser getByUsername(Long accountId, String username) {
        return tenantUserRepository.findByUsernameAndAccountIdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));
    }

    @Transactional(readOnly = true)
    public TenantUser getByEmailActive(Long accountId, String email) {
        TenantUser user = tenantUserRepository.findByEmailAndAccountIdAndDeletedFalse(email, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
            throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
        }
        return user;
    }

    // =========================
    // UPDATE STATUS
    // =========================
    public TenantUser updateStatus(Long userId, Long accountId, boolean active) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_DELETED", "Usuário está deletado", 409);

        LocalDateTime now = now();

        user.setSuspendedByAdmin(!active);
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    // =========================
    // CONTAGEM
    // =========================
    @Transactional(readOnly = true)
    public long countActiveUsers(Long accountId) {
        return tenantUserRepository.countActiveUsersByAccount(accountId);
    }

    public void softDelete(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_ALREADY_DELETED", "Usuário já removido", 409);

        LocalDateTime now = now();
        user.softDelete(now, appClock.epochMillis()); // ✅ novo método clock-aware
        user.setUpdatedAt(now);

        tenantUserRepository.save(user);
    }

    public TenantUser restore(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (!user.isDeleted()) throw new ApiException("USER_NOT_DELETED", "Usuário não está removido", 409);

        LocalDateTime now = now();

        user.restore();
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    public void hardDelete(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));
        tenantUserRepository.delete(user);
    }

    public TenantUser resetPassword(Long userId, Long accountId, String newPassword) {
        if (!StringUtils.hasText(newPassword) || !newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inválida", 400);
        }

        TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        LocalDateTime now = now();

        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(now);
        user.setMustChangePassword(false);
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

   // =========================
// RESET PASSWORD (TOKEN)
// =========================
// =========================
// RESET PASSWORD (TOKEN)
// =========================
public void resetPasswordWithToken(Long accountId, String username, String token, String newPassword) {
    if (!StringUtils.hasText(newPassword) || !newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
        throw new ApiException("INVALID_PASSWORD", "Senha fraca / inválida", 400);
    }
    if (accountId == null) {
        throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);
    }
    if (!StringUtils.hasText(token)) {
        throw new ApiException("INVALID_TOKEN", "Token inválido", 400);
    }

    LocalDateTime now = now();

    // ✅ usa o método que estava “só interface”
    TenantUser user = tenantUserRepository
            .findByPasswordResetTokenAndAccountId(token, accountId)
            .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

    if (user.isDeleted()) {
        throw new ApiException("USER_DELETED", "Usuário está deletado", 409);
    }

    // opcional (mantém coerência com o token que também carrega username)
    if (StringUtils.hasText(username) && !user.getUsername().equals(username)) {
        throw new ApiException("INVALID_TOKEN", "Token não confere", 400);
    }

    if (user.getPasswordResetExpires() == null || user.getPasswordResetExpires().isBefore(now)) {
        throw new ApiException("TOKEN_EXPIRED", "Token expirado", 400);
    }

    user.setPassword(passwordEncoder.encode(newPassword));
    user.setPasswordChangedAt(now);
    user.setMustChangePassword(false);

    user.setPasswordResetToken(null);
    user.setPasswordResetExpires(null);

    user.setUpdatedAt(now);
    tenantUserRepository.save(user);
}


    // usado no generatePasswordResetToken
    public TenantUser save(TenantUser user) {
        LocalDateTime now = now();
        user.setUpdatedAt(now);
        return tenantUserRepository.save(user);
    }

    public void transferTenantOwnerRole(Long accountId, Long fromUserId, Long toUserId) {
        TenantUser from = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(fromUserId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "TENANT_OWNER não encontrado", 404));

        TenantUser to = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(toUserId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "TENANT_ACCOUNT_ADMIN alvo não encontrado", 404));

        LocalDateTime now = now();

        from.setRole(TenantRole.TENANT_ADMIN);
        to.setRole(TenantRole.TENANT_OWNER);

        from.setUpdatedAt(now);
        to.setUpdatedAt(now);

        tenantUserRepository.save(from);
        tenantUserRepository.save(to);
    }
}
package brito.com.multitenancy001.tenant.application.username.generator;

import java.util.UUID;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.shared.domain.username.UsernamePolicy;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class UsernameGeneratorService {

	private static final int SUFFIX_LEN = 8;

	private final UsernamePolicy policy;
	private final TenantUserRepository tenantUserRepository;

	/**
	 * Gera username baseado no email, garantindo: - normalização - limite máximo
	 * (sem cortar sufixo) - unicidade por accountId (best-effort + fallback)
	 */
	public String generateFromEmail(String email, Long accountId) {
    if (accountId == null) {
        throw new IllegalArgumentException("accountId is required");
    }
    if (email == null || !email.contains("@")) {
        throw new IllegalArgumentException("Invalid email");
    }

    String local = email.split("@", 2)[0].toLowerCase();
    String base = policy.normalizeBase(local);

    for (int attempt = 0; attempt < 10; attempt++) {
        String candidate = policy.build(base, randomSuffix(SUFFIX_LEN));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    for (int counter = 2; counter < 200; counter++) {
        String candidate = policy.build(base, String.valueOf(counter));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    throw new IllegalStateException("Could not generate a unique username after multiple attempts");
}

public String ensureUnique(String initialUsername, Long accountId) {
    if (accountId == null) {
        throw new IllegalArgumentException("accountId is required");
    }

    if (policy.isValid(initialUsername) &&
        !tenantUserRepository.existsByUsernameAndAccountId(initialUsername, accountId)) {
        return initialUsername;
    }

    String base = policy.extractBase(initialUsername);

    for (int attempt = 0; attempt < 10; attempt++) {
        String candidate = policy.build(base, randomSuffix(SUFFIX_LEN));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    for (int counter = 2; counter < 200; counter++) {
        String candidate = policy.build(base, String.valueOf(counter));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    throw new IllegalStateException("Could not ensure unique username after multiple attempts");
}


	
	private String randomSuffix(int len) {
		return UUID.randomUUID().toString().replace("-", "").substring(0, len);
	}
}
package brito.com.multitenancy001.tenant.domain.category;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "categories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_categories_name",
                columnNames = "name"
        )
)
@Getter
@Setter
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}
package brito.com.multitenancy001.tenant.domain.category;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "subcategories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_subcategories_name_category",
                columnNames = {"category_id", "name"}
        )
)
@Getter
@Setter
public class Subcategory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_subcategories_category")
    )
    private Category category;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}
package brito.com.multitenancy001.tenant.domain.product;

import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "products")

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"supplier", "category", "subcategory"})
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(length = 100, nullable = false)
    private String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    @Builder.Default
    private Integer stockQuantity = 0;

    @Column(name = "min_stock")
    private Integer minStock;

    @Column(name = "max_stock")
    private Integer maxStock;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    @Column(name = "profit_margin", precision = 5, scale = 2)
    private BigDecimal profitMargin;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_products_category")
    )
    private Category category;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
            name = "subcategory_id",
            foreignKey = @ForeignKey(name = "fk_products_subcategory")
    )
    private Subcategory subcategory;

    @Column(name = "brand", length = 100)
    private String brand;

    @Column(name = "weight_kg", precision = 8, scale = 3)
    private BigDecimal weightKg;

    @Column(name = "dimensions", length = 50)
    private String dimensions;

    @Column(name = "barcode", length = 50)
    private String barcode;

    @Column(name = "active", nullable = false)
    @Builder.Default
    private Boolean active = true;

    @Column(name = "images_json", columnDefinition = "TEXT")
    private String imagesJson;

    @Column(name = "attributes_json", columnDefinition = "TEXT")
    private String attributesJson;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", foreignKey = @ForeignKey(name = "fk_product_supplier"))
    private Supplier supplier;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private Boolean deleted = false;

    @PrePersist
    protected void onCreate() {
        if (this.stockQuantity == null) this.stockQuantity = 0;
        if (this.active == null) this.active = true;
        if (this.deleted == null) this.deleted = false;
        calculateProfitMargin();
    }

    @PreUpdate
    protected void onUpdate() {
        calculateProfitMargin();
    }

    private void calculateProfitMargin() {
        if (this.costPrice != null && this.costPrice.compareTo(BigDecimal.ZERO) > 0 && this.price != null) {
            BigDecimal profit = this.price.subtract(this.costPrice);

            // % = (profit / cost) * 100
            BigDecimal percent = profit
                    .divide(this.costPrice, 6, RoundingMode.HALF_UP)
                    .multiply(BigDecimal.valueOf(100));

            // ✅ alinha com NUMERIC(5,2)
            this.profitMargin = percent.setScale(2, RoundingMode.HALF_UP);
        } else {
            this.profitMargin = null;
        }
    }

    // =====================
    // Regras de domínio
    // =====================

    public void softDelete(LocalDateTime now) {
        if (Boolean.TRUE.equals(this.deleted)) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!Boolean.TRUE.equals(this.deleted)) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }

    public void updatePrice(BigDecimal newPrice) {
        if (newPrice == null || newPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Preço inválido");
        }
        this.price = newPrice;
        calculateProfitMargin();
    }

    public void updateCostPrice(BigDecimal newCostPrice) {
        this.costPrice = newCostPrice;
        calculateProfitMargin();
    }

    public void addToStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;
        this.stockQuantity += quantity;
    }

    public void removeFromStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;

        if (this.stockQuantity < quantity) {
            throw new IllegalStateException("Estoque insuficiente. Disponível: " + this.stockQuantity);
        }
        this.stockQuantity -= quantity;
    }
}
package brito.com.multitenancy001.tenant.domain.sale;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "sales", indexes = {
        @Index(name = "idx_sales_sale_date", columnList = "sale_date"),
        @Index(name = "idx_sales_status", columnList = "status")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "items")
public class Sale {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    @Column(name = "sale_date", nullable = false)
    private LocalDateTime saleDate;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "customer_name", length = 200)
    private String customerName;

    @Column(name = "customer_document", length = 20)
    private String customerDocument;

    @Column(name = "customer_email", length = 150)
    private String customerEmail;

    @Column(name = "customer_phone", length = 20)
    private String customerPhone;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private SaleStatus status;

    @OneToMany(
            mappedBy = "sale",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            orphanRemoval = true,
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<SaleItem> items = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public void addItem(SaleItem item) {
        if (item == null) return;
        item.setSale(this);
        this.items.add(item);
        recalcTotal();
    }

    public void removeItem(SaleItem item) {
        if (item == null) return;
        this.items.remove(item);
        item.setSale(null);
        recalcTotal();
    }

    public void recalcTotal() {
        BigDecimal sum = BigDecimal.ZERO;
        for (SaleItem it : items) {
            if (it.getTotalPrice() != null) {
                sum = sum.add(it.getTotalPrice());
            }
        }
        this.totalAmount = sum;
    }

    public void cancel() {
        this.status = SaleStatus.CANCELLED;
    }
}
package brito.com.multitenancy001.tenant.domain.sale;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.util.UUID;

@Entity
@Table(name = "sale_items", indexes = {
        @Index(name = "idx_sale_items_sale_id", columnList = "sale_id"),
        @Index(name = "idx_sale_items_product_id", columnList = "product_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "sale")
public class SaleItem {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "sale_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_sale_items_sale")
    )
    private Sale sale;

    // Sem FK para products. Referência fraca (histórico)
    @Column(name = "product_id")
    private UUID productId;

    // Snapshot obrigatório do produto no momento da venda
    @Column(name = "product_name", nullable = false, length = 255)
    private String productName;

    @Column(name = "quantity", nullable = false, precision = 12, scale = 3)
    private BigDecimal quantity;

    @Column(name = "unit_price", nullable = false, precision = 12, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_price", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalPrice;

    public void recalcTotal() {
        if (quantity == null || unitPrice == null) {
            this.totalPrice = BigDecimal.ZERO;
            return;
        }
        this.totalPrice = unitPrice.multiply(quantity);
    }
}
package brito.com.multitenancy001.tenant.domain.sale;


public enum SaleStatus {
    DRAFT,
    CONFIRMED,
    PAID,
    CANCELLED
}
package brito.com.multitenancy001.tenant.domain.supplier;

import brito.com.multitenancy001.tenant.domain.product.Product;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "suppliers", indexes = {
        @Index(name = "idx_supplier_name", columnList = "name"),
        @Index(name = "idx_supplier_email", columnList = "email")
        // NÃO declare unique index de document aqui (é parcial no DB)
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"products"})
public class Supplier {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", updatable = false, nullable = false)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(name = "contact_person", length = 100)
    private String contactPerson;

    @Column(length = 150)
    private String email;

    @Column(length = 20)
    private String phone;

    @Column(columnDefinition = "TEXT")
    private String address;

    @Column(length = 20)
    private String document;

    @Column(name = "document_type", length = 10)
    private String documentType;

    @Column(name = "website", length = 200)
    private String website;

    @Column(name = "payment_terms", length = 100)
    private String paymentTerms;

    @Column(name = "lead_time_days")
    private Integer leadTimeDays;

    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating;

    @Builder.Default
    @Column(name = "active", nullable = false)
    private boolean active = true;

    @Builder.Default
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @OneToMany(
            mappedBy = "supplier",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<Product> products = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // =====================
    // Regras de domínio
    // =====================

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}
package brito.com.multitenancy001.tenant.domain.user;

import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(
    name = "tenant_users",
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_tenant_users_username_account", columnNames = {"username", "account_id"}),
        @UniqueConstraint(name = "uk_tenant_users_email_account", columnNames = {"email", "account_id"})
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "password")
public class TenantUser {

    private static final int USERNAME_MAX_LEN = 100;
    private static final int EMAIL_MAX_LEN = 150;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = USERNAME_MAX_LEN)
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inválido.")
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false, length = EMAIL_MAX_LEN)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private TenantRole role;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @ElementCollection
    @CollectionTable(
        name = "tenant_user_permissions",
        joinColumns = @JoinColumn(name = "tenant_user_id")
    )
    @Column(name = "permission", nullable = false, length = 120)
    @Builder.Default
    private Set<String> permissions = new LinkedHashSet<>();

    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts", nullable = false)
    @Builder.Default
    private int failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    @Column(name = "timezone", nullable = false, length = 60)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", nullable = false, length = 20)
    @Builder.Default
    private String locale = "pt_BR";

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @PrePersist
    @PreUpdate
    protected void onSave() {
        if (role == null) throw new IllegalStateException("Role is required");
        if (permissions == null) permissions = new LinkedHashSet<>();

        if (username != null) username = username.toLowerCase().trim();
        if (email != null) email = email.toLowerCase().trim();

        // 1) defaults por role (somente se vier vazio)
        if (permissions.isEmpty()) {
            permissions = new LinkedHashSet<>(
                TenantRolePermissions.permissionsFor(role).stream()
                    .map(Enum::name)
                    .toList()
            );
        }

        // 2) normaliza SEMPRE (trim, prefix TEN_, remove duplicadas, bloqueia CP_)
        permissions = new LinkedHashSet<>(PermissionScopeValidator.normalizeTenant(permissions));
    }

    public boolean isAccountNonLocked(LocalDateTime now) {
        return lockedUntil == null || !lockedUntil.isAfter(now);
    }

    public boolean isEnabledForLogin() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    public boolean isEnabledForLogin(LocalDateTime now) {
        return isEnabledForLogin() && isAccountNonLocked(now);
    }

    /**
     * ✅ Clock-aware: agora o tempo vem de fora (AppClock).
     * Chamada típica: user.softDelete(appClock.now(), appClock.epochMillis());
     */
    public void softDelete(LocalDateTime now, long suffixEpochMillis) {
        if (deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        deleted = true;
        deletedAt = now;

        suspendedByAccount = true;
        suspendedByAdmin = true;

        String ts = String.valueOf(suffixEpochMillis);

        renameUsernameForDelete(ts);
        renameEmailForDelete(ts);
    }

    private void renameUsernameForDelete(String ts) {
        String prefix = "deleted_";
        String suffix = "_" + ts;

        String middle = (username == null ? "user" : username)
                .toLowerCase()
                .trim()
                .replaceAll("[^a-z0-9._-]", "_")
                .replaceAll("_{2,}", "_")
                .replaceAll("^_|_$", "");

        if (middle.isBlank()) middle = "user";

        int maxMiddleLen = USERNAME_MAX_LEN - prefix.length() - suffix.length();
        if (maxMiddleLen < 1) maxMiddleLen = 1;

        if (middle.length() > maxMiddleLen) {
            middle = middle.substring(0, maxMiddleLen).replaceAll("_+$", "");
            if (middle.isBlank()) middle = "u";
        }

        username = prefix + middle + suffix;
    }

    private void renameEmailForDelete(String ts) {
        String prefix = "deleted_";
        String suffix = "_" + ts;

        String middle = (email == null ? "deleted" : email).trim();

        int maxMiddleLen = EMAIL_MAX_LEN - prefix.length() - suffix.length();
        if (maxMiddleLen < 1) maxMiddleLen = 1;

        if (middle.length() > maxMiddleLen) {
            middle = middle.substring(0, maxMiddleLen);
        }

        email = prefix + middle + suffix;
    }

    public void restore() {
        if (!deleted) return;

        deleted = false;
        deletedAt = null;

        // ao restaurar: admin deixa de bloquear; account status segue mandando
        suspendedByAdmin = false;
        // não altera suspendedByAccount aqui
    }
}
package brito.com.multitenancy001.tenant.persistence.category;

import brito.com.multitenancy001.tenant.domain.category.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantCategoryRepository extends JpaRepository<Category, Long> {

    // =========
    // Normal (default): NÃO retorna deletados
    // =========

    @Query("select c from Category c where c.deleted = false order by c.name asc")
    List<Category> findNotDeleted();

    @Query("select c from Category c where c.deleted = false and c.active = true order by c.name asc")
    List<Category> findActiveNotDeleted();

    @Query("select c from Category c where c.deleted = false and lower(c.name) = lower(:name)")
    Optional<Category> findNotDeletedByNameIgnoreCase(@Param("name") String name);

    @Query("select c from Category c where c.deleted = false and lower(c.name) like lower(concat('%', :name, '%')) order by c.name asc")
    List<Category> findNotDeletedByNameContainingIgnoreCase(@Param("name") String name);

    // =========
    // Admin: flags (includeDeleted / includeInactive)
    // =========

    @Query("""
           select c from Category c
           where (:includeDeleted = true or c.deleted = false)
             and (:includeInactive = true or c.active = true)
           order by c.name asc
           """)
    List<Category> findWithFlags(@Param("includeDeleted") boolean includeDeleted,
                                 @Param("includeInactive") boolean includeInactive);
}
package brito.com.multitenancy001.tenant.persistence.category;

import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantSubcategoryRepository extends JpaRepository<Subcategory, Long> {

    @Query("select s from Subcategory s join fetch s.category where s.id = :id")
    Optional<Subcategory> findByIdWithCategory(@Param("id") Long id);

    // =========
    // Default: NÃO retorna deletados
    // =========

    @Query("""
           select s from Subcategory s
           where s.deleted = false
           order by s.name asc
           """)
    List<Subcategory> findNotDeleted();

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.active = true
           order by s.name asc
           """)
    List<Subcategory> findActiveNotDeleted();

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.category.id = :categoryId
           order by s.name asc
           """)
    List<Subcategory> findNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.active = true and s.category.id = :categoryId
           order by s.name asc
           """)
    List<Subcategory> findActiveNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
           select s from Subcategory s
           where s.deleted = false
             and s.category.id = :categoryId
             and lower(s.name) = lower(:name)
           """)
    Optional<Subcategory> findNotDeletedByCategoryIdAndNameIgnoreCase(@Param("categoryId") Long categoryId,
                                                                      @Param("name") String name);

    // =========
    // Admin: flags (includeDeleted / includeInactive)
    // =========

    @Query("""
           select s from Subcategory s
           where s.category.id = :categoryId
             and (:includeDeleted = true or s.deleted = false)
             and (:includeInactive = true or s.active = true)
           order by s.name asc
           """)
    List<Subcategory> findByCategoryWithFlags(@Param("categoryId") Long categoryId,
                                              @Param("includeDeleted") boolean includeDeleted,
                                              @Param("includeInactive") boolean includeInactive);
}
package brito.com.multitenancy001.tenant.persistence.product;

import brito.com.multitenancy001.tenant.domain.product.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface TenantProductRepository extends JpaRepository<Product, UUID> {

    // =========================================================
    // ✅ "CATÁLOGO": SOMENTE ATIVOS E NÃO DELETADOS
    // =========================================================

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND LOWER(p.brand) = LOWER(:brand)
        """)
    List<Product> findActiveNotDeletedByBrandIgnoreCase(@Param("brand") String brand);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.category.id = :categoryId
        """)
    List<Product> findActiveNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.subcategory.id = :subcategoryId
        """)
    List<Product> findActiveNotDeletedBySubcategoryId(@Param("subcategoryId") Long subcategoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.category.id = :categoryId
          AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
        """)
    List<Product> findActiveNotDeletedByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
                                                                      @Param("subcategoryId") Long subcategoryId);

    // ✅ seu endpoint /active
    List<Product> findByActiveTrueAndDeletedFalse();

    // =========================================================
    // EXISTENTES (mantidos)
    // =========================================================

    // Se você ainda usa em algum lugar interno:
    List<Product> findByBrandIgnoreCase(String brand);

    List<Product> findByCategory_Id(Long categoryId);

    List<Product> findBySubcategory_Id(Long subcategoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.category.id = :categoryId
          AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
        """)
    List<Product> findByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
                                                      @Param("subcategoryId") Long subcategoryId);

    List<Product> findByNameContainingIgnoreCase(String name);

    Optional<Product> findBySku(String sku);

    List<Product> findByStockQuantityLessThan(Integer quantity);

    List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

    List<Product> findBySupplier_Id(UUID supplierId);

    Page<Product> findByNameContainingIgnoreCase(String name, Pageable pageable);

    @Query("""
        SELECT p FROM Product p WHERE
            (:name IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :name, '%'))) AND
            (:minPrice IS NULL OR p.price >= :minPrice) AND
            (:maxPrice IS NULL OR p.price <= :maxPrice) AND
            (:minStock IS NULL OR p.stockQuantity >= :minStock) AND
            (:maxStock IS NULL OR p.stockQuantity <= :maxStock)
        """)
    List<Product> searchProducts(@Param("name") String name,
                                 @Param("minPrice") BigDecimal minPrice,
                                 @Param("maxPrice") BigDecimal maxPrice,
                                 @Param("minStock") Integer minStock,
                                 @Param("maxStock") Integer maxStock);

    List<Product> findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(
            String name,
            BigDecimal minPrice,
            BigDecimal maxPrice,
            Integer minStock,
            Integer maxStock
    );

    @Query("SELECT COUNT(p) FROM Product p WHERE p.stockQuantity <= :threshold")
    Long countLowStock(@Param("threshold") Integer threshold);

    @Query("SELECT SUM(p.stockQuantity * p.price) FROM Product p")
    BigDecimal calculateTotalInventoryValue();

    @Query("SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id")
    List<Object[]> countProductsBySupplier();
    
    @Query("""
    	    SELECT p FROM Product p
    	    WHERE (:includeDeleted = true OR p.deleted = false)
    	      AND (:includeInactive = true OR p.active = true)
    	      AND p.category.id = :categoryId
    	    """)
    	List<Product> findByCategoryWithFlags(@Param("categoryId") Long categoryId,
    	                                     @Param("includeDeleted") boolean includeDeleted,
    	                                     @Param("includeInactive") boolean includeInactive);

}
package brito.com.multitenancy001.tenant.persistence.supplier;

import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface TenantSupplierRepository extends JpaRepository<Supplier, UUID> {

    // =========================
    // FINDs "crus" (podem incluir deletados) - mantenho, mas no service vamos usar os "ativos/notDeleted"
    // =========================
    Optional<Supplier> findByDocument(String document);

    List<Supplier> findByNameContainingIgnoreCase(String name);

    List<Supplier> findByEmail(String email);

    // =========================
    // RECOMENDADO: queries usadas pelos endpoints (não-deletados)
    // =========================

    @Query("SELECT s FROM Supplier s WHERE s.deleted = false ORDER BY s.name ASC")
    List<Supplier> findNotDeleted();

    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND LOWER(s.name) LIKE LOWER(CONCAT('%', :name, '%')) ORDER BY s.name ASC")
    List<Supplier> findNotDeletedByNameContainingIgnoreCase(@Param("name") String name);

    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND s.email = :email ORDER BY s.name ASC")
    List<Supplier> findNotDeletedByEmail(@Param("email") String email);

    @Query("""
           SELECT s FROM Supplier s
           WHERE s.deleted = false
             AND s.document IS NOT NULL
             AND TRIM(s.document) <> ''
             AND LOWER(s.document) = LOWER(:document)
           """)
    Optional<Supplier> findNotDeletedByDocumentIgnoreCase(@Param("document") String document);

    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND s.active = true ORDER BY s.name ASC")
    List<Supplier> findActiveNotDeleted();
}
package brito.com.multitenancy001.tenant.persistence.user;

import jakarta.transaction.Transactional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.user.TenantUser;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantUserRepository extends JpaRepository<TenantUser, Long> {
	
	
	 // ✅ Suspende por CONTA (sem mexer na suspensão por admin)
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = true
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int suspendAllByAccount(@Param("accountId") Long accountId);

    // ✅ Reativa por CONTA (sem mexer na suspensão por admin)
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = false
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int unsuspendAllByAccount(@Param("accountId") Long accountId);

  
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAdmin = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAdmin(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

  

	
    
    Optional<TenantUser> findByPasswordResetTokenAndAccountId(String passwordResetToken, Long accountId);

    Optional<TenantUser> findByUsernameAndDeletedFalse(String username);

    Optional<TenantUser> findByEmailAndAccountId(String email, Long accountId);

    Optional<TenantUser> findByEmailAndAccountIdAndDeletedFalse(String email, Long accountId);

    Optional<TenantUser> findByUsernameAndAccountId(String username, Long accountId);

    // (se você quiser filtrar deletados no login)
    Optional<TenantUser> findByUsernameAndAccountIdAndDeletedFalse(String username, Long accountId);

    boolean existsByUsernameAndAccountId(String username, Long accountId);

    boolean existsByEmailAndAccountId(String email, Long accountId);

    boolean existsByEmailAndAccountIdAndIdNot(String email, Long accountId, Long id);

    // ==========================
    // Listagens (Tenant)
    // ==========================
    List<TenantUser> findByAccountId(Long accountId);

    List<TenantUser> findByAccountIdAndDeletedFalse(Long accountId);

    // CORREÇÃO: Removido o método que usa "ActiveTrue" pois não existe na entidade
    // List<TenantUser> findByAccountIdAndActiveTrueAndDeletedFalse(Long accountId);
    
    // NOVO: Método para buscar usuários ativos usando lógica customizada
    @Query("SELECT u FROM TenantUser u WHERE u.accountId = :accountId " +
           "AND u.deleted = false " +
           "AND u.suspendedByAccount = false " +
           "AND u.suspendedByAdmin = false")
    List<TenantUser> findActiveUsersByAccount(@Param("accountId") Long accountId);

    // ==========================
    // Contagem / Limites
    // ==========================
    // CORREÇÃO: Removido método que não funciona
    // long countByAccountIdAndActiveTrueAndDeletedFalse(Long accountId);
    
    // NOVO: Contagem de usuários ativos
    @Query("SELECT COUNT(u) FROM TenantUser u WHERE u.accountId = :accountId " +
           "AND u.deleted = false " +
           "AND u.suspendedByAccount = false " +
           "AND u.suspendedByAdmin = false")
    long countActiveUsersByAccount(@Param("accountId") Long accountId);

    // ==========================
    // Busca por ID com scoping de conta
    // ==========================
    Optional<TenantUser> findByIdAndAccountId(Long id, Long accountId);

    // (se quiser reforçar deletado false)
    Optional<TenantUser> findByIdAndAccountIdAndDeletedFalse(Long id, Long accountId);
}package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.PermissionAuthority;

public enum TenantPermission implements PermissionAuthority {

    TEN_USER_READ,
    TEN_USER_CREATE,
    TEN_USER_UPDATE,
    TEN_USER_SUSPEND,
    TEN_USER_RESTORE,
    TEN_USER_DELETE,

    TEN_ROLE_TRANSFER, 

    TEN_PRODUCT_READ,
    TEN_PRODUCT_WRITE,

    TEN_CATEGORY_READ,
    TEN_CATEGORY_WRITE,

    TEN_SUPPLIER_READ,
    TEN_SUPPLIER_WRITE,

    TEN_SALE_READ,
    TEN_SALE_WRITE,
    TEN_SALE_ISSUES_READ,

    TEN_REPORT_SALES_READ,

    TEN_BILLING_READ,
    TEN_BILLING_WRITE,

    TEN_SETTINGS_READ,
    TEN_SETTINGS_WRITE,
	
	TEN_INVENTORY_READ,
	TEN_INVENTORY_WRITE;

    @Override
    public String asAuthority() {
        return name();
    }
}
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum TenantRole implements RoleAuthority {

    TENANT_OWNER,
    TENANT_ADMIN,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isTenantOwner() {
        return this == TENANT_OWNER;
    }
}
package brito.com.multitenancy001.tenant.security;

import java.util.EnumSet;
import java.util.Set;

public final class TenantRolePermissions {

    private TenantRolePermissions() {}

    public static Set<TenantPermission> permissionsFor(TenantRole role) {
        if (role == null) return Set.of();

        return switch (role) {
            case TENANT_OWNER -> EnumSet.allOf(TenantPermission.class);

            // ADMIN = “administra tudo” do tenant (conforme seu set de TenantPermission)
            case TENANT_ADMIN -> EnumSet.of(
                    // Users
                    TenantPermission.TEN_USER_READ,
                    TenantPermission.TEN_USER_CREATE,
                    TenantPermission.TEN_USER_UPDATE,
                    TenantPermission.TEN_USER_SUSPEND,
                    TenantPermission.TEN_USER_RESTORE,
                    TenantPermission.TEN_USER_DELETE,

                    // Transfer ownership/admin
                    TenantPermission.TEN_ROLE_TRANSFER,

                    // Products + Inventory
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_PRODUCT_WRITE,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_INVENTORY_WRITE,

                    // Catalog
                    TenantPermission.TEN_CATEGORY_READ,
                    TenantPermission.TEN_CATEGORY_WRITE,
                    TenantPermission.TEN_SUPPLIER_READ,
                    TenantPermission.TEN_SUPPLIER_WRITE,

                    // Sales + Reports
                    TenantPermission.TEN_SALE_READ,
                    TenantPermission.TEN_SALE_WRITE,
                    TenantPermission.TEN_SALE_ISSUES_READ,
                    TenantPermission.TEN_REPORT_SALES_READ,

                    // Billing + Settings
                    TenantPermission.TEN_BILLING_READ,
                    TenantPermission.TEN_BILLING_WRITE,
                    TenantPermission.TEN_SETTINGS_READ,
                    TenantPermission.TEN_SETTINGS_WRITE
            );

            case TENANT_PRODUCT_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_PRODUCT_WRITE,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_INVENTORY_WRITE
            );

            case TENANT_SALES_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_SALE_READ,
                    TenantPermission.TEN_SALE_WRITE,
                    TenantPermission.TEN_SALE_ISSUES_READ,
                    TenantPermission.TEN_REPORT_SALES_READ
            );

            case TENANT_BILLING_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_BILLING_READ,
                    TenantPermission.TEN_BILLING_WRITE
            );

            case TENANT_READ_ONLY -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_USER_READ
            );

            // OPERATOR “operacional” (não administra usuários/config/billing)
            case TENANT_OPERATOR -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_INVENTORY_WRITE,
                    TenantPermission.TEN_SALE_READ
            );
        };
    }
}
-- V1__create_table_accounts.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS accounts (
    id BIGSERIAL PRIMARY KEY,

    account_type   VARCHAR(20) NOT NULL DEFAULT 'TENANT',
    account_origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    -- Core identity (neutro)
    display_name VARCHAR(150) NOT NULL,
    legal_name   VARCHAR(200),
    legal_entity_type VARCHAR(20) NOT NULL DEFAULT 'COMPANY', -- INDIVIDUAL | COMPANY

    schema_name VARCHAR(100) NOT NULL,
    slug        VARCHAR(80)  NOT NULL,

    status            VARCHAR(50) NOT NULL DEFAULT 'FREE_TRIAL',
    subscription_plan VARCHAR(50) NOT NULL DEFAULT 'FREE',

    -- Emails (neutro)
    login_email   VARCHAR(150) NOT NULL,
    billing_email VARCHAR(150),

    -- Documento fiscal/identificador legal (neutro)
    tax_id_type      VARCHAR(20),
    tax_id_number    VARCHAR(40),
    tax_country_code VARCHAR(2)  NOT NULL DEFAULT 'BR',

    -- Contato / Endereço (neutro)
    phone   VARCHAR(20),
    address VARCHAR(500),
    city    VARCHAR(100),
    state   VARCHAR(50),
    country VARCHAR(60) NOT NULL DEFAULT 'Brasil',

    -- Preferências
    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale   VARCHAR(20) NOT NULL DEFAULT 'pt_BR',
    currency VARCHAR(10) NOT NULL DEFAULT 'BRL',

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,

    trial_end_date   TIMESTAMP,
    payment_due_date TIMESTAMP,
    next_billing_date TIMESTAMP,

    settings_json TEXT,
    metadata_json TEXT,

    deleted   BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP
);

-- =========================
-- CHECK constraints (enums)
-- =========================
ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_account_type
    CHECK (account_type IN ('TENANT', 'PLATFORM'));

ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_account_origin
    CHECK (account_origin IN ('BUILT_IN', 'ADMIN', 'API'));

ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_subscription_plan
    CHECK (subscription_plan IN ('FREE', 'PRO', 'ENTERPRISE', 'BUILT_IN_PLAN'));

ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_legal_entity_type
    CHECK (legal_entity_type IN ('INDIVIDUAL', 'COMPANY'));

-- tax_id_type: hoje você usa CPF/CNPJ, mas deixei neutro para crescer.
-- se quiser travar estrito em CPF/CNPJ por enquanto, use a versão "estreita" abaixo.
ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_tax_id_type
    CHECK (tax_id_type IS NULL OR tax_id_type IN ('CPF', 'CNPJ'));

-- Coerência: ou preenche ambos ou nenhum
ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_tax_id_pair
    CHECK (
        (tax_id_type IS NULL AND tax_id_number IS NULL)
        OR
        (tax_id_type IS NOT NULL AND tax_id_number IS NOT NULL)
    );

-- =========================
-- Índices / Uniques
-- =========================

-- Só 1 PLATFORM no banco (seu requisito)
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_single_system
ON accounts (account_type)
WHERE account_type = 'PLATFORM';

-- Unicidade de documento por conta ativa (neutro)
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_tax_id_active
ON accounts (tax_country_code, tax_id_type, tax_id_number)
WHERE deleted = false AND tax_id_type IS NOT NULL AND tax_id_number IS NOT NULL;

-- Unicidade de email principal por conta ativa (sua regra atual)
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_login_email_active
ON accounts (login_email)
WHERE deleted = false;

-- schema e slug globais
CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_schema_name
ON accounts (schema_name);

CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_slug
ON accounts (slug);

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_billing_email_active
ON accounts (billing_email)
WHERE deleted = false AND billing_email IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_accounts_display_name
ON accounts (display_name);



-- V2__create_table_account_entitlements.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS account_entitlements (
  account_id BIGINT PRIMARY KEY REFERENCES accounts(id) ON DELETE CASCADE,
  max_users INT NOT NULL,
  max_products INT NOT NULL,
  max_storage_mb INT NOT NULL
);

-- (opcional) coerência básica
ALTER TABLE account_entitlements
    ADD CONSTRAINT chk_entitlements_positive
    CHECK (max_users > 0 AND max_products > 0 AND max_storage_mb > 0);
-- V3__create_table_controlplane_users.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_users (
    id BIGSERIAL PRIMARY KEY,

    name VARCHAR(100) NOT NULL,

    username VARCHAR(100) NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(150) NOT NULL,

    role VARCHAR(50) NOT NULL,

    account_id BIGINT NOT NULL,

    -- ✅ origem do usuário (substitui is_built_in_user)
    user_origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,

    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(20) NOT NULL DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP,
    deleted BOOLEAN NOT NULL DEFAULT false,

    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    CONSTRAINT fk_controlplane_users_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE,

    CONSTRAINT chk_cp_user_origin
        CHECK (user_origin IN ('BUILT_IN', 'ADMIN', 'API')),

    CONSTRAINT chk_cp_reserved_usernames_block
        CHECK (
            NOT (
                lower(username) IN ('superadmin','billing','support','operator')
                AND user_origin <> 'BUILT_IN'
            )
        )
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_cp_users_username_active
ON controlplane_users (account_id, username)
WHERE deleted = false;

CREATE UNIQUE INDEX IF NOT EXISTS ux_cp_users_email_active
ON controlplane_users (account_id, email)
WHERE deleted = false;
-- V4__insert_controlplane_account.sql
SET search_path TO public;

INSERT INTO accounts (
    account_type,
    account_origin,
    display_name,
    legal_name,
    legal_entity_type,
    schema_name,
    slug,
    status,
    subscription_plan,
    tax_id_type,
    tax_id_number,
    tax_country_code,
    login_email,
    billing_email,
    country,
    timezone,
    locale,
    currency,
    deleted
)
SELECT
    'PLATFORM',
    'BUILT_IN',
    'Control Plane',
    NULL,
    'COMPANY',
    'public',
    'controlplane',
    'ACTIVE',
    'BUILT_IN_PLAN',
    'CNPJ',
    '00000000000000',
    'BR',
    'admin@controlplane.com',
    NULL,
    'Brasil',
    'America/Sao_Paulo',
    'pt_BR',
    'BRL',
    false
WHERE NOT EXISTS (
    SELECT 1 FROM accounts WHERE slug = 'controlplane'
);
-- V5__insert_controlplane_users.sql
SET search_path TO public;

-- Cria 4 usuários padrão do Control Plane no account PLATFORM (slug controlplane)
-- Se já existirem (ativos) com o mesmo username/email, não duplica.

WITH cp_account AS (
    SELECT id
    FROM accounts
    WHERE slug = 'controlplane'
    LIMIT 1
)
INSERT INTO controlplane_users (
    name,
    username,
    email,
    password,
    role,
    account_id,
    user_origin,              -- ✅ novo
    suspended_by_account,
    suspended_by_admin,
    must_change_password
)
SELECT
    u.name,
    u.username,
    u.email,
    u.password,
    u.role,
    a.id,
    'BUILT_IN',               -- ✅ sempre BUILT_IN para esses 4
    false,
    false,
    u.must_change_password
FROM cp_account a
JOIN (
    VALUES
      -- OWNER (superadmin)
      ('ControlPlane Super Admin', 'superadmin', 'admin@controlplane.com',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OWNER', false),

      -- BILLING MANAGER
      ('ControlPlane Billing Manager', 'billing', 'billing@controlplane.com',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_BILLING_MANAGER', true),

      -- SUPPORT
      ('ControlPlane Support', 'support', 'support@controlplane.com',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_SUPPORT', true),

      -- OPERATOR
      ('ControlPlane Operator', 'operator', 'operator@controlplane.com',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OPERATOR', true)

) AS u(name, username, email, password, role, must_change_password)
ON TRUE
WHERE NOT EXISTS (
    SELECT 1
    FROM controlplane_users existing
    WHERE existing.account_id = a.id
      AND existing.deleted = false
      AND (existing.username = u.username OR existing.email = u.email)
);
-- V6__create_table_controlplane_user_permissions.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_user_permissions (
    user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (user_id, permission),

    CONSTRAINT fk_cp_user_permissions_user
        FOREIGN KEY (user_id)
        REFERENCES controlplane_users(id)
        ON DELETE CASCADE
);
-- V7__create_table_payments.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS payments (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,

    payment_date TIMESTAMP NOT NULL,
    valid_until TIMESTAMP,

    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',

    transaction_id VARCHAR(100) UNIQUE,
    payment_method VARCHAR(50),
    payment_gateway VARCHAR(50),
    currency VARCHAR(3) NOT NULL DEFAULT 'BRL',

    description VARCHAR(500),
    metadata_json TEXT,

    invoice_url TEXT,
    receipt_url TEXT,

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,

    refunded_at TIMESTAMP,
    refund_amount NUMERIC(10,2),
    refund_reason VARCHAR(500),

    CONSTRAINT fk_payments_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_payment_account ON payments(account_id);
CREATE INDEX IF NOT EXISTS idx_payment_status ON payments(status);

CREATE INDEX IF NOT EXISTS idx_payment_date ON payments(payment_date);
-- V1__create_table_tenant_users.sql

CREATE TABLE IF NOT EXISTS tenant_users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    account_id BIGINT NOT NULL,

    name VARCHAR(100) NOT NULL,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(150) NOT NULL,
    password VARCHAR(255) NOT NULL,

    role VARCHAR(50) NOT NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(20) NOT NULL DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,

    deleted BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP,

    CONSTRAINT uk_tenant_users_username_account UNIQUE (username, account_id),
    CONSTRAINT uk_tenant_users_email_account UNIQUE (email, account_id)
);

CREATE INDEX IF NOT EXISTS idx_tenant_users_account_id ON tenant_users(account_id);

CREATE INDEX IF NOT EXISTS idx_tenant_users_deleted ON tenant_users(deleted) WHERE deleted = false;

-- V2__create_table_tenant_users_permissions.sql
CREATE TABLE IF NOT EXISTS tenant_user_permissions (
    tenant_user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (tenant_user_id, permission),

    CONSTRAINT fk_tenant_user_permissions_user
        FOREIGN KEY (tenant_user_id)
        REFERENCES tenant_users(id)
        ON DELETE CASCADE
);-- V3__create_table_categories.sql

CREATE TABLE IF NOT EXISTS categories (
  id BIGSERIAL PRIMARY KEY,

  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  CONSTRAINT uk_categories_name UNIQUE (name)
);

CREATE INDEX IF NOT EXISTS idx_categories_active  ON categories(active);
CREATE INDEX IF NOT EXISTS idx_categories_deleted ON categories(deleted) WHERE deleted = false;
-- V4__create_table_subcategories.sql

CREATE TABLE IF NOT EXISTS subcategories (
  id BIGSERIAL PRIMARY KEY,

  category_id BIGINT NOT NULL,
  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  CONSTRAINT fk_subcategories_category
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE,

  CONSTRAINT uk_subcategories_name_category UNIQUE (category_id, name)
);


CREATE INDEX IF NOT EXISTS idx_subcategories_active      ON subcategories(active);
CREATE INDEX IF NOT EXISTS idx_subcategories_deleted     ON subcategories(deleted) WHERE deleted = false;
-- V5__create_table_suppliers.sql

-- 1) Habilita função de UUID (Postgres)
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 2) Tabela suppliers com UUID gerado automaticamente
CREATE TABLE IF NOT EXISTS suppliers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  contact_person VARCHAR(100),

  email VARCHAR(150),
  phone VARCHAR(20),
  address TEXT,

  document VARCHAR(20),
  document_type VARCHAR(10),

  website VARCHAR(200),
  payment_terms VARCHAR(100),

  lead_time_days INTEGER,
  rating NUMERIC(3,2),

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  notes TEXT,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP
);

-- 3) document único somente para fornecedores ativos (não deletados) e com documento preenchido
CREATE UNIQUE INDEX IF NOT EXISTS ux_suppliers_document_active
ON suppliers(document)
WHERE document IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_supplier_name    ON suppliers(name);
CREATE INDEX IF NOT EXISTS idx_supplier_email   ON suppliers(email);
CREATE INDEX IF NOT EXISTS idx_supplier_active  ON suppliers(active);
CREATE INDEX IF NOT EXISTS idx_supplier_deleted ON suppliers(deleted) WHERE deleted = false;
-- V6__create_table_products.sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  description TEXT,

  sku VARCHAR(100) NOT NULL,
  price NUMERIC(10,2) NOT NULL,

  stock_quantity INT NOT NULL DEFAULT 0,
  min_stock INT,
  max_stock INT,

  cost_price NUMERIC(10,2),
  profit_margin NUMERIC(5,2),

  category_id BIGINT NOT NULL,
  subcategory_id BIGINT NULL,

  brand VARCHAR(100),
  weight_kg NUMERIC(8,3),
  dimensions VARCHAR(50),
  barcode VARCHAR(50),

  active BOOLEAN NOT NULL DEFAULT true,

  images_json TEXT,
  attributes_json TEXT,

  supplier_id UUID NULL,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  CONSTRAINT fk_products_category
    FOREIGN KEY (category_id) REFERENCES categories(id),

  CONSTRAINT fk_products_subcategory
    FOREIGN KEY (subcategory_id) REFERENCES subcategories(id),

  CONSTRAINT fk_product_supplier
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id),

  CONSTRAINT ck_products_sku_not_blank
    CHECK (length(trim(sku)) > 0)
);

-- ✅ SKU único para produtos não deletados (soft delete)
CREATE UNIQUE INDEX ux_products_sku_not_deleted
ON products (sku)
WHERE deleted = false;

-- IgnoreCase em name/brand (LOWER(..))
CREATE INDEX idx_products_name_lower
ON products (LOWER(name));

CREATE INDEX idx_products_brand_lower
ON products (LOWER(brand));

-- findByActiveTrueAndDeletedFalse()
CREATE INDEX idx_products_active_deleted
ON products (active, deleted);

-- filtros comuns
CREATE INDEX idx_products_supplier_id
ON products (supplier_id);

CREATE INDEX idx_products_category_id
ON products (category_id);

CREATE INDEX idx_products_subcategory_id
ON products (subcategory_id);

-- listagens recentes
CREATE INDEX idx_products_created_at
ON products (created_at);
-- V7__create_table_sales.sql

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS sales (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_date TIMESTAMP NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL,

  customer_name VARCHAR(200),
  customer_document VARCHAR(20),
  customer_email VARCHAR(150),
  customer_phone VARCHAR(20),

  status VARCHAR(20) NOT NULL,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_sales_sale_date ON sales(sale_date);
CREATE INDEX IF NOT EXISTS idx_sales_status ON sales(status);
-- V8__create_table_sales_items.sql

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS sale_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_id UUID NOT NULL,
  product_id UUID,
  product_name VARCHAR(255) NOT NULL,

  quantity NUMERIC(12,3) NOT NULL,
  unit_price NUMERIC(12,2) NOT NULL,
  total_price NUMERIC(12,2) NOT NULL,

  CONSTRAINT fk_sale_items_sale
    FOREIGN KEY (sale_id) REFERENCES sales(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_sale_items_sale_id ON sale_items(sale_id);
CREATE INDEX IF NOT EXISTS idx_sale_items_product_id ON sale_items(product_id);
package brito.com.multitenancy001;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Multitenancy001ApplicationTests {

	@Test
	void contextLoads() {
	}

}
