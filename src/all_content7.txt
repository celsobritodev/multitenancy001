package brito.com.multitenancy001.controlplane.api.controller.accounts;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/accounts")
@PreAuthorize("hasRole('SUPER_ADMIN')")
@RequiredArgsConstructor
@Slf4j
public class AccountAdminController {

	private final AccountLifecycleService accountLifecycleService;
	

	@GetMapping("/{id}/users")
	public ResponseEntity<List<AccountUserSummaryResponse>> listUsersByAccount(@PathVariable Long id) {
		log.info("Listando Usu√°rios por conta");
		return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, false));
	}

	@GetMapping("/{id}/users/active")
	public ResponseEntity<List<AccountUserSummaryResponse>> listActiveUsersByAccount(@PathVariable Long id) {
		return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, true));
	}

	@PatchMapping("/{id}/status")
	public ResponseEntity<AccountStatusChangeResponse> changeStatusAccount(
	        @PathVariable Long id,
	        @Valid @RequestBody AccountStatusChangeRequest req) {
	    return ResponseEntity.ok(accountLifecycleService.changeAccountStatus(id, req));
	}

	@GetMapping
	public ResponseEntity<List<AccountResponse>> listAllAccounts() {
		log.info("Listando todas as contas");
		return ResponseEntity.ok(accountLifecycleService.listAllAccounts());
	}

	@GetMapping("/{id}")
	public ResponseEntity<AccountResponse> getAccountById(@PathVariable Long id) {
		return ResponseEntity.ok(accountLifecycleService.getAccountByIdWithAdmin(id));
	}

	@GetMapping("/{id}/details")
	public ResponseEntity<AccountAdminDetailsResponse> getAccountByIdDetails(@PathVariable Long id) {
		return ResponseEntity.ok(accountLifecycleService.getAccountAdminDetails(id));
	}

	@DeleteMapping("/{id}")
	public ResponseEntity<Void> softDeleteAccount(@PathVariable Long id) {
		accountLifecycleService.softDeleteAccount(id);
		return ResponseEntity.noContent().build();
	}

	@PostMapping("/{id}/restore")
	public ResponseEntity<Void> restoreAccount(@PathVariable Long id) {
		accountLifecycleService.restoreAccount(id);
		return ResponseEntity.noContent().build();
	}
}
package brito.com.multitenancy001.controlplane.api.controller.accounts;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/signup")
@RequiredArgsConstructor
public class AccountSignupController {
    
    private final AccountLifecycleService accountLifecycleService;

    @PostMapping
    public ResponseEntity<AccountResponse> signup(
            @Valid @RequestBody SignupRequest request) {
        AccountResponse response = accountLifecycleService.createAccount( request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}package brito.com.multitenancy001.controlplane.api.controller.auth;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.application.AdminAuthService;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/auth")
@RequiredArgsConstructor
public class AdminAuthController {

	private final AdminAuthService adminAuthService;

	@PostMapping("/login")
	public ResponseEntity<JwtResponse> loginSuperAdmin(@Valid @RequestBody ControlPlaneAdminLoginRequest request) {

		JwtResponse response = adminAuthService.loginSuperAdmin(request);
		return ResponseEntity.ok(response);
	}
}
package brito.com.multitenancy001.controlplane.api.controller.users;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.application.user.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/controlplane-users")
@RequiredArgsConstructor
public class ControlPlaneUserAdminController {

    private final ControlPlaneUserService controlPlaneUserService;

    @PostMapping
    @PreAuthorize("hasAnyRole('SUPER_ADMIN','SUPPORT')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> createControlPlaneUser(@Valid @RequestBody ControlPlaneUserCreateRequest request) {
    	ControlPlaneUserDetailsResponse response = controlPlaneUserService.createControlPlaneUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('SUPER_ADMIN','SUPPORT','STAFF')")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listControlPlaneUsers() {
        return ResponseEntity.ok(controlPlaneUserService.listControlPlaneUsers());
    }

    @GetMapping("/{userId}")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN','SUPPORT','STAFF')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getControlPlaneUser(userId));
    }

    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN','SUPPORT')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUserStatus(
            @PathVariable Long userId,
            @RequestParam boolean active) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUserStatus(userId, active));
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<Void> deleteControlPlaneUser(@PathVariable Long userId) {
        controlPlaneUserService.softDeleteControlPlaneUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> restoreControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.restoreControlPlaneUser(userId));
    }
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;
import java.time.LocalDateTime;

public record AccountAdminDetailsResponse(

    // Identifica√ß√£o
    Long id,
    String name,
    String slug,
    String schemaName,
    String status,

    // Dados legais (sempre em conjunto)
    DocumentType companyDocType,
    String companyDocNumber,

    // Datas
    LocalDateTime createdAt,
    LocalDateTime trialEndDate,
    LocalDateTime paymentDueDate,
    LocalDateTime deletedAt,

    // Flags calculadas
    boolean inTrial,
    boolean trialExpired,
    long trialDaysRemaining,

    // Admin da conta
    ControlPlaneAdminUserSummaryResponse admin,

    // Indicadores
    long totalControlPlaneUsers,
    boolean active
) {

   
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import java.time.LocalDateTime;

public record AccountResponse(
    Long id,
    String name,
    String slug,
    String schemaName,
    String status,
    LocalDateTime createdAt,
    LocalDateTime trialEndDate,
    ControlPlaneAdminUserSummaryResponse admin,
    boolean systemAccount
) {
    
   
  
    
  
}package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public record AccountStatusChangeRequest(
		@NotNull(message = "status √© obrigat√≥rio")
        AccountStatus status,
        @Size(max = 255, message = "reason deve ter no m√°ximo 255 caracteres")
        String reason
) {    }
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import java.time.LocalDateTime;

public record AccountStatusChangeResponse(
        Long id,
        String status,
        String previousStatus,
        LocalDateTime effectiveAt,
        String tenantSchema,
        SideEffects sideEffects
) {
    public record SideEffects(
            boolean tenantUsersUpdated,
            String action,     // "SUSPEND_BY_ACCOUNT" | "UNSUSPEND_BY_ACCOUNT" | "CANCELLED" | "NONE"
            int tenantUsersCount
    ) {}
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

public record AccountUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}
package brito.com.multitenancy001.controlplane.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record ControlPlaneAdminLoginRequest(
	    @NotBlank String username,
	    @NotBlank String password
	) {}package brito.com.multitenancy001.controlplane.api.dto.billing;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

import java.math.BigDecimal;

public record PaymentRequest(
    @NotNull Long accountId,
    @NotNull @Positive BigDecimal amount,
    @NotNull String paymentMethod,
    String paymentGateway,
    String description,
    String cardToken
) {}package brito.com.multitenancy001.controlplane.api.dto.billing;



import java.math.BigDecimal;
import java.time.LocalDateTime;

public record PaymentResponse(
	    Long id,
	    Long accountId,
	    BigDecimal amount,
	    LocalDateTime paymentDate,
	    LocalDateTime validUntil,
	    String status,
	    String transactionId,
	    String paymentMethod,
	    String paymentGateway,
	    String description,
	    LocalDateTime createdAt,
	    LocalDateTime updatedAt
	) {}
// src/main/java/brito/com/multitenancy001/dtos/SignupRequest.java
package brito.com.multitenancy001.controlplane.api.dto.signup;

import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record SignupRequest(

    @NotBlank(message = "Nome da empresa √© obrigat√≥rio")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    String name,

    @NotBlank(message = "Email da empresa √© obrigat√≥rio")
    @Email(message = "Email inv√°lido")
    String companyEmail,

    @NotNull(message = "Tipo de documento √© obrigat√≥rio (CPF ou CNPJ)")
    DocumentType companyDocType,

    @NotBlank(message = "N√∫mero do documento √© obrigat√≥rio")
    String companyDocNumber,

    @NotBlank(message = "Senha √© obrigat√≥ria")
    @Pattern(
        regexp = ValidationPatterns.PASSWORD_PATTERN,
        message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas e n√∫meros"
    )
    String password,

    @NotBlank(message = "Confirma√ß√£o de senha √© obrigat√≥ria")
    String confirmPassword
) 
	{
		   @AssertTrue(message = "As senhas n√£o coincidem")
		   public boolean isPasswordMatching() {
		      if (password == null || confirmPassword == null) return true; // deixa @NotBlank fazer o trabalho
		      return password.equals(confirmPassword);
		   }
}
package brito.com.multitenancy001.controlplane.api.dto.users;

public record ControlPlaneAdminUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {
   
}
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.List;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;

@Builder
public record ControlPlaneUserCreateRequest(
    
    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String name,
    
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, 
             message = "Username inv√°lido. Use apenas letras, n√∫meros, . e _")
    @Size(min = 3, max = 50, message = "Username deve ter entre 3 e 50 caracteres")
    String username,
    
    @NotBlank(message = "Email √© obrigat√≥rio")
    @Email(message = "Email inv√°lido")
    @Size(max = 150, message = "Email n√£o pode exceder 150 caracteres")
    String email,
    
    @NotBlank(message = "Senha √© obrigat√≥ria")
    @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, 
             message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas, n√∫meros e caracteres especiais")
    String password,
    
    @NotBlank(message = "Role √© obrigat√≥ria")
    @Pattern(regexp = "TENANT_ADMIN|MANAGER|VIEWER|USER", message = "Role inv√°lida")
    String role,
    
    List<String> permissions,
    
    // üîπ CAMPOS NOVOS para UserTenant
    @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, 
             message = "Telefone inv√°lido")
    @Size(max = 20, message = "Telefone n√£o pode exceder 20 caracteres")
    String phone,
    
    @Size(max = 500, message = "URL do avatar n√£o pode exceder 500 caracteres")
    String avatarUrl
    
) {
    
    public ControlPlaneUserCreateRequest {
        if (phone != null) {
            phone = phone.trim();
        }
        if (avatarUrl != null) {
            avatarUrl = avatarUrl.trim();
        }
    }
}package brito.com.multitenancy001.controlplane.api.dto.users;



import java.time.LocalDateTime;
import java.util.List;

public record ControlPlaneUserDetailsResponse(
    Long id,
    String username,
    String name,
    String email,
    String role,
    boolean suspendedByAccount,
    boolean suspendedByAdmin,
    LocalDateTime createdAt,
    LocalDateTime updatedAt,
    Long accountId,
    List<String> permissions
) {
    public ControlPlaneUserDetailsResponse {
        if (permissions == null) {
            permissions = List.of();
        }
    }
}package brito.com.multitenancy001.controlplane.api.mapper;

import java.time.Clock;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

@Component
public class AccountAdminDetailsApiMapper {
	
	private final Clock clock;
	private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;
	


	public AccountAdminDetailsApiMapper(Clock clock, ControlPlaneUserApiMapper controlPlaneUserApiMapper) {
	    this.clock = clock;
	    this.controlPlaneUserApiMapper = controlPlaneUserApiMapper;
	}


   public AccountAdminDetailsResponse toResponse(Account account, ControlPlaneUser admin, long totalUsers) {
	   LocalDateTime now = LocalDateTime.now(clock);
	   LocalDate today = now.toLocalDate();
	   LocalDate end = account.getTrialEndDate() != null ? account.getTrialEndDate().toLocalDate() : null;  
	   
	   


    boolean inTrial = account.getTrialEndDate() != null && now.isBefore(account.getTrialEndDate());
    boolean trialExpired = account.getTrialEndDate() != null && now.isAfter(account.getTrialEndDate());

    long trialDaysRemaining = 0;
    if (inTrial) {
        trialDaysRemaining = ChronoUnit.DAYS.between(today, end);
    }

    return new AccountAdminDetailsResponse(
        account.getId(),
        account.getName(),
        account.getSlug(),
        account.getSchemaName(),
        account.getStatus().name(),

        account.getCompanyDocType(),
        account.getCompanyDocNumber(),

        account.getCreatedAt(),
        account.getTrialEndDate(),
        account.getPaymentDueDate(),
        account.getDeletedAt(),

        inTrial,
        trialExpired,
        trialDaysRemaining,

        admin != null ? controlPlaneUserApiMapper.toAdminSummary(admin) : null,



        totalUsers,
        account.isActive()
    );
}

}
package brito.com.multitenancy001.controlplane.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class AccountApiMapper {
	
	private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;
	
	

    public AccountResponse toResponse(Account account) {
        return new AccountResponse(
            account.getId(),
            account.getName(),
            account.getSlug(),
            account.getSchemaName(),
            account.getStatus().name(),
            account.getCreatedAt(),
            account.getTrialEndDate(),
            null,
            account.isSystemAccount()
        );
    }

    public AccountResponse toResponse(Account account, ControlPlaneUser adminUser) {
        ControlPlaneAdminUserSummaryResponse adminResponse =
            adminUser != null ? controlPlaneUserApiMapper.toAdminSummary(adminUser) : null;

        return new AccountResponse(
            account.getId(),
            account.getName(),
            account.getSlug(),
            account.getSchemaName(),
            account.getStatus().name(),
            account.getCreatedAt(),
            account.getTrialEndDate(),
            adminResponse,
            account.isSystemAccount()
        );
    }
}
package brito.com.multitenancy001.controlplane.api.mapper;

import java.time.Clock;
import java.time.LocalDateTime;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

@Component
public class ControlPlaneUserApiMapper {

    private final Clock clock;

    public ControlPlaneUserApiMapper(Clock clock) {
        this.clock = clock;
    }

    public ControlPlaneAdminUserSummaryResponse toAdminSummary(ControlPlaneUser user) {
        LocalDateTime now = LocalDateTime.now(clock);
        boolean enabled = user.isEnabledForLogin(now);

        return new ControlPlaneAdminUserSummaryResponse(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                enabled
        );
    }
}
package brito.com.multitenancy001.controlplane.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;

@Component
public class TenantUserApiMapper {

    public AccountUserSummaryResponse toAccountUserSummary(TenantUser u) {
        boolean enabled = !u.isDeleted()
                && !u.isSuspendedByAccount()
                && !u.isSuspendedByAdmin();

        return new AccountUserSummaryResponse(
                u.getId(),
                u.getUsername(),
                u.getEmail(),
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                enabled
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.mapper.AccountAdminDetailsApiMapper;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.exec.PublicExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountLifecycleService {
	
	private final ControlPlaneUserRepository controlPlaneUserRepository;

	
	private final AccountAdminDetailsApiMapper accountAdminDetailsApiMapper;

	
	private final AccountApiMapper accountApiMapper;
	
	private final PublicExecutor publicExecutor;

	

    private final AccountRepository accountRepository;

    private final AccountOnboardingService onboardingService;
    private final AccountStatusService accountStatusService;
    private final AccountTenantUserService accountTenantUserService;

    /* =========================================================
       1. ONBOARDING / SIGNUP
       ========================================================= */

    public AccountResponse createAccount(SignupRequest request) {
        return onboardingService.createAccount(request);
    }

    /* =========================================================
       2. CONSULTAS (PUBLIC)
       ========================================================= */

    @Transactional(readOnly = true)
    public List<AccountResponse> listAllAccounts() {
        return publicExecutor.run(() ->
            accountRepository.findAllByDeletedFalse()
                .stream()
                .map(accountApiMapper::toResponse)
                .toList()
        );
    }


    @Transactional(readOnly = true)
    public AccountResponse getAccountByIdWithAdmin(Long accountId) {
        return publicExecutor.run(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));
            return accountApiMapper.toResponse(account);
        });
    }


   @Transactional(readOnly = true)
public AccountAdminDetailsResponse getAccountAdminDetails(Long accountId) {
    return publicExecutor.run(() -> {
        Account account = accountRepository.findByIdAndDeletedFalse(accountId)
            .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));

        long totalUsers = controlPlaneUserRepository.countByAccountIdAndDeletedFalse(accountId);

        return accountAdminDetailsApiMapper.toResponse(account, null, totalUsers);
    });
}



    /* =========================================================
       3. STATUS / SOFT DELETE / RESTORE
       ========================================================= */

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        return accountStatusService.changeAccountStatus(accountId, req);
    }

    public void softDeleteAccount(Long accountId) {
        accountStatusService.softDeleteAccount(accountId);
    }

    public void restoreAccount(Long accountId) {
        accountStatusService.restoreAccount(accountId);
    }

    /* =========================================================
       4. TENANT USERS (ADMIN)
       ========================================================= */

    public List<AccountUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyActive) {
        return accountTenantUserService.listTenantUsers(accountId, onlyActive);
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        accountTenantUserService.setUserSuspendedByAdmin(accountId, userId, suspended);
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.time.LocalDateTime;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.exec.PublicExecutor;
import brito.com.multitenancy001.infrastructure.exec.TenantExecutor;
import brito.com.multitenancy001.infrastructure.exec.TxExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;
import brito.com.multitenancy001.tenant.domain.user.TenantRole;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;


@Service
@RequiredArgsConstructor
@Slf4j
public class AccountOnboardingService {
	
	private final AccountApiMapper accountApiMapper;
	
	private final PublicExecutor publicExec;
	private final TxExecutor txExecutor;
	private final TenantExecutor tenantExecutor;

	
	
	private final PublicAccountService publicAccountService;
	  private final TenantSchemaProvisioningService tenantSchemaProvisioningService;
	  private final TenantUserRepository tenantUserRepository;
	  private final PasswordEncoder passwordEncoder;
	   private final AccountRepository accountRepository;
	  

    /* =========================================================
       1. CRIA√á√ÉO DE CONTA 
       ========================================================= */

	   public AccountResponse createAccount(SignupRequest request) {
		    validateSignupRequest(request);

		    Account account = txExecutor.publicTx(() ->
		        publicExec.run(() -> publicAccountService.createAccountFromSignup(request))
		    );

		    tenantSchemaProvisioningService.schemaMigrationService(account.getSchemaName());

		    createTenantAdminInTenant(account, request);

		    log.info("‚úÖ Account criada | accountId={} | schema={} | slug={}",
		            account.getId(), account.getSchemaName(), account.getSlug());

		    return accountApiMapper.toResponse(account);
		}

    
   protected TenantUser createTenantAdminInTenant(Account account, SignupRequest request) {
    return tenantExecutor.run(account.getSchemaName(), () ->
        txExecutor.tenantTx(() -> {
            String username = generateUsernameFromEmail(request.companyEmail());

            boolean usernameExists = tenantUserRepository.existsByUsernameAndAccountId(username, account.getId());
            boolean emailExists = tenantUserRepository.existsByEmailAndAccountId(request.companyEmail(), account.getId());

            if (usernameExists) {
                username = ensureUniqueUsername(username, account.getId());
            }
            if (emailExists) {
                throw new ApiException("EMAIL_ALREADY_EXISTS", "Email j√° cadastrado nesta conta", 409);
            }

            TenantUser u = new TenantUser();
            u.setAccountId(account.getId());
            u.setName("Administrador");
            u.setUsername(username);
            u.setEmail(request.companyEmail());
            u.setPassword(passwordEncoder.encode(request.password()));
            u.setRole(TenantRole.TENANT_ADMIN);
            u.setSuspendedByAccount(false);
            u.setSuspendedByAdmin(false);
            u.setCreatedAt(LocalDateTime.now());
            u.setTimezone("America/Sao_Paulo");
            u.setLocale("pt_BR");

            return tenantUserRepository.save(u);
        })
    );
}

    
    
  
  
   
   
    
    private void validateSignupRequest(SignupRequest request) {
        if (!StringUtils.hasText(request.name())) {
            throw new ApiException("INVALID_COMPANY_NAME", "Nome da empresa √© obrigat√≥rio", 400);
        }
        
        if (!StringUtils.hasText(request.companyEmail())) {
            throw new ApiException("INVALID_EMAIL", "Email √© obrigat√≥rio", 400);
        }

        if (!request.companyEmail().contains("@")) {
            throw new ApiException("INVALID_EMAIL", "Email inv√°lido", 400);
        }

        // ‚úÖ docType + docNumber
        if (request.companyDocType() == null) {
            throw new ApiException("INVALID_COMPANY_DOC_TYPE", "Tipo de documento √© obrigat√≥rio", 400);
        }

        if (!StringUtils.hasText(request.companyDocNumber())) {
            throw new ApiException("INVALID_COMPANY_DOC_NUMBER", "N√∫mero do documento √© obrigat√≥rio", 400);
        }

        if (!StringUtils.hasText(request.password()) || !StringUtils.hasText(request.confirmPassword())) {
            throw new ApiException("INVALID_PASSWORD", "Senha e confirma√ß√£o s√£o obrigat√≥rias", 400);
        }

        if (!request.password().equals(request.confirmPassword())) {
            throw new ApiException("PASSWORD_MISMATCH", "As senhas n√£o coincidem", 400);
        }

        // ‚úÖ ajuste para m√©todo que faz sentido com seus campos atuais
        if (accountRepository.existsByCompanyEmailAndDeletedFalse(request.companyEmail())) {
            throw new ApiException("EMAIL_ALREADY_REGISTERED",
                    "Email j√° cadastrado na plataforma", 409);
        }

        // ‚úÖ recomend√°vel tamb√©m bloquear duplicidade de docNumber
        if (accountRepository.existsByCompanyDocTypeAndCompanyDocNumberAndDeletedFalse(
                request.companyDocType(), request.companyDocNumber()
        )) {
            throw new ApiException("DOC_ALREADY_REGISTERED",
                    "Documento j√° cadastrado na plataforma", 409);
        }
        
    }


    

    private String generateUsernameFromEmail(String email) {
        String base = email.split("@")[0].toLowerCase();
        return base.replaceAll("[^a-z0-9._-]", "_")
                   .replaceAll("_{2,}", "_")
                   .replaceAll("^_|_$", "");
    }
    
    


    private String ensureUniqueUsername(String baseUsername, Long accountId) {
        String username = baseUsername;
        int counter = 1;
        
        while (tenantUserRepository.existsByUsernameAndAccountId(username, accountId)) {
            username = baseUsername + counter;
            counter++;
        }
        
        return username;
    }

    
}

package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountProvisioningService {

    private final AccountRepository accountRepository;
    private final TenantSchemaProvisioningService tenantSchemaProvisionService;

    @Transactional
    public Account createAccount(String name, String companyEmail, String companyDocNumber,
                                      String adminUsername, String adminEmail, String adminPassword) {
    	log.info("provisionando");

        TenantContext.clear(); // PUBLIC

        Account account = createAccountTx(name, companyEmail, companyDocNumber);

        try {
            // TENANT
            TenantContext.bind(account.getSchemaName());
            tenantSchemaProvisionService.schemaMigrationService(account.getSchemaName());

            // cria admin com JPA no schema bindado
            tenantSchemaProvisionService.tenantAdminBootstrapService(account, adminUsername, adminEmail, adminPassword);

            return account;

        } finally {
            TenantContext.clear();
        }
    }

    @Transactional
    protected Account createAccountTx(String name, String companyEmail, String companyDocNumber) {

        int maxAttempts = 5;

        for (int attempt = 1; attempt <= maxAttempts; attempt++) {
            String slug = generateSlug(name);
            String schemaName = generateSchemaName(slug);

            try {
                Account account = Account.builder()
                        .name(name)
                        .slug(slug)
                        .schemaName(schemaName)
                        .companyEmail(companyEmail)
                        .companyDocNumber(companyDocNumber)
                        .status(AccountStatus.FREE_TRIAL)
                        .createdAt(LocalDateTime.now())
                        .trialEndDate(LocalDateTime.now().plusDays(30))
                        .systemAccount(false)
                        .build();

                return accountRepository.save(account);

            } catch (DataIntegrityViolationException e) {
                log.warn("‚ö†Ô∏è collision attempt {}/{} | slug={} schema={}", attempt, maxAttempts, slug, schemaName);
                if (attempt == maxAttempts) {
                    throw new ApiException("ACCOUNT_CREATE_FAILED",
                            "N√£o foi poss√≠vel criar conta (colis√£o). Tente novamente.", 409);
                }
            }
        }

        throw new ApiException("ACCOUNT_CREATE_FAILED", "Falha inesperada ao criar conta.", 500);
    }

    private String generateSlug(String name) {
        String base = name.toLowerCase().replaceAll("[^a-z0-9]+", "-").replaceAll("(^-|-$)", "");
        return base.isBlank() ? "tenant" : base;
    }

    private String generateSchemaName(String slug) {
        return "tenant_" + slug.replace("-", "_") + "_" + UUID.randomUUID().toString().substring(0, 8);
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.exec.PublicExecutor;
import brito.com.multitenancy001.infrastructure.exec.TenantExecutor;
import brito.com.multitenancy001.infrastructure.exec.TxExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountStatusService {

    private final PublicExecutor publicExecutor;
    private final TenantExecutor tenantExecutor;
    private final TxExecutor txExecutor;

    private final AccountRepository accountRepository;
    private final TenantUserRepository tenantUserRepository;

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        return txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));

            AccountStatus previous = account.getStatus(); // ‚úÖ captura antes de alterar

            // ... mantenha aqui suas regras de transi√ß√£o, valida√ß√µes, etc ...

            account.setStatus(req.status());
            if (req.status() == AccountStatus.ACTIVE) {
                account.setDeletedAt(null);
            }
            accountRepository.save(account);

            int affected = 0;
            boolean applied = false;
            String action = "NONE";

            if (req.status() == AccountStatus.SUSPENDED) {
                affected = suspendTenantUsersByAccount(account);
                applied = true;
                action = "SUSPEND_BY_ACCOUNT";
            } else if (req.status() == AccountStatus.ACTIVE) {
                affected = unsuspendTenantUsersByAccount(account);
                applied = true;
                action = "UNSUSPEND_BY_ACCOUNT";
            } else if (req.status() == AccountStatus.CANCELLED) {
                affected = cancelAccount(account);
                applied = true;
                action = "CANCELLED";
            }

            return buildStatusChangeResponse(account, previous, applied, action, affected);
        }));
    }

    private int cancelAccount(Account account) {
        // 1) PUBLIC (REQUIRES_NEW)
        txExecutor.publicRequiresNew(() -> publicExecutor.run(() -> {
            account.setDeletedAt(LocalDateTime.now());
            accountRepository.save(account);
            return null;
        }));

        // 2) TENANT (REQUIRES_NEW), best-effort (retorna 0 se schema/tabela n√£o existir)
        return tenantExecutor.runIfReady(
            account.getSchemaName(),
            "users_tenant",
            () -> txExecutor.tenantRequiresNew(() -> {
                List<TenantUser> users = tenantUserRepository.findByAccountId(account.getId());
                users.forEach(TenantUser::softDelete);
                tenantUserRepository.saveAll(users);
                return users.size();
            }),
            0
        );
    }

    protected int suspendTenantUsersByAccount(Account account) {
        return tenantExecutor.runIfReady(
            account.getSchemaName(),
            "users_tenant",
            () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.suspendAllByAccount(account.getId())),
            0
        );
    }

    protected int unsuspendTenantUsersByAccount(Account account) {
        return tenantExecutor.runIfReady(
            account.getSchemaName(),
            "users_tenant",
            () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.unsuspendAllByAccount(account.getId())),
            0
        );
    }

    public void softDeleteAccount(Long accountId) {
        txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isSystemAccount()) {
                throw new ApiException("SYSTEM_ACCOUNT_PROTECTED",
                        "N√£o √© permitido excluir contas do sistema", 403);
            }

            account.softDelete();
            accountRepository.save(account);

            softDeleteTenantUsers(accountId);

            return null;
        }));
    }

    public void restoreAccount(Long accountId) {
        txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isSystemAccount() && account.isDeleted()) {
                throw new ApiException("SYSTEM_ACCOUNT_PROTECTED",
                        "Contas do sistema n√£o podem ser restauradas via este endpoint", 403);
            }

            account.restore();
            accountRepository.save(account);

            restoreTenantUsers(accountId);

            return null;
        }));
    }

    private Account getAccountByIdRaw(Long accountId) {
        return accountRepository.findById(accountId)
            .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));
    }

    private void softDeleteTenantUsers(Long accountId) {
        Account account = txExecutor.publicReadOnlyTx(() -> publicExecutor.run(() -> getAccountByIdRaw(accountId)));

        tenantExecutor.runIfReady(account.getSchemaName(), "users_tenant", () -> {
            txExecutor.tenantRequiresNew(() -> {
                List<TenantUser> users = tenantUserRepository.findByAccountId(account.getId());
                users.forEach(u -> { if (!u.isDeleted()) u.softDelete(); });
                tenantUserRepository.saveAll(users);
                return null;
            });
            return null;
        }, null);
    }

    private void restoreTenantUsers(Long accountId) {
        Account account = txExecutor.publicReadOnlyTx(() -> publicExecutor.run(() -> getAccountByIdRaw(accountId)));

        tenantExecutor.runIfReady(account.getSchemaName(), "users_tenant", () -> {
            txExecutor.tenantRequiresNew(() -> {
                List<TenantUser> users = tenantUserRepository.findByAccountId(account.getId());
                users.forEach(u -> { if (u.isDeleted()) u.restore(); });
                tenantUserRepository.saveAll(users);
                return null;
            });
            return null;
        }, null);
    }

    private AccountStatusChangeResponse buildStatusChangeResponse(
            Account account,
            AccountStatus previous,
            boolean tenantUsersUpdated,
            String action,
            int count
    ) {
        return new AccountStatusChangeResponse(
                account.getId(),
                account.getStatus().name(),
                previous.name(),
                LocalDateTime.now(),
                account.getSchemaName(),
                new AccountStatusChangeResponse.SideEffects(tenantUsersUpdated, action, count)
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.exec.PublicExecutor;
import brito.com.multitenancy001.infrastructure.exec.TenantExecutor;
import brito.com.multitenancy001.infrastructure.exec.TxExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountTenantUserService {
	
	private final TenantUserApiMapper tenantUserApiMapper;


    private final PublicExecutor publicExecutor;
    private final TenantExecutor tenantExecutor;
    private final TxExecutor txExecutor;

    private final AccountRepository accountRepository;
    private final TenantUserRepository tenantUserRepository;

    public List<AccountUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyActive) {

        Account account = publicExecutor.run(() ->
            accountRepository.findByIdAndDeletedFalse(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404))
        );

        return tenantExecutor.runOrThrow(account.getSchemaName(), "users_tenant", () ->
            txExecutor.tenantReadOnlyTx(() -> {
                List<TenantUser> users = onlyActive
                    ? tenantUserRepository.findActiveUsersByAccount(account.getId())
                    : tenantUserRepository.findByAccountId(account.getId());

                return users.stream().map(tenantUserApiMapper::toAccountUserSummary).toList();
            })
        );
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {

        Account account = publicExecutor.run(() ->
            accountRepository.findByIdAndDeletedFalse(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404))
        );

        tenantExecutor.runOrThrow(account.getSchemaName(), "users_tenant", () ->
            txExecutor.tenantTx(() -> {
                int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
                if (updated == 0) {
                    throw new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado ou removido", 404);
                }
                return null;
            })
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AdminAuthService {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final ControlPlaneUserRepository controlPlaneUserRepository;

    public JwtResponse loginSuperAdmin(ControlPlaneAdminLoginRequest request) {

        // üî• SUPER ADMIN SEMPRE NO PUBLIC
        TenantContext.clear();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByUsernameAndDeletedFalse(request.username())
                .orElseThrow(() -> new ApiException(
                        "USER_NOT_FOUND",
                        "Super admin n√£o encontrado",
                        404
                ));

        // üîí Regras de neg√≥cio
        if (user.isSuspendedByAccount() || !user.getRole().isControlPlaneRole()) {
            throw new ApiException(
                    "ACCESS_DENIED",
                    "Usu√°rio n√£o autorizado",
                    403
            );
        }

        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        request.username(),
                        request.password()
                )
        );

        String accessToken = jwtTokenProvider.generateControlPlaneToken(
                authentication,
                user.getAccount().getId(),
                "public"
        );

        String refreshToken = jwtTokenProvider.generateRefreshToken(
                user.getUsername(),
                "public"
        );

        return new JwtResponse(
                accessToken,
                refreshToken,
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getRole().name(),
                user.getAccount().getId(),
                "public"
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.billing.PaymentRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentService {

    private final AccountRepository accountRepository;
    private final PaymentRepository paymentRepository;
    // private final EmailService emailService; // Opcional

    @Scheduled(cron = "${app.payment.check-cron:0 0 0 * * *}")
    public void checkPayments() {
        log.info("Iniciando verifica√ß√£o de pagamentos...");
        LocalDateTime today = LocalDateTime.now();

        List<Account> expiredTrials = accountRepository
                .findByStatus(AccountStatus.FREE_TRIAL)
                .stream()
                .filter(account -> account.getTrialEndDate() != null &&
                        account.getTrialEndDate().isBefore(today))
                .collect(Collectors.toList());

        for (Account account : expiredTrials) {
            suspendAccount(account, "Trial expirado");
        }

        List<Account> overdueAccounts = accountRepository
                .findByPaymentDueDateBefore(today);

        for (Account account : overdueAccounts) {
            if (account.getStatus() == AccountStatus.ACTIVE) {
                suspendAccount(account, "Pagamento atrasado");
            }
        }

        checkExpiredPendingPayments();
    }

    private void suspendAccount(Account account, String reason) {
        account.setStatus(AccountStatus.SUSPENDED);
        accountRepository.save(account);
        sendSuspensionEmail(account, reason);
    }

    private void checkExpiredPendingPayments() {
        LocalDateTime thirtyMinutesAgo = LocalDateTime.now().minusMinutes(30);

        List<Payment> expiredPayments = paymentRepository
                .findByStatusAndCreatedAtBefore(PaymentStatus.PENDING, thirtyMinutesAgo);

        for (Payment payment : expiredPayments) {
            payment.setStatus(PaymentStatus.EXPIRED);
            paymentRepository.save(payment);
        }
    }

    @Transactional
    public PaymentResponse processPayment(PaymentRequest request) {

        Account account = accountRepository.findById(request.accountId())
                .orElseThrow(() -> new ApiException(
                        "ACCOUNT_NOT_FOUND",
                        "Conta n√£o encontrada",
                        404
                ));

        validatePayment(account, request);

        Payment payment = Payment.builder()
                .account(account)
                .amount(request.amount())
                .paymentMethod(request.paymentMethod())
                .paymentGateway(request.paymentGateway())
                .description(request.description())
                .status(PaymentStatus.PENDING)
                .build();

        payment = paymentRepository.save(payment);

        boolean paymentSuccessful = processWithPaymentGateway(payment, request);

        if (paymentSuccessful) {
            completePayment(payment, account);
            return mapToResponse(payment, "Pagamento processado com sucesso");
        }

        failPayment(payment, "Falha no processamento do pagamento");

        throw new ApiException(
                "PAYMENT_FAILED",
                "Falha no processamento do pagamento",
                402
        );
    }

    @Transactional
    public PaymentResponse completePaymentManually(Long paymentId) {

        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException(
                        "PAYMENT_NOT_FOUND",
                        "Pagamento n√£o encontrado",
                        404
                ));

        if (payment.getStatus() != PaymentStatus.PENDING) {
            throw new ApiException(
                    "INVALID_PAYMENT_STATUS",
                    "Pagamento n√£o est√° pendente",
                    409
            );
        }

        completePayment(payment, payment.getAccount());
        return mapToResponse(payment, "Pagamento conclu√≠do manualmente");
    }

    private void completePayment(Payment payment, Account account) {
        payment.markAsCompleted();
        payment.setTransactionId(generateTransactionId());
        paymentRepository.save(payment);

        account.setStatus(AccountStatus.ACTIVE);
        account.setPaymentDueDate(calculateNextDueDate(payment.getValidUntil()));
        accountRepository.save(account);

        sendPaymentConfirmationEmail(account, payment);
    }

    private void failPayment(Payment payment, String reason) {
        payment.markAsFailed(reason);
        paymentRepository.save(payment);
    }

    private void validatePayment(Account account, PaymentRequest request) {

        if (request.amount() == null || request.amount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new ApiException(
                    "INVALID_AMOUNT",
                    "Valor do pagamento inv√°lido",
                    400
            );
        }

        if (account.isDeleted()) {
            throw new ApiException(
                    "ACCOUNT_DELETED",
                    "Conta deletada",
                    410
            );
        }

        Optional<Payment> activePayment =
                paymentRepository.findActivePayment(account.getId(), LocalDateTime.now());

        if (activePayment.isPresent()) {
            throw new ApiException(
                    "PAYMENT_ALREADY_EXISTS",
                    "J√° existe um pagamento ativo para esta conta",
                    409
            );
        }
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByAccount(Long accountId) {
        return paymentRepository.findByAccountId(accountId)
                .stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentById(Long paymentId) {

        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException(
                        "PAYMENT_NOT_FOUND",
                        "Pagamento n√£o encontrado",
                        404
                ));

        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    public boolean hasActivePayment(Long accountId) {
        return paymentRepository
                .findActivePayment(accountId, LocalDateTime.now())
                .isPresent();
    }

    @Transactional(readOnly = true)
    public BigDecimal getTotalRevenue(LocalDateTime startDate, LocalDateTime endDate) {
        List<Object[]> revenueByAccount =
                paymentRepository.getRevenueByAccount(startDate, endDate);

        return revenueByAccount.stream()
                .map(obj -> (BigDecimal) obj[1])
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    @Transactional
    public PaymentResponse refundPayment(Long paymentId, BigDecimal amount, String reason) {

        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException(
                        "PAYMENT_NOT_FOUND",
                        "Pagamento n√£o encontrado",
                        404
                ));

        if (!payment.canBeRefunded()) {
            throw new ApiException(
                    "PAYMENT_NOT_REFUNDABLE",
                    "Pagamento n√£o pode ser reembolsado",
                    409
            );
        }

        if (amount == null) {
            payment.refundFully(reason);
        } else {
            payment.refundPartially(amount, reason);
        }

        paymentRepository.save(payment);
        return mapToResponse(payment, "Reembolso processado");
    }

    private PaymentResponse mapToResponse(Payment payment) {
        return new PaymentResponse(
                payment.getId(),
                payment.getAccount().getId(),
                payment.getAmount(),
                payment.getPaymentDate(),
                payment.getValidUntil(),
                payment.getStatus().name(),
                payment.getTransactionId(),
                payment.getPaymentMethod(),
                payment.getPaymentGateway(),
                payment.getDescription(),
                payment.getCreatedAt(),
                payment.getUpdatedAt()
        );
    }

    private PaymentResponse mapToResponse(Payment payment, String message) {
        return mapToResponse(payment);
    }

    private void sendSuspensionEmail(Account account, String reason) {
        log.info("Enviando email de suspens√£o para: {}", account.getCompanyEmail());
 
    }
    

    private void sendPaymentConfirmationEmail(Account account, Payment payment) {
        log.info("Enviando confirma√ß√£o de pagamento para: {}", account.getCompanyEmail());
    }

    private String generateTransactionId() {
        return "TXN_" + System.currentTimeMillis() + "_" +
                UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }

    private LocalDateTime calculateNextDueDate(LocalDateTime validUntil) {
        return validUntil != null
                ? validUntil
                : LocalDateTime.now().plusMonths(1);
    }
    
    
    private boolean processWithPaymentGateway(Payment payment, PaymentRequest request) {

        log.info("Processando pagamento com gateway: {}", request.paymentGateway());

        try {
            // Simula√ß√£o de comunica√ß√£o com gateway externo
            // (Stripe, Mercado Pago, PagSeguro, etc.)
            Thread.sleep(1000);

            // Simula√ß√£o: 90% de chance de sucesso
            return Math.random() < 0.9;

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Erro ao processar pagamento no gateway", e);
            return false;
        }
    }
 
    
    
    
    
}
package brito.com.multitenancy001.controlplane.application.policy;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class AccountPolicy {
    
    private final AccountRepository accountRepository;
    
    /**
     * Valida se a conta pode ser gerenciada (n√£o √© conta do sistema)
     */
    public void validateNotSystemAccount(Long accountId) {
        Account account = accountRepository.findById(accountId)
            .orElseThrow(() -> new ApiException(
                "ACCOUNT_NOT_FOUND",
                "Conta n√£o encontrada",
                404
            ));
        
        if (account.isSystemAccount()) {
            throw new ApiException(
                "SYSTEM_ACCOUNT_PROTECTED",
                "Opera√ß√£o n√£o permitida para contas do sistema",
                403
            );
        }
    }
    
    /**
     * Valida se a conta pode ser gerenciada (n√£o √© conta do sistema)
     */
    public void validateNotSystemAccount(Account account) {
        if (account.isSystemAccount()) {
            throw new ApiException(
                "SYSTEM_ACCOUNT_PROTECTED",
                "Opera√ß√£o n√£o permitida para contas do sistema",
                403
            );
        }
    }
}package brito.com.multitenancy001.controlplane.application;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;

import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "publicTransactionManager")
public class PublicAccountService {

    private final AccountRepository accountRepository;


  
    public Account createAccountFromSignup(SignupRequest request) {
    	 TenantContext.clear();

    	    int maxAttempts = 5;
    	    for (int attempt = 1; attempt <= maxAttempts; attempt++) {
    	        String slug = generateSlug(request.name());
    	        String schemaName = generateSchemaName(request.name());

    	        try {
    	            Account account = new Account();
    	            account.setName(request.name());
    	            account.setSlug(slug);
    	            account.setSchemaName(schemaName);

    	            account.setCompanyEmail(request.companyEmail());

    	            // ‚úÖ novos campos (sempre em conjunto)
    	            account.setCompanyDocType(request.companyDocType());
    	            account.setCompanyDocNumber(request.companyDocNumber());

    	            account.setCreatedAt(LocalDateTime.now());
    	            account.setTrialEndDate(LocalDateTime.now().plusDays(30));
    	            account.setStatus(AccountStatus.FREE_TRIAL);
    	            account.setSystemAccount(false);

    	            // Defaults
    	            account.setSubscriptionPlan("FREE");
    	            account.setMaxUsers(5);
    	            account.setMaxProducts(100);
    	            account.setMaxStorageMb(100);
    	            account.setCompanyCountry("Brasil");
    	            account.setTimezone("America/Sao_Paulo");
    	            account.setLocale("pt_BR");
    	            account.setCurrency("BRL");

    	            return accountRepository.save(account);

    	        } catch (DataIntegrityViolationException e) {
    	            if (!isSlugOrSchemaUniqueViolation(e)) throw e;
    	            log.warn("‚ö†Ô∏è Colis√£o (tentativa {}/{}) | slug={} | schema={}",
    	                    attempt, maxAttempts, slug, schemaName);
    	        }
    	    }

    	    throw new ApiException("ACCOUNT_CREATE_FAILED",
    	            "N√£o foi poss√≠vel criar conta (colis√£o de identificadores). Tente novamente.", 409);
    	}
    
    
    private String generateSlug(String name) {
        String base = (name == null ? "conta" : name.toLowerCase())
                .replaceAll("[^a-z0-9]+", "-")
                .replaceAll("(^-|-$)", "");

        String slug = base;
        int i = 1;

        while (accountRepository.findBySlugAndDeletedFalse(slug).isPresent()) {
            slug = base + "-" + (i++);
        }
        return slug;
    }

    private String generateSchemaName(String name) {
        String base = (name == null ? "tenant" : name.toLowerCase())
                .replaceAll("[^a-z0-9]", "_");
        return "tenant_" + base + "_" + UUID.randomUUID().toString().substring(0, 8);
    }

   
    
    

    private boolean isSlugOrSchemaUniqueViolation(Throwable e) {
        Throwable t = e;
        while (t.getCause() != null) t = t.getCause();
        String msg = (t.getMessage() == null) ? "" : t.getMessage().toLowerCase();

        return msg.contains("ux_accounts_slug_active")
                || msg.contains("uk_accounts_slug")
                || msg.contains("uk_accounts_schema_name")
                || msg.contains("accounts_slug_key")
                || msg.contains("accounts_schema_name_key")
                || msg.contains("company_email");
    }

}
package brito.com.multitenancy001.controlplane.application.user;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneRole;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.List;

@Service
@Transactional
@RequiredArgsConstructor
public class ControlPlaneUserService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final AccountRepository accountRepository;
    private final PasswordEncoder passwordEncoder;
    private final Clock clock;
   
    

    private Account getControlPlaneAccount() {
        TenantContext.clear(); // PUBLIC
        return accountRepository.findBySlugAndDeletedFalse("controlplane")
                .orElseThrow(() -> new ApiException(
                        "CONTROLPLANE_ACCOUNT_NOT_FOUND",
                        "Conta controlplane n√£o encontrada. Rode a migration V3__insert_controlplane_account.sql",
                        500
                ));
    }

    public ControlPlaneUserDetailsResponse createControlPlaneUser(ControlPlaneUserCreateRequest request) {
        TenantContext.clear();

        Account controlPlaneAccount = getControlPlaneAccount();

        // valida√ß√µes b√°sicas
        if (!request.password().matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "A senha n√£o atende aos requisitos de seguran√ßa", 400);
        }
        if (request.username() == null || request.username().isBlank()) {
            throw new ApiException("INVALID_USERNAME", "Username √© obrigat√≥rio", 400);
        }
        if (!request.username().matches(ValidationPatterns.USERNAME_PATTERN)) {
            throw new ApiException("INVALID_USERNAME", "Username inv√°lido", 400);
        }

        String username = request.username().toLowerCase().trim();

        // role permitida somente plataforma
        ControlPlaneRole role;
        try {
            role = ControlPlaneRole.valueOf(request.role().toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new ApiException("INVALID_ROLE", "Role inv√°lida para plataforma", 400);
        }

        // garante que √© role de plataforma (SUPER_ADMIN/SUPPORT/STAFF)
        if (!role.isControlPlaneRole()) {
            throw new ApiException("INVALID_ROLE", "Role n√£o permitida para usu√°rio de plataforma", 400);
        }

        
        if (controlPlaneUserRepository.existsByUsernameAndAccountId(username, controlPlaneAccount.getId())) {
            throw new ApiException("USERNAME_ALREADY_EXISTS", "Username j√° existe", 409);
        }
        if (controlPlaneUserRepository.existsByEmailAndAccountId(request.email(), controlPlaneAccount.getId())) {
            throw new ApiException("EMAIL_ALREADY_EXISTS", "Email j√° existe", 409);
        }

        ControlPlaneUser user = ControlPlaneUser.builder()
                .name(request.name())
                .username(username)
                .email(request.email())
                .password(passwordEncoder.encode(request.password()))
                .role(role)
                .account(controlPlaneAccount) 
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .build();

        return mapToResponse(controlPlaneUserRepository.save(user));
    }

    @Transactional(readOnly = true)
    public List<ControlPlaneUserDetailsResponse> listControlPlaneUsers() {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();
        return controlPlaneUserRepository.findByAccountId(controlPlaneAccount.getId()).stream()
                .filter(u -> !u.isDeleted())
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    public ControlPlaneUserDetailsResponse getControlPlaneUser(Long userId) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404);
        }

        return mapToResponse(user);
    }
    
    
    
    
    
    
    public ControlPlaneUserDetailsResponse updateControlPlaneUserStatus(Long userId, boolean active) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_DELETED", "Usu√°rio est√° removido", 409);
        }

        // ‚úÖ a√ß√£o manual do admin da plataforma
        user.setSuspendedByAdmin(!active);

        return mapToResponse(controlPlaneUserRepository.save(user));
    }

    
    

    public void softDeleteControlPlaneUser(Long userId) {
    	   LocalDateTime now = LocalDateTime.now(clock);
           long suffix = clock.millis();
           
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_ALREADY_DELETED", "Usu√°rio j√° removido", 409);
        }

     
        user.softDelete(now, suffix);
        controlPlaneUserRepository.save(user);

    }
    

    public ControlPlaneUserDetailsResponse restoreControlPlaneUser(Long userId) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404));

        if (!user.isDeleted()) {
            throw new ApiException("USER_NOT_DELETED", "Usu√°rio n√£o est√° removido", 409);
        }

        user.restore();
        return mapToResponse(controlPlaneUserRepository.save(user));
    }
    
    

    private ControlPlaneUserDetailsResponse mapToResponse(ControlPlaneUser user) {
        return new ControlPlaneUserDetailsResponse(
                user.getId(),
                user.getUsername(),
                user.getName(),
                user.getEmail(),
                user.getRole().name(),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.getCreatedAt(),
                user.getUpdatedAt(),
                user.getAccount().getId(),
                List.of()
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.util.UUID;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;


@Service
@RequiredArgsConstructor
public class UsernameService {
	
	  private final TenantUserRepository tenantUserRepository;
	
	 private static final int USERNAME_MAX_LENGTH = 100;
	    private static final String USERNAME_PATTERN = "^[a-z0-9._-]+$";

	    /**
	     * üî• Novo m√©todo solicitado ‚Äî vers√£o PRO
	     * remove acentos, s√≠mbolos e espa√ßos e deixa tudo lowercase
	     */
	    public String normalize(String input) {
	        if (input == null || input.isBlank()) return "user";

	        // Remover acentos
	        String normalized = java.text.Normalizer
	                .normalize(input, java.text.Normalizer.Form.NFD)
	                .replaceAll("\\p{M}", "");

	        // Manter apenas letras, n√∫meros e _
	        normalized = normalized
	                .replaceAll("[^a-zA-Z0-9]", "_")
	                .replaceAll("_{2,}", "_")
	                .toLowerCase()
	                .replaceAll("^_|_$", "");

	        return normalized.isBlank() ? "user" : normalized;
	    }
	    
	    public String generateFromEmail(String email) {
	        String base = email.split("@")[0].toLowerCase();
	        base = base.replaceAll("[^a-z0-9._-]", "_");
	        base = base.replaceAll("_{2,}", "_");
	        base = base.replaceAll("^_|_$", "");

	        if (base.isEmpty()) base = "user";

	        String suffix = UUID.randomUUID().toString().replace("-", "").substring(0, 8);
	        String username = base + "_" + suffix;

	        if (username.length() > USERNAME_MAX_LENGTH) {
	            username = username.substring(0, USERNAME_MAX_LENGTH);
	        }

	        return username;
	    }
	    
	    public String generateFromNameAndEmail(String name, String email) {
	        String namePart = name.toLowerCase()
	                .replaceAll("[^a-z0-9]", "")
	                .substring(0, Math.min(name.length(), 20));
	        
	        String emailPart = email.split("@")[0].toLowerCase()
	                .replaceAll("[^a-z0-9]", "");
	        
	        return namePart + "_" + emailPart + "_" + 
	               UUID.randomUUID().toString().substring(0, 6);
	    }
	    
	    public boolean isValidUsername(String username) {
	        return username != null && 
	               username.length() >= 3 && 
	               username.length() <= USERNAME_MAX_LENGTH &&
	               username.matches(USERNAME_PATTERN);
	    }
	    
	    public String normalizeUsername(String username) {
	        if (username == null) return null;
	        return username.toLowerCase()
	                .replaceAll("[^a-z0-9._-]", "_")
	                .replaceAll("_{2,}", "_")
	                .replaceAll("^_|_$", "");
	    }
	    
	    public String ensureUniqueUsername(
	            String baseUsername,
	            Long accountId
	    ) {
	        String username = baseUsername;
	        int counter = 1;

	        while (tenantUserRepository
	                .existsByUsernameAndAccountId(username, accountId)) {
	            username = baseUsername + counter;
	            counter++;
	        }

	        return username;
	    }

}
package brito.com.multitenancy001.controlplane.domain.account;


import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(
		name = "accounts", uniqueConstraints = {
    @UniqueConstraint(columnNames = "slug"),
    @UniqueConstraint(columnNames = "schema_name")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Account {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "is_system_account", nullable = false)
    @Builder.Default
    private boolean systemAccount = false;
    
   
    @Column(nullable = false, length = 150)
    private String name;
    
   
    
    
    @Column(name = "schema_name", nullable = false, unique = true, length = 100)
    private String schemaName;
    
    @Column(name = "slug", nullable = false, unique = true, length = 50)
    private String slug;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    @Builder.Default
    private AccountStatus status = AccountStatus.FREE_TRIAL;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt; // ‚úÖ LocalDate
    
    @Column(name = "trial_end_date")
    private LocalDateTime trialEndDate; // ‚úÖ LocalDate
    
    @Column(name = "payment_due_date")
    private LocalDateTime paymentDueDate; // ‚úÖ LocalDate
    
    @Column(name = "next_billing_date")
    private LocalDateTime nextBillingDate; // ‚úÖ LocalDate
    
    @Column(name = "subscription_plan", length = 50)
    @Builder.Default
    private String subscriptionPlan = "FREE";
    
    @Column(name = "max_users")
    @Builder.Default
    private Integer maxUsers = 5;
    
    @Column(name = "max_products")
    @Builder.Default
    private Integer maxProducts = 100;
    
    @Column(name = "max_storage_mb")
    @Builder.Default
    private Integer maxStorageMb = 100;
    
    @Column(name = "company_email", nullable = false, length = 150)
    private String companyEmail;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "company_doc_type", nullable = false, length = 10)
    private DocumentType companyDocType;
    
    @Column(name = "company_doc_number", nullable = false, length = 20)
    private String companyDocNumber;
    
    @Column(name = "company_phone", length = 20)
    private String companyPhone;
    
   
    
    @Column(name = "company_address", length = 500)
    private String companyAddress;
    
    @Column(name = "company_city", length = 100)
    private String companyCity;
    
    @Column(name = "company_state", length = 50)
    private String companyState;
    
    @Column(name = "company_country", length = 50)
    @Builder.Default
    private String companyCountry = "Brasil";
    
    @Column(name = "timezone", length = 50)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";
    
    @Column(name = "locale", length = 10)
    @Builder.Default
    private String locale = "pt_BR";
    
    @Column(name = "currency", length = 3)
    @Builder.Default
    private String currency = "BRL";
    
    @OneToMany(mappedBy = "account", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    @ToString.Exclude
    private List<ControlPlaneUser> userAccount = new ArrayList<>();
    
    
    
    
    @Column(name = "settings_json", columnDefinition = "TEXT")
    private String settingsJson;
    
    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt; // ‚úÖ LocalDateTime para auditoria
    
    @Column(name = "deleted")
    @Builder.Default
    private boolean deleted = false;
    
 
    
    
    
    
    @PrePersist
    protected void onCreate() {

        if (this.createdAt == null) {
            this.createdAt = LocalDateTime.now();
        }

        // üîπ Gera slug automaticamente se n√£o vier preenchido
        if (this.slug == null || this.slug.isBlank()) {
            this.slug = this.name.toLowerCase()
                .replaceAll("[^a-z0-9]+", "-")
                .replaceAll("(^-|-$)", "");
        }

        // üîπ Gera schemaName automaticamente se n√£o vier preenchido
        if (this.schemaName == null) {
            this.schemaName =
                "tenant_" +
                this.slug.replace("-", "_") +
                "_" +
                UUID.randomUUID().toString().substring(0, 8);
        }

        // üîπ Define trial automaticamente
        if (this.trialEndDate == null) {
            this.trialEndDate = this.createdAt.plusDays(30);
        }
    }
    
    
    

    @PreUpdate
    protected void onUpdate() {
        // M√©todo para l√≥gica de atualiza√ß√£o se necess√°rio
    }
    
    /**
     * Verifica se a conta est√° em trial ativo
     */
    public boolean isTrialActive() {
        return this.status == AccountStatus.FREE_TRIAL && 
               this.trialEndDate != null && 
               this.trialEndDate.isAfter(LocalDateTime.now());
    }
    
    /**
     * Verifica se a conta est√° ativa
     */
    public boolean isActive() {
        return this.status == AccountStatus.ACTIVE || 
               (this.status == AccountStatus.FREE_TRIAL && isTrialActive());
    }
    
    /**
     * Verifica se o pagamento est√° atrasado
     */
    public boolean isPaymentOverdue() {
        return this.paymentDueDate != null && 
               this.paymentDueDate.isBefore(LocalDateTime.now());
    }
    
    /**
     * Dias restantes no trial
     */
    public long getDaysRemainingInTrial() {
        if (this.trialEndDate == null || !isTrialActive()) {
            return 0;
        }
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDateTime.now(), this.trialEndDate);
    }
    
   /**
 * Soft delete da conta
 */
public void softDelete() {
    if (!this.deleted) {
        this.deleted = true;
        this.deletedAt = LocalDateTime.now();
        this.status = AccountStatus.CANCELLED;
    }
}

    
    /**
     * Restaura a conta (undo soft delete)
     */
    public void restore() {
        if (this.deleted) {
            this.deleted = false;
            this.deletedAt = null;

            // Regra de neg√≥cio: ao restaurar, volta para ACTIVE
            this.status = AccountStatus.ACTIVE;
        }
    }
    
    public boolean isSystemAccount() {
        return this.systemAccount || "public".equals(this.schemaName);
    }
    

    
}package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountStatus {
    FREE_TRIAL("Trial Gratuito"),
    ACTIVE("Ativa"),
    SUSPENDED("Suspensa"),
    CANCELLED("Cancelada"),
    EXPIRED("Expirada");
    
    private final String description;
    
    AccountStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * Verifica se o status permite opera√ß√µes
     */
    public boolean isOperational() {
        return this == FREE_TRIAL || this == ACTIVE;
    }
    
    /**
     * Verifica se o status est√° em trial
     */
    public boolean isTrial() {
        return this == FREE_TRIAL;
    }
    
    /**
     * Verifica se o status est√° ativo
     */
    public boolean isActive() {
        return this == ACTIVE;
    }
    
    /**
     * Verifica se o status est√° suspenso
     */
    public boolean isSuspended() {
        return this == SUSPENDED;
    }
    
    /**
     * Verifica se o status est√° cancelado
     */
    public boolean isCancelled() {
        return this == CANCELLED || this == EXPIRED;
    }
}package brito.com.multitenancy001.controlplane.domain.account;

import lombok.Getter;

@Getter
public enum DocumentType {
    CPF,
    CNPJ;

   
    }
package brito.com.multitenancy001.controlplane.domain.billing;


import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "payments", indexes = {
    @Index(name = "idx_payment_account", columnList = "account_id"),
    @Index(name = "idx_payment_status", columnList = "status"),
    @Index(name = "idx_payment_transaction", columnList = "transaction_id", unique = true),
    @Index(name = "idx_payment_date", columnList = "payment_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "payment_date", nullable = false)
    private LocalDateTime paymentDate;
    
    @Column(name = "valid_until")
    private LocalDateTime validUntil;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private PaymentStatus status = PaymentStatus.PENDING;
    
    @Column(name = "transaction_id", unique = true, length = 100)
    private String transactionId;
    
    @Column(name = "payment_method", length = 50)
    private String paymentMethod;
    
    @Column(name = "payment_gateway", length = 50)
    private String paymentGateway;
    
    @Column(name = "currency", length = 3)
    @Builder.Default
    private String currency = "BRL";
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;
    
    @Column(name = "invoice_url")
    private String invoiceUrl;
    
    @Column(name = "receipt_url")
    private String receiptUrl;
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Column(name = "refunded_at")
    private LocalDateTime refundedAt;
    
    @Column(name = "refund_amount", precision = 10, scale = 2)
    private BigDecimal refundAmount;
    
    @Column(name = "refund_reason", length = 500)
    private String refundReason;
    
    @PrePersist
    protected void onCreate() {
        if (this.transactionId == null) {
            this.transactionId = "PAY_" + UUID.randomUUID().toString()
                    .replace("-", "")
                    .substring(0, 16)
                    .toUpperCase();
        }

        if (this.paymentDate == null) {
            this.paymentDate = LocalDateTime.now();
        }

        if (this.createdAt == null) {
            this.createdAt = LocalDateTime.now();
        }

        if (this.status == PaymentStatus.COMPLETED && this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil();
        }

    }
    
    
  
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
    
    private LocalDateTime calculateDefaultValidUntil() {
        return this.paymentDate.plusDays(30); // per√≠odo default do ciclo
    }
    
    /**
     * Marca o pagamento como conclu√≠do
     */
    public void markAsCompleted() {
        this.status = PaymentStatus.COMPLETED;
        if (this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil();
        }
    }
    
    /**
     * Marca o pagamento como falhado
     */
    public void markAsFailed(String reason) {
        this.status = PaymentStatus.FAILED;
        if (this.metadataJson == null) {
            this.metadataJson = "{\"failure_reason\":\"" + reason + "\"}";
        }
    }
    
    /**
     * Realiza reembolso parcial
     */
    public void refundPartially(BigDecimal amount, String reason) {
        if (amount.compareTo(BigDecimal.ZERO) <= 0 || amount.compareTo(this.amount) > 0) {
            throw new IllegalArgumentException("Valor de reembolso inv√°lido");
        }
        
        this.refundAmount = amount;
        this.refundReason = reason;
        this.refundedAt = LocalDateTime.now();
        this.status = PaymentStatus.REFUNDED;
    }
    
    /**
     * Realiza reembolso total
     */
    public void refundFully(String reason) {
        this.refundAmount = this.amount;
        this.refundReason = reason;
        this.refundedAt = LocalDateTime.now();
        this.status = PaymentStatus.REFUNDED;
    }
    
    /**
     * Verifica se o pagamento est√° ativo (n√£o expirado)
     */
    public boolean isActive() {
        return this.status == PaymentStatus.COMPLETED && 
               (this.validUntil == null || this.validUntil.isAfter(LocalDateTime.now()));
    }
    
    /**
     * Verifica se o pagamento pode ser reembolsado
     */
    public boolean canBeRefunded() {
        return this.status == PaymentStatus.COMPLETED && 
               this.refundedAt == null &&
               this.paymentDate.isAfter(LocalDateTime.now().minusDays(90)); // Reembolso at√© 90 dias
    }
}package brito.com.multitenancy001.controlplane.domain.billing;



public enum PaymentStatus {
    PENDING("Pendente"),
    COMPLETED("Conclu√≠do"),
    FAILED("Falhou"),
    REFUNDED("Reembolsado"),
    CANCELLED("Cancelado"),
    EXPIRED("Expirado");
    
    private final String description;
    
    PaymentStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * Verifica se o status indica pagamento bem-sucedido
     */
    public boolean isSuccessful() {
        return this == COMPLETED;
    }
    
    /**
     * Verifica se o status indica pagamento finalizado (n√£o pendente)
     */
    public boolean isFinal() {
        return this != PENDING;
    }
    
    /**
     * Converte string para PaymentStatus
     */
    public static PaymentStatus fromString(String status) {
        if (status == null) {
            return PENDING;
        }
        try {
            return PaymentStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            return PENDING;
        }
    }
}package brito.com.multitenancy001.controlplane.domain.user;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum ControlPlaneRole implements RoleAuthority {

    SUPER_ADMIN(true),
    SUPPORT(true),
	STAFF(true);

    private final boolean controlPlaneRole;

    ControlPlaneRole(boolean newControPlaneRole) {
        this.controlPlaneRole = newControPlaneRole;
    }

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    // ‚úÖ M√âTODO QUE FALTAVA
    public boolean isControlPlaneRole() {
        return controlPlaneRole;
    }

    // (Opcional, mas elegante)
    public boolean isSuperAdmin() {
        return this == SUPER_ADMIN;
    }
}
package brito.com.multitenancy001.controlplane.domain.user;

import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

import java.time.LocalDateTime;

@Entity
@Table(name = "users_account", schema = "public")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
@ToString(exclude = { "account", "password" })
public class ControlPlaneUser {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = 100)
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inv√°lido.")
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false, length = 150)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private ControlPlaneRole role;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    // ‚úÖ NOVO
    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    // üîê SEGURAN√áA
    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts")
    @Builder.Default
    private Integer failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password")
    @Builder.Default
    private Boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    // üßæ AUDITORIA
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted")
    @Builder.Default
    private boolean deleted = false;


    public boolean isEnabledForLogin(LocalDateTime now) {
        if (lockedUntil != null && lockedUntil.isAfter(now)) return false;
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }


    // se voc√™ usa esse m√©todo em algum lugar, deixe coerente:
    public boolean isAccountNonLocked(LocalDateTime now) {
        return isEnabledForLogin(now);
    }

    public void softDelete(LocalDateTime now, long uniqueSuffix) {
        if (deleted) return;
        deleted = true;
        deletedAt = now;

        suspendedByAccount = true;
        suspendedByAdmin = true;

        username = "deleted_" + username + "_" + uniqueSuffix;
        email = "deleted_" + email + "_" + uniqueSuffix;
    }



    public void restore() {
        this.deleted = false;
        this.deletedAt = null;

        // restaurar n√£o ‚Äúdes-suspende‚Äù admin por padr√£o ‚Äî mas como √© plataforma, voc√™ decide.
        this.suspendedByAccount = false;
        this.suspendedByAdmin = false;
    }
}
package brito.com.multitenancy001.controlplane.persistence.account;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {

    boolean existsByCompanyEmailAndDeletedFalse(String companyEmail);

    // ‚úÖ docType + docNumber juntos
    boolean existsByCompanyDocTypeAndCompanyDocNumberAndDeletedFalse(DocumentType companyDocType, String companyDocNumber);

    List<Account> findAllByDeletedFalse();
    List<Account> findByDeletedFalseOrderByCreatedAtDesc();

    Optional<Account> findBySlugAndDeletedFalse(String slug);
    Optional<Account> findByIdAndDeletedFalse(Long id);

    List<Account> findByStatus(AccountStatus status);
    List<Account> findByStatusAndDeletedFalse(AccountStatus status);
    List<Account> findByPaymentDueDateBefore(LocalDateTime date);

    @Query("SELECT a FROM Account a WHERE a.trialEndDate <= :date AND a.status = :status")
    List<Account> findExpiredTrials(@Param("date") LocalDateTime date, @Param("status") AccountStatus status);

    @Query("SELECT COUNT(a) FROM Account a WHERE a.deleted = false")
    Long countActiveAccounts();

    @Query("SELECT a FROM Account a WHERE a.status = :status AND a.paymentDueDate < :today")
    List<Account> findOverdueAccounts(@Param("status") AccountStatus status, @Param("today") LocalDateTime today);

    boolean existsByNameAndDeletedFalse(String name);
    boolean existsBySchemaNameAndDeletedFalse(String schemaName);

    @Query("SELECT a FROM Account a WHERE a.createdAt BETWEEN :startDate AND :endDate")
    List<Account> findAccountsCreatedBetween(@Param("startDate") LocalDateTime startDate,
                                                   @Param("endDate") LocalDateTime endDate);

    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.status IN :statuses")
    List<Account> findByStatuses(@Param("statuses") List<AccountStatus> statuses);

    @Query("SELECT a FROM Account a WHERE LOWER(a.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) AND a.deleted = false")
    List<Account> searchByName(@Param("searchTerm") String searchTerm);
}
package brito.com.multitenancy001.controlplane.persistence.billing;



import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface PaymentRepository extends JpaRepository<Payment, Long> {
    
    List<Payment> findByAccountId(Long accountId);
    
    List<Payment> findByAccountIdAndStatus(Long accountId, PaymentStatus status);
    
    Page<Payment> findByAccountId(Long accountId, Pageable pageable);
    
    Optional<Payment> findByTransactionId(String transactionId);
    
    List<Payment> findByStatus(PaymentStatus status);
    
    List<Payment> findByStatusAndCreatedAtBefore(PaymentStatus status, LocalDateTime date);
    
    List<Payment> findByValidUntilBeforeAndStatus(LocalDateTime date, PaymentStatus status);
    
    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' ORDER BY p.paymentDate DESC")
    List<Payment> findCompletedPaymentsByAccount(@Param("accountId") Long accountId);
    
    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.validUntil > :now AND p.status = 'COMPLETED'")
    Optional<Payment> findActivePayment(@Param("accountId") Long accountId, @Param("now") LocalDateTime now);
    
    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalPaidInPeriod(@Param("accountId") Long accountId, 
                                   @Param("startDate") LocalDateTime startDate, 
                                   @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT COUNT(p) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED'")
    Long countCompletedPayments(@Param("accountId") Long accountId);
    
    @Query("SELECT p FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate")
    List<Payment> findPaymentsInPeriod(@Param("startDate") LocalDateTime startDate, 
                                      @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT p.account.id, SUM(p.amount) FROM Payment p WHERE p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate GROUP BY p.account.id")
    List<Object[]> getRevenueByAccount(@Param("startDate") LocalDateTime startDate, 
                                      @Param("endDate") LocalDateTime endDate);
    
    boolean existsByTransactionId(String transactionId);
}package brito.com.multitenancy001.controlplane.persistence.user;



import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlaneUserRepository extends JpaRepository<ControlPlaneUser, Long> {
	
	long countByAccountIdAndDeletedFalse(Long accountId);
	
	Optional<ControlPlaneUser> findFirstByAccountIdAndDeletedFalse(Long accountId);
    
    Optional<ControlPlaneUser> findByUsername(String username);
    
    Optional<ControlPlaneUser> findByEmail(String email);
    
    List<ControlPlaneUser> findByAccountId(Long accountId);
    
    @Query("SELECT (COUNT(u) > 0) FROM ControlPlaneUser u " +
    	       "WHERE u.username = :username AND u.account.id = :accountId AND u.deleted = false")
    	boolean existsByUsernameAndAccountId(@Param("username") String username,
    	                                     @Param("accountId") Long accountId);
    
    
    
    @Query("SELECT (COUNT(u) > 0) FROM ControlPlaneUser u " +
    	       "WHERE u.email = :email AND u.account.id = :accountId AND u.deleted = false")
    	boolean existsByEmailAndAccountId(@Param("email") String email,
    	                                  @Param("accountId") Long accountId);    
    Optional<ControlPlaneUser> findByIdAndAccountId(Long id, Long accountId);
    
    Optional<ControlPlaneUser> findByUsernameAndDeletedFalse(String username);
    
    Optional<ControlPlaneUser> findByEmailAndDeletedFalse(String email);
}package brito.com.multitenancy001.infrastructure.config;

import java.time.Clock;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TimeConfig {

    @Bean
    public Clock systemClock() {
        return Clock.systemDefaultZone();
    }
}
package brito.com.multitenancy001.infrastructure.db.flyway;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PublicFlywayConfig {

    @Bean
    public Flyway flywayAccount(DataSource dataSource) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas("public")
                .locations("classpath:db/migration/accounts")
                .baselineOnMigrate(true)
                .load();

        // üöÄ EXECUTA NA INICIALIZA√á√ÉO
        //flyway.migrate();

        return flyway;
    }
}
package brito.com.multitenancy001.infrastructure.db.flyway;

import org.flywaydb.core.Flyway;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Component
@RequiredArgsConstructor
@Slf4j
public class PublicFlywayRunner implements ApplicationRunner {

    private final Flyway flywayAccount;
    
   

    @Override
    public void run(ApplicationArguments args) {
    	
   
    	
    	
        log.info("üöÄ Executando Flyway ACCOUNT (public)");
        flywayAccount.migrate();
    }
}
package brito.com.multitenancy001.infrastructure.db.flyway;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class PublicSchemaVerifier {
    
    private final JdbcTemplate jdbc;
    
    @EventListener(ApplicationReadyEvent.class)
    public void verifyTables() {
        log.info("üîç Verificando tabelas criadas pelo Flyway...");
        
        try {
            // Apenas VERIFICA, n√£o cria
            Integer accountsCount = jdbc.queryForObject(
                "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'accounts'", 
                Integer.class
            );
            
            Integer usersCount = jdbc.queryForObject(
            	    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'controlplane_users'",
            	    Integer.class
            	);

            
            log.info("‚úÖ Verifica√ß√£o OK! Tabelas encontradas: accounts={}, controlplane_users={}", accountsCount, usersCount);

        } catch (Exception e) {
            log.error("‚ö†Ô∏è Aviso na verifica√ß√£o: {}", e.getMessage());
        }
    }
}package brito.com.multitenancy001.infrastructure.exec;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Component
public class PublicExecutor {

    public <T> T run(Supplier<T> supplier) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            return supplier.get();
        }
    }

    public void run(Runnable runnable) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            runnable.run();
        }
    }
}
package brito.com.multitenancy001.infrastructure.exec;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;

@Component
public class TenantExecutor {

    private final TenantSchemaProvisioningService tenantSchemaService;

    public TenantExecutor(TenantSchemaProvisioningService tenantSchemaService) {
        this.tenantSchemaService = tenantSchemaService;
    }

    public <T> T run(String schema, Supplier<T> fn) {
        if (schema == null || "public".equals(schema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inv√°lido", 404);
        }

        // ‚úÖ padronizado: nada de bind/clear manual
        try (TenantContext.Scope ignored = TenantContext.scope(schema)) {
            return fn.get();
        }
    }

    public void run(String schema, Runnable fn) {
        run(schema, () -> { fn.run(); return null; });
    }

    /** Retorna defaultValue se schema/tabela n√£o existir (bom p/ side-effects). */
    public <T> T runIfReady(String schema, String requiredTable, Supplier<T> fn, T defaultValue) {
        if (schema == null || "public".equals(schema)) return defaultValue;
        if (!tenantSchemaService.validateTenantSchema(schema)) return defaultValue;
        if (requiredTable != null && !tenantSchemaService.tableExists(schema, requiredTable)) return defaultValue;
        return run(schema, fn);
    }

    /** Lan√ßa ApiException se schema/tabela n√£o existir (bom p/ endpoints admin). */
    public void assertReadyOrThrow(String schema, String requiredTable) {
        if (schema == null || "public".equals(schema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inv√°lido", 404);
        }
        if (!tenantSchemaService.validateTenantSchema(schema)) {
            throw new ApiException("TENANT_SCHEMA_NOT_FOUND", "Schema do tenant n√£o existe", 404);
        }
        if (requiredTable != null && !tenantSchemaService.tableExists(schema, requiredTable)) {
            throw new ApiException("TENANT_TABLE_NOT_FOUND", "Tabela " + requiredTable + " n√£o existe no tenant", 404);
        }
    }

    public <T> T runOrThrow(String schema, String requiredTable, Supplier<T> fn) {
        assertReadyOrThrow(schema, requiredTable);
        return run(schema, fn);
    }
}
package brito.com.multitenancy001.infrastructure.exec;

import java.util.function.Supplier;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

@Component
public class TxExecutor {

    private final TransactionTemplate publicTx;
    private final TransactionTemplate publicRequiresNew;

    private final TransactionTemplate publicReadOnlyTx;
    private final TransactionTemplate publicRequiresNewReadOnly;

    private final TransactionTemplate tenantTx;
    private final TransactionTemplate tenantRequiresNew;

    private final TransactionTemplate tenantReadOnlyTx;
    private final TransactionTemplate tenantRequiresNewReadOnly;

    public TxExecutor(
            @Qualifier("publicTransactionManager") PlatformTransactionManager publicTm,
            @Qualifier("tenantTransactionManager") PlatformTransactionManager tenantTm
    ) {
        // PUBLIC - REQUIRED
        this.publicTx = new TransactionTemplate(publicTm);
        this.publicTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // PUBLIC - REQUIRES_NEW
        this.publicRequiresNew = new TransactionTemplate(publicTm);
        this.publicRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // PUBLIC - REQUIRED READONLY
        this.publicReadOnlyTx = new TransactionTemplate(publicTm);
        this.publicReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.publicReadOnlyTx.setReadOnly(true);

        // PUBLIC - REQUIRES_NEW READONLY
        this.publicRequiresNewReadOnly = new TransactionTemplate(publicTm);
        this.publicRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.publicRequiresNewReadOnly.setReadOnly(true);

        // TENANT - REQUIRED
        this.tenantTx = new TransactionTemplate(tenantTm);
        this.tenantTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // TENANT - REQUIRES_NEW
        this.tenantRequiresNew = new TransactionTemplate(tenantTm);
        this.tenantRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // TENANT - REQUIRED READONLY
        this.tenantReadOnlyTx = new TransactionTemplate(tenantTm);
        this.tenantReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.tenantReadOnlyTx.setReadOnly(true);

        // TENANT - REQUIRES_NEW READONLY
        this.tenantRequiresNewReadOnly = new TransactionTemplate(tenantTm);
        this.tenantRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.tenantRequiresNewReadOnly.setReadOnly(true);
    }

    // ---------- PUBLIC ----------
    public <T> T publicTx(Supplier<T> fn) {
        return publicTx.execute(status -> fn.get());
    }
    public void publicTx(Runnable fn) {
        publicTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNew(Supplier<T> fn) {
        return publicRequiresNew.execute(status -> fn.get());
    }
    public void publicRequiresNew(Runnable fn) {
        publicRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicReadOnlyTx(Supplier<T> fn) {
        return publicReadOnlyTx.execute(status -> fn.get());
    }
    public void publicReadOnlyTx(Runnable fn) {
        publicReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNewReadOnly(Supplier<T> fn) {
        return publicRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void publicRequiresNewReadOnly(Runnable fn) {
        publicRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }

    // ---------- TENANT ----------
    public <T> T tenantTx(Supplier<T> fn) {
        return tenantTx.execute(status -> fn.get());
    }
    public void tenantTx(Runnable fn) {
        tenantTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNew(Supplier<T> fn) {
        return tenantRequiresNew.execute(status -> fn.get());
    }
    public void tenantRequiresNew(Runnable fn) {
        tenantRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantReadOnlyTx(Supplier<T> fn) {
        return tenantReadOnlyTx.execute(status -> fn.get());
    }
    public void tenantReadOnlyTx(Runnable fn) {
        tenantReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNewReadOnly(Supplier<T> fn) {
        return tenantRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void tenantRequiresNewReadOnly(Runnable fn) {
        tenantRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
@EnableJpaRepositories(
    basePackages =  "brito.com.multitenancy001.controlplane",
    entityManagerFactoryRef = "publicEntityManagerFactory",
    transactionManagerRef = "publicTransactionManager"
)
public class ControlPlanePersistenceConfig {

    @Bean(name = "publicTransactionManager")
    @Primary
    public PlatformTransactionManager publicTransactionManager(
            @Qualifier("publicEntityManagerFactory") EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.extern.slf4j.Slf4j;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

@Slf4j
@Component
public class CurrentTenantSchemaResolver
        implements CurrentTenantIdentifierResolver<String> {

    private static final String DEFAULT_SCHEMA = "public";
    private static final ThreadLocal<String> TENANT_THREAD_LOCAL = new ThreadLocal<>();

    /**
     * Bind do tenant na thread atual.
     * - Se vier vazio/nulo: remove o tenant (fica "sem tenant", e o resolver decide fallback).
     * - Se vier preenchido: seta no ThreadLocal.
     */
    public static void bindTenantToCurrentThread(String tenantId) {
        String previous = TENANT_THREAD_LOCAL.get();

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (StringUtils.hasText(normalized)) {
            TENANT_THREAD_LOCAL.set(normalized);
            if (!normalized.equals(previous)) {
                log.info("üîÑ Tenant bindado √† thread: {} -> {}", previous, normalized);
            } else {
                log.debug("üîÑ Tenant j√° estava bindado: {}", normalized);
            }
        } else {
            TENANT_THREAD_LOCAL.remove();
            if (previous != null) {
                log.info("üßπ Tenant removido da thread (anterior: {})", previous);
            } else {
                log.debug("üßπ Tenant j√° estava vazio (nada para remover)");
            }
        }
    }

    /**
     * Retorna o tenant REALMENTE bindado.
     * ‚úÖ Importante: aqui retornamos null quando n√£o h√° tenant,
     * pra n√£o mascarar estado e facilitar debug.
     */
    public static String resolveBoundTenantOrNull() {
        String t = TENANT_THREAD_LOCAL.get();
        return StringUtils.hasText(t) ? t : null;
    }

    /**
     * Mant√©m compatibilidade com seu c√≥digo atual (ex.: logs do provider).
     * Use isso somente quando voc√™ quer um fallback expl√≠cito para public.
     */
    public static String resolveBoundTenantOrDefault() {
        String t = resolveBoundTenantOrNull();
        return (t != null ? t : DEFAULT_SCHEMA);
    }

    public static void unbindTenantFromCurrentThread() {
        String previous = TENANT_THREAD_LOCAL.get();
        TENANT_THREAD_LOCAL.remove();
        if (previous != null) {
            log.info("üßπ Tenant desbindado da thread (anterior: {})", previous);
        } else {
            log.debug("üßπ Tenant desbindado (j√° estava vazio)");
        }
    }

    /**
     * O Hibernate sempre precisa de um tenant v√°lido.
     * ‚úÖ Aqui sim a gente aplica fallback para DEFAULT_TENANT.
     */
    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenant = resolveBoundTenantOrNull();
        String resolved = (tenant != null ? tenant : DEFAULT_SCHEMA);

        if (log.isDebugEnabled()) {
            log.debug("üè∑Ô∏è Hibernate resolveu tenant={} (bound={}, default={})",
                    resolved, tenant, DEFAULT_SCHEMA);
        }
        return resolved;
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return false;
    }

    @Override
    public boolean isRoot(String tenantIdentifier) {
        return DEFAULT_SCHEMA.equals(tenantIdentifier);
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
@EnableJpaRepositories(
		basePackages = "brito.com.multitenancy001.tenant",
		entityManagerFactoryRef = "tenantEntityManagerFactory",
		transactionManagerRef = "tenantTransactionManager")
public class TenantPlanePersistenceConfig {

	@Bean(name = "tenantTransactionManager")
	public PlatformTransactionManager tenantTransactionManager(
			@Qualifier("tenantEntityManagerFactory") EntityManagerFactory emf) {
		return new JpaTransactionManager(emf);
	}
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.sql.DataSource;
import java.sql.*;

@Slf4j
@Component
@RequiredArgsConstructor
public class TenantSchemaConnectionProvider
        extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String> {

    private static final long serialVersionUID = 1L;
    private static final String DEFAULT_TENANT = "public";

    private final DataSource dataSource;

    @Override
    protected DataSource selectAnyDataSource() {
        return dataSource;
    }

    @Override
    protected DataSource selectDataSource(String tenantIdentifier) {
        return dataSource;
    }

    @Override
    public Connection getConnection(String tenantIdentifier) throws SQLException {

        long threadId = Thread.currentThread().threadId();
        String threadTenant = CurrentTenantSchemaResolver.resolveBoundTenantOrDefault();

        String effectiveTenant = StringUtils.hasText(tenantIdentifier)
                ? tenantIdentifier
                : DEFAULT_TENANT;

        if (!StringUtils.hasText(tenantIdentifier)) {
            log.warn("‚ö†Ô∏è [MT] tenantIdentifier vazio ‚Üí usando DEFAULT ({}) | threadTenant={}",
                    DEFAULT_TENANT, threadTenant);
        }

        validateSchemaName(effectiveTenant);

        Connection connection = dataSource.getConnection();

        try (Statement stmt = connection.createStatement()) {

            if (!DEFAULT_TENANT.equals(effectiveTenant)) {
                ensureSchemaExists(connection, effectiveTenant);

                String quotedTenant = quoteIdentifier(effectiveTenant);

                String setSearchPath = "SET search_path TO " + quotedTenant + ", public";
                log.info("üéØ [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL={}",
                        threadId, tenantIdentifier, threadTenant, setSearchPath);

                stmt.execute(setSearchPath);

            } else {
                log.info("üè† [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL=SET search_path TO public;",
                        threadId, tenantIdentifier, threadTenant);

                stmt.execute("SET search_path TO public;");
            }

            return connection;

        } catch (SQLException e) {
            log.error("‚ùå [MT] Erro configurando conex√£o | effectiveTenant={}", effectiveTenant, e);
            try { connection.close(); } catch (SQLException ignore) {}
            throw e;
        }
    }

    @Override
    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
        if (connection == null || connection.isClosed()) return;

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("SET search_path TO public;");
        } finally {
            connection.close();
        }
    }

    private void ensureSchemaExists(Connection connection, String schemaName) throws SQLException {
        String quotedSchema = quoteIdentifier(schemaName);

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE SCHEMA IF NOT EXISTS " + quotedSchema);
        }

        try (PreparedStatement ps = connection.prepareStatement(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = ?")) {
            ps.setString(1, schemaName);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    throw new SQLException("Schema " + schemaName + " n√£o encontrado ap√≥s CREATE");
                }
            }
        }
    }

    private void validateSchemaName(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new IllegalArgumentException("schemaName vazio");
        }
        if (!schemaName.matches("[A-Za-z_][A-Za-z0-9_]*")) {
            throw new IllegalArgumentException("schemaName inv√°lido: " + schemaName);
        }
    }

    private String quoteIdentifier(String identifier) {
        return "\"" + identifier + "\"";
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class TenantSchemaHibernateConfig {

    private final DataSource dataSource;
    private final TenantSchemaConnectionProvider multiTenantConnectionProvider;
    private final CurrentTenantSchemaResolver tenantResolver;

    @Bean(name = "publicEntityManagerFactory")
    @Primary
    public LocalContainerEntityManagerFactoryBean publicEntityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);
        emf.setPackagesToScan("brito.com.multitenancy001.controlplane.domain");
        emf.setPersistenceUnitName("PUBLIC_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();

        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);
        props.put("hibernate.default_schema", "public");

        emf.setJpaPropertyMap(props);
        return emf;
    }

    @Bean(name = "tenantEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);
        emf.setPackagesToScan("brito.com.multitenancy001.tenant.model");

 
        emf.setPersistenceUnitName("TENANT_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
  
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);

        // ‚úÖ multi-tenant via string keys (compat√≠vel)
        props.put("hibernate.multiTenancy", "SCHEMA");
        props.put("hibernate.multi_tenant_connection_provider", multiTenantConnectionProvider);
        props.put("hibernate.tenant_identifier_resolver", tenantResolver);

        emf.setJpaPropertyMap(props);
        return emf;
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
public class TransactionManagementConfig {
}
package brito.com.multitenancy001.infrastructure.multitenancy.observability;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Aspect
@Component
@Slf4j
public class TenantContextMonitor {
    
    @Around("@within(org.springframework.stereotype.Service)")
    public Object monitorServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        String currentTenant = TenantContext.getOrNull();
        
        log.debug("üèÅ IN√çCIO {} - Tenant: {}", methodName, currentTenant);
        
        try {
            Object result = joinPoint.proceed();
            log.debug("‚úÖ FIM {} - Tenant: {}", methodName, TenantContext.getOrNull());
            return result;
        } catch (Exception e) {
            log.error("‚ùå ERRO {} - Tenant: {} - Erro: {}", 
                     methodName, currentTenant, e.getMessage());
            throw e;
        }
    }
}package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.security.RoleAuthority;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.List;

@Getter
public class AuthenticatedUserContext implements UserDetails {

    private static final long serialVersionUID = 1L;

    private final Long userId;
    private final String username;
    private final String email;
    private final String password;

    private final boolean active;

    private final Long accountId;
    private final String schemaName;
    private final Collection<? extends GrantedAuthority> authorities;

    public AuthenticatedUserContext(ControlPlaneUser user, String schemaName, LocalDateTime now) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.password = user.getPassword();
        this.active = user.isEnabledForLogin(now);
        this.accountId = user.getAccount().getId();
        this.schemaName = schemaName;
        this.authorities = mapRolesToAuthorities(user.getRole());
    }

    public AuthenticatedUserContext(TenantUser user, String schemaName, LocalDateTime now) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.password = user.getPassword();
        this.active = user.isEnabledForLogin(now);
        this.accountId = user.getAccountId();
        this.schemaName = schemaName;
        this.authorities = mapRolesToAuthorities(user.getRole());
    }

    private List<GrantedAuthority> mapRolesToAuthorities(RoleAuthority role) {
        return List.of(new SimpleGrantedAuthority(role.asAuthority()));
    }

    @Override public Collection<? extends GrantedAuthority> getAuthorities() { return authorities; }
    @Override public String getPassword() { return password; }
    @Override public String getUsername() { return username; }
    @Override public boolean isAccountNonExpired() { return true; }
    @Override public boolean isAccountNonLocked() { return active; }
    @Override public boolean isCredentialsNonExpired() { return true; }
    @Override public boolean isEnabled() { return active; }
}
package brito.com.multitenancy001.infrastructure.security.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import brito.com.multitenancy001.infrastructure.security.filter.JwtAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig
    ) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(authz -> authz

                // üîì ACTUATOR HEALTH (PUBLIC)
                .requestMatchers("/actuator/health").permitAll()

                // üîì LOGIN / REFRESH (CONTROLPLANE)
                .requestMatchers(
                    "/api/admin/auth/login",
                    "/api/admin/auth/refresh"
                ).permitAll()

                // üîì LOGIN / REFRESH (TENANT)
                .requestMatchers(
                		"/api/tenant/auth/login",
                    "/api/auth/refresh",
                    "/api/accounts/auth/checkuser",
                    "/api/tenant/auth/forgot-password",
                    "/api/tenant/auth/reset-password",
                    "/api/signup"
                ).permitAll()

                // üîí CONTROLPLANE(AP√ìS LOGIN)
                .requestMatchers("/api/admin/**").hasRole("SUPER_ADMIN")

                .anyRequest().authenticated()
            )
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            );

        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
package brito.com.multitenancy001.infrastructure.security.filter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.context.TenantContext;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final UserDetailsService userDetailsService; // ‚úÖ Mant√©m interface

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        try {
            final String authHeader = request.getHeader("Authorization");

            if (!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
                filterChain.doFilter(request, response);
                return;
            }

            final String jwt = authHeader.substring(7);

            // 1) valida token (assinatura + expira√ß√£o)
            if (!jwtTokenProvider.validateToken(jwt)) {
                filterChain.doFilter(request, response);
                return;
            }

            // 2) extrai tenantSchema e binda ANTES de qualquer JPA
            final String tenantSchema = jwtTokenProvider.getTenantSchemaFromToken(jwt);
            TenantContext.bind(tenantSchema);

            // 3) autentica√ß√£o
            final String username = jwtTokenProvider.getUsernameFromToken(jwt);

            if (StringUtils.hasText(username)
                    && SecurityContextHolder.getContext().getAuthentication() == null) {

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities()
                        );

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }

            filterChain.doFilter(request, response);

        } finally {
            // 4) limpa sempre (anti vazamento)
            TenantContext.clear();
        }
    }
}
package brito.com.multitenancy001.infrastructure.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.stream.Collectors;

@Component
public class JwtTokenProvider {

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private long jwtExpirationInMs;

    @Value("${app.jwt.refresh.expiration}")
    private long refreshExpirationInMs;

    private SecretKey key;

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            throw new IllegalArgumentException("JWT secret must be at least 256 bits (32 chars)");
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    /* =========================
       TOKEN CONTROLPLANE (para usu√°rios da CONTROLPLANE)
       ========================= */
    public String generateControlPlaneToken(
            Authentication authentication,
            Long accountId,
            String context
    ) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
            .subject(user.getUsername())
            .claim("roles", user.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(",")))
            .claim("type", "CONTROLPLANE") 
            .claim("context", context)
            .claim("accountId", accountId)
            .claim("userId", user.getUserId())
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + jwtExpirationInMs))
            .signWith(key, Jwts.SIG.HS512)
            .compact();
    }

    /* =========================
       TOKEN TENANT (para usu√°rios dentro de um tenant)
       ========================= */
    public String generateTenantToken(
            Authentication authentication,
            Long accountId,
            String context
    ) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
            .subject(user.getUsername())
            .claim("roles", user.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(",")))
            .claim("type", "TENANT")
            .claim("context", context)
            .claim("accountId", accountId)
            .claim("userId", user.getUserId())
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + jwtExpirationInMs))
            .signWith(key, Jwts.SIG.HS512)
            .compact();
    }

    /* =========================
       REFRESH TOKEN (JWT)
       ========================= */
    public String generateRefreshToken(String username, String context) {
        return Jwts.builder()
            .subject(username)
            .claim("type", "REFRESH")
            .claim("context", context)
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + refreshExpirationInMs))
            .signWith(key, Jwts.SIG.HS512)
            .compact();
    }

    /* =========================
       PASSWORD RESET TOKEN
       ========================= */
    public String generatePasswordResetToken(
            String username,
            String context,
            Long accountId
    ) {
        return Jwts.builder()
            .subject(username)
            .claim("type", "PASSWORD_RESET")
            .claim("context", context)
            .claim("accountId", accountId)
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + 3600000)) // 1h
            .signWith(key, Jwts.SIG.HS512)
            .compact();
    }

    /* =========================
       LEITURA DE CLAIMS
       ========================= */
    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
            .verifyWith(key)
            .build()
            .parseSignedClaims(token)
            .getPayload();
    }

    public String getUsernameFromToken(String token) {
        return getAllClaimsFromToken(token).getSubject();
    }

    /**
     * Obt√©m o contexto do token (antigo tenantSchema)
     * Mant√©m compatibilidade retornando "tenantSchema" se "context" n√£o existir
     */
    public String getContextFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);
        
        // Tenta obter pelo novo nome "context"
        String context = claims.get("context", String.class);
        if (context != null) {
            return context;
        }
        
        // Fallback para compatibilidade com tokens antigos
        return claims.get("tenantSchema", String.class);
    }
    
    /**
     * M√©todo para compatibilidade (chama getContextFromToken)
     */
    public String getTenantSchemaFromToken(String token) {
        return getContextFromToken(token);
    }

    public Long getAccountIdFromToken(String token) {
        return getAllClaimsFromToken(token).get("accountId", Long.class);
    }

    public String getTokenType(String token) {
        return getAllClaimsFromToken(token).get("type", String.class);
    }

    public Long getUserIdFromToken(String token) {
        return getAllClaimsFromToken(token).get("userId", Long.class);
    }

    public boolean isTokenExpired(String token) {
        try {
            Claims claims = getAllClaimsFromToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(new Date());
        } catch (Exception e) {
            return true;
        }
    }

    public boolean validateToken(String token) {
        try {
            getAllClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    /* =========================
       M√âTODOS AUXILIARES
       ========================= */
    public boolean isControlPlaneToken(String token) {
        return "CONTROLPLANE".equals(getTokenType(token));
    }

    public boolean isTenantToken(String token) {
        return "TENANT".equals(getTokenType(token));
    }

    public boolean isRefreshToken(String token) {
        return "REFRESH".equals(getTokenType(token));
    }

    public boolean isPasswordResetToken(String token) {
        return "PASSWORD_RESET".equals(getTokenType(token));
    }
    
    /**
     * Verifica se o token √© de um contexto espec√≠fico
     */
    public boolean isTokenInContext(String token, String expectedContext) {
        String actualContext = getContextFromToken(token);
        return expectedContext.equals(actualContext);
    }
    
    /**
     * Verifica se o token √© do contexto da plataforma (public)
     */
    public boolean isControlPlaneContextToken(String token) {
        String context = getContextFromToken(token);
        return "public".equals(context);
    }
}package brito.com.multitenancy001.infrastructure.security;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.api.error.ApiException;

@Component
@RequiredArgsConstructor
public class SecurityUtils {
    
    public Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUserId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usu√°rio n√£o autenticado", 401);
    }
    
    public Long getCurrentAccountId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getAccountId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usu√°rio n√£o autenticado", 401);
    }
    
    public String getCurrentSchema() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getSchemaName();
        }
        throw new ApiException("UNAUTHENTICATED", "Usu√°rio n√£o autenticado", 401);
    }
    
    public String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUsername();
        }
        return authentication != null ? authentication.getName() : null;
    }
}package brito.com.multitenancy001.infrastructure.security.userdetails;



import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;

import java.time.Clock;
import java.time.LocalDateTime;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MultiContextUserDetailsService implements UserDetailsService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final TenantUserRepository tenantUserRepository;
    private final Clock clock;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String currentSchema = TenantContext.getOrNull();
        LocalDateTime now = LocalDateTime.now(clock);

        if ("public".equals(currentSchema) || currentSchema == null) {
            ControlPlaneUser user = controlPlaneUserRepository.findByUsernameAndDeletedFalse(username)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND","Usu√°rio account n√£o encontrado",404));

            return new AuthenticatedUserContext(user, "public", now);
        } else {
            TenantUser user = tenantUserRepository.findByUsernameAndDeletedFalse(username)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND","Usu√°rio n√£o encontrado no tenant",404));

            return new AuthenticatedUserContext(user, currentSchema, now);
        }
    }

    public UserDetails loadUserByUsernameAndSchema(String username, String schema) {
        LocalDateTime now = LocalDateTime.now(clock);

        if ("public".equals(schema)) {
            ControlPlaneUser user = controlPlaneUserRepository.findByUsernameAndDeletedFalse(username)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND","Usu√°rio account n√£o encontrado",404));

            return new AuthenticatedUserContext(user, schema, now);
        }

        throw new ApiException("INVALID_OPERATION","N√£o √© poss√≠vel carregar usu√°rio de tenant sem accountId",400);
    }
}
package brito.com.multitenancy001;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
//@EnableCaching
@EnableScheduling
public class Multitenancy001Application {

	public static void main(String[] args) {
		SpringApplication.run(Multitenancy001Application.class, args);
	}

}
package brito.com.multitenancy001.shared.api.dto.auth;



public record JwtResponse(
    String accessToken,
    String refreshToken,
    String tokenType,
    Long userId,
    String username,
    String email,
    String role,
    Long accountId,
    String tenantSchema
) {
    public JwtResponse {
        if (tokenType == null || tokenType.isEmpty()) {
            tokenType = "Bearer";
        }
    }
    
    // Constructor conveni√™ncia
    public JwtResponse(String accessToken, String refreshToken, 
                      Long userId, String username, String email, 
                      String role, Long accountId, String tenantSchema) {
        this(accessToken, refreshToken, "Bearer", 
             userId, username, email, role, accountId, tenantSchema);
    }
}package brito.com.multitenancy001.shared.api.error;



import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiEnumErrorResponse {
    private LocalDateTime timestamp;
    private String error;
    private String message;
    private String field;
    private String invalidValue;
    private List<String> allowedValues;
}package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
public class ApiErrorResponse {

    private LocalDateTime timestamp;
    private String error;
    private String message;

    // üî• novo campo (opcional)
    private List<String> details;
}
package brito.com.multitenancy001.shared.api.error;

import lombok.Getter;

@Getter
public class ApiException extends RuntimeException {

    private static final long serialVersionUID = 1L;
    private final String error;
    private final int status;
    private final Object details;
    private final Object[] allowedValues; // üî• NOVO CAMPO

    // Construtor sem allowedValues
    public ApiException(String error, String message, int status) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = null;
        this.allowedValues = null;
    }

    // Construtor com details
    public ApiException(String error, String message, int status, Object details) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = details;
        this.allowedValues = null;
    }

    // üî• NOVO CONSTRUTOR com allowedValues
    public ApiException(String error, String message, int status, Object details, Object[] allowedValues) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = details;
        this.allowedValues = allowedValues;
    }

    // M√©todo para obter allowedValues
    public Object[] getAllowedValues() {
        return allowedValues;
    }

    // M√©todo para verificar se tem allowedValues
    public boolean hasAllowedValues() {
        return allowedValues != null && allowedValues.length > 0;
    }
}package brito.com.multitenancy001.shared.api.error;

import com.fasterxml.jackson.databind.exc.InvalidFormatException;

import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleNotReadable(HttpMessageNotReadableException ex) {
        
        Throwable cause = ex.getCause();
        
        if (cause instanceof InvalidFormatException ife) {
            Class<?> targetType = ife.getTargetType();
            
            if (targetType != null && targetType.isEnum()) {
                String fieldName = ife.getPath().isEmpty() ? "status" : ife.getPath().get(0).getFieldName();
                String invalidValue = ife.getValue() != null ? ife.getValue().toString() : "null";
                
                List<String> allowedValues = Arrays.stream(targetType.getEnumConstants())
                    .map(Object::toString)
                    .toList();
                
                return ResponseEntity.badRequest().body(
                    ApiEnumErrorResponse.builder()
                        .timestamp(LocalDateTime.now())
                        .error("INVALID_ENUM")
                        .message("Valor inv√°lido para o campo " + fieldName)
                        .field(fieldName)
                        .invalidValue(invalidValue)
                        .allowedValues(allowedValues)
                        .build()
                );
            }
        }
        
        return ResponseEntity.badRequest().body(
            ApiEnumErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error("INVALID_REQUEST_BODY")
                .message("Corpo da requisi√ß√£o inv√°lido")
                .build()
        );
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        
        String errorMessage = ex.getMostSpecificCause().getMessage();
        
        // Log para debug
        System.out.println("=== DEBUG DataIntegrityViolationException ===");
        System.out.println("Error message: " + errorMessage);
        
        // Verifica qual constraint foi violada
        if (errorMessage.contains("company_doc_number")) {
            String cnpj = extractValue(errorMessage, "company_doc_number");
            return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                    .timestamp(LocalDateTime.now())
                    .error("DUPLICATE_CNPJ")
                    .message("J√° existe uma conta com o CNPJ " + cnpj)
                    .field("companyDocNumber")
                    .invalidValue(cnpj)
                    .build()
            );
        }
        
        if (errorMessage.contains("company_email")) {
            String email = extractValue(errorMessage, "company_email");
            return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                    .timestamp(LocalDateTime.now())
                    .error("DUPLICATE_EMAIL")
                    .message("J√° existe uma conta com o email " + email)
                    .field("companyEmail")
                    .invalidValue(email)
                    .build()
            );
        }
        
        if (errorMessage.contains("slug")) {
            String slug = extractValue(errorMessage, "slug");
            return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                    .timestamp(LocalDateTime.now())
                    .error("DUPLICATE_SLUG")
                    .message("J√° existe uma conta com o slug " + slug)
                    .field("slug")
                    .invalidValue(slug)
                    .build()
            );
        }
        
        if (errorMessage.contains("schema_name")) {
            String schema = extractValue(errorMessage, "schema_name");
            return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                    .timestamp(LocalDateTime.now())
                    .error("DUPLICATE_SCHEMA")
                    .message("Erro interno: schema " + schema + " j√° existe")
                    .build()
            );
        }
        
        // Caso gen√©rico
        return ResponseEntity.status(409).body(
            ApiEnumErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error("DUPLICATE_ENTRY")
                .message("Registro duplicado. Verifique os dados informados.")
                .build()
        );
    }
    
    private String extractValue(String message, String fieldName) {
        try {
            // Padr√£o para PostgreSQL: "Chave (company_doc_number)=(4254567235667712) j√° existe."
            Pattern pattern = Pattern.compile("\\(" + fieldName + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher = pattern.matcher(message);
            
            if (matcher.find()) {
                return matcher.group(1);
            }
            
            // Padr√£o alternativo: "Key (company_doc_number)=(value) already exists."
            Pattern pattern2 = Pattern.compile("Key \\(" + fieldName + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher2 = pattern2.matcher(message);
            
            if (matcher2.find()) {
                return matcher2.group(1);
            }
            
        } catch (Exception e) {
            System.out.println("Erro ao extrair valor: " + e.getMessage());
        }
        
        return "n√£o identificado";
    }

    @ExceptionHandler(ApiException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleApi(ApiException ex) {
        return ResponseEntity.status(ex.getStatus()).body(
            ApiEnumErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error(ex.getError())
                .message(ex.getMessage())
                .build()
        );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiEnumErrorResponse> handleGeneric(Exception ex) {
        // üî• REMOVA os logs de debug do handler gen√©rico
        // System.out.println("=== DEBUG Generic Exception ===");
        // System.out.println("Exception type: " + ex.getClass().getName());
        // System.out.println("Message: " + ex.getMessage());
        // ex.printStackTrace();
        
        return ResponseEntity.internalServerError().body(
            ApiEnumErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error("INTERNAL_SERVER_ERROR")
                .message("Erro interno inesperado. Contate o suporte.")
                .build()
        );
    }
    
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiErrorResponse> handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .toList();
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error("VALIDATION_ERROR")
                .message("Erro de valida√ß√£o")
                .details(errors)
                .build();
        
        return ResponseEntity.badRequest().body(errorResponse);
    }
    
    
    
}package brito.com.multitenancy001.shared.context;

import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.infrastructure.multitenancy.hibernate.CurrentTenantSchemaResolver;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TenantContext {

    public static String getOrNull() {
        return CurrentTenantSchemaResolver.resolveBoundTenantOrDefault();
    }

    public static void bind(String tenantId) {
        if (TransactionSynchronizationManager.isActualTransactionActive()) {
            log.error("üî• ERRO GRAVE: bindTenant chamado DENTRO de transa√ß√£o! tenant={}", tenantId);
        }

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (!StringUtils.hasText(normalized)) {
            CurrentTenantSchemaResolver.bindTenantToCurrentThread(null);
            log.info("üîÑ Tenant limpo (sem tenant) | thread={}", Thread.currentThread().threadId());
            return;
        }

        CurrentTenantSchemaResolver.bindTenantToCurrentThread(normalized);
        log.info("üîÑ Tenant bindado | thread={} | tenant={}",
                Thread.currentThread().threadId(),
                normalized);
    }

    public static void clear() {
        CurrentTenantSchemaResolver.unbindTenantFromCurrentThread();
        log.info("üßπ Tenant desbindado | thread={}", Thread.currentThread().threadId());
    }

    // ‚úÖ NOVO: escopo seguro
    public static Scope scope(String tenantId) {
        bind(tenantId);
        return new Scope();
    }

    // ‚úÖ NOVO: escopo PUBLIC expl√≠cito (garante que n√£o ficou tenant pendurado)
    public static Scope publicScope() {
        clear();
        return new Scope();
    }

    public static final class Scope implements AutoCloseable {
        private boolean closed = false;

        private Scope() {}

        @Override
        public void close() {
            if (!closed) {
                TenantContext.clear();
                closed = true;
            }
        }
    }
}
package brito.com.multitenancy001.shared.security;

/**
 * Contrato comum para roles da plataforma e do tenant
 * Permite unifica√ß√£o no Spring Security (GrantedAuthority)
 */
public interface RoleAuthority {

    /**
     * Retorna a authority no padr√£o Spring Security
     * Ex: ROLE_SUPER_ADMIN, ROLE_TENANT_ADMIN
     */
    String asAuthority();

    /**
     * Helper padr√£o (opcional)
     */
    default boolean isAdmin() {
        return false;
    }
}
package brito.com.multitenancy001.shared.validation; // ou .validation

/**
 * Padr√µes de valida√ß√£o reutiliz√°veis em todo o sistema
 */
public final class ValidationPatterns {
    
    // Username: 3-50 caracteres, letras, n√∫meros, ponto, underscore, h√≠fen
   // public static final String USERNAME_PATTERN = "^[a-zA-Z0-9._-]{3,50}$";
	
	
	// usado pra facilidar no desenvolvimento
	// Username: 3-50 caracteres, APENAS letras (a-z, A-Z) e n√∫meros (0-9)
	public static final String USERNAME_PATTERN = "^[a-zA-Z0-9._-]{3,50}$";
    
    // Password: m√≠nimo 8 caracteres, pelo menos 1 letra mai√∫scula, 1 min√∫scula e 1 n√∫mero
   // public static final String PASSWORD_PATTERN = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$";

    
    
 // ‚ö†Ô∏è APENAS PARA TESTE/DEV - NUNCA EM PRODU√á√ÉO!
    // Password: m√≠nimo 3 caracteres, apenas letras (mai√∫sculas/min√∫sculas)
    // N√£o precisa de n√∫meros nem caracteres especiais
	  public static final String PASSWORD_PATTERN = "^[a-zA-Z0-9]{3,}$";
    
    
    
    
    
    
    // Email: valida√ß√£o b√°sica (Spring j√° tem @Email, mas para refer√™ncia)
    public static final String EMAIL_PATTERN = "^[A-Za-z0-9+_.-]+@(.+)$";
    
    // Nome: apenas letras, espa√ßos e alguns caracteres especiais
    public static final String NAME_PATTERN = "^[a-zA-Z√Ä-√ø\\s'-]{2,100}$";
    
    // Telefone: formato brasileiro
    public static final String PHONE_PATTERN = "^(\\(?\\d{2}\\)?)?\\s?\\d{4,5}-?\\d{4}$";
    
    // CNPJ: formato brasileiro
    public static final String CNPJ_PATTERN = "^\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}$";
    
    // CPF: formato brasileiro
    public static final String CPF_PATTERN = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$";
    
    // CEP: formato brasileiro
    public static final String CEP_PATTERN = "^\\d{5}-\\d{3}$";
    
    // URL: para avatar_url, website, etc.
    public static final String URL_PATTERN = "^(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?$";
    
    // Timezone: formato padr√£o (America/Sao_Paulo)
    public static final String TIMEZONE_PATTERN = "^[A-Za-z_]+/[A-Za-z_]+$";
    
    // Locale: pt_BR, en_US, etc.
    public static final String LOCALE_PATTERN = "^[a-z]{2}_[A-Z]{2}$";
    
    // Currency: BRL, USD, EUR (3 letras)
    public static final String CURRENCY_PATTERN = "^[A-Z]{3}$";
    
    // Hex color: #FFFFFF ou #FFF
    public static final String COLOR_PATTERN = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
    
    // IP Address
    public static final String IP_PATTERN = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
    
    // UUID
    public static final String UUID_PATTERN = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";
    
    // Permiss√µes: UPPER_CASE_WITH_UNDERSCORE
    public static final String PERMISSION_PATTERN = "^[A-Z_]+$";
    
    private ValidationPatterns() {
        // Construtor privado para classe utilit√°ria
        throw new UnsupportedOperationException("Classe utilit√°ria - n√£o instanci√°vel");
    }
    
    /**
     * Valida se um valor corresponde ao padr√£o
     */
    public static boolean isValid(String value, String pattern) {
        return value != null && value.matches(pattern);
    }
    
    /**
     * Valida username com mensagem descritiva
     */
    public static void validateUsername(String username) {
        if (username == null || !username.matches(USERNAME_PATTERN)) {
            throw new IllegalArgumentException(
                "Username deve ter 3-50 caracteres e conter apenas: " +
                "letras (a-z, A-Z), n√∫meros (0-9), ponto (.), underscore (_), h√≠fen (-)"
            );
        }
    }
    
    /**
     * Valida password com mensagem descritiva
     */
    public static void validatePassword(String password) {
        if (password == null || !password.matches(PASSWORD_PATTERN)) {
            throw new IllegalArgumentException(
                "Senha deve ter pelo menos 8 caracteres contendo: " +
                "1 letra mai√∫scula, 1 letra min√∫scula e 1 n√∫mero"
            );
        }
    }
}package brito.com.multitenancy001.tenant.api.controller.auth;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.tenant.api.dto.auth.ForgotPasswordRequest;
import brito.com.multitenancy001.tenant.api.dto.auth.ResetPasswordRequest;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.application.TenantAuthService;
import brito.com.multitenancy001.tenant.application.TenantUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/tenant/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantAuthController {

	private final TenantAuthService tenantAuthService;
	private final TenantUserService tenantUserService;

	@PostMapping("/login")
	public ResponseEntity<JwtResponse> loginTenant(@Valid @RequestBody TenantLoginRequest request) {

		JwtResponse response = tenantAuthService.loginTenant(request);
		return ResponseEntity.ok(response);
	}

	@PostMapping("/forgot-password")
	public ResponseEntity<String> forgotPassword(@Valid @RequestBody ForgotPasswordRequest req) {
	    tenantUserService.generatePasswordResetToken(req.slug(), req.email());
	    return ResponseEntity.ok("Token gerado");
	}
	
	
	@PostMapping("/reset-password")
	public ResponseEntity<String> resetPassword(@Valid @RequestBody ResetPasswordRequest req) {
	    tenantUserService.resetPasswordWithToken(req.token(), req.newPassword());
	    return ResponseEntity.ok("Senha redefinida com sucesso");
	}


}
package brito.com.multitenancy001.tenant.api.controller.products;

import brito.com.multitenancy001.tenant.api.dto.products.ProductUpsertRequest;
import brito.com.multitenancy001.tenant.api.mapper.ProductApiMapper;
import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.application.TenantProductService;
import brito.com.multitenancy001.tenant.model.Category;
import brito.com.multitenancy001.tenant.model.Product;
import brito.com.multitenancy001.tenant.model.Subcategory;
import brito.com.multitenancy001.tenant.model.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class TenantProductController {
	
	private final ProductApiMapper productApiMapper;

	private final TenantProductService tenantProductService;

	// Novos endpoints para os campos adicionais

	@GetMapping("/category/{categoryId}")
	@PreAuthorize("hasAnyRole('ADMIN', 'PRODUCT_MANAGER', 'VIEWER')")
	public ResponseEntity<List<ProductResponse>> getProductsByCategory(@PathVariable Long categoryId) {
	    List<Product> products = tenantProductService.findByCategoryId(categoryId);
	    List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
	    return ResponseEntity.ok(dtos);
	}


	@GetMapping("/brand/{brand}")
	@PreAuthorize("hasAnyRole('ADMIN', 'PRODUCT_MANAGER', 'VIEWER')")
	public ResponseEntity<List<ProductResponse>> getProductsByBrand(@PathVariable String brand) {
		List<Product> products = tenantProductService.findByBrand(brand);
		List<ProductResponse> productDTOs = products.stream().map(productApiMapper::toResponse).collect(Collectors.toList());
		return ResponseEntity.ok(productDTOs);
	}

	@GetMapping("/active")
	@PreAuthorize("hasAnyRole('ADMIN', 'PRODUCT_MANAGER', 'VIEWER')")
	public ResponseEntity<List<ProductResponse>> getActiveProducts() {
		List<Product> products = tenantProductService.findActiveProducts();
		List<ProductResponse> productDTOs = products.stream().map(productApiMapper::toResponse).collect(Collectors.toList());
		return ResponseEntity.ok(productDTOs);
	}

	@PatchMapping("/{id}/cost-price")
	@PreAuthorize("hasAnyRole('ADMIN', 'PRODUCT_MANAGER')")
	public ResponseEntity<ProductResponse> updateCostPrice(@PathVariable UUID id, @RequestParam BigDecimal costPrice) {

		Product updatedProduct = tenantProductService.updateCostPrice(id, costPrice);
		return ResponseEntity.ok(productApiMapper.toResponse(updatedProduct));
	}

	@GetMapping("/inventory-value")
	@PreAuthorize("hasAnyRole('ADMIN', 'PRODUCT_MANAGER')")
	public ResponseEntity<BigDecimal> getTotalInventoryValue() {
		BigDecimal value = tenantProductService.calculateTotalInventoryValue();
		return ResponseEntity.ok(value != null ? value : BigDecimal.ZERO);
	}

	@GetMapping("/low-stock/count")
	@PreAuthorize("hasAnyRole('ADMIN', 'PRODUCT_MANAGER')")
	public ResponseEntity<Long> countLowStockProducts(@RequestParam(defaultValue = "10") Integer threshold) {

		Long count = tenantProductService.countLowStockProducts(threshold);
		return ResponseEntity.ok(count != null ? count : 0L);
	}

	@PatchMapping("/{id}/toggle-active")
	@PreAuthorize("hasAnyRole('ADMIN', 'PRODUCT_MANAGER')")
	public ResponseEntity<ProductResponse> toggleActive(@PathVariable UUID id) {
		Product product = tenantProductService.findById(id);
		product.setActive(!Boolean.TRUE.equals(product.getActive()));
		tenantProductService.create(product); // Reutiliza o m√©todo save
		return ResponseEntity.ok(productApiMapper.toResponse(product));
	}

	@PostMapping("/detailed")
	@PreAuthorize("hasAnyRole('ADMIN', 'PRODUCT_MANAGER')")
	public ResponseEntity<ProductResponse> createDetailedProduct(@Valid @RequestBody ProductUpsertRequest request) {

		Product product = new Product();
		product.setName(request.name());
		product.setDescription(request.description());
		product.setSku(request.sku());
		product.setPrice(request.price());
		product.setStockQuantity(request.stockQuantity());
		product.setMinStock(request.minStock());
		product.setMaxStock(request.maxStock());
		product.setCostPrice(request.costPrice());
		product.setBrand(request.brand());
		product.setWeightKg(request.weightKg());
		product.setDimensions(request.dimensions());
		product.setBarcode(request.barcode());
		product.setActive(request.active());

		// ‚úÖ Category obrigat√≥ria
		Category category = new Category();
		category.setId(request.categoryId());
		product.setCategory(category);

		// ‚úÖ Subcategory opcional
		if (request.subcategoryId() != null) {
			Subcategory sub = new Subcategory();
			sub.setId(request.subcategoryId());
			product.setSubcategory(sub);
		}

		// Supplier (como voc√™ j√° fazia)
		if (request.supplierId() != null) {
			Supplier supplier = new Supplier();
			 supplier.setId(request.supplierId());
			product.setSupplier(supplier);
		}

		Product savedProduct = tenantProductService.create(product);
		return ResponseEntity.status(HttpStatus.CREATED).body(productApiMapper.toResponse(savedProduct));
	}

}package brito.com.multitenancy001.tenant.api.controller.users.admin;

import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.tenant.api.dto.users.admin.TenantUserAdminSuspendRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/users")
@PreAuthorize("hasRole('TENANT_ADMIN')")
@RequiredArgsConstructor
public class TenantUserAdminController {

    private final AccountLifecycleService accountLifecycleService;

    @PatchMapping("/{userId}/suspend")
    public ResponseEntity<Void> suspendUser(
            @PathVariable Long userId,
            @RequestBody TenantUserAdminSuspendRequest req,
            @AuthenticationPrincipal AuthenticatedUserContext me
    ) {
        accountLifecycleService.setUserSuspendedByAdmin(me.getAccountId(), userId, req.suspended());
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.tenant.api.controller.users;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.application.TenantUserService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/users")
@RequiredArgsConstructor
public class TenantUserController {
    
    private final TenantUserService tenantUserService;
    
    @PostMapping
    @PreAuthorize("hasRole('TENANT_ADMIN')")
    public ResponseEntity<TenantUserDetailsResponse> createTenantUser(
            @Valid @RequestBody TenantUserCreateRequest request) {
    	TenantUserDetailsResponse response = tenantUserService.createTenantUser(request);
                                               
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
    
    @GetMapping
    @PreAuthorize("hasAnyRole( 'TENANT_ADMIN', 'PRODUCT_MANAGER', 'SALES_MANAGER', 'VIEWER')")
    public ResponseEntity<List<AccountUserSummaryResponse>> listTenantUsers() {
        List<AccountUserSummaryResponse> users = tenantUserService.listTenantUsers();
        return ResponseEntity.ok(users);
    }
    
    @GetMapping("/active")
    @PreAuthorize("hasAnyRole( 'TENANT_ADMIN', 'PRODUCT_MANAGER', 'SALES_MANAGER')")
    public ResponseEntity<List<AccountUserSummaryResponse>> listActiveTenantUsers() {
        List<AccountUserSummaryResponse> users = tenantUserService.listActiveTenantUsers();
        return ResponseEntity.ok(users);
    }
    
    @GetMapping("/{userId}")
    @PreAuthorize("hasAnyRole( 'TENANT_ADMIN', 'PRODUCT_MANAGER', 'SALES_MANAGER')")
    public ResponseEntity<TenantUserDetailsResponse> getTenantUser(@PathVariable Long userId) {
    	TenantUserDetailsResponse user = tenantUserService.getTenantUser(userId);
        return ResponseEntity.ok(user);
    }
    
    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAnyRole( 'TENANT_ADMIN')")
    public ResponseEntity<AccountUserSummaryResponse> updateTenantUserStatus(
            @PathVariable Long userId,
            @RequestParam boolean active) {
    	AccountUserSummaryResponse response = tenantUserService.updateTenantUserStatus(userId, active);
        return ResponseEntity.ok(response);
    }
    
    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAnyRole( 'TENANT_ADMIN')")
    public ResponseEntity<Void> deleteTenantUser(@PathVariable Long userId) {
        tenantUserService.softDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }
    
    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAnyRole('TENANT_ADMIN')")
    public ResponseEntity<AccountUserSummaryResponse> restoreTenantUser(@PathVariable Long userId) {
    	AccountUserSummaryResponse response = tenantUserService.restoreTenantUser(userId);
        return ResponseEntity.ok(response);
    }
    
    @PatchMapping("/{userId}/password")
    @PreAuthorize("hasAnyRole('TENANT_ADMIN')")
    public ResponseEntity<AccountUserSummaryResponse> resetTenantUserPassword(
            @PathVariable Long userId,
            @RequestParam
            @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN,
                 message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas e n√∫meros")
           String newPassword) {
    	AccountUserSummaryResponse response = tenantUserService.resetTenantUserPassword(userId, newPassword);
        return ResponseEntity.ok(response);
    }
    
    @DeleteMapping("/{userId}/hard")
    @PreAuthorize("hasRole('TENANT_ADMIN')")
    public ResponseEntity<Void> hardDeleteTenantUser(@PathVariable Long userId) {
        tenantUserService.hardDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }
}package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ForgotPasswordRequest(
        @NotBlank String slug,
        @NotBlank @Email String email
) {}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record ResetPasswordRequest(
        @NotBlank String token,
        @NotBlank
        @Pattern(
          regexp = ValidationPatterns.PASSWORD_PATTERN,
          message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas, n√∫meros e caracteres especiais"
        )
        String newPassword
) {}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record TenantLoginRequest(
	    @NotBlank String username,
	    @NotBlank String password,
	    @NotBlank String slug
	) {}
package brito.com.multitenancy001.tenant.api.dto.products;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

public record ProductResponse(
        UUID id,
        @NotBlank String name,
        String description,
        String sku,
        @NotNull @PositiveOrZero BigDecimal price,
        @PositiveOrZero Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        BigDecimal profitMargin,

        Long categoryId,
        String categoryName,
        Long subcategoryId,
        String subcategoryName,

        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,

        UUID supplierId,
        String supplierName,

        LocalDateTime createdAt,
        LocalDateTime updatedAt
) {
    public ProductResponse {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }

  
}
package brito.com.multitenancy001.tenant.api.dto.products;

import java.math.BigDecimal;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

// Record para cria√ß√£o/atualiza√ß√£o expandido (com Category/Subcategory por ID)
public record ProductUpsertRequest(
     @NotBlank String name,
     String description,
     String sku,
     @NotNull @PositiveOrZero BigDecimal price,
     @PositiveOrZero Integer stockQuantity,
     Integer minStock,
     Integer maxStock,
     BigDecimal costPrice,

     @NotNull Long categoryId,     // ‚úÖ obrigat√≥rio
     Long subcategoryId,           // ‚úÖ opcional

     String brand,
     BigDecimal weightKg,
     String dimensions,
     String barcode,
     Boolean active,
     UUID supplierId
) {
    public ProductUpsertRequest {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}
package brito.com.multitenancy001.tenant.api.dto.users.admin;

public record TenantUserAdminSuspendRequest(boolean suspended) {}package brito.com.multitenancy001.tenant.api.dto.users;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.List;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;

@Builder
public record TenantUserCreateRequest(
    
    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String name,
    
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, 
             message = "Username inv√°lido. Use apenas letras, n√∫meros, . e _")
    @Size(min = 3, max = 50, message = "Username deve ter entre 3 e 50 caracteres")
    String username,
    
    @NotBlank(message = "Email √© obrigat√≥rio")
    @Email(message = "Email inv√°lido")
    @Size(max = 150, message = "Email n√£o pode exceder 150 caracteres")
    String email,
    
    @NotBlank(message = "Senha √© obrigat√≥ria")
    @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, 
             message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas, n√∫meros e caracteres especiais")
    String password,
    
    @NotBlank(message = "Role √© obrigat√≥ria")
    @Pattern(regexp = "TENANT_ADMIN|MANAGER|VIEWER|USER", message = "Role inv√°lida")
    String role,
    
    List<String> permissions,
    
    // üîπ CAMPOS NOVOS para UserTenant
    @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, 
             message = "Telefone inv√°lido")
    @Size(max = 20, message = "Telefone n√£o pode exceder 20 caracteres")
    String phone,
    
    @Size(max = 500, message = "URL do avatar n√£o pode exceder 500 caracteres")
    String avatarUrl
    
) {
    
    public TenantUserCreateRequest {
        if (phone != null) {
            phone = phone.trim();
        }
        if (avatarUrl != null) {
            avatarUrl = avatarUrl.trim();
        }
    }
}package brito.com.multitenancy001.tenant.api.dto.users;

import java.time.LocalDateTime;
import java.util.List;

import brito.com.multitenancy001.tenant.domain.user.TenantUser;

public record TenantUserDetailsResponse(
        Long id,
        String username,
        String name,
        String email,
        String role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled,
        LocalDateTime createdAt,
        LocalDateTime updatedAt,
        Long accountId,
        List<String> permissions
) {
    public TenantUserDetailsResponse {
        if (permissions == null) permissions = List.of();
    }

    public static TenantUserDetailsResponse from(TenantUser u) {
        boolean enabled = !u.isDeleted() && !u.isSuspendedByAccount() && !u.isSuspendedByAdmin();
        return new TenantUserDetailsResponse(
                u.getId(),
                u.getUsername(),
                u.getName(),
                u.getEmail(),
                u.getRole() != null ? u.getRole().name() : null,
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                enabled,
                u.getCreatedAt(),
                u.getUpdatedAt(),
                u.getAccountId(),
                u.getPermissions()
        );
    }
}
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.model.Product;

@Component
public class ProductApiMapper {

    public ProductResponse toResponse(Product product) {
        return new ProductResponse(
            product.getId(),
            product.getName(),
            product.getDescription(),
            product.getSku(),
            product.getPrice(),
            product.getStockQuantity(),
            product.getMinStock(),
            product.getMaxStock(),
            product.getCostPrice(),
            product.getProfitMargin(),

            product.getCategory() != null ? product.getCategory().getId() : null,
            product.getCategory() != null ? product.getCategory().getName() : null,
            product.getSubcategory() != null ? product.getSubcategory().getId() : null,
            product.getSubcategory() != null ? product.getSubcategory().getName() : null,

            product.getBrand(),
            product.getWeightKg(),
            product.getDimensions(),
            product.getBarcode(),
            product.getActive(),

            product.getSupplier() != null ? product.getSupplier().getId() : null,
            product.getSupplier() != null ? product.getSupplier().getName() : null,

            product.getCreatedAt(),
            product.getUpdatedAt()
        );
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProvisioningService {

    private final TenantSchemaProvisioningService tenantSchemaService;

    public void createSchemaAndMigrate(String schemaName) {
        tenantSchemaService.schemaMigrationService(schemaName);
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import lombok.RequiredArgsConstructor;
import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;

@Service
@RequiredArgsConstructor
public class TenantSchemaMigrationService {

    private final DataSource dataSource;

    public void migrateTenant(String schemaName) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas(schemaName)
                .defaultSchema(schemaName) // üî• ESSENCIAL
                .createSchemas(false)
                .locations("classpath:db/migration/tenants")
                .baselineOnMigrate(true)
                .load();

        flyway.migrate();
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.domain.user.TenantRole;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Slf4j
@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningService {

    private final JdbcTemplate jdbcTemplate;
    private final TenantSchemaMigrationService tenantSchemaMigrationService;
    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;

    public boolean schemaExists(String schemaName) {
        if (!StringUtils.hasText(schemaName) || "public".equals(schemaName)) return false;

        String sql = "SELECT EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = ?)";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, schemaName);
        return Boolean.TRUE.equals(exists);
    }

    public boolean validateTenantSchema(String schemaName) {
        return schemaExists(schemaName);
    }

    public boolean tableExists(String schemaName, String tableName) {
        if (!StringUtils.hasText(schemaName) || !StringUtils.hasText(tableName)) return false;

        String sql =
                "SELECT EXISTS(" +
                "  SELECT 1 FROM information_schema.tables " +
                "  WHERE table_schema = ? AND table_name = ?" +
                ")";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, schemaName, tableName);
        return Boolean.TRUE.equals(exists);
    }

    public void schemaMigrationService(String schemaName) {
        if (!StringUtils.hasText(schemaName) || "public".equals(schemaName)) {
            throw new ApiException("INVALID_SCHEMA", "Schema inv√°lido", 400);
        }

        if (!schemaExists(schemaName)) {
            log.info("üì¶ Criando schema {}", schemaName);
            jdbcTemplate.execute("CREATE SCHEMA IF NOT EXISTS \"" + schemaName + "\"");
        }

        log.info("üß¨ Rodando migrations do tenant: {}", schemaName);
        tenantSchemaMigrationService.migrateTenant(schemaName);
    }

    /**
     * Deve ser chamado com TenantContext j√° bindado no schema do tenant
     */
    public TenantUser tenantAdminBootstrapService(Account account, String username, String email, String rawPassword) {
        String bound = TenantContext.getOrNull();
        if (bound == null || !bound.equals(account.getSchemaName())) {
            throw new ApiException("TENANT_NOT_BOUND", "Tenant n√£o est√° bindado no schema esperado", 500);
        }

        String normUsername = username == null ? null : username.trim().toLowerCase();
        String normEmail = email == null ? null : email.trim().toLowerCase();

        if (!StringUtils.hasText(normUsername)) {
            throw new ApiException("INVALID_USERNAME", "Username √© obrigat√≥rio", 400);
        }
        if (!StringUtils.hasText(normEmail)) {
            throw new ApiException("INVALID_EMAIL", "Email √© obrigat√≥rio", 400);
        }

        boolean existsUser = tenantUserRepository.existsByUsernameAndAccountId(normUsername, account.getId());
        boolean existsEmail = tenantUserRepository.existsByEmailAndAccountId(normEmail, account.getId());

        if (existsUser) throw new ApiException("ADMIN_EXISTS", "J√° existe usu√°rio com este username", 409);
        if (existsEmail) throw new ApiException("ADMIN_EXISTS", "J√° existe usu√°rio com este email", 409);

        TenantUser admin = TenantUser.builder()
                .accountId(account.getId())
                .name("Administrador")
                .username(normUsername)
                .email(normEmail)
                .password(passwordEncoder.encode(rawPassword))
                .role(TenantRole.TENANT_ADMIN)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .timezone(account.getTimezone() != null ? account.getTimezone() : "America/Sao_Paulo")
                .locale(account.getLocale() != null ? account.getLocale() : "pt_BR")
                .build();

        return tenantUserRepository.save(admin);
    }
}
package brito.com.multitenancy001.tenant.application;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantAuthService {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final AccountRepository accountRepository;
    private final TenantUserRepository tenantUserRepository;

    public JwtResponse loginTenant(TenantLoginRequest request) {

        // 1Ô∏è‚É£ PUBLIC ‚Äî resolve conta
        TenantContext.clear();

        Account account = accountRepository
                .findBySlugAndDeletedFalse(request.slug())
                .orElseThrow(() -> new ApiException(
                        "ACCOUNT_NOT_FOUND",
                        "Conta n√£o encontrada",
                        404
                ));

        if (!account.isActive()) {
            throw new ApiException(
                    "ACCOUNT_INACTIVE",
                    "Conta inativa",
                    403
            );
        }

        // 2Ô∏è‚É£ TENANT ‚Äî bind correto
        TenantContext.bind(account.getSchemaName());

        try {
            Authentication authentication =
                    authenticationManager.authenticate(
                            new UsernamePasswordAuthenticationToken(
                                    request.username(),
                                    request.password()
                            )
                    );

            TenantUser user = tenantUserRepository
                    .findByUsernameAndAccountId(
                            request.username(),
                            account.getId()
                    )
                    .orElseThrow(() -> new ApiException(
                            "USER_NOT_FOUND",
                            "Usu√°rio n√£o encontrado",
                            404
                    ));

            if (user.isSuspendedByAccount() || user.isDeleted()) {
                throw new ApiException(
                        "USER_INACTIVE",
                        "Usu√°rio inativo",
                        403
                );
            }

            String accessToken = tokenProvider.generateTenantToken(
                    authentication,
                    account.getId(),
                    account.getSchemaName()
            );

            String refreshToken = tokenProvider.generateRefreshToken(
                    user.getUsername(),
                    account.getSchemaName()
            );

            return new JwtResponse(
                    accessToken,
                    refreshToken,
                    user.getId(),
                    user.getUsername(),
                    user.getEmail(),
                    user.getRole().name(),
                    account.getId(),
                    account.getSchemaName()
            );

        } finally {
            TenantContext.clear();
        }
    }
}
// ===============================
// ProductService.java
// (corrigido: resolveCategoryAndSubcategory sem duplica√ß√£o,
//  update limpando subcategory quando vier null,
//  usando findByIdWithCategory pra validar)
// ===============================
package brito.com.multitenancy001.tenant.application;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.tenant.model.Category;
import brito.com.multitenancy001.tenant.model.Product;
import brito.com.multitenancy001.tenant.model.Subcategory;
import brito.com.multitenancy001.tenant.model.Supplier;
import brito.com.multitenancy001.tenant.persistence.CategoryRepository;
import brito.com.multitenancy001.tenant.persistence.ProductRepository;
import brito.com.multitenancy001.tenant.persistence.SubcategoryRepository;
import brito.com.multitenancy001.tenant.persistence.SupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProductService {

    private final ProductRepository productRepository;
    private final SupplierRepository supplierRepository;
    private final CategoryRepository categoryRepository;
    private final SubcategoryRepository subcategoryRepository;

    @Transactional(readOnly = true)
    public Page<Product> findAll(Pageable pageable) {
        return productRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    public Product findById(UUID id) {
        return productRepository.findById(id)
            .orElseThrow(() -> new ApiException("PRODUCT_NOT_FOUND",
                "Produto n√£o encontrado com ID: " + id, 404));
    }

    @Transactional
    public Product create(Product product) {
        validateProduct(product);

        resolveCategoryAndSubcategory(product);
        resolveSupplier(product);
        validateSubcategoryBelongsToCategory(product);

        return productRepository.save(product);
    }

    @Transactional
    public Product update(UUID id, Product productDetails) {
        Product existingProduct = findById(id);

        if (StringUtils.hasText(productDetails.getName())) {
            existingProduct.setName(productDetails.getName());
        }

        if (productDetails.getDescription() != null) {
            existingProduct.setDescription(productDetails.getDescription());
        }

        if (StringUtils.hasText(productDetails.getSku())) {
            Optional<Product> productWithSku = productRepository.findBySku(productDetails.getSku());
            if (productWithSku.isPresent() && !productWithSku.get().getId().equals(id)) {
                throw new ApiException("SKU_ALREADY_EXISTS",
                    "SKU j√° cadastrado: " + productDetails.getSku(), 409);
            }
            existingProduct.setSku(productDetails.getSku());
        }

        if (productDetails.getPrice() != null) {
            validatePrice(productDetails.getPrice());
            existingProduct.setPrice(productDetails.getPrice());
        }

        if (productDetails.getStockQuantity() != null) {
            existingProduct.setStockQuantity(productDetails.getStockQuantity());
        }

        // ‚úÖ category
        if (productDetails.getCategory() != null && productDetails.getCategory().getId() != null) {
            Category category = categoryRepository.findById(productDetails.getCategory().getId())
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria n√£o encontrada", 404));
            existingProduct.setCategory(category);
        }

        // ‚úÖ subcategory (se veio ID)
        if (productDetails.getSubcategory() != null && productDetails.getSubcategory().getId() != null) {
            Subcategory sub = subcategoryRepository.findByIdWithCategory(productDetails.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria n√£o encontrada", 404));
            existingProduct.setSubcategory(sub);
        }

        // ‚úÖ se veio explicitamente subcategory = null -> limpa
        if (productDetails.getSubcategory() == null) {
            existingProduct.setSubcategory(null);
        }

        // ‚úÖ supplier
        if (productDetails.getSupplier() != null && productDetails.getSupplier().getId() != null) {
            Supplier supplier = supplierRepository.findById(productDetails.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND", "Fornecedor n√£o encontrado", 404));
            existingProduct.setSupplier(supplier);
        }

        validateSubcategoryBelongsToCategory(existingProduct);

        return productRepository.save(existingProduct);
    }

    private void resolveSupplier(Product product) {
        if (product.getSupplier() != null && product.getSupplier().getId() != null) {
            UUID supplierId = product.getSupplier().getId();
            Supplier supplier = supplierRepository.findById(product.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                    "Fornecedor n√£o encontrado com ID: " + supplierId, 404));
            product.setSupplier(supplier);
        }
    }


    private void resolveCategoryAndSubcategory(Product product) {
        // ‚úÖ category obrigat√≥ria
        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria √© obrigat√≥ria", 400);
        }

        Category category = categoryRepository.findById(product.getCategory().getId())
            .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria n√£o encontrada", 404));
        product.setCategory(category);

        // ‚úÖ subcategory opcional
        if (product.getSubcategory() != null && product.getSubcategory().getId() != null) {
            Subcategory sub = subcategoryRepository.findByIdWithCategory(product.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria n√£o encontrada", 404));
            product.setSubcategory(sub);
        } else {
            product.setSubcategory(null);
        }
    }

    private void validateSubcategoryBelongsToCategory(Product product) {
        if (product.getSubcategory() == null) return;

        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria √© obrigat√≥ria", 400);
        }

        if (product.getSubcategory().getCategory() == null
            || product.getSubcategory().getCategory().getId() == null) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria sem categoria associada (cadastro inconsistente)", 409);
        }

        Long subCatCategoryId = product.getSubcategory().getCategory().getId();
        Long productCategoryId = product.getCategory().getId();

        if (!subCatCategoryId.equals(productCategoryId)) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria n√£o pertence √† categoria informada", 409);
        }
    }

    // ======= outros m√©todos =======

    @Transactional(readOnly = true)
    public List<Product> searchProducts(String name, String sku, BigDecimal minPrice,
                                        BigDecimal maxPrice, Integer minStock, Integer maxStock) {
        return productRepository.searchProducts(name, minPrice, maxPrice, minStock, maxStock);
    }

    @Transactional(readOnly = true)
    public List<Product> findLowStock(Integer threshold) {
        return productRepository.findByStockQuantityLessThan(threshold);
    }

    @Transactional
    public Product updateStock(UUID id, Integer quantityChange) {
        Product product = findById(id);
        if (quantityChange > 0) product.addToStock(quantityChange);
        else if (quantityChange < 0) product.removeFromStock(Math.abs(quantityChange));
        return productRepository.save(product);
    }

    @Transactional
    public Product updatePrice(UUID id, BigDecimal newPrice) {
        validatePrice(newPrice);
        Product product = findById(id);
        product.updatePrice(newPrice);
        return productRepository.save(product);
    }

    @Transactional
    public void delete(UUID id) {
        Product product = findById(id);
        product.softDelete();
        productRepository.save(product);
    }

    private void validateProduct(Product product) {
        if (!StringUtils.hasText(product.getName())) {
            throw new ApiException("PRODUCT_NAME_REQUIRED", "Nome do produto √© obrigat√≥rio", 400);
        }
        if (product.getPrice() == null) {
            throw new ApiException("PRODUCT_PRICE_REQUIRED", "Pre√ßo do produto √© obrigat√≥rio", 400);
        }
        validatePrice(product.getPrice());

        if (product.getStockQuantity() == null) product.setStockQuantity(0);
        if (product.getStockQuantity() < 0) {
            throw new ApiException("INVALID_STOCK", "Quantidade em estoque n√£o pode ser negativa", 400);
        }
    }

    private void validatePrice(BigDecimal price) {
        if (price == null) throw new ApiException("INVALID_PRICE", "Pre√ßo n√£o pode ser nulo", 400);
        if (price.compareTo(BigDecimal.ZERO) < 0) throw new ApiException("INVALID_PRICE", "Pre√ßo n√£o pode ser negativo", 400);
        if (price.compareTo(BigDecimal.valueOf(1_000_000)) > 0) {
            throw new ApiException("PRICE_TOO_HIGH", "Pre√ßo muito alto. Valor m√°ximo permitido: 1.000.000", 400);
        }
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryId(Long categoryId) {
        return productRepository.findByCategory_Id(categoryId);
    }

    @Transactional(readOnly = true)
    public List<Product> findByBrand(String brand) {
        return productRepository.findAll().stream()
            .filter(p -> brand.equals(p.getBrand()))
            .toList();
    }

    @Transactional(readOnly = true)
    public List<Product> findActiveProducts() {
        return productRepository.findAll().stream()
            .filter(p -> Boolean.TRUE.equals(p.getActive()) && !Boolean.TRUE.equals(p.getDeleted()))
            .toList();
    }

    @Transactional
    public Product updateCostPrice(UUID id, BigDecimal costPrice) {
        Product product = findById(id);
        product.updateCostPrice(costPrice);
        return productRepository.save(product);
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateTotalInventoryValue() {
        return productRepository.calculateTotalInventoryValue();
    }

    @Transactional(readOnly = true)
    public Long countLowStockProducts(Integer threshold) {
        return productRepository.countLowStock(threshold);
    }
}
package brito.com.multitenancy001.tenant.application;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantUserService {

	private final TenantUserApiMapper tenantUserApiMapper;

	
    private final TenantUserTxService tenantUserTxService; // ‚úÖ novo
    private final AccountRepository accountRepository; // PUBLIC
    private final JwtTokenProvider jwtTokenProvider;
    private final SecurityUtils securityUtils;

    // ===== helpers =====
    private <T> T runInTenant(String schema, java.util.concurrent.Callable<T> action) {
        TenantContext.bind(schema);
        try {
            return action.call();
        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            TenantContext.clear();
        }
    }

    private void runInTenant(String schema, Runnable action) {
        TenantContext.bind(schema);
        try {
            action.run();
        } finally {
            TenantContext.clear();
        }
    }

   public TenantUserDetailsResponse createTenantUser(TenantUserCreateRequest request) {
    Long accountId = securityUtils.getCurrentAccountId();
    String schema = securityUtils.getCurrentSchema();

    validateCreateRequest(request);

    String username = request.username().trim().toLowerCase();
    String email = request.email().trim().toLowerCase();

    return runInTenant(schema, () -> toDetails(
            tenantUserTxService.createTenantUser(
                    accountId,
                    request.name().trim(),
                    username,
                    email,
                    request.password(),
                    request.role(),
                    request.phone(),
                    request.avatarUrl(),
                    request.permissions()
            )
    ));
}


   public List<AccountUserSummaryResponse> listTenantUsers() {
	    Long accountId = securityUtils.getCurrentAccountId();
	    String schema = securityUtils.getCurrentSchema();

	    return runInTenant(schema, () ->
	            tenantUserTxService.listUsers(accountId).stream()
	                    .map(this::toSummary)
	                    .toList()
	    );
	}

    
    

    public List<AccountUserSummaryResponse> listActiveTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () ->
        tenantUserTxService.listActiveUsers(accountId).stream()
                .map(this::toSummary)
                .toList()
);

    }

    public TenantUserDetailsResponse getTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> toDetails(tenantUserTxService.getUser(userId, accountId)));
    }

    
    
    private AccountUserSummaryResponse toSummary(TenantUser u) {
        return tenantUserApiMapper.toAccountUserSummary(u);
    }



    private TenantUserDetailsResponse toDetails(TenantUser u) {
        return TenantUserDetailsResponse.from(u);
    }
    

    public AccountUserSummaryResponse updateTenantUserStatus(Long userId, boolean active) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> toSummary(
                tenantUserTxService.updateStatus(userId, accountId, active) ));
    }

    public void softDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () -> tenantUserTxService.softDelete(userId, accountId));
    }

    public AccountUserSummaryResponse restoreTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        return runInTenant(schema, () -> toSummary(
                tenantUserTxService.restore(userId, accountId)
        ));

    }

    public AccountUserSummaryResponse resetTenantUserPassword(Long userId, String newPassword) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> toSummary(
                tenantUserTxService.resetPassword(userId, accountId, newPassword)
        ));
    
    }

    public void hardDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () -> tenantUserTxService.hardDelete(userId, accountId));
    }

    // ===== PASSWORD RESET (PUBLIC + TENANT) =====
    public String generatePasswordResetToken(String slug, String email) {
        if (!StringUtils.hasText(slug)) throw new ApiException("INVALID_SLUG", "Slug √© obrigat√≥rio", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email √© obrigat√≥rio", 400);

        // PUBLIC (sem @Transactional tenant)
        TenantContext.clear();
        Account account = accountRepository.findBySlugAndDeletedFalse(slug)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));
        if (!account.isActive()) throw new ApiException("ACCOUNT_INACTIVE", "Conta inativa", 403);

        String schema = account.getSchemaName();
        String normalizedEmail = email.trim().toLowerCase();

        return runInTenant(schema, () -> {
//            TenantUser user = tx // aqui voc√™ pode criar um m√©todo tx.getByEmail(...)
//                    .listUsers(account.getId()).stream()
//                    .filter(u -> normalizedEmail.equals(u.getEmail()) && !u.isDeleted())
//                    .findFirst()
//                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
            TenantUser user = tenantUserTxService.getByEmailActive(account.getId(), normalizedEmail);

            if (user.isSuspendedByAccount() || user.isDeleted()) throw new ApiException("USER_INACTIVE", "Usu√°rio inativo", 403);

            String token = jwtTokenProvider.generatePasswordResetToken(
                    user.getUsername(),
                    schema,
                    account.getId()
            );

            // Atualizar token precisa ser TX TENANT tamb√©m ‚Äî ideal: criar m√©todo tx.setResetToken(...)
            user.setPasswordResetToken(token);
            user.setPasswordResetExpires(LocalDateTime.now().plusHours(1));

            tenantUserTxService.save(user);
            return token;
        });
    }
    
    
    public void resetPasswordWithToken(String token, String newPassword) {
        if (!StringUtils.hasText(token)) {
            throw new ApiException("INVALID_TOKEN", "Token √© obrigat√≥rio", 400);
        }
        if (!StringUtils.hasText(newPassword)) {
            throw new ApiException("INVALID_PASSWORD", "Senha √© obrigat√≥ria", 400);
        }

        if (!jwtTokenProvider.validateToken(token) || !jwtTokenProvider.isPasswordResetToken(token)) {
            throw new ApiException("INVALID_TOKEN", "Token inv√°lido", 400);
        }

        String schema = jwtTokenProvider.getContextFromToken(token);
        Long accountId = jwtTokenProvider.getAccountIdFromToken(token);
        String username = jwtTokenProvider.getUsernameFromToken(token);

        if (!StringUtils.hasText(schema) || accountId == null || !StringUtils.hasText(username)) {
            throw new ApiException("INVALID_TOKEN", "Token incompleto", 400);
        }

        // ‚úÖ bind antes da TX (por isso usamos runInTenant)
        runInTenant(schema, () -> {
            tenantUserTxService.resetPasswordWithToken(accountId, username, token, newPassword);
        });
    }
 
    
    
    
    

    private void validateCreateRequest(TenantUserCreateRequest r) { /* mant√©m seu m√©todo */ }
}
package brito.com.multitenancy001.tenant.application;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.domain.user.TenantRole;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "tenantTransactionManager")
public class TenantUserTxService {

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;

    // =========================
    // CREATE
    // =========================
    public TenantUser createTenantUser(
            Long accountId,
            String name,
            String username,
            String email,
            String rawPassword,
            String role,
            String phone,
            String avatarUrl,
            List<String> permissions
    ) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigat√≥rio", 400);

        if (!StringUtils.hasText(name)) throw new ApiException("INVALID_NAME", "Nome obrigat√≥rio", 400);
        if (!StringUtils.hasText(username)) throw new ApiException("INVALID_USERNAME", "Username obrigat√≥rio", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email obrigat√≥rio", 400);

        if (!StringUtils.hasText(rawPassword) || !rawPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inv√°lida", 400);
        }

        String u = username.trim().toLowerCase();
        String e = email.trim().toLowerCase();

        if (tenantUserRepository.existsByUsernameAndAccountId(u, accountId)) {
            throw new ApiException("USERNAME_ALREADY_EXISTS", "Username j√° existe nesta conta", 409);
        }
        if (tenantUserRepository.existsByEmailAndAccountId(e, accountId)) {
            throw new ApiException("EMAIL_ALREADY_EXISTS", "Email j√° existe nesta conta", 409);
        }

        TenantRole parsedRole = parseTenantRole(role);
        
        TenantUser user = TenantUser.builder()
                .accountId(accountId)
                .name(name.trim())
                .username(u)
                .email(e)
                .password(passwordEncoder.encode(rawPassword))
                .role(parsedRole)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .phone(phone)
                .avatarUrl(avatarUrl)
                .timezone("America/Sao_Paulo")
                .locale("pt_BR")
                .createdAt(LocalDateTime.now())
                .build();

        // se quiser respeitar permissions do request (opcional)
        if (permissions != null && !permissions.isEmpty()) {
            user.setPermissions(permissions);
        }

        return tenantUserRepository.save(user);
    }
    
    
    @Transactional(transactionManager = "tenantTransactionManager")
    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
        if (updated == 0) {
            throw new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado ou removido", 404);
        }
    }

    
    

    // =========================
    // LIST / GET
    // =========================
    @Transactional(readOnly = true)
    public List<TenantUser> listUsers(Long accountId) {
        return tenantUserRepository.findByAccountIdAndDeletedFalse(accountId);
    }

    @Transactional(readOnly = true)
    public List<TenantUser> listActiveUsers(Long accountId) {
        // CORRE√á√ÉO: Use o novo m√©todo customizado
        return tenantUserRepository.findActiveUsersByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public TenantUser getUser(Long userId, Long accountId) {
        return tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
    }

    // usado em login/valida√ß√µes (sem deleted=true)
    @Transactional(readOnly = true)
    public TenantUser getByUsername(Long accountId, String username) {
        return tenantUserRepository.findByUsernameAndAccountIdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
    }

    // ‚úÖ isto substitui seu "getByEmailActive"
    @Transactional(readOnly = true)
    public TenantUser getByEmailActive(Long accountId, String email) {
        TenantUser user = tenantUserRepository.findByEmailAndAccountIdAndDeletedFalse(email, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
            throw new ApiException("USER_INACTIVE", "Usu√°rio inativo", 403);
        }
        return user;
    }

    // =========================
    // UPDATE STATUS 
    // =========================
    public TenantUser updateStatus(Long userId, Long accountId, boolean active) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_DELETED", "Usu√°rio est√° deletado", 409);

        // ‚úÖ a√ß√£o do admin: suspende/reativa manualmente
        user.setSuspendedByAdmin(!active);

        // ‚úÖ N√ÉO mexe em suspendedByAccount aqui (quem manda √© o status da conta)
        user.setUpdatedAt(LocalDateTime.now());
        return tenantUserRepository.save(user);
    }
    
    // =========================
    // CONTAGEM
    // =========================
    @Transactional(readOnly = true)
    public long countActiveUsers(Long accountId) {
        return tenantUserRepository.countActiveUsersByAccount(accountId);
    }

    public void softDelete(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_ALREADY_DELETED", "Usu√°rio j√° removido", 409);

        user.softDelete();
        user.setUpdatedAt(LocalDateTime.now());
        tenantUserRepository.save(user);
    }

    public TenantUser restore(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (!user.isDeleted()) throw new ApiException("USER_NOT_DELETED", "Usu√°rio n√£o est√° removido", 409);

        user.restore();
        user.setUpdatedAt(LocalDateTime.now());
        return tenantUserRepository.save(user);
    }

    public void hardDelete(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
        tenantUserRepository.delete(user);
    }

    // =========================
    // RESET PASSWORD (ADMIN / USERID)
    // =========================
    public TenantUser resetPassword(Long userId, Long accountId, String newPassword) {
        if (!StringUtils.hasText(newPassword) || !newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inv√°lida", 400);
        }

        TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(LocalDateTime.now());
        user.setMustChangePassword(false);
        user.setUpdatedAt(LocalDateTime.now());

        return tenantUserRepository.save(user);
    }

    // =========================
    // RESET PASSWORD (TOKEN)
    // =========================
    public void resetPasswordWithToken(Long accountId, String username, String token, String newPassword) {
        if (!StringUtils.hasText(newPassword) || !newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inv√°lida", 400);
        }

        TenantUser user = tenantUserRepository.findByUsernameAndAccountId(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.getPasswordResetToken() == null || !user.getPasswordResetToken().equals(token)) {
            throw new ApiException("INVALID_TOKEN", "Token n√£o confere", 400);
        }
        if (user.getPasswordResetExpires() == null || user.getPasswordResetExpires().isBefore(LocalDateTime.now())) {
            throw new ApiException("TOKEN_EXPIRED", "Token expirado", 400);
        }

        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(LocalDateTime.now());
        user.setMustChangePassword(false);

        user.setPasswordResetToken(null);
        user.setPasswordResetExpires(null);

        user.setUpdatedAt(LocalDateTime.now());
        tenantUserRepository.save(user);
    }

    // usado no generatePasswordResetToken
    public TenantUser save(TenantUser user) {
        user.setUpdatedAt(LocalDateTime.now());
        return tenantUserRepository.save(user);
    }

    private TenantRole parseTenantRole(String role) {
        if (!StringUtils.hasText(role)) throw new ApiException("INVALID_ROLE", "Role obrigat√≥ria", 400);

        String r = role.trim().toUpperCase();

        return switch (r) {
            case "TENANT_ADMIN", "ADMIN" -> TenantRole.TENANT_ADMIN;
            case "MANAGER", "PRODUCT_MANAGER", "SALES_MANAGER" -> TenantRole.MANAGER;
            case "VIEWER" -> TenantRole.VIEWER;
            case "USER" -> TenantRole.USER;
            default -> throw new ApiException("INVALID_ROLE", "Role inv√°lida: " + role, 400);
        };
    }
}package brito.com.multitenancy001.tenant.domain.user;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum TenantRole implements RoleAuthority {
    TENANT_ADMIN,
    MANAGER,
    VIEWER,
    USER;

    public boolean isAdmin() {
        return this == TENANT_ADMIN;
    }

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }
}
package brito.com.multitenancy001.tenant.domain.user;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(
    name = "users_tenant",
    uniqueConstraints = {
        @UniqueConstraint(
            name = "uk_user_tenant_account_username",
            columnNames = {"account_id", "username"}
        )
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "password")
public class TenantUser {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = 100)
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inv√°lido.")
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false, length = 150)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private TenantRole role;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    // ‚úÖ NOVO: suspens√£o por conta (status da conta)
    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    // ‚úÖ NOVO: suspens√£o manual por admin do tenant
    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @ElementCollection
    @CollectionTable(
        name = "user_tenant_permissions",
        joinColumns = @JoinColumn(name = "user_tenant_id")
    )
    @Column(name = "permission", length = 100)
    @Builder.Default
    private List<String> permissions = new ArrayList<>();

    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts")
    @Builder.Default
    private Integer failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password")
    @Builder.Default
    private Boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    @Column(name = "timezone", length = 50)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", length = 10)
    @Builder.Default
    private String locale = "pt_BR";

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted")
    @Builder.Default
    private boolean deleted = false;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @PrePersist
    protected void onCreate() {
        if (username != null) username = username.toLowerCase().trim();
        if (permissions == null) permissions = new ArrayList<>();
        if (permissions.isEmpty()) addDefaultPermissions();
    }

    private void addDefaultPermissions() {
        switch (role) {
            case TENANT_ADMIN -> permissions.addAll(List.of(
                "USER_CREATE","USER_UPDATE","USER_DELETE","USER_VIEW",
                "PRODUCT_CREATE","PRODUCT_UPDATE","PRODUCT_DELETE","PRODUCT_VIEW",
                "SALE_CREATE","SALE_UPDATE","SALE_DELETE","SALE_VIEW",
                "REPORT_VIEW","SETTINGS_MANAGE"
            ));
            case MANAGER -> permissions.addAll(List.of(
                "PRODUCT_CREATE","PRODUCT_UPDATE","PRODUCT_VIEW",
                "SALE_CREATE","SALE_VIEW","REPORT_VIEW"
            ));
            case VIEWER -> permissions.addAll(List.of(
                "USER_VIEW","PRODUCT_VIEW","SALE_VIEW","REPORT_VIEW"
            ));
            case USER -> permissions.add("VIEW_BASIC");
        }
    }

    public boolean isEnabledForLogin(LocalDateTime now) {
        if (lockedUntil != null && lockedUntil.isAfter(now)) return false;
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }


    public void softDelete() {
        if (deleted) return;
        deleted = true;
        deletedAt = LocalDateTime.now();

        // ‚úÖ deletado sempre bloqueia login
        suspendedByAccount = true;
        suspendedByAdmin = true;

        long ts = System.currentTimeMillis();
        username = "deleted_" + username + "_" + ts;
        email = "deleted_" + email + "_" + ts;
    }

    public void restore() {
        if (!deleted) return;
        deleted = false;
        deletedAt = null;

        // ‚úÖ ao restaurar: volta ‚Äúdesbloqueado‚Äù pela l√≥gica normal
        // (conta ativa vai controlar suspendedByAccount; admin controla suspendedByAdmin)
        suspendedByAdmin = false;
        // n√£o for√ßa false em suspendedByAccount aqui ‚Äî quem manda √© o status da conta
    }
}
// ===============================
// Category.java
// ===============================
package brito.com.multitenancy001.tenant.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
    name = "categories",
    uniqueConstraints = @UniqueConstraint(
        name = "uk_categories_name",
        columnNames = "name"
    )
)
@Getter
@Setter
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable=false, length=100)
    private String name;

    @Column(nullable=false)
    private Boolean active = true;

    @Column(nullable=false)
    private Boolean deleted = false;
}
package brito.com.multitenancy001.tenant.model;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "products", indexes = {
    @Index(name = "idx_product_name", columnList = "name"),
    @Index(name = "idx_product_sku", columnList = "sku", unique = true),
    @Index(name = "idx_product_supplier", columnList = "supplier_id"),
    @Index(name = "idx_product_created_at", columnList = "created_at"),
    @Index(name = "idx_products_category_id", columnList = "category_id"),
    @Index(name = "idx_products_subcategory_id", columnList = "subcategory_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"supplier", "category", "subcategory"})
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(unique = true, length = 100)
    private String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    @Builder.Default
    private Integer stockQuantity = 0;

    @Column(name = "min_stock")
    private Integer minStock;

    @Column(name = "max_stock")
    private Integer maxStock;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    @Column(name = "profit_margin", precision = 5, scale = 2)
    private BigDecimal profitMargin;

    // ‚úÖ FK simples (category_id) - obrigat√≥rio
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
        name = "category_id",
        nullable = false,
        foreignKey = @ForeignKey(name = "fk_products_category")
    )
    private Category category;

    // ‚úÖ CORRE√á√ÉO: FK simples para subcategory (REMOVER a composta)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
        name = "subcategory_id",
        foreignKey = @ForeignKey(name = "fk_products_subcategory")
    )
    private Subcategory subcategory;

    @Column(name = "brand", length = 100)
    private String brand;

    @Column(name = "weight_kg", precision = 8, scale = 3)
    private BigDecimal weightKg;

    @Column(name = "dimensions", length = 50)
    private String dimensions;

    @Column(name = "barcode", length = 50)
    private String barcode;

    @Column(name = "active")
    @Builder.Default
    private Boolean active = true;

    @Column(name = "images_json", columnDefinition = "TEXT")
    private String imagesJson;

    @Column(name = "attributes_json", columnDefinition = "TEXT")
    private String attributesJson;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", foreignKey = @ForeignKey(name = "fk_product_supplier"))
    private Supplier supplier;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted")
    @Builder.Default
    private Boolean deleted = false;

    @PrePersist
    protected void onCreate() {
       
        if (this.stockQuantity == null) this.stockQuantity = 0;
        if (this.active == null) this.active = true;
        calculateProfitMargin();
    }

    @PreUpdate
    protected void onUpdate() {
        calculateProfitMargin();
    }

    private void calculateProfitMargin() {
        if (this.costPrice != null && this.costPrice.compareTo(BigDecimal.ZERO) > 0 && this.price != null) {
            BigDecimal profit = this.price.subtract(this.costPrice);
            this.profitMargin = profit
                .divide(this.costPrice, 4, RoundingMode.HALF_UP)
                .multiply(BigDecimal.valueOf(100));
        }
    }

    public void softDelete() {
        this.deleted = true;
        this.deletedAt = LocalDateTime.now();
        this.active = false;
    }

    public void updatePrice(BigDecimal newPrice) {
        if (newPrice == null || newPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Pre√ßo inv√°lido");
        }
        this.price = newPrice;
        calculateProfitMargin();
    }

    public void updateCostPrice(BigDecimal newCostPrice) {
        this.costPrice = newCostPrice;
        calculateProfitMargin();
    }
    
    public void addToStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;
        this.stockQuantity += quantity;
    }

    public void removeFromStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;

        if (this.stockQuantity < quantity) {
            throw new IllegalStateException("Estoque insuficiente. Dispon√≠vel: " + this.stockQuantity);
        }
        this.stockQuantity -= quantity;
    }
}package brito.com.multitenancy001.tenant.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

//Sale.java
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "sales")
public class Sale {
 @Id
 @GeneratedValue(strategy = GenerationType.UUID)
 private String id;
 
 @Column(nullable = false)
 private LocalDateTime saleDate;
 
 @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
 @JoinColumn(name = "sale_id")
 @Builder.Default
 private List<SaleItem> items = new ArrayList<>();
 
 @Column(precision = 10, scale = 2)
 private BigDecimal totalAmount;
 
 private String customerName;
 private String customerEmail;
 
 @Enumerated(EnumType.STRING)
 private SaleStatus status;
 
 public enum SaleStatus {
     PENDING, COMPLETED, CANCELLED, REFUNDED
 }
}
package brito.com.multitenancy001.tenant.model;



import jakarta.persistence.*;

@Entity  // ‚Üê ESTA ANOTA√á√ÉO √â OBRIGAT√ìRIA!
@Table(name = "sale_items")
public class SaleItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // ... outros campos
    
    // VERIFIQUE SE TEM @ManyToOne para Sale
    @ManyToOne
    @JoinColumn(name = "sale_id")
    private Sale sale;
    
    // Getters e setters
}// ===============================
// Subcategory.java
// ===============================
package brito.com.multitenancy001.tenant.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
    name="subcategories",
    uniqueConstraints = @UniqueConstraint(
        name="uk_subcategories_name_category",
        columnNames={"category_id","name"}
    )
)
@Getter
@Setter
public class Subcategory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional=false)
    @JoinColumn(
        name="category_id",
        nullable=false,
        foreignKey=@ForeignKey(name="fk_subcategories_category")
    )
    private Category category;

    @Column(nullable=false, length=100)
    private String name;

    @Column(nullable=false)
    private Boolean active = true;

    @Column(nullable=false)
    private Boolean deleted = false;
}
package brito.com.multitenancy001.tenant.model;



import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "suppliers", indexes = {
    @Index(name = "idx_supplier_name", columnList = "name"),
    @Index(name = "idx_supplier_document", columnList = "document", unique = true),
    @Index(name = "idx_supplier_email", columnList = "email")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"products"})
public class Supplier {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(nullable = false, length = 200)
    private String name;
    
    @Column(name = "contact_person", length = 100)
    private String contactPerson;
    
    @Column(length = 150)
    private String email;
    
    @Column(length = 20)
    private String phone;
    
    @Column(columnDefinition = "TEXT")
    private String address;
    
    @Column(length = 20, unique = true)
    private String document; // CNPJ/CPF
    
    @Column(name = "document_type", length = 10)
    private String documentType; // CNPJ, CPF, etc.
    
    @Column(name = "website", length = 200)
    private String website;
    
    @Column(name = "payment_terms", length = 100)
    private String paymentTerms;
    
    @Column(name = "lead_time_days")
    private Integer leadTimeDays;
    
    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating;
    
    @Column(name = "active")
    @Builder.Default
    private Boolean active = true;
    
    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;
    
    @OneToMany(mappedBy = "supplier", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @Builder.Default
    private List<Product> products = new ArrayList<>();
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
   
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}package brito.com.multitenancy001.tenant.persistence;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.model.Category;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {}package brito.com.multitenancy001.tenant.persistence;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.model.Product;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface ProductRepository extends JpaRepository<Product, UUID> {

	List<Product> findByCategory_Id(Long categoryId);

	List<Product> findBySubcategory_Id(Long subcategoryId);

	@Query("""
			SELECT p FROM Product p
			WHERE p.category.id = :categoryId
			  AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
			""")
	List<Product> findByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
			@Param("subcategoryId") Long subcategoryId);

	List<Product> findByNameContainingIgnoreCase(String name);

	Optional<Product> findBySku(String sku);

	List<Product> findByStockQuantityLessThan(Integer quantity);

	List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

	List<Product> findBySupplier_Id(UUID supplierId);

	Page<Product> findByNameContainingIgnoreCase(String name, Pageable pageable);

	@Query("SELECT p FROM Product p WHERE "
			+ "(:name IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :name, '%'))) AND "
			+ "(:minPrice IS NULL OR p.price >= :minPrice) AND " + "(:maxPrice IS NULL OR p.price <= :maxPrice) AND "
			+ "(:minStock IS NULL OR p.stockQuantity >= :minStock) AND "
			+ "(:maxStock IS NULL OR p.stockQuantity <= :maxStock)")
	List<Product> searchProducts(@Param("name") String name, @Param("minPrice") BigDecimal minPrice,
			@Param("maxPrice") BigDecimal maxPrice, @Param("minStock") Integer minStock,
			@Param("maxStock") Integer maxStock);

	List<Product> findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(String name, BigDecimal minPrice,
			BigDecimal maxPrice, Integer minStock, Integer maxStock);

	@Query("SELECT COUNT(p) FROM Product p WHERE p.stockQuantity <= :threshold")
	Long countLowStock(@Param("threshold") Integer threshold);

	@Query("SELECT SUM(p.stockQuantity * p.price) FROM Product p")
	BigDecimal calculateTotalInventoryValue();

	@Query("SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id")
	List<Object[]> countProductsBySupplier();
}package brito.com.multitenancy001.tenant.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.model.Subcategory;

import java.util.Optional;

@Repository
public interface SubcategoryRepository extends JpaRepository<Subcategory, Long> {

    @Query("select s from Subcategory s join fetch s.category where s.id = :id")
    Optional<Subcategory> findByIdWithCategory(@Param("id") Long id);
}
package brito.com.multitenancy001.tenant.persistence;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.model.Supplier;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface SupplierRepository extends JpaRepository<Supplier, UUID> {
    
    Optional<Supplier> findByDocument(String document);
    
    List<Supplier> findByNameContainingIgnoreCase(String name);
    
    List<Supplier> findByEmail(String email);
}package brito.com.multitenancy001.tenant.persistence.user;

import jakarta.transaction.Transactional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.user.TenantUser;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantUserRepository extends JpaRepository<TenantUser, Long> {
	
	
	 // ‚úÖ Suspende por CONTA (sem mexer na suspens√£o por admin)
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = true
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int suspendAllByAccount(@Param("accountId") Long accountId);

    // ‚úÖ Reativa por CONTA (sem mexer na suspens√£o por admin)
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = false
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int unsuspendAllByAccount(@Param("accountId") Long accountId);

    // ‚úÖ Suspender 1 usu√°rio manualmente pelo ADMIN do TENANT
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAdmin = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAdmin(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

  

	
    
    Optional<TenantUser> findByPasswordResetTokenAndAccountId(String passwordResetToken, Long accountId);

    Optional<TenantUser> findByUsernameAndDeletedFalse(String username);

    Optional<TenantUser> findByEmailAndAccountId(String email, Long accountId);

    Optional<TenantUser> findByEmailAndAccountIdAndDeletedFalse(String email, Long accountId);

    Optional<TenantUser> findByUsernameAndAccountId(String username, Long accountId);

    // (se voc√™ quiser filtrar deletados no login)
    Optional<TenantUser> findByUsernameAndAccountIdAndDeletedFalse(String username, Long accountId);

    boolean existsByUsernameAndAccountId(String username, Long accountId);

    boolean existsByEmailAndAccountId(String email, Long accountId);

    boolean existsByEmailAndAccountIdAndIdNot(String email, Long accountId, Long id);

    // ==========================
    // Listagens (Tenant)
    // ==========================
    List<TenantUser> findByAccountId(Long accountId);

    List<TenantUser> findByAccountIdAndDeletedFalse(Long accountId);

    // CORRE√á√ÉO: Removido o m√©todo que usa "ActiveTrue" pois n√£o existe na entidade
    // List<TenantUser> findByAccountIdAndActiveTrueAndDeletedFalse(Long accountId);
    
    // NOVO: M√©todo para buscar usu√°rios ativos usando l√≥gica customizada
    @Query("SELECT u FROM TenantUser u WHERE u.accountId = :accountId " +
           "AND u.deleted = false " +
           "AND u.suspendedByAccount = false " +
           "AND u.suspendedByAdmin = false")
    List<TenantUser> findActiveUsersByAccount(@Param("accountId") Long accountId);

    // ==========================
    // Contagem / Limites
    // ==========================
    // CORRE√á√ÉO: Removido m√©todo que n√£o funciona
    // long countByAccountIdAndActiveTrueAndDeletedFalse(Long accountId);
    
    // NOVO: Contagem de usu√°rios ativos
    @Query("SELECT COUNT(u) FROM TenantUser u WHERE u.accountId = :accountId " +
           "AND u.deleted = false " +
           "AND u.suspendedByAccount = false " +
           "AND u.suspendedByAdmin = false")
    long countActiveUsersByAccount(@Param("accountId") Long accountId);

    // ==========================
    // Busca por ID com scoping de conta
    // ==========================
    Optional<TenantUser> findByIdAndAccountId(Long id, Long accountId);

    // (se quiser refor√ßar deletado false)
    Optional<TenantUser> findByIdAndAccountIdAndDeletedFalse(Long id, Long accountId);
}-- V1__create_accounts.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS accounts (
    id BIGSERIAL PRIMARY KEY,

    -- Flag para identificar contas do sistema
    is_system_account BOOLEAN NOT NULL DEFAULT false,

    name VARCHAR(150) NOT NULL,

    -- Infra
    schema_name VARCHAR(100) NOT NULL,
    slug VARCHAR(50) NOT NULL,

    -- Status / Plano
    status VARCHAR(50) NOT NULL,
    subscription_plan VARCHAR(50) DEFAULT 'FREE',

    max_users INTEGER DEFAULT 5,
    max_products INTEGER DEFAULT 100,
    max_storage_mb INTEGER DEFAULT 100,

    -- Identidade da empresa (CR√çTICO)
    company_doc_type VARCHAR(10) NOT NULL,
    company_doc_number VARCHAR(20) NOT NULL,
    company_email VARCHAR(150) NOT NULL,

    company_phone VARCHAR(20),
    company_address VARCHAR(500),
    company_city VARCHAR(100),
    company_state VARCHAR(50),
    company_country VARCHAR(50) DEFAULT 'Brasil',

    -- Localiza√ß√£o
    timezone VARCHAR(50) DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(10) DEFAULT 'pt_BR',
    currency VARCHAR(3) DEFAULT 'BRL',

    -- Datas
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    trial_end_date TIMESTAMP,
    payment_due_date TIMESTAMP,
    next_billing_date TIMESTAMP,

    settings_json TEXT,
    metadata_json TEXT,

    deleted BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP
);

-- Unicidade de documento por conta ativa
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_company_doc_active
ON accounts (company_doc_type, company_doc_number)
WHERE deleted = false;

-- Unicidade de email por conta ativa
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_company_email_active
ON accounts (company_email)
WHERE deleted = false;

-- Unicidade de schema (global)
CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_schema_name
ON accounts (schema_name);

-- Unicidade de slug (global)
CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_slug
ON accounts (slug);

-- V2__create_controlplane_users.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_users (
    id BIGSERIAL PRIMARY KEY,

    name VARCHAR(100) NOT NULL,
    username VARCHAR(100) NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(150) NOT NULL,

    role VARCHAR(50) NOT NULL,

    account_id BIGINT NOT NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,

    timezone VARCHAR(50) DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(10) DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP,
    deleted BOOLEAN NOT NULL DEFAULT false,

    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    CONSTRAINT fk_controlplane_users_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE,

    CONSTRAINT ux_controlplane_users_username UNIQUE (account_id, username),
    CONSTRAINT ux_controlplane_users_email UNIQUE (account_id, email)
);

CREATE TABLE IF NOT EXISTS controlplane_user_permissions (
    user_id BIGINT NOT NULL,
    permission VARCHAR(100) NOT NULL,

    CONSTRAINT fk_controlplane_user_permissions_user
        FOREIGN KEY (user_id) REFERENCES controlplane_users(id) ON DELETE CASCADE,

    CONSTRAINT pk_controlplane_user_permissions PRIMARY KEY (user_id, permission)
);

-- V3__insert_controlplane_account.sql
SET search_path TO public;

INSERT INTO accounts (
    is_system_account,
    name,
    schema_name,
    slug,
    status,
    subscription_plan,
    company_doc_type,
    company_doc_number,
    company_email,
    company_country,
    deleted
)
SELECT
    true,
    'ControlPlane',
    'public',
    'controlplane',
    'ACTIVE',
    'FREE',
    'CNPJ',
    '00000000000000',
    'controlplane@system.com',
    'Brasil',
    false
WHERE NOT EXISTS (
    SELECT 1
    FROM accounts
    WHERE slug = 'controlplane'
);
-- V4__insert_controlplane_super_admin.sql
SET search_path TO public;

INSERT INTO controlplane_users (
    name,
    username,
    email,
    password,
    role,
    account_id,
    suspended_by_account,
    suspended_by_admin
)
SELECT
    'ControlPlane Super Admin',
    'superadmin',
    'admin@controlplane.com',
    '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
    'SUPER_ADMIN',
    a.id,
    false,
    false
FROM accounts a
WHERE a.slug = 'controlplane'
AND NOT EXISTS (
    SELECT 1
    FROM controlplane_users u
    WHERE u.account_id = a.id
      AND (u.username = 'superadmin' OR u.email = 'admin@controlplane.com')
);

-- V5__create_payments.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS payments (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,

    payment_date TIMESTAMP NOT NULL,
    valid_until TIMESTAMP,

    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',

    transaction_id VARCHAR(100) UNIQUE,
    payment_method VARCHAR(50),
    payment_gateway VARCHAR(50),
    currency VARCHAR(3) DEFAULT 'BRL',

    description VARCHAR(500),
    metadata_json TEXT,

    invoice_url TEXT,
    receipt_url TEXT,

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,

    refunded_at TIMESTAMP,
    refund_amount NUMERIC(10,2),
    refund_reason VARCHAR(500),

    CONSTRAINT fk_payments_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_payment_account ON payments(account_id);
CREATE INDEX IF NOT EXISTS idx_payment_status ON payments(status);
CREATE UNIQUE INDEX IF NOT EXISTS idx_payment_transaction ON payments(transaction_id) WHERE transaction_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_payment_date ON payments(payment_date);
-- V1__create_tenants_users.sql

CREATE TABLE IF NOT EXISTS users_tenant (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    account_id BIGINT NOT NULL,

    name VARCHAR(100) NOT NULL,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(150) NOT NULL,
    password VARCHAR(255) NOT NULL,

    role VARCHAR(50) NOT NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    timezone VARCHAR(50) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(10) NOT NULL DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,

    deleted BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP,

    CONSTRAINT uk_users_tenant_username_account UNIQUE (username, account_id),
    CONSTRAINT uk_users_tenant_email_account UNIQUE (email, account_id)
);

CREATE INDEX IF NOT EXISTS idx_users_tenant_account_id ON users_tenant(account_id);
CREATE INDEX IF NOT EXISTS idx_users_tenant_username ON users_tenant(username);
CREATE INDEX IF NOT EXISTS idx_users_tenant_email ON users_tenant(email);
CREATE INDEX IF NOT EXISTS idx_users_tenant_deleted ON users_tenant(deleted) WHERE deleted = false;

-- V2__create_tenant_users_permissions.sql
CREATE TABLE IF NOT EXISTS user_tenant_permissions (
    user_tenant_id BIGINT NOT NULL,
    permission VARCHAR(100) NOT NULL,

    PRIMARY KEY (user_tenant_id, permission),

    CONSTRAINT fk_user_tenant_permissions_user
        FOREIGN KEY (user_tenant_id)
        REFERENCES users_tenant(id)
        ON DELETE CASCADE
);-- V3__create_categories.sql

CREATE TABLE IF NOT EXISTS categories (
  id BIGSERIAL PRIMARY KEY,

  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  CONSTRAINT uk_categories_name UNIQUE (name)
);

CREATE INDEX IF NOT EXISTS idx_categories_active  ON categories(active);
CREATE INDEX IF NOT EXISTS idx_categories_deleted ON categories(deleted) WHERE deleted = false;
-- V4__create_subcategories.sql

CREATE TABLE IF NOT EXISTS subcategories (
  id BIGSERIAL PRIMARY KEY,

  category_id BIGINT NOT NULL,
  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  CONSTRAINT fk_subcategories_category
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE,

  CONSTRAINT uk_subcategories_name_category UNIQUE (category_id, name)
);

CREATE INDEX IF NOT EXISTS idx_subcategories_category_id ON subcategories(category_id);
CREATE INDEX IF NOT EXISTS idx_subcategories_active      ON subcategories(active);
CREATE INDEX IF NOT EXISTS idx_subcategories_deleted     ON subcategories(deleted) WHERE deleted = false;
-- V5__create_suppliers.sql

CREATE TABLE IF NOT EXISTS suppliers (
  id UUID PRIMARY KEY,

  name VARCHAR(200) NOT NULL,
  contact_person VARCHAR(100),

  email VARCHAR(150),
  phone VARCHAR(20),
  address TEXT,

  document VARCHAR(20),
  document_type VARCHAR(10),

  website VARCHAR(200),
  payment_terms VARCHAR(100),

  lead_time_days INTEGER,
  rating NUMERIC(3,2),

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  notes TEXT,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP
);

-- document √∫nico somente para fornecedores ativos e com documento preenchido
CREATE UNIQUE INDEX IF NOT EXISTS ux_suppliers_document_active
ON suppliers(document)
WHERE document IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_supplier_name   ON suppliers(name);
CREATE INDEX IF NOT EXISTS idx_supplier_email  ON suppliers(email);
CREATE INDEX IF NOT EXISTS idx_supplier_active ON suppliers(active);
CREATE INDEX IF NOT EXISTS idx_supplier_deleted ON suppliers(deleted) WHERE deleted = false;
-- V6__create_products.sql

CREATE TABLE IF NOT EXISTS products (
  id UUID PRIMARY KEY,

  name VARCHAR(200) NOT NULL,
  description TEXT,

  sku VARCHAR(100),
  price NUMERIC(10,2) NOT NULL,

  stock_quantity INT NOT NULL DEFAULT 0,
  min_stock INT,
  max_stock INT,

  cost_price NUMERIC(10,2),
  profit_margin NUMERIC(5,2),

  category_id BIGINT NOT NULL,
  subcategory_id BIGINT NULL,

  brand VARCHAR(100),
  weight_kg NUMERIC(8,3),
  dimensions VARCHAR(50),
  barcode VARCHAR(50),

  active BOOLEAN NOT NULL DEFAULT true,

  images_json TEXT,
  attributes_json TEXT,

  supplier_id UUID NULL,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  CONSTRAINT fk_products_category
    FOREIGN KEY (category_id) REFERENCES categories(id),

  CONSTRAINT fk_products_subcategory
    FOREIGN KEY (subcategory_id) REFERENCES subcategories(id),

  CONSTRAINT fk_product_supplier
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);

-- sku √∫nico apenas quando preenchido e produto ativo
CREATE UNIQUE INDEX IF NOT EXISTS ux_products_sku_active
ON products(sku)
WHERE sku IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_product_name       ON products(name);
CREATE INDEX IF NOT EXISTS idx_product_supplier   ON products(supplier_id);
CREATE INDEX IF NOT EXISTS idx_product_created_at ON products(created_at);

CREATE INDEX IF NOT EXISTS idx_products_category_id    ON products(category_id);
CREATE INDEX IF NOT EXISTS idx_products_subcategory_id ON products(subcategory_id);

CREATE INDEX IF NOT EXISTS idx_products_deleted ON products(deleted) WHERE deleted = false;
package brito.com.multitenancy001;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Multitenancy001ApplicationTests {

	@Test
	void contextLoads() {
	}

}
