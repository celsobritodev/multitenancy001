package brito.com.multitenancy001.controlplane.api.controller.accounts.admin;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/accounts")
@RequiredArgsConstructor
@Slf4j
public class AccountAdminController {

    private final AccountLifecycleService accountLifecycleService;

    @GetMapping
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountResponse>> listAllAccounts() {
        log.info("Listando todas as contas");
        return ResponseEntity.ok(accountLifecycleService.listAllAccounts());
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountResponse> getAccountById(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.getAccountById(id));
    }

    @GetMapping("/{id}/details")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountAdminDetailsResponse> getAccountByIdDetails(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.getAccountAdminDetails(id));
    }

    @GetMapping("/{id}/users")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountUserSummaryResponse>> listUsersByAccount(@PathVariable Long id) {
        log.info("Listando Usuários por conta");
        return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, false));
    }

    @GetMapping("/{id}/users/active")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountUserSummaryResponse>> listActiveUsersByAccount(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, true));
    }

    @PatchMapping("/{id}/status")
    @PreAuthorize("hasAnyAuthority('CP_TENANT_SUSPEND','CP_TENANT_ACTIVATE')")
    public ResponseEntity<AccountStatusChangeResponse> changeStatusAccount(
            @PathVariable Long id,
            @Valid @RequestBody AccountStatusChangeRequest req
    ) {
        return ResponseEntity.ok(accountLifecycleService.changeAccountStatus(id, req));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('CP_TENANT_DELETE')")
    public ResponseEntity<Void> softDeleteAccount(@PathVariable Long id) {
        accountLifecycleService.softDeleteAccount(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('CP_TENANT_ACTIVATE')")
    public ResponseEntity<Void> restoreAccount(@PathVariable Long id) {
        accountLifecycleService.restoreAccount(id);
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.controlplane.api.controller.auth;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.application.AdminAuthService;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/auth")
@RequiredArgsConstructor
public class AdminAuthController {

	private final AdminAuthService adminAuthService;

	@PostMapping("/login")
	public ResponseEntity<JwtResponse> loginSuperAdmin(@Valid @RequestBody ControlPlaneAdminLoginRequest request) {

		JwtResponse response = adminAuthService.loginSuperAdmin(request);
		return ResponseEntity.ok(response);
	}
}
package brito.com.multitenancy001.controlplane.api.controller.billing;

import brito.com.multitenancy001.controlplane.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.application.billing.PaymentService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/controlplane/billing/payments")
@RequiredArgsConstructor
@Validated
public class PaymentController {

    private final PaymentService paymentService;
    
    @PostMapping("/by-account/{accountId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> processPaymentForAccount(
            @PathVariable Long accountId,
            @Valid @RequestBody AdminPaymentRequest body
    ) {
        // Garante que o path manda (evita inconsistência)
        AdminPaymentRequest req = new AdminPaymentRequest(
                accountId,
                body.amount(),
                body.paymentMethod(),
                body.paymentGateway(),
                body.description()
        );

        PaymentResponse response = paymentService.processPaymentForAccount(req);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    

    @PostMapping
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> processPayment(@Valid @RequestBody PaymentRequest request) {
        PaymentResponse response = paymentService.processPaymentForMyAccount(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/{paymentId}")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<PaymentResponse> getById(@PathVariable Long paymentId) {
        return ResponseEntity.ok(paymentService.getPaymentById(paymentId));
    }

    // =========================
    // MINHA CONTA (SAFE DEFAULT)
    // =========================

    @GetMapping("/by-account")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getByMyAccount() {
        return ResponseEntity.ok(paymentService.getPaymentsByMyAccount());
    }

    @GetMapping("/by-account/active")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<Boolean> hasActivePaymentMyAccount() {
        return ResponseEntity.ok(paymentService.hasActivePaymentMyAccount());
    }

 

    @GetMapping("/by-account/{accountId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getByAccountAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(paymentService.getPaymentsByAccount(accountId));
    }

    @GetMapping("/by-account/{accountId}/active")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<Boolean> hasActivePaymentAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(paymentService.hasActivePayment(accountId));
    }

    @PostMapping("/{paymentId}/complete-manual")
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> completeManually(@PathVariable Long paymentId) {
        return ResponseEntity.ok(paymentService.completePaymentManually(paymentId));
    }

    @PostMapping("/{paymentId}/refund")
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> refund(
            @PathVariable Long paymentId,
            @Valid @RequestBody RefundRequest request
    ) {
        PaymentResponse response =
                paymentService.refundPayment(paymentId, request.amount(), request.reason());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/revenue")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<BigDecimal> getRevenue(
            @RequestParam("start")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam("end")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate
    ) {
        return ResponseEntity.ok(paymentService.getTotalRevenue(startDate, endDate));
    }

    public record RefundRequest(
            @DecimalMin(value = "0.01", message = "amount deve ser > 0 quando informado")
            BigDecimal amount,

            @NotBlank(message = "reason é obrigatório")
            String reason
    ) {}
}

package brito.com.multitenancy001.controlplane.api.controller.signup;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/signup")
@RequiredArgsConstructor
public class AccountSignupController {
    
    private final AccountLifecycleService accountLifecycleService;

    @PostMapping
    public ResponseEntity<AccountResponse> signup(
            @Valid @RequestBody SignupRequest request) {
        AccountResponse response = accountLifecycleService.createAccount( request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}package brito.com.multitenancy001.controlplane.api.controller.users;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.application.user.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/controlplane-users")
@RequiredArgsConstructor
public class ControlPlaneUserAdminController {

    private final ControlPlaneUserService controlPlaneUserService;

    @PostMapping
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> createControlPlaneUser(@Valid @RequestBody ControlPlaneUserCreateRequest request) {
        ControlPlaneUserDetailsResponse response = controlPlaneUserService.createControlPlaneUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listControlPlaneUsers() {
        return ResponseEntity.ok(controlPlaneUserService.listControlPlaneUsers());
    }

    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getControlPlaneUser(userId));
    }

    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUserStatus(
            @PathVariable Long userId,
            @RequestParam boolean active) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUserStatus(userId, active));
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_DELETE')")
    public ResponseEntity<Void> deleteControlPlaneUser(@PathVariable Long userId) {
        controlPlaneUserService.softDeleteControlPlaneUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> restoreControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.restoreControlPlaneUser(userId));
    }
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;
import java.time.LocalDateTime;

public record AccountAdminDetailsResponse(

    // Identificação
    Long id,
    String name,
    String slug,
    String schemaName,
    String status,

    // Dados legais (sempre em conjunto)
    DocumentType companyDocType,
    String companyDocNumber,

    // Datas
    LocalDateTime createdAt,
    LocalDateTime trialEndDate,
    LocalDateTime paymentDueDate,
    LocalDateTime deletedAt,

    // Flags calculadas
    boolean inTrial,
    boolean trialExpired,
    long trialDaysRemaining,

    // Admin da conta
    ControlPlaneAdminUserSummaryResponse admin,

    // Indicadores
    long totalControlPlaneUsers,
    boolean active
) {

   
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import java.time.LocalDateTime;

public record AccountResponse(
    Long id,
    String name,
    String slug,
    String schemaName,
    String status,
    LocalDateTime createdAt,
    LocalDateTime trialEndDate,
    ControlPlaneAdminUserSummaryResponse admin,
    boolean systemAccount
) {
    
   
  
    
  
}package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public record AccountStatusChangeRequest(
		@NotNull(message = "status é obrigatório")
        AccountStatus status,
        @Size(max = 255, message = "reason deve ter no máximo 255 caracteres")
        String reason
) {    }
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import java.time.LocalDateTime;

public record AccountStatusChangeResponse(
        Long id,
        String status,
        String previousStatus,
        LocalDateTime effectiveAt,
        String tenantSchema,
        SideEffects sideEffects
) {
    public record SideEffects(
            boolean tenantUsersUpdated,
            String action,     // "SUSPEND_BY_ACCOUNT" | "UNSUSPEND_BY_ACCOUNT" | "CANCELLED" | "NONE"
            int tenantUsersCount
    ) {}
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

public record AccountUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}
package brito.com.multitenancy001.controlplane.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record ControlPlaneAdminLoginRequest(
	    @NotBlank String username,
	    @NotBlank String password
	) {}package brito.com.multitenancy001.controlplane.api.dto.billing;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record AdminPaymentRequest(

        @NotNull
        Long accountId,

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotBlank
        String paymentMethod,

        @NotBlank
        String paymentGateway,

        String description
) {}
package brito.com.multitenancy001.controlplane.api.dto.billing;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record PaymentRequest(

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotBlank
        String paymentMethod,

        @NotBlank
        String paymentGateway,

        String description
) {}
package brito.com.multitenancy001.controlplane.api.dto.billing;



import java.math.BigDecimal;
import java.time.LocalDateTime;

public record PaymentResponse(
	    Long id,
	    Long accountId,
	    BigDecimal amount,
	    LocalDateTime paymentDate,
	    LocalDateTime validUntil,
	    String status,
	    String transactionId,
	    String paymentMethod,
	    String paymentGateway,
	    String description,
	    LocalDateTime createdAt,
	    LocalDateTime updatedAt
	) {}
// src/main/java/brito/com/multitenancy001/dtos/SignupRequest.java
package brito.com.multitenancy001.controlplane.api.dto.signup;

import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record SignupRequest(

    @NotBlank(message = "Nome da empresa é obrigatório")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    String name,

    @NotBlank(message = "Email da empresa é obrigatório")
    @Email(message = "Email inválido")
    String companyEmail,

    @NotNull(message = "Tipo de documento é obrigatório (CPF ou CNPJ)")
    DocumentType companyDocType,

    @NotBlank(message = "Número do documento é obrigatório")
    String companyDocNumber,

    @NotBlank(message = "Senha é obrigatória")
    @Pattern(
        regexp = ValidationPatterns.PASSWORD_PATTERN,
        message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas e números"
    )
    String password,

    @NotBlank(message = "Confirmação de senha é obrigatória")
    String confirmPassword
) 
	{
		   @AssertTrue(message = "As senhas não coincidem")
		   public boolean isPasswordMatching() {
		      if (password == null || confirmPassword == null) return true; // deixa @NotBlank fazer o trabalho
		      return password.equals(confirmPassword);
		   }
}
package brito.com.multitenancy001.controlplane.api.dto.users;

public record ControlPlaneAdminUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {
   
}
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.List;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;

@Builder
public record ControlPlaneUserCreateRequest(
    
    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String name,
    
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, 
             message = "Username inválido. Use apenas letras, números, . e _")
    @Size(min = 3, max = 50, message = "Username deve ter entre 3 e 50 caracteres")
    String username,
    
    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email inválido")
    @Size(max = 150, message = "Email não pode exceder 150 caracteres")
    String email,
    
    @NotBlank(message = "Senha é obrigatória")
    @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, 
             message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais")
    String password,
    
    @NotBlank(message = "Role é obrigatória")
    @Pattern(regexp = "PLATFORM_OWNER|PLATFORM_BILLING_MANAGER|PLATFORM_SUPPORT|PLATFORM_OPERATOR\r\n"
    		+ "", message = "Role inválida")
    String role,

    
    List<String> permissions,
    

    @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, 
             message = "Telefone inválido")
    @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
    String phone,
    
    @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
    String avatarUrl
    
) {
    
    public ControlPlaneUserCreateRequest {
        if (phone != null) {
            phone = phone.trim();
        }
        if (avatarUrl != null) {
            avatarUrl = avatarUrl.trim();
        }
    }
}package brito.com.multitenancy001.controlplane.api.dto.users;



import java.time.LocalDateTime;
import java.util.List;

public record ControlPlaneUserDetailsResponse(
    Long id,
    String username,
    String name,
    String email,
    String role,
    boolean suspendedByAccount,
    boolean suspendedByAdmin,
    LocalDateTime createdAt,
    LocalDateTime updatedAt,
    Long accountId,
    List<String> permissions
) {
    public ControlPlaneUserDetailsResponse {
        if (permissions == null) {
            permissions = List.of();
        }
    }
}package brito.com.multitenancy001.controlplane.api.mapper;

import java.time.Clock;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

@Component
public class AccountAdminDetailsApiMapper {
	
	private final Clock clock;
	private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;
	


	public AccountAdminDetailsApiMapper(Clock clock, ControlPlaneUserApiMapper controlPlaneUserApiMapper) {
	    this.clock = clock;
	    this.controlPlaneUserApiMapper = controlPlaneUserApiMapper;
	}


   public AccountAdminDetailsResponse toResponse(Account account, ControlPlaneUser admin, long totalUsers) {
	   LocalDateTime now = LocalDateTime.now(clock);
	   LocalDate today = now.toLocalDate();
	   LocalDate end = account.getTrialEndDate() != null ? account.getTrialEndDate().toLocalDate() : null;  
	   
	   


    boolean inTrial = account.getTrialEndDate() != null && now.isBefore(account.getTrialEndDate());
    boolean trialExpired = account.getTrialEndDate() != null && now.isAfter(account.getTrialEndDate());

    long trialDaysRemaining = 0;
    if (inTrial) {
        trialDaysRemaining = ChronoUnit.DAYS.between(today, end);
    }

    return new AccountAdminDetailsResponse(
        account.getId(),
        account.getName(),
        account.getSlug(),
        account.getSchemaName(),
        account.getStatus().name(),

        account.getCompanyDocType(),
        account.getCompanyDocNumber(),

        account.getCreatedAt(),
        account.getTrialEndDate(),
        account.getPaymentDueDate(),
        account.getDeletedAt(),

        inTrial,
        trialExpired,
        trialDaysRemaining,

        admin != null ? controlPlaneUserApiMapper.toAdminSummary(admin) : null,



        totalUsers,
        account.isActive()
    );
}

}
package brito.com.multitenancy001.controlplane.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class AccountApiMapper {
	
	private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;
	
	

    public AccountResponse toResponse(Account account) {
        return new AccountResponse(
            account.getId(),
            account.getName(),
            account.getSlug(),
            account.getSchemaName(),
            account.getStatus().name(),
            account.getCreatedAt(),
            account.getTrialEndDate(),
            null,
            account.isSystemAccount()
        );
    }

    public AccountResponse toResponse(Account account, ControlPlaneUser adminUser) {
        ControlPlaneAdminUserSummaryResponse adminResponse =
            adminUser != null ? controlPlaneUserApiMapper.toAdminSummary(adminUser) : null;

        return new AccountResponse(
            account.getId(),
            account.getName(),
            account.getSlug(),
            account.getSchemaName(),
            account.getStatus().name(),
            account.getCreatedAt(),
            account.getTrialEndDate(),
            adminResponse,
            account.isSystemAccount()
        );
    }
}
package brito.com.multitenancy001.controlplane.api.mapper;

import java.time.Clock;
import java.time.LocalDateTime;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

@Component
public class ControlPlaneUserApiMapper {

    private final Clock clock;

    public ControlPlaneUserApiMapper(Clock clock) {
        this.clock = clock;
    }

    public ControlPlaneAdminUserSummaryResponse toAdminSummary(ControlPlaneUser user) {
        LocalDateTime now = LocalDateTime.now(clock);
        boolean enabled = user.isEnabledForLogin(now);

        return new ControlPlaneAdminUserSummaryResponse(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                enabled
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.mapper.AccountAdminDetailsApiMapper;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.exec.PublicExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountLifecycleService {
	
	private final ControlPlaneUserRepository controlPlaneUserRepository;

	
	private final AccountAdminDetailsApiMapper accountAdminDetailsApiMapper;

	
	private final AccountApiMapper accountApiMapper;
	
	private final PublicExecutor publicExecutor;

	

    private final AccountRepository accountRepository;

    private final AccountOnboardingService accountOnboardingService;
    private final AccountStatusService accountStatusService;
    private final AccountTenantUserService accountTenantUserService;

    /* =========================================================
       1. ONBOARDING / SIGNUP
       ========================================================= */

    public AccountResponse createAccount(SignupRequest request) {
        return accountOnboardingService.createAccount(request);
    }

    /* =========================================================
       2. CONSULTAS (PUBLIC)
       ========================================================= */

    @Transactional(readOnly = true)
    public List<AccountResponse> listAllAccounts() {
        return publicExecutor.run(() ->
            accountRepository.findAllByDeletedFalse()
                .stream()
                .map(accountApiMapper::toResponse)
                .toList()
        );
    }


    @Transactional(readOnly = true)
    public AccountResponse getAccountById(Long accountId) {
        return publicExecutor.run(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
            return accountApiMapper.toResponse(account);
        });
    }


   @Transactional(readOnly = true)
public AccountAdminDetailsResponse getAccountAdminDetails(Long accountId) {
    return publicExecutor.run(() -> {
        Account account = accountRepository.findByIdAndDeletedFalse(accountId)
            .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

        long totalUsers = controlPlaneUserRepository.countByAccountIdAndDeletedFalse(accountId);

        return accountAdminDetailsApiMapper.toResponse(account, null, totalUsers);
    });
}



    /* =========================================================
       3. STATUS / SOFT DELETE / RESTORE
       ========================================================= */

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        return accountStatusService.changeAccountStatus(accountId, req);
    }

    public void softDeleteAccount(Long accountId) {
        accountStatusService.softDeleteAccount(accountId);
    }

    public void restoreAccount(Long accountId) {
        accountStatusService.restoreAccount(accountId);
    }

    

    public List<AccountUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyActive) {
        return accountTenantUserService.listTenantUsers(accountId, onlyActive);
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        accountTenantUserService.setUserSuspendedByAdmin(accountId, userId, suspended);
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.time.LocalDateTime;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.exec.PublicExecutor;
import brito.com.multitenancy001.infrastructure.exec.TenantExecutor;
import brito.com.multitenancy001.infrastructure.exec.TxExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;
import brito.com.multitenancy001.tenant.application.username.generator.UsernameGeneratorService;
import brito.com.multitenancy001.tenant.domain.security.TenantRole;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;


@Service
@RequiredArgsConstructor
@Slf4j
public class AccountOnboardingService {
	
	private final UsernameGeneratorService usernameGenerator;

	
	private final AccountApiMapper accountApiMapper;
	
	private final PublicExecutor publicExecutor;
	private final TxExecutor txExecutor;
	private final TenantExecutor tenantExecutor;

	
	
	private final PublicAccountService publicAccountService;
	  private final TenantSchemaProvisioningService tenantSchemaProvisioningService;
	  private final TenantUserRepository tenantUserRepository;
	  private final PasswordEncoder passwordEncoder;
	   private final AccountRepository accountRepository;
	  

    /* =========================================================
       1. CRIAÇÃO DE CONTA 
       ========================================================= */

	   public AccountResponse createAccount(SignupRequest request) {
		    validateSignupRequest(request);
		    
		    log.info("Tentando criar conta");

		    Account account = txExecutor.publicTx(() ->
		        publicExecutor.run(() -> publicAccountService.createAccountFromSignup(request))
		    );

		    tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(account.getSchemaName());

		    createTenantOwnerInTenant(account, request);

		    log.info("✅ Account criada | accountId={} | schema={} | slug={}",
		            account.getId(), account.getSchemaName(), account.getSlug());

		    return accountApiMapper.toResponse(account);
		}

    

protected TenantUser createTenantOwnerInTenant(Account account, SignupRequest request) {
    return tenantExecutor.run(account.getSchemaName(), () ->
        txExecutor.tenantTx(() -> {

            boolean emailExists = tenantUserRepository
                    .existsByEmailAndAccountId(request.companyEmail(), account.getId());

            if (emailExists) {
                throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já cadastrado nesta conta", 409);
            }

            TenantUser u = new TenantUser();
            u.setAccountId(account.getId());
            u.setName("Administrador");
            u.setEmail(request.companyEmail());
            u.setPassword(passwordEncoder.encode(request.password()));
            u.setRole(TenantRole.TENANT_ACCOUNT_OWNER);
            u.setSuspendedByAccount(false);
            u.setSuspendedByAdmin(false);
            u.setCreatedAt(LocalDateTime.now());
            u.setTimezone("America/Sao_Paulo");
            u.setLocale("pt_BR");

            for (int attempt = 0; attempt < 5; attempt++) {
                u.setUsername(usernameGenerator.generateFromEmail(request.companyEmail(), account.getId()));

                try {
                    return tenantUserRepository.save(u);
                } catch (DataIntegrityViolationException e) {
                    log.warn("Colisão de username ao criar admin. Tentativa {}. accountId={} email={}",
                            attempt + 1, account.getId(), request.companyEmail());
                }
            }

            throw new IllegalStateException("Failed to create tenant admin due to repeated username collisions");
        })
    );
}
  
    
  
  
   
   
    
    private void validateSignupRequest(SignupRequest request) {
        if (!StringUtils.hasText(request.name())) {
            throw new ApiException("INVALID_COMPANY_NAME", "Nome da empresa é obrigatório", 400);
        }
        
        if (!StringUtils.hasText(request.companyEmail())) {
            throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
        }

        if (!request.companyEmail().contains("@")) {
            throw new ApiException("INVALID_EMAIL", "Email inválido", 400);
        }

        // ✅ docType + docNumber
        if (request.companyDocType() == null) {
            throw new ApiException("INVALID_COMPANY_DOC_TYPE", "Tipo de documento é obrigatório", 400);
        }

        if (!StringUtils.hasText(request.companyDocNumber())) {
            throw new ApiException("INVALID_COMPANY_DOC_NUMBER", "Número do documento é obrigatório", 400);
        }

        if (!StringUtils.hasText(request.password()) || !StringUtils.hasText(request.confirmPassword())) {
            throw new ApiException("INVALID_PASSWORD", "Senha e confirmação são obrigatórias", 400);
        }

        if (!request.password().equals(request.confirmPassword())) {
            throw new ApiException("PASSWORD_MISMATCH", "As senhas não coincidem", 400);
        }

        // ✅ ajuste para método que faz sentido com seus campos atuais
        if (accountRepository.existsByCompanyEmailAndDeletedFalse(request.companyEmail())) {
            throw new ApiException("EMAIL_ALREADY_REGISTERED",
                    "Email já cadastrado na plataforma", 409);
        }

        // ✅ recomendável também bloquear duplicidade de docNumber
        if (accountRepository.existsByCompanyDocTypeAndCompanyDocNumberAndDeletedFalse(
                request.companyDocType(), request.companyDocNumber()
        )) {
            throw new ApiException("DOC_ALREADY_REGISTERED",
                    "Documento já cadastrado na plataforma", 409);
        }
        
    }



	

	

    
}

package brito.com.multitenancy001.controlplane.application;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.exec.PublicExecutor;
import brito.com.multitenancy001.infrastructure.exec.TenantExecutor;
import brito.com.multitenancy001.infrastructure.exec.TxExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountStatusService {

    private final PublicExecutor publicExecutor;
    private final TenantExecutor tenantExecutor;
    private final TxExecutor txExecutor;

    private final AccountRepository accountRepository;
    private final TenantUserRepository tenantUserRepository;

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        return txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            AccountStatus previous = account.getStatus(); // ✅ captura antes de alterar

            // ... mantenha aqui suas regras de transição, validações, etc ...

            account.setStatus(req.status());
            if (req.status() == AccountStatus.ACTIVE) {
                account.setDeletedAt(null);
            }
            accountRepository.save(account);

            int affected = 0;
            boolean applied = false;
            String action = "NONE";

            if (req.status() == AccountStatus.SUSPENDED) {
                affected = suspendTenantUsersByAccount(account);
                applied = true;
                action = "SUSPEND_BY_ACCOUNT";
            } else if (req.status() == AccountStatus.ACTIVE) {
                affected = unsuspendTenantUsersByAccount(account);
                applied = true;
                action = "UNSUSPEND_BY_ACCOUNT";
            } else if (req.status() == AccountStatus.CANCELLED) {
                affected = cancelAccount(account);
                applied = true;
                action = "CANCELLED";
            }

            return buildStatusChangeResponse(account, previous, applied, action, affected);
        }));
    }

    private int cancelAccount(Account account) {
        // 1) PUBLIC (REQUIRES_NEW)
        txExecutor.publicRequiresNew(() -> publicExecutor.run(() -> {
            account.setDeletedAt(LocalDateTime.now());
            accountRepository.save(account);
            return null;
        }));

        // 2) TENANT (REQUIRES_NEW), best-effort (retorna 0 se schema/tabela não existir)
        return tenantExecutor.runIfReady(
            account.getSchemaName(),
            "users_tenant",
            () -> txExecutor.tenantRequiresNew(() -> {
                List<TenantUser> users = tenantUserRepository.findByAccountId(account.getId());
                users.forEach(TenantUser::softDelete);
                tenantUserRepository.saveAll(users);
                return users.size();
            }),
            0
        );
    }

    protected int suspendTenantUsersByAccount(Account account) {
        return tenantExecutor.runIfReady(
            account.getSchemaName(),
            "users_tenant",
            () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.suspendAllByAccount(account.getId())),
            0
        );
    }

    protected int unsuspendTenantUsersByAccount(Account account) {
        return tenantExecutor.runIfReady(
            account.getSchemaName(),
            "users_tenant",
            () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.unsuspendAllByAccount(account.getId())),
            0
        );
    }

    public void softDeleteAccount(Long accountId) {
        txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isSystemAccount()) {
                throw new ApiException("SYSTEM_ACCOUNT_PROTECTED",
                        "Não é permitido excluir contas do sistema", 403);
            }

            account.softDelete();
            accountRepository.save(account);

            softDeleteTenantUsers(accountId);

            return null;
        }));
    }

    public void restoreAccount(Long accountId) {
        txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isSystemAccount() && account.isDeleted()) {
                throw new ApiException("SYSTEM_ACCOUNT_PROTECTED",
                        "Contas do sistema não podem ser restauradas via este endpoint", 403);
            }

            account.restore();
            accountRepository.save(account);

            restoreTenantUsers(accountId);

            return null;
        }));
    }

    private Account getAccountByIdRaw(Long accountId) {
        return accountRepository.findById(accountId)
            .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
    }

   private void softDeleteTenantUsers(Long accountId) {

    Account account = txExecutor.publicReadOnlyTx(() ->
        publicExecutor.run(() -> getAccountByIdRaw(accountId))
    );

    tenantExecutor.runIfReady(account.getSchemaName(), "users_tenant", () -> {
        txExecutor.tenantRequiresNew(() -> {
            List<TenantUser> users = tenantUserRepository.findByAccountId(account.getId());
            users.forEach(u -> { if (!u.isDeleted()) u.softDelete(); });
            tenantUserRepository.saveAll(users);
            return null;
        });
        return null;
    }, null);
}

    private void restoreTenantUsers(Long accountId) {
        Account account = txExecutor.publicReadOnlyTx(() -> publicExecutor.run(() -> getAccountByIdRaw(accountId)));

        tenantExecutor.runIfReady(account.getSchemaName(), "users_tenant", () -> {
            txExecutor.tenantRequiresNew(() -> {
                List<TenantUser> users = tenantUserRepository.findByAccountId(account.getId());
                users.forEach(u -> { if (u.isDeleted()) u.restore(); });
                tenantUserRepository.saveAll(users);
                return null;
            });
            return null;
        }, null);
    }

    private AccountStatusChangeResponse buildStatusChangeResponse(
            Account account,
            AccountStatus previous,
            boolean tenantUsersUpdated,
            String action,
            int count
    ) {
        return new AccountStatusChangeResponse(
                account.getId(),
                account.getStatus().name(),
                previous.name(),
                LocalDateTime.now(),
                account.getSchemaName(),
                new AccountStatusChangeResponse.SideEffects(tenantUsersUpdated, action, count)
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.exec.PublicExecutor;
import brito.com.multitenancy001.infrastructure.exec.TenantExecutor;
import brito.com.multitenancy001.infrastructure.exec.TxExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.tenant.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountTenantUserService {

    private final TenantUserApiMapper tenantUserApiMapper;

    private final PublicExecutor publicExecutor;
    private final TenantExecutor tenantExecutor;
    private final TxExecutor txExecutor;

    private final AccountRepository accountRepository;
    private final TenantUserRepository tenantUserRepository;

    public List<AccountUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyActive) {

        Account account = publicExecutor.run(() ->
            accountRepository.findByIdAndDeletedFalse(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );

        // ✅ Evita problema de assinatura do runOrThrow: faz explícito
        tenantExecutor.assertReadyOrThrow(account.getSchemaName(), "users_tenant");

        return tenantExecutor.run(account.getSchemaName(), () ->
            txExecutor.tenantReadOnlyTx(() -> {
                List<TenantUser> users = onlyActive
                    ? tenantUserRepository.findActiveUsersByAccount(account.getId())
                    : tenantUserRepository.findByAccountId(account.getId());

                return users.stream()
                        .map(tenantUserApiMapper::toAccountUserSummary)
                        .toList();
            })
        );
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {

        Account account = publicExecutor.run(() ->
            accountRepository.findByIdAndDeletedFalse(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );

        // ✅ idem
        tenantExecutor.assertReadyOrThrow(account.getSchemaName(), "users_tenant");

        tenantExecutor.run(account.getSchemaName(), () ->
            txExecutor.tenantTx(() -> {
                int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
                if (updated == 0) {
                    throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado ou removido", 404);
                }
                return null;
            })
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AdminAuthService {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final ControlPlaneUserRepository controlPlaneUserRepository;

    public JwtResponse loginSuperAdmin(ControlPlaneAdminLoginRequest request) {


        TenantContext.clear();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByUsernameAndDeletedFalse(request.username())
                .orElseThrow(() -> new ApiException(
                        "USER_NOT_FOUND",
                        "Super admin não encontrado",
                        404
                ));

        // 🔒 Regras de negócio
        if (user.isSuspendedByAccount() ) {
            throw new ApiException(
                    "ACCESS_DENIED",
                    "Usuário não autorizado",
                    403
            );
        }

        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        request.username(),
                        request.password()
                )
        );

        String accessToken = jwtTokenProvider.generateControlPlaneToken(
                authentication,
                user.getAccount().getId(),
                "public"
        );

        String refreshToken = jwtTokenProvider.generateRefreshToken(
                user.getUsername(),
                "public"
        );

        return new JwtResponse(
                accessToken,
                refreshToken,
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getRole().name(),
                user.getAccount().getId(),
                "public"
        );
    }
}
package brito.com.multitenancy001.controlplane.application.billing;

import brito.com.multitenancy001.controlplane.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.billing.PaymentRepository;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentService {

	private final AccountRepository accountRepository;
	private final PaymentRepository paymentRepository;
	private final SecurityUtils securityUtils;

	@Scheduled(cron = "${app.payment.check-cron:0 0 0 * * *}")
	public void checkPayments() {
		log.info("Iniciando verificação de pagamentos...");
		LocalDateTime today = LocalDateTime.now();

		List<Account> expiredTrials = accountRepository.findByStatus(AccountStatus.FREE_TRIAL).stream()
				.filter(account -> account.getTrialEndDate() != null && account.getTrialEndDate().isBefore(today))
				.collect(Collectors.toList());

		for (Account account : expiredTrials) {
			suspendAccount(account, "Trial expirado");
		}

		List<Account> overdueAccounts = accountRepository.findByPaymentDueDateBefore(today);

		for (Account account : overdueAccounts) {
			if (account.getStatus() == AccountStatus.ACTIVE) {
				suspendAccount(account, "Pagamento atrasado");
			}
		}

		checkExpiredPendingPayments();
	}

	private void suspendAccount(Account account, String reason) {
		account.setStatus(AccountStatus.SUSPENDED);
		accountRepository.save(account);
		sendSuspensionEmail(account, reason);
	}

	private void checkExpiredPendingPayments() {
		LocalDateTime thirtyMinutesAgo = LocalDateTime.now().minusMinutes(30);

		List<Payment> expiredPayments = paymentRepository.findByStatusAndCreatedAtBefore(PaymentStatus.PENDING,
				thirtyMinutesAgo);

		for (Payment payment : expiredPayments) {
			payment.setStatus(PaymentStatus.EXPIRED);
			paymentRepository.save(payment);
		}
	}

	@Transactional
	public PaymentResponse processPaymentForAccount(AdminPaymentRequest request) {

		if (request.accountId() == null) {
			throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
		}

		Account account = accountRepository.findById(request.accountId())
				.orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

		// Reusa validação central (mantém regras iguais)
		validatePayment(account, request.amount());

		Payment payment = Payment.builder().account(account).amount(request.amount())
				.paymentMethod(request.paymentMethod()).paymentGateway(request.paymentGateway())
				.description(request.description()).status(PaymentStatus.PENDING).build();

		payment = paymentRepository.save(payment);

		boolean ok = processWithPaymentGateway(payment, new PaymentRequest(request.amount(), request.paymentMethod(),
				request.paymentGateway(), request.description()));

		if (ok) {
			completePayment(payment, account);
			return mapToResponse(payment);
		}

		failPayment(payment, "Falha no processamento do pagamento");

		throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
	}

	@Transactional
	public PaymentResponse processPaymentForMyAccount(PaymentRequest request) {
		Long accountId = securityUtils.getCurrentAccountId();
		Account account = findAccountOrThrow(accountId);

		validatePayment(account, request.amount());

		Payment payment = Payment.builder().account(account).amount(request.amount())
				.paymentMethod(request.paymentMethod()).paymentGateway(request.paymentGateway())
				.description(request.description()).status(PaymentStatus.PENDING).build();

		payment = paymentRepository.save(payment);

		boolean ok = processWithPaymentGateway(payment, request);

		if (ok) {
			completePayment(payment, account);
			return mapToResponse(payment);
		}

		failPayment(payment, "Falha no processamento do pagamento");

		throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
	}

	@Transactional(readOnly = true)
	public List<PaymentResponse> getPaymentsByMyAccount() {
		Long accountId = securityUtils.getCurrentAccountId();
		return getPaymentsByAccount(accountId);
	}

	@Transactional(readOnly = true)
	public boolean hasActivePaymentMyAccount() {
		Long accountId = securityUtils.getCurrentAccountId();
		return hasActivePayment(accountId);
	}



	@Transactional(readOnly = true)
	public List<PaymentResponse> getPaymentsByAccount(Long accountId) {
		return paymentRepository.findByAccountId(accountId).stream().map(this::mapToResponse)
				.collect(Collectors.toList());
	}

	@Transactional(readOnly = true)
	public boolean hasActivePayment(Long accountId) {
		return paymentRepository.findActivePayment(accountId, LocalDateTime.now()).isPresent();
	}

	

	@Transactional(readOnly = true)
	public PaymentResponse getPaymentById(Long paymentId) {
		Payment payment = paymentRepository.findById(paymentId)
				.orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));
		return mapToResponse(payment);
	}

	@Transactional
	public PaymentResponse completePaymentManually(Long paymentId) {

		Payment payment = paymentRepository.findById(paymentId)
				.orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

		if (payment.getStatus() != PaymentStatus.PENDING) {
			throw new ApiException("INVALID_PAYMENT_STATUS", "Pagamento não está pendente", 409);
		}

		completePayment(payment, payment.getAccount());
		return mapToResponse(payment);
	}

	@Transactional
	public PaymentResponse refundPayment(Long paymentId, BigDecimal amount, String reason) {

		Payment payment = paymentRepository.findById(paymentId)
				.orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

		if (!payment.canBeRefunded()) {
			throw new ApiException("PAYMENT_NOT_REFUNDABLE", "Pagamento não pode ser reembolsado", 409);
		}

		if (amount == null) {
			payment.refundFully(reason);
		} else {
			payment.refundPartially(amount, reason);
		}

		paymentRepository.save(payment);
		return mapToResponse(payment);
	}

	@Transactional(readOnly = true)
	public BigDecimal getTotalRevenue(LocalDateTime startDate, LocalDateTime endDate) {
		List<Object[]> revenueByAccount = paymentRepository.getRevenueByAccount(startDate, endDate);

		return revenueByAccount.stream().map(obj -> (BigDecimal) obj[1]).reduce(BigDecimal.ZERO, BigDecimal::add);
	}

	/*
	 * ========================================================= PRIVATE HELPERS
	 * =========================================================
	 */

	private Account findAccountOrThrow(Long accountId) {
		return accountRepository.findById(accountId)
				.orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
	}

	private void completePayment(Payment payment, Account account) {
		payment.markAsCompleted();
		payment.setTransactionId(generateTransactionId());
		paymentRepository.save(payment);

		account.setStatus(AccountStatus.ACTIVE);
		account.setPaymentDueDate(calculateNextDueDate(payment.getValidUntil()));
		accountRepository.save(account);

		sendPaymentConfirmationEmail(account, payment);
	}

	private void failPayment(Payment payment, String reason) {
		payment.markAsFailed(reason);
		paymentRepository.save(payment);
	}

	private void validatePayment(Account account, BigDecimal amount) {

		if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
			throw new ApiException("INVALID_AMOUNT", "Valor do pagamento inválido", 400);
		}

		if (account.isDeleted()) {
			throw new ApiException("ACCOUNT_DELETED", "Conta deletada", 410);
		}

		Optional<Payment> activePayment = paymentRepository.findActivePayment(account.getId(), LocalDateTime.now());

		if (activePayment.isPresent()) {
			throw new ApiException("PAYMENT_ALREADY_EXISTS", "Já existe um pagamento ativo para esta conta", 409);
		}
	}

	private PaymentResponse mapToResponse(Payment payment) {
		return new PaymentResponse(payment.getId(), payment.getAccount().getId(), payment.getAmount(),
				payment.getPaymentDate(), payment.getValidUntil(), payment.getStatus().name(),
				payment.getTransactionId(), payment.getPaymentMethod(), payment.getPaymentGateway(),
				payment.getDescription(), payment.getCreatedAt(), payment.getUpdatedAt());
	}

	private void sendSuspensionEmail(Account account, String reason) {
		log.info("Enviando email de suspensão para: {}", account.getCompanyEmail());
	}

	private void sendPaymentConfirmationEmail(Account account, Payment payment) {
		log.info("Enviando confirmação de pagamento para: {}", account.getCompanyEmail());
	}

	private String generateTransactionId() {
		return "TXN_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
	}

	private LocalDateTime calculateNextDueDate(LocalDateTime validUntil) {
		return validUntil != null ? validUntil : LocalDateTime.now().plusMonths(1);
	}

	private boolean processWithPaymentGateway(Payment payment, PaymentRequest request) {

		log.info("Processando pagamento com gateway: {}", request.paymentGateway());

		try {
			Thread.sleep(1000);
			return Math.random() < 0.9;

		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			log.error("Erro ao processar pagamento no gateway", e);
			return false;
		}
	}
}
package brito.com.multitenancy001.controlplane.application;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;

import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "publicTransactionManager")
public class PublicAccountService {

    private final AccountRepository accountRepository;


  
    public Account createAccountFromSignup(SignupRequest request) {
    	 TenantContext.clear();

    	    int maxAttempts = 5;
    	    for (int attempt = 1; attempt <= maxAttempts; attempt++) {
    	        String slug = generateSlug(request.name());
    	        String schemaName = generateSchemaName(request.name());

    	        try {
    	            Account account = new Account();
    	            account.setName(request.name());
    	            account.setSlug(slug);
    	            account.setSchemaName(schemaName);

    	            account.setCompanyEmail(request.companyEmail());

    	            // ✅ novos campos (sempre em conjunto)
    	            account.setCompanyDocType(request.companyDocType());
    	            account.setCompanyDocNumber(request.companyDocNumber());

    	            account.setCreatedAt(LocalDateTime.now());
    	            account.setTrialEndDate(LocalDateTime.now().plusDays(30));
    	            account.setStatus(AccountStatus.FREE_TRIAL);
    	            account.setSystemAccount(false);

    	            // Defaults
    	            account.setSubscriptionPlan("FREE");
    	            account.setMaxUsers(5);
    	            account.setMaxProducts(100);
    	            account.setMaxStorageMb(100);
    	            account.setCompanyCountry("Brasil");
    	            account.setTimezone("America/Sao_Paulo");
    	            account.setLocale("pt_BR");
    	            account.setCurrency("BRL");

    	            return accountRepository.save(account);

    	        } catch (DataIntegrityViolationException e) {
    	            if (!isSlugOrSchemaUniqueViolation(e)) throw e;
    	            log.warn("⚠️ Colisão (tentativa {}/{}) | slug={} | schema={}",
    	                    attempt, maxAttempts, slug, schemaName);
    	        }
    	    }

    	    throw new ApiException("ACCOUNT_CREATE_FAILED",
    	            "Não foi possível criar conta (colisão de identificadores). Tente novamente.", 409);
    	}
    
    
    private String generateSlug(String name) {
        String base = (name == null ? "conta" : name.toLowerCase())
                .replaceAll("[^a-z0-9]+", "-")
                .replaceAll("(^-|-$)", "");

        String slug = base;
        int i = 1;

        while (accountRepository.findBySlugAndDeletedFalse(slug).isPresent()) {
            slug = base + "-" + (i++);
        }
        return slug;
    }

    private String generateSchemaName(String name) {
        String base = (name == null ? "tenant" : name.toLowerCase())
                .replaceAll("[^a-z0-9]", "_");
        return "tenant_" + base + "_" + UUID.randomUUID().toString().substring(0, 8);
    }

   
    
    

    private boolean isSlugOrSchemaUniqueViolation(Throwable e) {
        Throwable t = e;
        while (t.getCause() != null) t = t.getCause();
        String msg = (t.getMessage() == null) ? "" : t.getMessage().toLowerCase();

        return msg.contains("ux_accounts_slug_active")
                || msg.contains("uk_accounts_slug")
                || msg.contains("uk_accounts_schema_name")
                || msg.contains("accounts_slug_key")
                || msg.contains("accounts_schema_name_key")
                || msg.contains("company_email");
    }

}
package brito.com.multitenancy001.controlplane.application.user;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneRole;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.security.PermissionNormalizer;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Clock;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;

@Service
@Transactional
@RequiredArgsConstructor
public class ControlPlaneUserService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final AccountRepository accountRepository;
    private final PasswordEncoder passwordEncoder;
    private final Clock clock;
   
    

    private Account getControlPlaneAccount() {
        TenantContext.clear(); // PUBLIC
        return accountRepository.findBySlugAndDeletedFalse("controlplane")
                .orElseThrow(() -> new ApiException(
                        "CONTROLPLANE_ACCOUNT_NOT_FOUND",
                        "Conta controlplane não encontrada. Rode a migration V3__insert_controlplane_account.sql",
                        500
                ));
    }

   public ControlPlaneUserDetailsResponse createControlPlaneUser(ControlPlaneUserCreateRequest request) {
    TenantContext.clear();

    Account controlPlaneAccount = getControlPlaneAccount();

    // validações básicas
    if (!request.password().matches(ValidationPatterns.PASSWORD_PATTERN)) {
        throw new ApiException("INVALID_PASSWORD", "A senha não atende aos requisitos de segurança", 400);
    }
    if (request.username() == null || request.username().isBlank()) {
        throw new ApiException("INVALID_USERNAME", "Username é obrigatório", 400);
    }
    if (!request.username().matches(ValidationPatterns.USERNAME_PATTERN)) {
        throw new ApiException("INVALID_USERNAME", "Username inválido", 400);
    }

    String username = request.username().toLowerCase().trim();

    // role permitida somente plataforma
    ControlPlaneRole role;
    try {
        role = ControlPlaneRole.valueOf(request.role().toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new ApiException("INVALID_ROLE", "Role inválida para plataforma", 400);
    }

   

    if (controlPlaneUserRepository.existsByUsernameAndAccountId(username, controlPlaneAccount.getId())) {
        throw new ApiException("USERNAME_ALREADY_EXISTS", "Username já existe", 409);
    }
    if (controlPlaneUserRepository.existsByEmailAndAccountId(request.email(), controlPlaneAccount.getId())) {
        throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já existe", 409);
    }

    // =========================================================
    // ✅ AQUI É O LOCAL EXATO: antes do builder
    // =========================================================
    Set<String> normalizedPermissions;
    try {
        normalizedPermissions = PermissionNormalizer.normalizeControlPlane(request.permissions());
    } catch (IllegalArgumentException e) {
        throw new ApiException("INVALID_PERMISSION", e.getMessage(), 400);
    }
    // =========================================================

    ControlPlaneUser user = ControlPlaneUser.builder()
            .name(request.name())
            .username(username)
            .email(request.email())
            .password(passwordEncoder.encode(request.password()))
            .role(role)
            .account(controlPlaneAccount)
            .suspendedByAccount(false)
            .suspendedByAdmin(false)

            // =====================================================
            // ✅ E AQUI: dentro do builder, antes do .build()
            // =====================================================
            .permissions(normalizedPermissions)

            // =====================================================

            .build();

    return mapToResponse(controlPlaneUserRepository.save(user));
}


    @Transactional(readOnly = true)
    public List<ControlPlaneUserDetailsResponse> listControlPlaneUsers() {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();
        return controlPlaneUserRepository.findByAccountId(controlPlaneAccount.getId()).stream()
                .filter(u -> !u.isDeleted())
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    public ControlPlaneUserDetailsResponse getControlPlaneUser(Long userId) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404);
        }

        return mapToResponse(user);
    }
    
    
    
    
    
    
    public ControlPlaneUserDetailsResponse updateControlPlaneUserStatus(Long userId, boolean active) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_DELETED", "Usuário está removido", 409);
        }

        // ✅ ação manual do admin da plataforma
        user.setSuspendedByAdmin(!active);

        return mapToResponse(controlPlaneUserRepository.save(user));
    }

    
    

    public void softDeleteControlPlaneUser(Long userId) {
    	   LocalDateTime now = LocalDateTime.now(clock);
           long suffix = clock.millis();
           
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_ALREADY_DELETED", "Usuário já removido", 409);
        }

     
        user.softDelete(now, suffix);
        controlPlaneUserRepository.save(user);

    }
    

    public ControlPlaneUserDetailsResponse restoreControlPlaneUser(Long userId) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));

        if (!user.isDeleted()) {
            throw new ApiException("USER_NOT_DELETED", "Usuário não está removido", 409);
        }

        user.restore();
        return mapToResponse(controlPlaneUserRepository.save(user));
    }
    
    

   private ControlPlaneUserDetailsResponse mapToResponse(ControlPlaneUser user) {
    return new ControlPlaneUserDetailsResponse(
            user.getId(),
            user.getUsername(),
            user.getName(),
            user.getEmail(),
            user.getRole().name(),
            user.isSuspendedByAccount(),
            user.isSuspendedByAdmin(),
            user.getCreatedAt(),
            user.getUpdatedAt(),
            user.getAccount().getId(),
            user.getPermissions() == null
                    ? List.of()
                    : user.getPermissions().stream().sorted().toList()
    );
}

}
package brito.com.multitenancy001.controlplane.domain.account;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "accounts")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Account {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "is_system_account", nullable = false)
    @Builder.Default
    private boolean systemAccount = false;

    @Column(nullable = false, length = 150)
    private String name;

    @Column(name = "schema_name", nullable = false, unique = true, length = 100)
    private String schemaName;

    @Column(name = "slug", nullable = false, unique = true, length = 50)
    private String slug;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    @Builder.Default
    private AccountStatus status = AccountStatus.FREE_TRIAL;

    // ✅ AUDITORIA (técnico)
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // ✅ NEGÓCIO
    @Column(name = "trial_end_date")
    private LocalDateTime trialEndDate;

    @Column(name = "payment_due_date")
    private LocalDateTime paymentDueDate;

    @Column(name = "next_billing_date")
    private LocalDateTime nextBillingDate;

    @Column(name = "subscription_plan", length = 50)
    @Builder.Default
    private String subscriptionPlan = "FREE";

    @Column(name = "max_users")
    @Builder.Default
    private Integer maxUsers = 5;

    @Column(name = "max_products")
    @Builder.Default
    private Integer maxProducts = 100;

    @Column(name = "max_storage_mb")
    @Builder.Default
    private Integer maxStorageMb = 100;

    @Column(name = "company_email", nullable = false, length = 150)
    private String companyEmail;

    @Enumerated(EnumType.STRING)
    @Column(name = "company_doc_type", nullable = false, length = 10)
    private DocumentType companyDocType;

    @Column(name = "company_doc_number", nullable = false, length = 20)
    private String companyDocNumber;

    @Column(name = "company_phone", length = 20)
    private String companyPhone;

    @Column(name = "company_address", length = 500)
    private String companyAddress;

    @Column(name = "company_city", length = 100)
    private String companyCity;

    @Column(name = "company_state", length = 50)
    private String companyState;

    @Column(name = "company_country", length = 50)
    @Builder.Default
    private String companyCountry = "Brasil";

    @Column(name = "timezone", length = 50)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", length = 10)
    @Builder.Default
    private String locale = "pt_BR";

    @Column(name = "currency", length = 3)
    @Builder.Default
    private String currency = "BRL";

    @OneToMany(mappedBy = "account", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    @ToString.Exclude
    private List<ControlPlaneUser> controlPlaneUsers = new ArrayList<>();

    @Column(name = "settings_json", columnDefinition = "TEXT")
    private String settingsJson;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @PrePersist
    protected void onCreate() {
        // base para regras de negócio (não use createdAt aqui)
        LocalDateTime now = LocalDateTime.now();

        // slug
        if (this.slug == null || this.slug.isBlank()) {
            this.slug = this.name.toLowerCase()
                .replaceAll("[^a-z0-9]+", "-")
                .replaceAll("(^-|-$)", "");
        }

        // schemaName
        if (this.schemaName == null) {
            this.schemaName =
                "tenant_" +
                this.slug.replace("-", "_") +
                "_" +
                UUID.randomUUID().toString().substring(0, 8);
        }

        // trial
        if (this.trialEndDate == null) {
            this.trialEndDate = now.plusDays(30);
        }
    }

    public boolean isTrialActive() {
        return this.status == AccountStatus.FREE_TRIAL &&
               this.trialEndDate != null &&
               this.trialEndDate.isAfter(LocalDateTime.now());
    }

    public boolean isActive() {
        return this.status == AccountStatus.ACTIVE ||
               (this.status == AccountStatus.FREE_TRIAL && isTrialActive());
    }

    public boolean isPaymentOverdue() {
        return this.paymentDueDate != null &&
               this.paymentDueDate.isBefore(LocalDateTime.now());
    }

    public long getDaysRemainingInTrial() {
        if (this.trialEndDate == null || !isTrialActive()) return 0;
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDateTime.now(), this.trialEndDate);
    }

    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        this.deletedAt = LocalDateTime.now();
        this.status = AccountStatus.CANCELLED;
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        this.deletedAt = null;
        this.status = AccountStatus.ACTIVE;
    }

    public boolean isSystemAccount() {
        return this.systemAccount || "public".equals(this.schemaName);
    }
}
package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountStatus {
    FREE_TRIAL("Trial Gratuito"),
    ACTIVE("Ativa"),
    SUSPENDED("Suspensa"),
    CANCELLED("Cancelada"),
    EXPIRED("Expirada");
    
    private final String description;
    
    AccountStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * Verifica se o status permite operações
     */
    public boolean isOperational() {
        return this == FREE_TRIAL || this == ACTIVE;
    }
    
    /**
     * Verifica se o status está em trial
     */
    public boolean isTrial() {
        return this == FREE_TRIAL;
    }
    
    /**
     * Verifica se o status está ativo
     */
    public boolean isActive() {
        return this == ACTIVE;
    }
    
    /**
     * Verifica se o status está suspenso
     */
    public boolean isSuspended() {
        return this == SUSPENDED;
    }
    
    /**
     * Verifica se o status está cancelado
     */
    public boolean isCancelled() {
        return this == CANCELLED || this == EXPIRED;
    }
}package brito.com.multitenancy001.controlplane.domain.account;

import lombok.Getter;

@Getter
public enum DocumentType {
    CPF,
    CNPJ;

   
    }
package brito.com.multitenancy001.controlplane.domain.billing;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "payments", indexes = {
    @Index(name = "idx_payment_account", columnList = "account_id"),
    @Index(name = "idx_payment_status", columnList = "status"),
    @Index(name = "idx_payment_transaction", columnList = "transaction_id", unique = true),
    @Index(name = "idx_payment_date", columnList = "payment_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    // ✅ NEGÓCIO
    @Column(name = "payment_date", nullable = false)
    private LocalDateTime paymentDate;

    // ✅ NEGÓCIO
    @Column(name = "valid_until")
    private LocalDateTime validUntil;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private PaymentStatus status = PaymentStatus.PENDING;

    @Column(name = "transaction_id", unique = true, length = 100)
    private String transactionId;

    @Column(name = "payment_method", length = 50)
    private String paymentMethod;

    @Column(name = "payment_gateway", length = 50)
    private String paymentGateway;

    @Column(name = "currency", length = 3)
    @Builder.Default
    private String currency = "BRL";

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    @Column(name = "invoice_url")
    private String invoiceUrl;

    @Column(name = "receipt_url")
    private String receiptUrl;

    // ✅ AUDITORIA (técnico)
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // ✅ NEGÓCIO
    @Column(name = "refunded_at")
    private LocalDateTime refundedAt;

    @Column(name = "refund_amount", precision = 10, scale = 2)
    private BigDecimal refundAmount;

    @Column(name = "refund_reason", length = 500)
    private String refundReason;

    @PrePersist
    protected void onCreate() {
        if (this.transactionId == null) {
            this.transactionId = "PAY_" + UUID.randomUUID().toString()
                    .replace("-", "")
                    .substring(0, 16)
                    .toUpperCase();
        }

        if (this.paymentDate == null) {
            this.paymentDate = LocalDateTime.now();
        }

        if (this.status == PaymentStatus.COMPLETED && this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil();
        }
    }

    private LocalDateTime calculateDefaultValidUntil() {
        return this.paymentDate.plusDays(30);
    }

    public void markAsCompleted() {
        this.status = PaymentStatus.COMPLETED;
        if (this.validUntil == null) this.validUntil = calculateDefaultValidUntil();
    }

    public void markAsFailed(String reason) {
        this.status = PaymentStatus.FAILED;
        if (this.metadataJson == null) {
            this.metadataJson = "{\"failure_reason\":\"" + reason + "\"}";
        }
    }

    public void refundPartially(BigDecimal amount, String reason) {
        if (amount.compareTo(BigDecimal.ZERO) <= 0 || amount.compareTo(this.amount) > 0) {
            throw new IllegalArgumentException("Valor de reembolso inválido");
        }
        this.refundAmount = amount;
        this.refundReason = reason;
        this.refundedAt = LocalDateTime.now();
        this.status = PaymentStatus.REFUNDED;
    }

    public void refundFully(String reason) {
        this.refundAmount = this.amount;
        this.refundReason = reason;
        this.refundedAt = LocalDateTime.now();
        this.status = PaymentStatus.REFUNDED;
    }

    public boolean isActive() {
        return this.status == PaymentStatus.COMPLETED &&
               (this.validUntil == null || this.validUntil.isAfter(LocalDateTime.now()));
    }

    public boolean canBeRefunded() {
        return this.status == PaymentStatus.COMPLETED &&
               this.refundedAt == null &&
               this.paymentDate.isAfter(LocalDateTime.now().minusDays(90));
    }
}
package brito.com.multitenancy001.controlplane.domain.billing;



public enum PaymentStatus {
    PENDING("Pendente"),
    COMPLETED("Concluído"),
    FAILED("Falhou"),
    REFUNDED("Reembolsado"),
    CANCELLED("Cancelado"),
    EXPIRED("Expirado");
    
    private final String description;
    
    PaymentStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * Verifica se o status indica pagamento bem-sucedido
     */
    public boolean isSuccessful() {
        return this == COMPLETED;
    }
    
    /**
     * Verifica se o status indica pagamento finalizado (não pendente)
     */
    public boolean isFinal() {
        return this != PENDING;
    }
    
    /**
     * Converte string para PaymentStatus
     */
    public static PaymentStatus fromString(String status) {
        if (status == null) {
            return PENDING;
        }
        try {
            return PaymentStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            return PENDING;
        }
    }
}package brito.com.multitenancy001.controlplane.domain.security;

import brito.com.multitenancy001.shared.security.PermissionAuthority;

public enum ControlPlanePermission implements PermissionAuthority {

    CP_TENANT_READ,
    CP_TENANT_SUSPEND,
    CP_TENANT_ACTIVATE,
    CP_TENANT_DELETE,

    CP_BILLING_READ,
    CP_BILLING_WRITE,

    CP_SUPPORT_RESET_PASSWORD,

    CP_USER_READ,
    CP_USER_WRITE,
    CP_USER_DELETE;

    @Override
    public String asAuthority() {
        return name();
    }
}
package brito.com.multitenancy001.controlplane.domain.security;

import java.util.EnumSet;
import java.util.Set;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneRole;

public final class ControlPlaneRolePermissions {

    private ControlPlaneRolePermissions() {}

    public static Set<ControlPlanePermission> permissionsFor(ControlPlaneRole role) {
        if (role == null) return Set.of();

        return switch (role) {
            case PLATFORM_OWNER -> EnumSet.allOf(ControlPlanePermission.class);

            case PLATFORM_BILLING_MANAGER -> EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_TENANT_SUSPEND,
                ControlPlanePermission.CP_TENANT_ACTIVATE,
                ControlPlanePermission.CP_BILLING_READ,
                ControlPlanePermission.CP_BILLING_WRITE
            );

            case PLATFORM_SUPPORT -> EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_TENANT_SUSPEND,
                ControlPlanePermission.CP_TENANT_ACTIVATE,
                ControlPlanePermission.CP_USER_READ,
                ControlPlanePermission.CP_USER_WRITE
            );

            case PLATFORM_OPERATOR -> EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_USER_READ
            );
        };
    }
}
package brito.com.multitenancy001.controlplane.domain.user;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum ControlPlaneRole implements RoleAuthority {

    PLATFORM_OWNER,
    PLATFORM_BILLING_MANAGER,  
    PLATFORM_SUPPORT,
    PLATFORM_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isSuperAdmin() {
        return this == PLATFORM_OWNER;
    }

    public boolean isBillingAdmin() {
        return this == PLATFORM_BILLING_MANAGER;
    }
}
package brito.com.multitenancy001.controlplane.domain.user;

import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.shared.security.PermissionNormalizer;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(
    name = "controlplane_users",
    schema = "public",
    uniqueConstraints = {
        @UniqueConstraint(name = "ux_controlplane_users_username", columnNames = {"account_id", "username"}),
        @UniqueConstraint(name = "ux_controlplane_users_email", columnNames = {"account_id", "email"})
    }
)
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
@ToString(exclude = { "account", "password" })
public class ControlPlaneUser {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(name = "username", nullable = false, length = 100)
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inválido.")
    private String username;

    @Column(name = "password", nullable = false, length = 255)
    private String password;

    @Column(name = "email", nullable = false, length = 150)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 40)
    private ControlPlaneRole role;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    // 🔐 SEGURANÇA
    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts", nullable = false)
    @Builder.Default
    private Integer failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private Boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    // ✅ ESTES CAMPOS EXISTEM NA MIGRATION
    @Column(name = "timezone", length = 50)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", length = 10)
    @Builder.Default
    private String locale = "pt_BR";

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    // 🧾 AUDITORIA
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
        name = "controlplane_user_permissions",
        joinColumns = @JoinColumn(name = "user_id")
    )
    @Column(name = "permission", nullable = false, length = 120)
    @Builder.Default
    private Set<String> permissions = new HashSet<>();
    
    @PrePersist
    @PreUpdate
    private void normalizePermissions() {
        // garante Set não nulo
        if (permissions == null) permissions = new HashSet<>();

        // normaliza prefixo/trim e bloqueia TEN_ no controlplane
        permissions = PermissionNormalizer.normalizeControlPlane(permissions);
    }


    

    // ✅ se lockedUntil estiver no futuro: lock
    public boolean isAccountNonLocked(LocalDateTime now) {
        return lockedUntil == null || !lockedUntil.isAfter(now);
    }

    // ✅ enabled “puro” (não deletado / não suspenso)
    public boolean isEnabledForLogin() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    // ✅ decisão final de login (enabled + lock)
    public boolean isEnabledForLogin(LocalDateTime now) {
        return isEnabledForLogin() && isAccountNonLocked(now);
    }

    public void softDelete(LocalDateTime now, long uniqueSuffix) {
        if (deleted) return;
        deleted = true;
        deletedAt = now;

        suspendedByAccount = true;
        suspendedByAdmin = true;

        username = "deleted_" + username + "_" + uniqueSuffix;
        email = "deleted_" + email + "_" + uniqueSuffix;
    }

    public void restore() {
        this.deleted = false;
        this.deletedAt = null;
        this.suspendedByAccount = false;
        this.suspendedByAdmin = false;
    }
}
package brito.com.multitenancy001.controlplane.persistence.account;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {

    boolean existsByCompanyEmailAndDeletedFalse(String companyEmail);

    // ✅ docType + docNumber juntos
    boolean existsByCompanyDocTypeAndCompanyDocNumberAndDeletedFalse(DocumentType companyDocType, String companyDocNumber);

    List<Account> findAllByDeletedFalse();
    List<Account> findByDeletedFalseOrderByCreatedAtDesc();

    Optional<Account> findBySlugAndDeletedFalse(String slug);
    Optional<Account> findByIdAndDeletedFalse(Long id);

    List<Account> findByStatus(AccountStatus status);
    List<Account> findByStatusAndDeletedFalse(AccountStatus status);
    List<Account> findByPaymentDueDateBefore(LocalDateTime date);

    @Query("SELECT a FROM Account a WHERE a.trialEndDate <= :date AND a.status = :status")
    List<Account> findExpiredTrials(@Param("date") LocalDateTime date, @Param("status") AccountStatus status);

    @Query("SELECT COUNT(a) FROM Account a WHERE a.deleted = false")
    Long countActiveAccounts();

    @Query("SELECT a FROM Account a WHERE a.status = :status AND a.paymentDueDate < :today")
    List<Account> findOverdueAccounts(@Param("status") AccountStatus status, @Param("today") LocalDateTime today);

    boolean existsByNameAndDeletedFalse(String name);
    boolean existsBySchemaNameAndDeletedFalse(String schemaName);

    @Query("SELECT a FROM Account a WHERE a.createdAt BETWEEN :startDate AND :endDate")
    List<Account> findAccountsCreatedBetween(@Param("startDate") LocalDateTime startDate,
                                                   @Param("endDate") LocalDateTime endDate);

    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.status IN :statuses")
    List<Account> findByStatuses(@Param("statuses") List<AccountStatus> statuses);

    @Query("SELECT a FROM Account a WHERE LOWER(a.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) AND a.deleted = false")
    List<Account> searchByName(@Param("searchTerm") String searchTerm);
}
package brito.com.multitenancy001.controlplane.persistence.billing;



import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface PaymentRepository extends JpaRepository<Payment, Long> {
    
    List<Payment> findByAccountId(Long accountId);
    
    List<Payment> findByAccountIdAndStatus(Long accountId, PaymentStatus status);
    
    Page<Payment> findByAccountId(Long accountId, Pageable pageable);
    
    Optional<Payment> findByTransactionId(String transactionId);
    
    List<Payment> findByStatus(PaymentStatus status);
    
    List<Payment> findByStatusAndCreatedAtBefore(PaymentStatus status, LocalDateTime date);
    
    List<Payment> findByValidUntilBeforeAndStatus(LocalDateTime date, PaymentStatus status);
    
    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' ORDER BY p.paymentDate DESC")
    List<Payment> findCompletedPaymentsByAccount(@Param("accountId") Long accountId);
    
    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.validUntil > :now AND p.status = 'COMPLETED'")
    Optional<Payment> findActivePayment(@Param("accountId") Long accountId, @Param("now") LocalDateTime now);
    
    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalPaidInPeriod(@Param("accountId") Long accountId, 
                                   @Param("startDate") LocalDateTime startDate, 
                                   @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT COUNT(p) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED'")
    Long countCompletedPayments(@Param("accountId") Long accountId);
    
    @Query("SELECT p FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate")
    List<Payment> findPaymentsInPeriod(@Param("startDate") LocalDateTime startDate, 
                                      @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT p.account.id, SUM(p.amount) FROM Payment p WHERE p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate GROUP BY p.account.id")
    List<Object[]> getRevenueByAccount(@Param("startDate") LocalDateTime startDate, 
                                      @Param("endDate") LocalDateTime endDate);
    
    boolean existsByTransactionId(String transactionId);
}package brito.com.multitenancy001.controlplane.persistence.user;



import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlaneUserRepository extends JpaRepository<ControlPlaneUser, Long> {
	
	Optional<ControlPlaneUser> findByUsernameAndAccount_IdAndDeletedFalse(String username, Long accountId);


	long countByAccountIdAndDeletedFalse(Long accountId);
	
	Optional<ControlPlaneUser> findFirstByAccountIdAndDeletedFalse(Long accountId);
    
    Optional<ControlPlaneUser> findByUsername(String username);
    
    Optional<ControlPlaneUser> findByEmail(String email);
    
    List<ControlPlaneUser> findByAccountId(Long accountId);
    
    @Query("SELECT (COUNT(u) > 0) FROM ControlPlaneUser u " +
    	       "WHERE u.username = :username AND u.account.id = :accountId AND u.deleted = false")
    	boolean existsByUsernameAndAccountId(@Param("username") String username,
    	                                     @Param("accountId") Long accountId);
    
    
    
    @Query("SELECT (COUNT(u) > 0) FROM ControlPlaneUser u " +
    	       "WHERE u.email = :email AND u.account.id = :accountId AND u.deleted = false")
    	boolean existsByEmailAndAccountId(@Param("email") String email,
    	                                  @Param("accountId") Long accountId);    
    Optional<ControlPlaneUser> findByIdAndAccountId(Long id, Long accountId);
    
    Optional<ControlPlaneUser> findByUsernameAndDeletedFalse(String username);
    
    Optional<ControlPlaneUser> findByEmailAndDeletedFalse(String email);
}package brito.com.multitenancy001.infrastructure.config;

import java.time.Clock;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TimeConfig {

    @Bean
    public Clock systemClock() {
        return Clock.systemDefaultZone();
    }
}
package brito.com.multitenancy001.infrastructure.db.flyway;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PublicFlywayConfig {

    @Bean
    public Flyway flywayAccount(DataSource dataSource) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas("public")
                .locations("classpath:db/migration/accounts")
                .baselineOnMigrate(true)
                .load();

        // 🚀 EXECUTA NA INICIALIZAÇÃO
        //flyway.migrate();

        return flyway;
    }
}
package brito.com.multitenancy001.infrastructure.db.flyway;

import org.flywaydb.core.Flyway;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Component
@RequiredArgsConstructor
@Slf4j
public class PublicFlywayRunner implements ApplicationRunner {

    private final Flyway flywayAccount;
    
   

    @Override
    public void run(ApplicationArguments args) {
    	
   
    	
    	
        log.info("🚀 Executando Flyway ACCOUNT (public)");
        flywayAccount.migrate();
    }
}
package brito.com.multitenancy001.infrastructure.db.flyway;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class PublicSchemaVerifier {
    
    private final JdbcTemplate jdbc;
    
    @EventListener(ApplicationReadyEvent.class)
    public void verifyTables() {
        log.info("🔍 Verificando tabelas criadas pelo Flyway...");
        
        try {
            // Apenas VERIFICA, não cria
            Integer accountsCount = jdbc.queryForObject(
                "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'accounts'", 
                Integer.class
            );
            
            Integer usersCount = jdbc.queryForObject(
            	    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'controlplane_users'",
            	    Integer.class
            	);

            
            log.info("✅ Verificação OK! Tabelas encontradas: accounts={}, controlplane_users={}", accountsCount, usersCount);

        } catch (Exception e) {
            log.error("⚠️ Aviso na verificação: {}", e.getMessage());
        }
    }
}package brito.com.multitenancy001.infrastructure.exec;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Component
public class PublicExecutor {

    public <T> T run(Supplier<T> supplier) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            return supplier.get();
        }
    }

    public void run(Runnable runnable) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            runnable.run();
        }
    }
}
package brito.com.multitenancy001.infrastructure.exec;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;

@Component
public class TenantExecutor {

    private final TenantSchemaProvisioningService tenantSchemaService;

    public TenantExecutor(TenantSchemaProvisioningService tenantSchemaService) {
        this.tenantSchemaService = tenantSchemaService;
    }

    public <T> T run(String schema, Supplier<T> fn) {
        if (schema == null || "public".equals(schema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inválido", 404);
        }

        // ✅ padronizado: nada de bind/clear manual
        try (TenantContext.Scope ignored = TenantContext.scope(schema)) {
            return fn.get();
        }
    }

    public void run(String schema, Runnable fn) {
        run(schema, () -> { fn.run(); return null; });
    }

    /** Retorna defaultValue se schema/tabela não existir (bom p/ side-effects). */
    public <T> T runIfReady(String schema, String requiredTable, Supplier<T> fn, T defaultValue) {
        if (schema == null || "public".equals(schema)) return defaultValue;
        if (!tenantSchemaService.schemaExists(schema)) return defaultValue;
        if (requiredTable != null && !tenantSchemaService.tableExists(schema, requiredTable)) return defaultValue;
        return run(schema, fn);
    }

    /** Lança ApiException se schema/tabela não existir (bom p/ endpoints admin). */
    public void assertReadyOrThrow(String schema, String requiredTable) {
        if (schema == null || "public".equals(schema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inválido", 404);
        }
        if (!tenantSchemaService.schemaExists(schema)) {
            throw new ApiException("TENANT_SCHEMA_NOT_FOUND", "Schema do tenant não existe", 404);
        }
        if (requiredTable != null && !tenantSchemaService.tableExists(schema, requiredTable)) {
            throw new ApiException("TENANT_TABLE_NOT_FOUND", "Tabela " + requiredTable + " não existe no tenant", 404);
        }
    }

    public <T> T runOrThrow(String schema, String requiredTable, Supplier<T> fn) {
        assertReadyOrThrow(schema, requiredTable);
        return run(schema, fn);
    }
}
package brito.com.multitenancy001.infrastructure.exec;

import java.util.function.Supplier;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

@Component
public class TxExecutor {

    private final TransactionTemplate publicTx;
    private final TransactionTemplate publicRequiresNew;

    private final TransactionTemplate publicReadOnlyTx;
    private final TransactionTemplate publicRequiresNewReadOnly;

    private final TransactionTemplate tenantTx;
    private final TransactionTemplate tenantRequiresNew;

    private final TransactionTemplate tenantReadOnlyTx;
    private final TransactionTemplate tenantRequiresNewReadOnly;

    public TxExecutor(
            @Qualifier("publicTransactionManager") PlatformTransactionManager publicTm,
            @Qualifier("tenantTransactionManager") PlatformTransactionManager tenantTm
    ) {
        // PUBLIC - REQUIRED
        this.publicTx = new TransactionTemplate(publicTm);
        this.publicTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // PUBLIC - REQUIRES_NEW
        this.publicRequiresNew = new TransactionTemplate(publicTm);
        this.publicRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // PUBLIC - REQUIRED READONLY
        this.publicReadOnlyTx = new TransactionTemplate(publicTm);
        this.publicReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.publicReadOnlyTx.setReadOnly(true);

        // PUBLIC - REQUIRES_NEW READONLY
        this.publicRequiresNewReadOnly = new TransactionTemplate(publicTm);
        this.publicRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.publicRequiresNewReadOnly.setReadOnly(true);

        // TENANT - REQUIRED
        this.tenantTx = new TransactionTemplate(tenantTm);
        this.tenantTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // TENANT - REQUIRES_NEW
        this.tenantRequiresNew = new TransactionTemplate(tenantTm);
        this.tenantRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // TENANT - REQUIRED READONLY
        this.tenantReadOnlyTx = new TransactionTemplate(tenantTm);
        this.tenantReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.tenantReadOnlyTx.setReadOnly(true);

        // TENANT - REQUIRES_NEW READONLY
        this.tenantRequiresNewReadOnly = new TransactionTemplate(tenantTm);
        this.tenantRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.tenantRequiresNewReadOnly.setReadOnly(true);
    }

    // ---------- PUBLIC ----------
    public <T> T publicTx(Supplier<T> fn) {
        return publicTx.execute(status -> fn.get());
    }
    public void publicTx(Runnable fn) {
        publicTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNew(Supplier<T> fn) {
        return publicRequiresNew.execute(status -> fn.get());
    }
    public void publicRequiresNew(Runnable fn) {
        publicRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicReadOnlyTx(Supplier<T> fn) {
        return publicReadOnlyTx.execute(status -> fn.get());
    }
    public void publicReadOnlyTx(Runnable fn) {
        publicReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNewReadOnly(Supplier<T> fn) {
        return publicRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void publicRequiresNewReadOnly(Runnable fn) {
        publicRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }

    // ---------- TENANT ----------
    public <T> T tenantTx(Supplier<T> fn) {
        return tenantTx.execute(status -> fn.get());
    }
    public void tenantTx(Runnable fn) {
        tenantTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNew(Supplier<T> fn) {
        return tenantRequiresNew.execute(status -> fn.get());
    }
    public void tenantRequiresNew(Runnable fn) {
        tenantRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantReadOnlyTx(Supplier<T> fn) {
        return tenantReadOnlyTx.execute(status -> fn.get());
    }
    public void tenantReadOnlyTx(Runnable fn) {
        tenantReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNewReadOnly(Supplier<T> fn) {
        return tenantRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void tenantRequiresNewReadOnly(Runnable fn) {
        tenantRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
@EnableJpaRepositories(
    basePackages =  "brito.com.multitenancy001.controlplane",
    entityManagerFactoryRef = "publicEntityManagerFactory",
    transactionManagerRef = "publicTransactionManager"
)
public class ControlPlanePersistenceConfig {

    @Bean(name = "publicTransactionManager")
    @Primary
    public PlatformTransactionManager publicTransactionManager(
            @Qualifier("publicEntityManagerFactory") EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.extern.slf4j.Slf4j;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

@Slf4j
@Component
public class CurrentTenantSchemaResolver
        implements CurrentTenantIdentifierResolver<String> {

    private static final String DEFAULT_SCHEMA = "public";
    private static final ThreadLocal<String> TENANT_THREAD_LOCAL = new ThreadLocal<>();

    /**
     * Bind do tenant na thread atual.
     * - Se vier vazio/nulo: remove o tenant (fica "sem tenant", e o resolver decide fallback).
     * - Se vier preenchido: seta no ThreadLocal.
     */
    public static void bindTenantToCurrentThread(String tenantId) {
        String previous = TENANT_THREAD_LOCAL.get();

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (StringUtils.hasText(normalized)) {
            TENANT_THREAD_LOCAL.set(normalized);
            if (!normalized.equals(previous)) {
                log.info("🔄 Tenant bindado à thread: {} -> {}", previous, normalized);
            } else {
                log.debug("🔄 Tenant já estava bindado: {}", normalized);
            }
        } else {
            TENANT_THREAD_LOCAL.remove();
            if (previous != null) {
                log.info("🧹 Tenant removido da thread (anterior: {})", previous);
            } else {
                log.debug("🧹 Tenant já estava vazio (nada para remover)");
            }
        }
    }

    /**
     * Retorna o tenant REALMENTE bindado.
     * ✅ Importante: aqui retornamos null quando não há tenant,
     * pra não mascarar estado e facilitar debug.
     */
    public static String resolveBoundTenantOrNull() {
        String t = TENANT_THREAD_LOCAL.get();
        return StringUtils.hasText(t) ? t : null;
    }

    /**
     * Mantém compatibilidade com seu código atual (ex.: logs do provider).
     * Use isso somente quando você quer um fallback explícito para public.
     */
    public static String resolveBoundTenantOrDefault() {
        String t = resolveBoundTenantOrNull();
        return (t != null ? t : DEFAULT_SCHEMA);
    }

    public static void unbindTenantFromCurrentThread() {
        String previous = TENANT_THREAD_LOCAL.get();
        TENANT_THREAD_LOCAL.remove();
        if (previous != null) {
            log.info("🧹 Tenant desbindado da thread (anterior: {})", previous);
        } else {
            log.debug("🧹 Tenant desbindado (já estava vazio)");
        }
    }

    /**
     * O Hibernate sempre precisa de um tenant válido.
     * ✅ Aqui sim a gente aplica fallback para DEFAULT_TENANT.
     */
    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenant = resolveBoundTenantOrNull();
        String resolved = (tenant != null ? tenant : DEFAULT_SCHEMA);

        if (log.isDebugEnabled()) {
            log.debug("🏷️ Hibernate resolveu tenant={} (bound={}, default={})",
                    resolved, tenant, DEFAULT_SCHEMA);
        }
        return resolved;
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return false;
    }

    @Override
    public boolean isRoot(String tenantIdentifier) {
        return DEFAULT_SCHEMA.equals(tenantIdentifier);
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
@EnableJpaRepositories(
		basePackages = "brito.com.multitenancy001.tenant",
		entityManagerFactoryRef = "tenantEntityManagerFactory",
		transactionManagerRef = "tenantTransactionManager")
public class TenantPlanePersistenceConfig {

	@Bean(name = "tenantTransactionManager")
	public PlatformTransactionManager tenantTransactionManager(
			@Qualifier("tenantEntityManagerFactory") EntityManagerFactory emf) {
		return new JpaTransactionManager(emf);
	}
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.sql.DataSource;
import java.sql.*;

@Slf4j
@Component
@RequiredArgsConstructor
public class TenantSchemaConnectionProvider
        extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String> {

    private static final long serialVersionUID = 1L;
    private static final String DEFAULT_TENANT = "public";

    private final DataSource dataSource;

    @Override
    protected DataSource selectAnyDataSource() {
        return dataSource;
    }

    @Override
    protected DataSource selectDataSource(String tenantIdentifier) {
        return dataSource;
    }

    @Override
    public Connection getConnection(String tenantIdentifier) throws SQLException {

        long threadId = Thread.currentThread().threadId();
        String threadTenant = CurrentTenantSchemaResolver.resolveBoundTenantOrDefault();

        String effectiveTenant = StringUtils.hasText(tenantIdentifier)
                ? tenantIdentifier
                : DEFAULT_TENANT;

        if (!StringUtils.hasText(tenantIdentifier)) {
            log.warn("⚠️ [MT] tenantIdentifier vazio → usando DEFAULT ({}) | threadTenant={}",
                    DEFAULT_TENANT, threadTenant);
        }

        validateSchemaName(effectiveTenant);

        Connection connection = dataSource.getConnection();

        try (Statement stmt = connection.createStatement()) {

            if (!DEFAULT_TENANT.equals(effectiveTenant)) {
                ensureSchemaExists(connection, effectiveTenant);

                String quotedTenant = quoteIdentifier(effectiveTenant);

                String setSearchPath = "SET search_path TO " + quotedTenant + ", public";
                log.info("🎯 [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL={}",
                        threadId, tenantIdentifier, threadTenant, setSearchPath);

                stmt.execute(setSearchPath);

            } else {
                log.info("🏠 [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL=SET search_path TO public;",
                        threadId, tenantIdentifier, threadTenant);

                stmt.execute("SET search_path TO public;");
            }

            return connection;

        } catch (SQLException e) {
            log.error("❌ [MT] Erro configurando conexão | effectiveTenant={}", effectiveTenant, e);
            try { connection.close(); } catch (SQLException ignore) {}
            throw e;
        }
    }

    @Override
    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
        if (connection == null || connection.isClosed()) return;

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("SET search_path TO public;");
        } finally {
            connection.close();
        }
    }

    private void ensureSchemaExists(Connection connection, String schemaName) throws SQLException {
        String quotedSchema = quoteIdentifier(schemaName);

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE SCHEMA IF NOT EXISTS " + quotedSchema);
        }

        try (PreparedStatement ps = connection.prepareStatement(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = ?")) {
            ps.setString(1, schemaName);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    throw new SQLException("Schema " + schemaName + " não encontrado após CREATE");
                }
            }
        }
    }

    private void validateSchemaName(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new IllegalArgumentException("schemaName vazio");
        }
        if (!schemaName.matches("[A-Za-z_][A-Za-z0-9_]*")) {
            throw new IllegalArgumentException("schemaName inválido: " + schemaName);
        }
    }

    private String quoteIdentifier(String identifier) {
        return "\"" + identifier + "\"";
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class TenantSchemaHibernateConfig {

    private final DataSource dataSource;
    private final TenantSchemaConnectionProvider multiTenantConnectionProvider;
    private final CurrentTenantSchemaResolver tenantResolver;

    @Bean(name = "publicEntityManagerFactory")
    @Primary
    public LocalContainerEntityManagerFactoryBean publicEntityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);
        emf.setPackagesToScan("brito.com.multitenancy001.controlplane.domain");
        emf.setPersistenceUnitName("PUBLIC_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();

        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);
        props.put("hibernate.default_schema", "public");

        emf.setJpaPropertyMap(props);
        return emf;
    }

    @Bean(name = "tenantEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        // ✅ aqui:
        emf.setPackagesToScan("brito.com.multitenancy001.tenant.domain");
        // (ou "brito.com.multitenancy001.tenant" se você quer pegar tudo do tenant)

        emf.setPersistenceUnitName("TENANT_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);

        props.put("hibernate.multiTenancy", "SCHEMA");
        props.put("hibernate.multi_tenant_connection_provider", multiTenantConnectionProvider);
        props.put("hibernate.tenant_identifier_resolver", tenantResolver);

        emf.setJpaPropertyMap(props);
        return emf;
    }

}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
public class TransactionManagementConfig {
}
package brito.com.multitenancy001.infrastructure.multitenancy.observability;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Aspect
@Component
@Slf4j
public class TenantContextMonitor {
    
    @Around("@within(org.springframework.stereotype.Service)")
    public Object monitorServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        String currentTenant = TenantContext.getOrNull();
        
        log.debug("🏁 INÍCIO {} - Tenant: {}", methodName, currentTenant);
        
        try {
            Object result = joinPoint.proceed();
            log.debug("✅ FIM {} - Tenant: {}", methodName, TenantContext.getOrNull());
            return result;
        } catch (Exception e) {
            log.error("❌ ERRO {} - Tenant: {} - Erro: {}", 
                     methodName, currentTenant, e.getMessage());
            throw e;
        }
    }
}package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;

@Getter
public class AuthenticatedUserContext implements UserDetails {

    private static final long serialVersionUID = 1L;

    private final Long userId;
    private final String username;
    private final String email;
    private final String password;

    private final boolean enabled;
    private final boolean accountNonLocked;

    private final Long accountId;
    private final String schemaName;

    // opcional: manter role para debug/claims (NÃO entra em authorities)
    private final String roleAuthority;

    // ✅ permission-only
    private final Collection<? extends GrantedAuthority> authorities;

    public AuthenticatedUserContext(
            ControlPlaneUser user,
            String schemaName,
            LocalDateTime now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.password = user.getPassword();

        this.accountId = user.getAccount().getId();
        this.schemaName = schemaName;

        this.roleAuthority = user.getRole() != null ? user.getRole().asAuthority() : null;

        this.authorities = authorities;

        this.enabled = user.isEnabledForLogin();
        this.accountNonLocked = user.isAccountNonLocked(now);
    }

    public AuthenticatedUserContext(
            TenantUser user,
            String schemaName,
            LocalDateTime now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.password = user.getPassword();

        this.accountId = user.getAccountId();
        this.schemaName = schemaName;

        this.roleAuthority = user.getRole() != null ? user.getRole().asAuthority() : null;

        this.authorities = authorities;

        this.enabled = !user.isDeleted() && !user.isSuspendedByAccount() && !user.isSuspendedByAdmin();
        this.accountNonLocked = user.getLockedUntil() == null || !user.getLockedUntil().isAfter(now);
    }

    @Override public Collection<? extends GrantedAuthority> getAuthorities() { return authorities; }
    @Override public String getPassword() { return password; }
    @Override public String getUsername() { return username; }

    @Override public boolean isAccountNonExpired() { return true; }
    @Override public boolean isAccountNonLocked() { return accountNonLocked; }
    @Override public boolean isCredentialsNonExpired() { return true; }
    @Override public boolean isEnabled() { return enabled; }
}
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.infrastructure.security.filter.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz

                // =========================
                // 🔓 PUBLIC
                // =========================
                .requestMatchers("/actuator/health").permitAll()

                // =========================
                // 🔓 AUTH CONTROLPLANE (admin)
                // =========================
                .requestMatchers(
                    "/api/admin/auth/login",
                    "/api/admin/auth/refresh"
                ).permitAll()

                // =========================
                // 🔓 AUTH TENANT
                // =========================
                .requestMatchers(
                    "/api/tenant/auth/login",
                    "/api/tenant/auth/refresh"
                ).permitAll()

                // =========================
                // 🔓 PASSWORD RESET TENANT
                // =========================
                .requestMatchers(
                    "/api/tenant/password/forgot",
                    "/api/tenant/password/reset"
                ).permitAll()

                // =========================
                // 🔓 SIGNUP / CHECKUSER
                // =========================
                .requestMatchers(
                    "/api/accounts/auth/checkuser",
                    "/api/signup"
                ).permitAll()

                // =========================
                // ✅ BOUNDARIES OFICIAIS
                // =========================
                .requestMatchers("/api/admin/**").authenticated()
                .requestMatchers("/api/controlplane/**").authenticated()
                .requestMatchers("/api/tenant/**").authenticated()

                // =========================
                // ❌ Qualquer rota fora disso é erro de arquitetura
                // =========================
                .anyRequest().denyAll()
            );

        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
}
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final MultiContextUserDetailsService multiContextUserDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        boolean bound = false;

        try {
            final String authHeader = request.getHeader("Authorization");

            if (!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
                filterChain.doFilter(request, response);
                return;
            }

            final String jwt = authHeader.substring(7);

            if (!jwtTokenProvider.validateToken(jwt)) {
                filterChain.doFilter(request, response);
                return;
            }

            final String tokenType = jwtTokenProvider.getTokenType(jwt);
            final String username = jwtTokenProvider.getUsernameFromToken(jwt);

            // ✅ TRAVA: token tem que bater com a rota
            if (requiresControlPlane(request) && !"CONTROLPLANE".equals(tokenType)) {
                filterChain.doFilter(request, response);
                return;
            }
            if (requiresTenant(request) && !"TENANT".equals(tokenType)) {
                filterChain.doFilter(request, response);
                return;
            }

            // só aceitamos TENANT / CONTROLPLANE aqui
            if (!"TENANT".equals(tokenType) && !"CONTROLPLANE".equals(tokenType)) {
                filterChain.doFilter(request, response);
                return;
            }

            if (!StringUtils.hasText(username)) {
                filterChain.doFilter(request, response);
                return;
            }

            if (SecurityContextHolder.getContext().getAuthentication() == null) {

                UserDetails userDetails;

                if ("TENANT".equals(tokenType)) {
                    final String tenantSchema = jwtTokenProvider.getTenantSchemaFromToken(jwt);

                    if (!StringUtils.hasText(tenantSchema) || "public".equalsIgnoreCase(tenantSchema)) {
                        filterChain.doFilter(request, response);
                        return;
                    }

                    if (!tenantSchema.matches("^[a-zA-Z0-9_]+$")) {
                        filterChain.doFilter(request, response);
                        return;
                    }

                    TenantContext.bind(tenantSchema);
                    bound = true;

                    Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
                    if (accountId == null) {
                        filterChain.doFilter(request, response);
                        return;
                    }

                    userDetails = multiContextUserDetailsService.loadTenantUser(username, accountId);

                } else { // CONTROLPLANE
                    String context = jwtTokenProvider.getContextFromToken(jwt);
                    if (StringUtils.hasText(context) && !"public".equalsIgnoreCase(context)) {
                        filterChain.doFilter(request, response);
                        return;
                    }

                    Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
                    if (accountId == null) {
                        filterChain.doFilter(request, response);
                        return;
                    }

                    userDetails = multiContextUserDetailsService.loadControlPlaneUser(username, accountId);
                }

                UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities()
                        );

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }

            filterChain.doFilter(request, response);

        } finally {
            if (bound) {
                TenantContext.clear();
            }
        }
    }

    private boolean requiresControlPlane(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/api/admin/") || path.startsWith("/api/controlplane/");
    }

    private boolean requiresTenant(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/api/tenant/");
    }

}
package brito.com.multitenancy001.infrastructure.security.jwt;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtTokenProvider {

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private long jwtExpirationInMs;

    @Value("${app.jwt.refresh.expiration}")
    private long refreshExpirationInMs;

    private SecretKey key;

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            throw new IllegalArgumentException("JWT secret must be at least 256 bits (32 chars)");
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    /* =========================
       TOKEN CONTROLPLANE
       ========================= */
    public String generateControlPlaneToken(
            Authentication authentication,
            Long accountId,
            String context
    ) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getUsername())
                // ✅ permission-first: authorities = CP_*
                .claim("authorities", user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim("type", "CONTROLPLANE")
                .claim("context", context)
                .claim("accountId", accountId)
                .claim("userId", user.getUserId())
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       TOKEN TENANT
       ========================= */
    public String generateTenantToken(
            Authentication authentication,
            Long accountId,
            String context
    ) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getUsername())
                // ✅ permission-first: authorities = TEN_*
                .claim("authorities", user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim("type", "TENANT")
                .claim("context", context)
                .claim("accountId", accountId)
                .claim("userId", user.getUserId())
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       REFRESH TOKEN
       ========================= */
    public String generateRefreshToken(String username, String context) {
        return Jwts.builder()
                .subject(username)
                .claim("type", "REFRESH")
                .claim("context", context)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + refreshExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       PASSWORD RESET TOKEN
       ========================= */
    public String generatePasswordResetToken(String username, String context, Long accountId) {
        return Jwts.builder()
                .subject(username)
                .claim("type", "PASSWORD_RESET")
                .claim("context", context)
                .claim("accountId", accountId)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + 3600000)) // 1h
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       LEITURA DE CLAIMS
       ========================= */
    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    public String getUsernameFromToken(String token) {
        return getAllClaimsFromToken(token).getSubject();
    }

    /**
     * Obtém o contexto do token (antigo tenantSchema)
     * Mantém compatibilidade retornando "tenantSchema" se "context" não existir
     */
    public String getContextFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String context = claims.get("context", String.class);
        if (context == null) {
            context = claims.get("tenantSchema", String.class);
        }

        String type = claims.get("type", String.class);

        // ✅ Só TENANT não pode ter public
        if ("TENANT".equals(type) && "public".equalsIgnoreCase(context)) {
            throw new JwtException("Invalid context for TENANT token: public");
        }

        return context;
    }

    public String getTenantSchemaFromToken(String token) {
        return getContextFromToken(token);
    }

    public Long getAccountIdFromToken(String token) {
        return getAllClaimsFromToken(token).get("accountId", Long.class);
    }

    public String getTokenType(String token) {
        return getAllClaimsFromToken(token).get("type", String.class);
    }

    public Long getUserIdFromToken(String token) {
        return getAllClaimsFromToken(token).get("userId", Long.class);
    }

    /**
     * ✅ NOVO: lê authorities do token (permission-first).
     * Compatível com tokens antigos que ainda tenham "roles".
     */
    public List<String> getAuthoritiesFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        // novo padrão
        String authorities = claims.get("authorities", String.class);

        // compatibilidade antiga (se existir)
        if (!StringUtils.hasText(authorities)) {
            authorities = claims.get("roles", String.class);
        }

        return splitCsv(authorities);
    }

    private List<String> splitCsv(String csv) {
        if (!StringUtils.hasText(csv)) return List.of();

        return Arrays.stream(csv.split(","))
                .map(String::trim)
                .filter(StringUtils::hasText)
                .distinct()
                .toList();
    }

    public boolean isTokenExpired(String token) {
        try {
            Claims claims = getAllClaimsFromToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(new Date());
        } catch (Exception e) {
            return true;
        }
    }

    public boolean validateToken(String token) {
        try {
            getAllClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    /* =========================
       MÉTODOS AUXILIARES
       ========================= */
    public boolean isControlPlaneToken(String token) {
        return "CONTROLPLANE".equals(getTokenType(token));
    }

    public boolean isTenantToken(String token) {
        return "TENANT".equals(getTokenType(token));
    }

    public boolean isRefreshToken(String token) {
        return "REFRESH".equals(getTokenType(token));
    }

    public boolean isPasswordResetToken(String token) {
        return "PASSWORD_RESET".equals(getTokenType(token));
    }

    public boolean isTokenInContext(String token, String expectedContext) {
        String actualContext = getContextFromToken(token);
        return expectedContext.equals(actualContext);
    }

    public boolean isControlPlaneContextToken(String token) {
        String context = getContextFromToken(token);
        return "public".equals(context);
    }
}
package brito.com.multitenancy001.infrastructure.security;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.api.error.ApiException;

@Component
@RequiredArgsConstructor
public class SecurityUtils {
    
    public Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUserId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
    public Long getCurrentAccountId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getAccountId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
    public String getCurrentSchema() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getSchemaName();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
    public String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUsername();
        }
        return authentication != null ? authentication.getName() : null;
    }
}package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.domain.security.ControlPlaneRolePermissions;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.security.PermissionNormalizer;
import brito.com.multitenancy001.tenant.domain.security.TenantRolePermissions;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Set;

public final class AuthoritiesFactory {

    private AuthoritiesFactory() {}

    public static Collection<? extends GrantedAuthority> forControlPlane(ControlPlaneUser user) {
        Set<String> perms = new LinkedHashSet<>();

        // 1) role -> permissions (enum -> name)
        ControlPlaneRolePermissions.permissionsFor(user.getRole())
                .forEach(p -> perms.add(p.name()));

        // 2) permissions explícitas do user (Set<String>)
        if (user.getPermissions() != null) {
            perms.addAll(user.getPermissions());
        }

        // 3) normaliza CP_ e bloqueia TEN_
        Set<String> normalized = PermissionNormalizer.normalizeControlPlane(perms);

        return normalized.stream()
                .map(SimpleGrantedAuthority::new)
                .toList();
    }

    public static Collection<? extends GrantedAuthority> forTenant(TenantUser user) {
        Set<String> permissions = new LinkedHashSet<>();

        // 1) role -> permissions (enum -> name)
        TenantRolePermissions.permissionsFor(user.getRole())
                .forEach(p -> permissions.add(p.name()));

        // 2) permissions explícitas do user (List<String>)
        if (user.getPermissions() != null) {
            permissions.addAll(user.getPermissions());
        }

        // 3) normaliza TEN_ e bloqueia CP_
        Set<String> normalized = PermissionNormalizer.normalizeTenant(permissions);

        return normalized.stream()
                .map(SimpleGrantedAuthority::new)
                .toList();
    }
}
package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.time.Clock;
import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class MultiContextUserDetailsService implements UserDetailsService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final TenantUserRepository tenantUserRepository;
    private final Clock clock;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String schema = TenantContext.getOrNull();

        if (schema == null || "public".equalsIgnoreCase(schema)) {
            return loadControlPlaneUser(username);
        }

        LocalDateTime now = LocalDateTime.now(clock);

        TenantUser user = tenantUserRepository.findByUsernameAndDeletedFalse(username)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado no tenant", 404));

        var authorities = AuthoritiesFactory.forTenant(user);
        return new AuthenticatedUserContext(user, schema, now, authorities);
    }

    public UserDetails loadControlPlaneUser(String username, Long accountId) {
        LocalDateTime now = LocalDateTime.now(clock);

        if (accountId == null) {
            throw new ApiException("ACCOUNT_REQUIRED",
                    "accountId é obrigatório para autenticar usuário da controlplane", 400);
        }

        ControlPlaneUser user = controlPlaneUserRepository
                .findByUsernameAndAccount_IdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND",
                        "Usuário controlplane não encontrado para esta conta", 404));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return new AuthenticatedUserContext(user, "public", now, authorities);
    }

    public UserDetails loadControlPlaneUser(String username) {
        LocalDateTime now = LocalDateTime.now(clock);

        ControlPlaneUser user = controlPlaneUserRepository.findByUsernameAndDeletedFalse(username)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário controlplane não encontrado", 404));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return new AuthenticatedUserContext(user, "public", now, authorities);
    }

    public UserDetails loadTenantUser(String username, Long accountId) {
        String schema = TenantContext.getOrNull();
        if (schema == null || "public".equalsIgnoreCase(schema)) {
            throw new ApiException("TENANT_CONTEXT_REQUIRED",
                    "TenantContext não está bindado para autenticar usuário tenant", 401);
        }

        if (accountId == null) {
            throw new ApiException("ACCOUNT_REQUIRED",
                    "accountId é obrigatório para autenticar usuário tenant", 400);
        }

        LocalDateTime now = LocalDateTime.now(clock);

        TenantUser user = tenantUserRepository
                .findByUsernameAndAccountIdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado no tenant", 404));

        var authorities = AuthoritiesFactory.forTenant(user);
        return new AuthenticatedUserContext(user, schema, now, authorities);
    }
}
package brito.com.multitenancy001;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
//@EnableCaching
@EnableScheduling
public class Multitenancy001Application {

	public static void main(String[] args) {
		SpringApplication.run(Multitenancy001Application.class, args);
	}

}
package brito.com.multitenancy001.shared.api.dto.auth;



public record JwtResponse(
    String accessToken,
    String refreshToken,
    String tokenType,
    Long userId,
    String username,
    String email,
    String role,
    Long accountId,
    String tenantSchema
) {
    public JwtResponse {
        if (tokenType == null || tokenType.isEmpty()) {
            tokenType = "Bearer";
        }
    }
    
    // Constructor conveniência
    public JwtResponse(String accessToken, String refreshToken, 
                      Long userId, String username, String email, 
                      String role, Long accountId, String tenantSchema) {
        this(accessToken, refreshToken, "Bearer", 
             userId, username, email, role, accountId, tenantSchema);
    }
}package brito.com.multitenancy001.shared.api.error;



import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiEnumErrorResponse {
    private LocalDateTime timestamp;
    private String error;
    private String message;
    private String field;
    private String invalidValue;
    private List<String> allowedValues;
}package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
public class ApiErrorResponse {

    private LocalDateTime timestamp;
    private String error;
    private String message;

    // 🔥 novo campo (opcional)
    private List<String> details;
}
package brito.com.multitenancy001.shared.api.error;

import lombok.Getter;

@Getter
public class ApiException extends RuntimeException {

    private static final long serialVersionUID = 1L;
    private final String error;
    private final int status;
    private final Object details;
    private final Object[] allowedValues; // 🔥 NOVO CAMPO

    // Construtor sem allowedValues
    public ApiException(String error, String message, int status) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = null;
        this.allowedValues = null;
    }

    // Construtor com details
    public ApiException(String error, String message, int status, Object details) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = details;
        this.allowedValues = null;
    }

    // 🔥 NOVO CONSTRUTOR com allowedValues
    public ApiException(String error, String message, int status, Object details, Object[] allowedValues) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = details;
        this.allowedValues = allowedValues;
    }

    // Método para obter allowedValues
    public Object[] getAllowedValues() {
        return allowedValues;
    }

    // Método para verificar se tem allowedValues
    public boolean hasAllowedValues() {
        return allowedValues != null && allowedValues.length > 0;
    }
}package brito.com.multitenancy001.shared.api.error;

import com.fasterxml.jackson.databind.exc.InvalidFormatException;

import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleNotReadable(HttpMessageNotReadableException ex) {
        
        Throwable cause = ex.getCause();
        
        if (cause instanceof InvalidFormatException ife) {
            Class<?> targetType = ife.getTargetType();
            
            if (targetType != null && targetType.isEnum()) {
                String fieldName = ife.getPath().isEmpty() ? "status" : ife.getPath().get(0).getFieldName();
                String invalidValue = ife.getValue() != null ? ife.getValue().toString() : "null";
                
                List<String> allowedValues = Arrays.stream(targetType.getEnumConstants())
                    .map(Object::toString)
                    .toList();
                
                return ResponseEntity.badRequest().body(
                    ApiEnumErrorResponse.builder()
                        .timestamp(LocalDateTime.now())
                        .error("INVALID_ENUM")
                        .message("Valor inválido para o campo " + fieldName)
                        .field(fieldName)
                        .invalidValue(invalidValue)
                        .allowedValues(allowedValues)
                        .build()
                );
            }
        }
        
        return ResponseEntity.badRequest().body(
            ApiEnumErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error("INVALID_REQUEST_BODY")
                .message("Corpo da requisição inválido")
                .build()
        );
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        
        String errorMessage = ex.getMostSpecificCause().getMessage();
        
        // Log para debug
        System.out.println("=== DEBUG DataIntegrityViolationException ===");
        System.out.println("Error message: " + errorMessage);
        
        // Verifica qual constraint foi violada
        if (errorMessage.contains("company_doc_number")) {
            String cnpj = extractValue(errorMessage, "company_doc_number");
            return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                    .timestamp(LocalDateTime.now())
                    .error("DUPLICATE_CNPJ")
                    .message("Já existe uma conta com o CNPJ " + cnpj)
                    .field("companyDocNumber")
                    .invalidValue(cnpj)
                    .build()
            );
        }
        
        if (errorMessage.contains("company_email")) {
            String email = extractValue(errorMessage, "company_email");
            return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                    .timestamp(LocalDateTime.now())
                    .error("DUPLICATE_EMAIL")
                    .message("Já existe uma conta com o email " + email)
                    .field("companyEmail")
                    .invalidValue(email)
                    .build()
            );
        }
        
        if (errorMessage.contains("slug")) {
            String slug = extractValue(errorMessage, "slug");
            return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                    .timestamp(LocalDateTime.now())
                    .error("DUPLICATE_SLUG")
                    .message("Já existe uma conta com o slug " + slug)
                    .field("slug")
                    .invalidValue(slug)
                    .build()
            );
        }
        
        if (errorMessage.contains("schema_name")) {
            String schema = extractValue(errorMessage, "schema_name");
            return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                    .timestamp(LocalDateTime.now())
                    .error("DUPLICATE_SCHEMA")
                    .message("Erro interno: schema " + schema + " já existe")
                    .build()
            );
        }
        
        // Caso genérico
        return ResponseEntity.status(409).body(
            ApiEnumErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error("DUPLICATE_ENTRY")
                .message("Registro duplicado. Verifique os dados informados.")
                .build()
        );
    }
    
    private String extractValue(String message, String fieldName) {
        try {
            // Padrão para PostgreSQL: "Chave (company_doc_number)=(4254567235667712) já existe."
            Pattern pattern = Pattern.compile("\\(" + fieldName + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher = pattern.matcher(message);
            
            if (matcher.find()) {
                return matcher.group(1);
            }
            
            // Padrão alternativo: "Key (company_doc_number)=(value) already exists."
            Pattern pattern2 = Pattern.compile("Key \\(" + fieldName + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher2 = pattern2.matcher(message);
            
            if (matcher2.find()) {
                return matcher2.group(1);
            }
            
        } catch (Exception e) {
            System.out.println("Erro ao extrair valor: " + e.getMessage());
        }
        
        return "não identificado";
    }

    @ExceptionHandler(ApiException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleApi(ApiException ex) {
        return ResponseEntity.status(ex.getStatus()).body(
            ApiEnumErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error(ex.getError())
                .message(ex.getMessage())
                .build()
        );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiEnumErrorResponse> handleGeneric(Exception ex) {
        // 🔥 REMOVA os logs de debug do handler genérico
        // System.out.println("=== DEBUG Generic Exception ===");
        // System.out.println("Exception type: " + ex.getClass().getName());
        // System.out.println("Message: " + ex.getMessage());
        // ex.printStackTrace();
        
        return ResponseEntity.internalServerError().body(
            ApiEnumErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error("INTERNAL_SERVER_ERROR")
                .message("Erro interno inesperado. Contate o suporte.")
                .build()
        );
    }
    
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiErrorResponse> handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .toList();
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .error("VALIDATION_ERROR")
                .message("Erro de validação")
                .details(errors)
                .build();
        
        return ResponseEntity.badRequest().body(errorResponse);
    }
    
    
    
}package brito.com.multitenancy001.shared.context;

import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.infrastructure.multitenancy.hibernate.CurrentTenantSchemaResolver;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TenantContext {

    public static String getOrNull() {
        return CurrentTenantSchemaResolver.resolveBoundTenantOrDefault();
    }

    public static void bind(String tenantId) {
        if (TransactionSynchronizationManager.isActualTransactionActive()) {
            log.error("🔥 ERRO GRAVE: bindTenant chamado DENTRO de transação! tenant={}", tenantId);
        }

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (!StringUtils.hasText(normalized)) {
            CurrentTenantSchemaResolver.bindTenantToCurrentThread(null);
            log.info("🔄 Tenant limpo (sem tenant) | thread={}", Thread.currentThread().threadId());
            return;
        }

        CurrentTenantSchemaResolver.bindTenantToCurrentThread(normalized);
        log.info("🔄 Tenant bindado | thread={} | tenant={}",
                Thread.currentThread().threadId(),
                normalized);
    }

    public static void clear() {
        CurrentTenantSchemaResolver.unbindTenantFromCurrentThread();
        log.info("🧹 Tenant desbindado | thread={}", Thread.currentThread().threadId());
    }

    // ✅ NOVO: escopo seguro
    public static Scope scope(String tenantId) {
        bind(tenantId);
        return new Scope();
    }

    // ✅ NOVO: escopo PUBLIC explícito (garante que não ficou tenant pendurado)
    public static Scope publicScope() {
        clear();
        return new Scope();
    }

    public static final class Scope implements AutoCloseable {
        private boolean closed = false;

        private Scope() {}

        @Override
        public void close() {
            if (!closed) {
                TenantContext.clear();
                closed = true;
            }
        }
    }
}
package brito.com.multitenancy001.shared.domain.username;

import java.text.Normalizer;
import java.util.Objects;
import java.util.regex.Pattern;

import org.springframework.stereotype.Component;


@Component
public class UsernamePolicy {

	public static final String USERNAME_REGEX = "^[a-z0-9._-]+$";
    public static final int USERNAME_MAX_LENGTH = 100;
    private static final Pattern USERNAME_PATTERN = Pattern.compile("^[a-z0-9._-]+$");

    private static final String FALLBACK_BASE = "user";
    private static final String SEPARATOR = "_";

    public String normalizeBase(String raw) {
        if (raw == null || raw.isBlank()) return FALLBACK_BASE;

        String base = raw.toLowerCase();
        // opcional: remover acentos (se você quiser aplicar em nome também)
        base = Normalizer.normalize(base, Normalizer.Form.NFD).replaceAll("\\p{M}", "");

        base = base.replaceAll("[^a-z0-9._-]", "_")
                   .replaceAll("_{2,}", "_")
                   .replaceAll("^_|_$", "");

        return base.isBlank() ? FALLBACK_BASE : base;
    }

    public boolean isValid(String username) {
        if (username == null) return false;
        if (username.length() < 3 || username.length() > USERNAME_MAX_LENGTH) return false;
        return USERNAME_PATTERN.matcher(username).matches();
    }

    /** Monta base + "_" + suffix respeitando max length, cortando só base */
    public String build(String base, String suffix) {
        Objects.requireNonNull(suffix, "suffix");

        int maxBaseLen = USERNAME_MAX_LENGTH - SEPARATOR.length() - suffix.length();
        if (maxBaseLen <= 0) {
            base = "u";
            maxBaseLen = 1;
        }

        base = normalizeBase(base);

        if (base.length() > maxBaseLen) {
            base = base.substring(0, maxBaseLen).replaceAll("_+$", "");
            if (base.isBlank()) base = "u";
        }

        return base + SEPARATOR + suffix;
    }

    public String extractBase(String username) {
        if (username == null) return FALLBACK_BASE;
        int idx = username.lastIndexOf(SEPARATOR);
        if (idx <= 0) return normalizeBase(username);
        return normalizeBase(username.substring(0, idx));
    }
}
package brito.com.multitenancy001.shared.security;

public interface PermissionAuthority {
    String asAuthority(); // ex: "CP_USER_READ" ou "TEN_USER_READ"
}
package brito.com.multitenancy001.shared.security;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

public final class PermissionNormalizer {

    private PermissionNormalizer() {}

    public static Set<String> normalizeTenant(Collection<String> perms) {
        Set<String> out = new HashSet<>();
        if (perms == null) return out;
        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            // bloqueia perm de control plane no tenant
            if (x.startsWith("CP_")) {
                throw new IllegalArgumentException("Permission de Control Plane não é permitida no Tenant: " + x);
            }

            // se não tiver prefixo TEN_, adiciona
            if (!x.startsWith("TEN_")) x = "TEN_" + x;
            out.add(x);
        }
        return out;
    }

    public static Set<String> normalizeControlPlane(Collection<String> perms) {
        Set<String> out = new HashSet<>();
        if (perms == null) return out;
        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            // bloqueia perm de tenant no control plane
            if (x.startsWith("TEN_")) {
                throw new IllegalArgumentException("Permission de Tenant não é permitida no Control Plane: " + x);
            }

            if (!x.startsWith("CP_")) x = "CP_" + x;
            out.add(x);
        }
        return out;
    }
}
package brito.com.multitenancy001.shared.security;

/**
 * Contrato comum para roles da plataforma e do tenant
 * Permite unificação no Spring Security (GrantedAuthority)
 */
public interface RoleAuthority {

    /**
     * Retorna a authority no padrão Spring Security
     *
     */
    String asAuthority();

    /**
     * Helper padrão (opcional)
     */
    default boolean isAdmin() {
        return false;
    }
}
package brito.com.multitenancy001.shared.validation; // ou .validation

import brito.com.multitenancy001.shared.domain.username.UsernamePolicy;

/**
 * Padrões de validação reutilizáveis em todo o sistema
 */
public final class ValidationPatterns {
    
    // Username: 3-50 caracteres, letras, números, ponto, underscore, hífen
   // public static final String USERNAME_PATTERN = "^[a-zA-Z0-9._-]{3,50}$";
	
	
	// usado pra facilidar no desenvolvimento
	// Username: 3-50 caracteres, APENAS letras (a-z, A-Z) e números (0-9)
	public static final String USERNAME_PATTERN = UsernamePolicy.USERNAME_REGEX;
    
    // Password: mínimo 8 caracteres, pelo menos 1 letra maiúscula, 1 minúscula e 1 número
   // public static final String PASSWORD_PATTERN = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$";

    
    
 // ⚠️ APENAS PARA TESTE/DEV - NUNCA EM PRODUÇÃO!
    // Password: mínimo 3 caracteres, apenas letras (maiúsculas/minúsculas)
    // Não precisa de números nem caracteres especiais
	  public static final String PASSWORD_PATTERN = "^[a-zA-Z0-9]{3,}$";
    
    
    
    
    
    
    // Email: validação básica (Spring já tem @Email, mas para referência)
    public static final String EMAIL_PATTERN = "^[A-Za-z0-9+_.-]+@(.+)$";
    
    // Nome: apenas letras, espaços e alguns caracteres especiais
    public static final String NAME_PATTERN = "^[a-zA-ZÀ-ÿ\\s'-]{2,100}$";
    
    // Telefone: formato brasileiro
    public static final String PHONE_PATTERN = "^(\\(?\\d{2}\\)?)?\\s?\\d{4,5}-?\\d{4}$";
    
    // CNPJ: formato brasileiro
    public static final String CNPJ_PATTERN = "^\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}$";
    
    // CPF: formato brasileiro
    public static final String CPF_PATTERN = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$";
    
    // CEP: formato brasileiro
    public static final String CEP_PATTERN = "^\\d{5}-\\d{3}$";
    
    // URL: para avatar_url, website, etc.
    public static final String URL_PATTERN = "^(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?$";
    
    // Timezone: formato padrão (America/Sao_Paulo)
    public static final String TIMEZONE_PATTERN = "^[A-Za-z_]+/[A-Za-z_]+$";
    
    // Locale: pt_BR, en_US, etc.
    public static final String LOCALE_PATTERN = "^[a-z]{2}_[A-Z]{2}$";
    
    // Currency: BRL, USD, EUR (3 letras)
    public static final String CURRENCY_PATTERN = "^[A-Z]{3}$";
    
    // Hex color: #FFFFFF ou #FFF
    public static final String COLOR_PATTERN = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
    
    // IP Address
    public static final String IP_PATTERN = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
    
    // UUID
    public static final String UUID_PATTERN = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";
    
    // Permissões: UPPER_CASE_WITH_UNDERSCORE
    public static final String PERMISSION_PATTERN = "^[A-Z_]+$";
    
    private ValidationPatterns() {
        // Construtor privado para classe utilitária
        throw new UnsupportedOperationException("Classe utilitária - não instanciável");
    }
    
    /**
     * Valida se um valor corresponde ao padrão
     */
    public static boolean isValid(String value, String pattern) {
        return value != null && value.matches(pattern);
    }
    
    /**
     * Valida username com mensagem descritiva
     */
    public static void validateUsername(String username) {
        if (username == null || !username.matches(USERNAME_PATTERN)) {
            throw new IllegalArgumentException(
                "Username deve ter 3-50 caracteres e conter apenas: " +
                "letras (a-z, A-Z), números (0-9), ponto (.), underscore (_), hífen (-)"
            );
        }
    }
    
    /**
     * Valida password com mensagem descritiva
     */
    public static void validatePassword(String password) {
        if (password == null || !password.matches(PASSWORD_PATTERN)) {
            throw new IllegalArgumentException(
                "Senha deve ter pelo menos 8 caracteres contendo: " +
                "1 letra maiúscula, 1 letra minúscula e 1 número"
            );
        }
    }
}package brito.com.multitenancy001.tenant.api.controller.auth;

import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.application.auth.TenantAuthService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantAuthController {

    private final TenantAuthService tenantAuthService;

    @PostMapping("/login")
    public ResponseEntity<JwtResponse> loginTenant(@Valid @RequestBody TenantLoginRequest request) {
        JwtResponse response = tenantAuthService.loginTenant(request);
        return ResponseEntity.ok(response);
    }
}
package brito.com.multitenancy001.tenant.api.controller.auth;

import brito.com.multitenancy001.tenant.api.dto.auth.ForgotPasswordRequest;
import brito.com.multitenancy001.tenant.api.dto.auth.ResetPasswordRequest;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/password")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantPasswordController {

    private final TenantUserService tenantUserService;

    @PostMapping("/forgot")
    public ResponseEntity<String> forgotPassword(@Valid @RequestBody ForgotPasswordRequest req) {
        tenantUserService.generatePasswordResetToken(req.slug(), req.email());
        return ResponseEntity.ok("Token gerado");
    }

    @PostMapping("/reset")
    public ResponseEntity<String> resetPassword(@Valid @RequestBody ResetPasswordRequest req) {
        tenantUserService.resetPasswordWithToken(req.token(), req.newPassword());
        return ResponseEntity.ok("Senha redefinida com sucesso");
    }
}
package brito.com.multitenancy001.tenant.api.controller.products;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.api.dto.products.ProductUpsertRequest;
import brito.com.multitenancy001.tenant.api.mapper.ProductApiMapper;
import brito.com.multitenancy001.tenant.application.product.TenantProductService;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.product.Product;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/tenant/products")
@RequiredArgsConstructor
public class TenantProductController {

    private final ProductApiMapper productApiMapper;
    private final TenantProductService tenantProductService;

    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByCategory(@PathVariable Long categoryId) {
        List<Product> products = tenantProductService.findByCategoryId(categoryId);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/brand/{brand}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByBrand(@PathVariable String brand) {
        List<Product> products = tenantProductService.findByBrand(brand);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getActiveProducts() {
        List<Product> products = tenantProductService.findActiveProducts();
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @PatchMapping("/{id}/cost-price")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> updateCostPrice(
            @PathVariable UUID id,
            @RequestParam BigDecimal costPrice
    ) {
        Product updatedProduct = tenantProductService.updateCostPrice(id, costPrice);
        return ResponseEntity.ok(productApiMapper.toResponse(updatedProduct));
    }

    @GetMapping("/inventory-value")
    @PreAuthorize("hasAuthority('TEN_INVENTORY_READ')")
    public ResponseEntity<BigDecimal> getTotalInventoryValue() {
        BigDecimal value = tenantProductService.calculateTotalInventoryValue();
        return ResponseEntity.ok(value != null ? value : BigDecimal.ZERO);
    }

    @GetMapping("/low-stock/count")
    @PreAuthorize("hasAuthority('TEN_INVENTORY_READ')")
    public ResponseEntity<Long> countLowStockProducts(@RequestParam(defaultValue = "10") Integer threshold) {
        Long count = tenantProductService.countLowStockProducts(threshold);
        return ResponseEntity.ok(count != null ? count : 0L);
    }

    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> toggleActive(@PathVariable UUID id) {
        Product product = tenantProductService.findById(id);
        product.setActive(!Boolean.TRUE.equals(product.getActive()));
        tenantProductService.create(product);
        return ResponseEntity.ok(productApiMapper.toResponse(product));
    }

    @PostMapping("/detailed")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> createDetailedProduct(@Valid @RequestBody ProductUpsertRequest request) {

        Product product = new Product();
        product.setName(request.name());
        product.setDescription(request.description());
        product.setSku(request.sku());
        product.setPrice(request.price());
        product.setStockQuantity(request.stockQuantity());
        product.setMinStock(request.minStock());
        product.setMaxStock(request.maxStock());
        product.setCostPrice(request.costPrice());
        product.setBrand(request.brand());
        product.setWeightKg(request.weightKg());
        product.setDimensions(request.dimensions());
        product.setBarcode(request.barcode());
        product.setActive(request.active());

        Category category = new Category();
        category.setId(request.categoryId());
        product.setCategory(category);

        if (request.subcategoryId() != null) {
            Subcategory sub = new Subcategory();
            sub.setId(request.subcategoryId());
            product.setSubcategory(sub);
        }

        if (request.supplierId() != null) {
            Supplier supplier = new Supplier();
            supplier.setId(request.supplierId());
            product.setSupplier(supplier);
        }

        Product savedProduct = tenantProductService.create(product);
        return ResponseEntity.status(HttpStatus.CREATED).body(productApiMapper.toResponse(savedProduct));
    }
}
package brito.com.multitenancy001.tenant.api.controller.users.admin;

import brito.com.multitenancy001.tenant.api.dto.users.admin.TenantUserAdminSuspendRequest;
import brito.com.multitenancy001.tenant.application.user.admin.TenantUserAdminService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/admin/users")
@RequiredArgsConstructor
public class TenantUserAdminController {

    private final TenantUserAdminService tenantUserAdminService;

    @PatchMapping("/{userId}/suspend")
    @PreAuthorize("hasAuthority('TEN_USER_SUSPEND')")
    public ResponseEntity<Void> suspendUser(
            @PathVariable Long userId,
            @RequestBody TenantUserAdminSuspendRequest req
    ) {
        tenantUserAdminService.setUserSuspendedByAdmin(userId, req.suspended());
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.tenant.api.controller.users;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/users")
@RequiredArgsConstructor
public class TenantUserController {

    private final TenantUserService tenantUserService;

    @PatchMapping("/{userId}/transfer-admin")
    @PreAuthorize("hasAuthority('TEN_ROLE_TRANSFER')")
    public ResponseEntity<Void> transferTenantOwner(@PathVariable Long userId) {
        tenantUserService.transferTenantOwner(userId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping
    @PreAuthorize("hasAuthority('TEN_USER_CREATE')")
    public ResponseEntity<TenantUserDetailsResponse> createTenantUser(@Valid @RequestBody TenantUserCreateRequest request) {
        TenantUserDetailsResponse response = tenantUserService.createTenantUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<List<TenantUserSummaryResponse>> listTenantUsers() {
        List<TenantUserSummaryResponse> users = tenantUserService.listTenantUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<List<TenantUserSummaryResponse>> listActiveTenantUsers() {
        List<TenantUserSummaryResponse> users = tenantUserService.listActiveTenantUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<TenantUserDetailsResponse> getTenantUser(@PathVariable Long userId) {
        TenantUserDetailsResponse user = tenantUserService.getTenantUser(userId);
        return ResponseEntity.ok(user);
    }

    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAuthority('TEN_USER_UPDATE')")
    public ResponseEntity<TenantUserSummaryResponse> updateTenantUserStatus(
            @PathVariable Long userId,
            @RequestParam boolean active
    ) {
        TenantUserSummaryResponse response = tenantUserService.updateTenantUserStatus(userId, active);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_DELETE')")
    public ResponseEntity<Void> deleteTenantUser(@PathVariable Long userId) {
        tenantUserService.softDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority('TEN_USER_RESTORE')")
    public ResponseEntity<TenantUserSummaryResponse> restoreTenantUser(@PathVariable Long userId) {
        TenantUserSummaryResponse response = tenantUserService.restoreTenantUser(userId);
        return ResponseEntity.ok(response);
    }

    @PatchMapping("/{userId}/password")
    @PreAuthorize("hasAuthority('TEN_USER_UPDATE')")
    public ResponseEntity<TenantUserSummaryResponse> resetTenantUserPassword(
            @PathVariable Long userId,
            @RequestParam
            @Pattern(
                    regexp = ValidationPatterns.PASSWORD_PATTERN,
                    message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas e números"
            )
            String newPassword
    ) {
        TenantUserSummaryResponse response = tenantUserService.resetTenantUserPassword(userId, newPassword);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{userId}/hard")
    @PreAuthorize("hasAuthority('TEN_USER_DELETE')")
    public ResponseEntity<Void> hardDeleteTenantUser(@PathVariable Long userId) {
        tenantUserService.hardDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ForgotPasswordRequest(
        @NotBlank String slug,
        @NotBlank @Email String email
) {}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record ResetPasswordRequest(
        @NotBlank String token,
        @NotBlank
        @Pattern(
          regexp = ValidationPatterns.PASSWORD_PATTERN,
          message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais"
        )
        String newPassword
) {}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record TenantLoginRequest(
	    @NotBlank String username,
	    @NotBlank String password,
	    @NotBlank String slug
	) {}
package brito.com.multitenancy001.tenant.api.dto.products;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

public record ProductResponse(
        UUID id,
        @NotBlank String name,
        String description,
        String sku,
        @NotNull @PositiveOrZero BigDecimal price,
        @PositiveOrZero Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        BigDecimal profitMargin,

        Long categoryId,
        String categoryName,
        Long subcategoryId,
        String subcategoryName,

        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,

        UUID supplierId,
        String supplierName,

        LocalDateTime createdAt,
        LocalDateTime updatedAt
) {
    public ProductResponse {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }

  
}
package brito.com.multitenancy001.tenant.api.dto.products;

import java.math.BigDecimal;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

// Record para criação/atualização expandido (com Category/Subcategory por ID)
public record ProductUpsertRequest(
     @NotBlank String name,
     String description,
     String sku,
     @NotNull @PositiveOrZero BigDecimal price,
     @PositiveOrZero Integer stockQuantity,
     Integer minStock,
     Integer maxStock,
     BigDecimal costPrice,

     @NotNull Long categoryId,     // ✅ obrigatório
     Long subcategoryId,           // ✅ opcional

     String brand,
     BigDecimal weightKg,
     String dimensions,
     String barcode,
     Boolean active,
     UUID supplierId
) {
    public ProductUpsertRequest {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}
package brito.com.multitenancy001.tenant.api.dto.users.admin;

public record TenantUserAdminSuspendRequest(boolean suspended) {}package brito.com.multitenancy001.tenant.api.dto.users;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.LinkedHashSet;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

@Builder
public record TenantUserCreateRequest(
    
    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String name,
    
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, 
             message = "Username inválido. Use apenas letras, números, . e _")
    @Size(min = 3, max = 50, message = "Username deve ter entre 3 e 50 caracteres")
    String username,
    
    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email inválido")
    @Size(max = 150, message = "Email não pode exceder 150 caracteres")
    String email,
    
    @NotBlank(message = "Senha é obrigatória")
    @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, 
             message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais")
    String password,
    
    @NotBlank(message = "Role é obrigatória")
    @Pattern(regexp = "TENANT_ACCOUNT_OWNER|TENANT_ACCOUNT_ADMIN|TENANT_CATALOG_MANAGER|TENANT_SALES_MANAGER|TENANT_BILLING_MANAGER|TENANT_READ_ONLY|TENANT_OPERATOR", message = "Role inválida")
    String role,
    
    LinkedHashSet<String> permissions,
    
    // 🔹 CAMPOS NOVOS para UserTenant
    @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, 
             message = "Telefone inválido")
    @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
    String phone,
    
    @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
    String avatarUrl
    
) {
    
    public TenantUserCreateRequest {
        if (phone != null) {
            phone = phone.trim();
        }
        if (avatarUrl != null) {
            avatarUrl = avatarUrl.trim();
        }
    }
}package brito.com.multitenancy001.tenant.api.dto.users;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;

public record TenantUserDetailsResponse(
        Long id,
        String username,
        String name,
        String email,
        String role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled,
        LocalDateTime createdAt,
        LocalDateTime updatedAt,
        Long accountId,
        LinkedHashSet<String> permissions
) {
	public TenantUserDetailsResponse {
	    if (permissions == null) permissions = new LinkedHashSet<>();
	}


    public static TenantUserDetailsResponse from(TenantUser tenantUser) {
        boolean enabled = !tenantUser.isDeleted() && !tenantUser.isSuspendedByAccount() && !tenantUser.isSuspendedByAdmin();
        return new TenantUserDetailsResponse(
                tenantUser.getId(),
                tenantUser.getUsername(),
                tenantUser.getName(),
                tenantUser.getEmail(),
                tenantUser.getRole() != null ? tenantUser.getRole().name() : null,
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                enabled,
                tenantUser.getCreatedAt(),
                tenantUser.getUpdatedAt(),
                tenantUser.getAccountId(),
                tenantUser.getPermissions()
        );
    }
}
package brito.com.multitenancy001.tenant.api.dto.users;

public record TenantUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.domain.product.Product;

@Component
public class ProductApiMapper {

    public ProductResponse toResponse(Product product) {
        return new ProductResponse(
            product.getId(),
            product.getName(),
            product.getDescription(),
            product.getSku(),
            product.getPrice(),
            product.getStockQuantity(),
            product.getMinStock(),
            product.getMaxStock(),
            product.getCostPrice(),
            product.getProfitMargin(),

            product.getCategory() != null ? product.getCategory().getId() : null,
            product.getCategory() != null ? product.getCategory().getName() : null,
            product.getSubcategory() != null ? product.getSubcategory().getId() : null,
            product.getSubcategory() != null ? product.getSubcategory().getName() : null,

            product.getBrand(),
            product.getWeightKg(),
            product.getDimensions(),
            product.getBarcode(),
            product.getActive(),

            product.getSupplier() != null ? product.getSupplier().getId() : null,
            product.getSupplier() != null ? product.getSupplier().getName() : null,

            product.getCreatedAt(),
            product.getUpdatedAt()
        );
    }
}
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;

@Component
public class TenantUserApiMapper {

    public TenantUserSummaryResponse toSummary(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                && !tenantUser.isSuspendedByAccount()
                && !tenantUser.isSuspendedByAdmin();

        return new TenantUserSummaryResponse(
                tenantUser.getId(),
                tenantUser.getUsername(),
                tenantUser.getEmail(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                enabled
        );
    }
}
package brito.com.multitenancy001.tenant.application.auth;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantAuthService {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final AccountRepository accountRepository;
    private final TenantUserRepository tenantUserRepository;

    public JwtResponse loginTenant(TenantLoginRequest request) {

        // 1️⃣ PUBLIC — resolve conta
        TenantContext.clear();

        Account account = accountRepository
                .findBySlugAndDeletedFalse(request.slug())
                .orElseThrow(() -> new ApiException(
                        "ACCOUNT_NOT_FOUND",
                        "Conta não encontrada",
                        404
                ));

        if (!account.isActive()) {
            throw new ApiException(
                    "ACCOUNT_INACTIVE",
                    "Conta inativa",
                    403
            );
        }

        // 2️⃣ TENANT — bind correto
        TenantContext.bind(account.getSchemaName());

        try {
            Authentication authentication =
                    authenticationManager.authenticate(
                            new UsernamePasswordAuthenticationToken(
                                    request.username(),
                                    request.password()
                            )
                    );

            TenantUser user = tenantUserRepository
                    .findByUsernameAndAccountId(
                            request.username(),
                            account.getId()
                    )
                    .orElseThrow(() -> new ApiException(
                            "USER_NOT_FOUND",
                            "Usuário não encontrado",
                            404
                    ));

            if (user.isSuspendedByAccount() || user.isDeleted()) {
                throw new ApiException(
                        "USER_INACTIVE",
                        "Usuário inativo",
                        403
                );
            }

            String accessToken = tokenProvider.generateTenantToken(
                    authentication,
                    account.getId(),
                    account.getSchemaName()
            );

            String refreshToken = tokenProvider.generateRefreshToken(
                    user.getUsername(),
                    account.getSchemaName()
            );

            return new JwtResponse(
                    accessToken,
                    refreshToken,
                    user.getId(),
                    user.getUsername(),
                    user.getEmail(),
                    user.getRole().name(),
                    account.getId(),
                    account.getSchemaName()
            );

        } finally {
            TenantContext.clear();
        }
    }
}
// ===============================
// ProductService.java
// (corrigido: resolveCategoryAndSubcategory sem duplicação,
//  update limpando subcategory quando vier null,
//  usando findByIdWithCategory pra validar)
// ===============================
package brito.com.multitenancy001.tenant.application.product;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.product.Product;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import brito.com.multitenancy001.tenant.persistence.category.CategoryRepository;
import brito.com.multitenancy001.tenant.persistence.category.SubcategoryRepository;
import brito.com.multitenancy001.tenant.persistence.product.ProductRepository;
import brito.com.multitenancy001.tenant.persistence.supplier.SupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProductService {

    private final ProductRepository productRepository;
    private final SupplierRepository supplierRepository;
    private final CategoryRepository categoryRepository;
    private final SubcategoryRepository subcategoryRepository;

    @Transactional(readOnly = true)
    public Page<Product> findAll(Pageable pageable) {
        return productRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    public Product findById(UUID id) {
        return productRepository.findById(id)
            .orElseThrow(() -> new ApiException("PRODUCT_NOT_FOUND",
                "Produto não encontrado com ID: " + id, 404));
    }

    @Transactional
    public Product create(Product product) {
        validateProduct(product);

        resolveCategoryAndSubcategory(product);
        resolveSupplier(product);
        validateSubcategoryBelongsToCategory(product);

        return productRepository.save(product);
    }

    @Transactional
    public Product update(UUID id, Product productDetails) {
        Product existingProduct = findById(id);

        if (StringUtils.hasText(productDetails.getName())) {
            existingProduct.setName(productDetails.getName());
        }

        if (productDetails.getDescription() != null) {
            existingProduct.setDescription(productDetails.getDescription());
        }

        if (StringUtils.hasText(productDetails.getSku())) {
            Optional<Product> productWithSku = productRepository.findBySku(productDetails.getSku());
            if (productWithSku.isPresent() && !productWithSku.get().getId().equals(id)) {
                throw new ApiException("SKU_ALREADY_EXISTS",
                    "SKU já cadastrado: " + productDetails.getSku(), 409);
            }
            existingProduct.setSku(productDetails.getSku());
        }

        if (productDetails.getPrice() != null) {
            validatePrice(productDetails.getPrice());
            existingProduct.setPrice(productDetails.getPrice());
        }

        if (productDetails.getStockQuantity() != null) {
            existingProduct.setStockQuantity(productDetails.getStockQuantity());
        }

        // ✅ category
        if (productDetails.getCategory() != null && productDetails.getCategory().getId() != null) {
            Category category = categoryRepository.findById(productDetails.getCategory().getId())
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada", 404));
            existingProduct.setCategory(category);
        }

        // ✅ subcategory (se veio ID)
        if (productDetails.getSubcategory() != null && productDetails.getSubcategory().getId() != null) {
            Subcategory sub = subcategoryRepository.findByIdWithCategory(productDetails.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada", 404));
            existingProduct.setSubcategory(sub);
        }

        // ✅ se veio explicitamente subcategory = null -> limpa
        if (productDetails.getSubcategory() == null) {
            existingProduct.setSubcategory(null);
        }

        // ✅ supplier
        if (productDetails.getSupplier() != null && productDetails.getSupplier().getId() != null) {
            Supplier supplier = supplierRepository.findById(productDetails.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND", "Fornecedor não encontrado", 404));
            existingProduct.setSupplier(supplier);
        }

        validateSubcategoryBelongsToCategory(existingProduct);

        return productRepository.save(existingProduct);
    }

    private void resolveSupplier(Product product) {
        if (product.getSupplier() != null && product.getSupplier().getId() != null) {
            UUID supplierId = product.getSupplier().getId();
            Supplier supplier = supplierRepository.findById(product.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                    "Fornecedor não encontrado com ID: " + supplierId, 404));
            product.setSupplier(supplier);
        }
    }


    private void resolveCategoryAndSubcategory(Product product) {
        // ✅ category obrigatória
        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria é obrigatória", 400);
        }

        Category category = categoryRepository.findById(product.getCategory().getId())
            .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada", 404));
        product.setCategory(category);

        // ✅ subcategory opcional
        if (product.getSubcategory() != null && product.getSubcategory().getId() != null) {
            Subcategory sub = subcategoryRepository.findByIdWithCategory(product.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada", 404));
            product.setSubcategory(sub);
        } else {
            product.setSubcategory(null);
        }
    }

    private void validateSubcategoryBelongsToCategory(Product product) {
        if (product.getSubcategory() == null) return;

        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria é obrigatória", 400);
        }

        if (product.getSubcategory().getCategory() == null
            || product.getSubcategory().getCategory().getId() == null) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria sem categoria associada (cadastro inconsistente)", 409);
        }

        Long subCatCategoryId = product.getSubcategory().getCategory().getId();
        Long productCategoryId = product.getCategory().getId();

        if (!subCatCategoryId.equals(productCategoryId)) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria não pertence à categoria informada", 409);
        }
    }

    // ======= outros métodos =======

    @Transactional(readOnly = true)
    public List<Product> searchProducts(String name, String sku, BigDecimal minPrice,
                                        BigDecimal maxPrice, Integer minStock, Integer maxStock) {
        return productRepository.searchProducts(name, minPrice, maxPrice, minStock, maxStock);
    }

    @Transactional(readOnly = true)
    public List<Product> findLowStock(Integer threshold) {
        return productRepository.findByStockQuantityLessThan(threshold);
    }

    @Transactional
    public Product updateStock(UUID id, Integer quantityChange) {
        Product product = findById(id);
        if (quantityChange > 0) product.addToStock(quantityChange);
        else if (quantityChange < 0) product.removeFromStock(Math.abs(quantityChange));
        return productRepository.save(product);
    }

    @Transactional
    public Product updatePrice(UUID id, BigDecimal newPrice) {
        validatePrice(newPrice);
        Product product = findById(id);
        product.updatePrice(newPrice);
        return productRepository.save(product);
    }

    @Transactional
    public void delete(UUID id) {
        Product product = findById(id);
        product.softDelete();
        productRepository.save(product);
    }

    private void validateProduct(Product product) {
        if (!StringUtils.hasText(product.getName())) {
            throw new ApiException("PRODUCT_NAME_REQUIRED", "Nome do produto é obrigatório", 400);
        }
        if (product.getPrice() == null) {
            throw new ApiException("PRODUCT_PRICE_REQUIRED", "Preço do produto é obrigatório", 400);
        }
        validatePrice(product.getPrice());

        if (product.getStockQuantity() == null) product.setStockQuantity(0);
        if (product.getStockQuantity() < 0) {
            throw new ApiException("INVALID_STOCK", "Quantidade em estoque não pode ser negativa", 400);
        }
    }

    private void validatePrice(BigDecimal price) {
        if (price == null) throw new ApiException("INVALID_PRICE", "Preço não pode ser nulo", 400);
        if (price.compareTo(BigDecimal.ZERO) < 0) throw new ApiException("INVALID_PRICE", "Preço não pode ser negativo", 400);
        if (price.compareTo(BigDecimal.valueOf(1_000_000)) > 0) {
            throw new ApiException("PRICE_TOO_HIGH", "Preço muito alto. Valor máximo permitido: 1.000.000", 400);
        }
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryId(Long categoryId) {
        return productRepository.findByCategory_Id(categoryId);
    }

    @Transactional(readOnly = true)
    public List<Product> findByBrand(String brand) {
        return productRepository.findAll().stream()
            .filter(p -> brand.equals(p.getBrand()))
            .toList();
    }

    @Transactional(readOnly = true)
    public List<Product> findActiveProducts() {
        return productRepository.findAll().stream()
            .filter(p -> Boolean.TRUE.equals(p.getActive()) && !Boolean.TRUE.equals(p.getDeleted()))
            .toList();
    }

    @Transactional
    public Product updateCostPrice(UUID id, BigDecimal costPrice) {
        Product product = findById(id);
        product.updateCostPrice(costPrice);
        return productRepository.save(product);
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateTotalInventoryValue() {
        return productRepository.calculateTotalInventoryValue();
    }

    @Transactional(readOnly = true)
    public Long countLowStockProducts(Integer threshold) {
        return productRepository.countLowStock(threshold);
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProvisioningService {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public void createSchemaAndMigrate(String schemaName) {
        tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(schemaName);
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import lombok.RequiredArgsConstructor;
import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;

@Service
@RequiredArgsConstructor
public class TenantSchemaMigrationService {

    private final DataSource dataSource;

    public void migrateTenant(String schemaName) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas(schemaName)
                .defaultSchema(schemaName) // 🔥 ESSENCIAL
                .createSchemas(false)
                .locations("classpath:db/migration/tenants")
                .baselineOnMigrate(true)
                .load();

        flyway.migrate();
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.domain.security.TenantRole;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.regex.Pattern;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Slf4j
@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningService {

    private final JdbcTemplate jdbcTemplate;
    private final TenantSchemaMigrationService tenantSchemaMigrationService;
    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;
    
    
    private static final Pattern SCHEMA_PATTERN = Pattern.compile("^[a-zA-Z0-9_]+$");
    
   

    

    private void validateSchemaNameOrThrow(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new ApiException("INVALID_SCHEMA", "Schema inválido", 400);
        }

        String trimmed = schemaName.trim();

        if ("public".equalsIgnoreCase(trimmed)) {
            throw new ApiException("INVALID_SCHEMA", "Schema 'public' não é permitido", 400);
        }

        if (!SCHEMA_PATTERN.matcher(trimmed).matches()) {
            throw new ApiException(
                    "INVALID_SCHEMA",
                    "Schema inválido: use apenas letras, números e _ (underscore)",
                    400
            );
        }
    }

    

    public boolean schemaExists(String schemaName) {
        if (!StringUtils.hasText(schemaName)) return false;

        String normalized = schemaName.trim();

        if ("public".equalsIgnoreCase(normalized)) return false;

        String sql = "SELECT EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = ?)";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, normalized);
        return Boolean.TRUE.equals(exists);
    }

   

    public boolean tableExists(String schemaName, String tableName) {
        if (!StringUtils.hasText(schemaName) || !StringUtils.hasText(tableName)) return false;

        String sql =
                "SELECT EXISTS(" +
                "  SELECT 1 FROM information_schema.tables " +
                "  WHERE table_schema = ? AND table_name = ?" +
                ")";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, schemaName, tableName);
        return Boolean.TRUE.equals(exists);
    }

    public void ensureSchemaExistsAndMigrate(String schemaName) {
        validateSchemaNameOrThrow(schemaName);

        String normalized = schemaName.trim().toLowerCase();


        if (!schemaExists(normalized)) {
            log.info("📦 Criando schema {}", normalized);
            jdbcTemplate.execute("CREATE SCHEMA IF NOT EXISTS \"" + normalized + "\"");
        }

        log.info("🧬 Rodando migrations do tenant: {}", normalized);
        tenantSchemaMigrationService.migrateTenant(normalized);
    }

    /**
     * Deve ser chamado com TenantContext já bindado no schema do tenant
     */
    public TenantUser tenantOwnerBootstrapService(Account account, String username, String email, String rawPassword) {
        String bound = TenantContext.getOrNull();
        if (bound == null || !bound.equals(account.getSchemaName())) {
            throw new ApiException("TENANT_NOT_BOUND", "Tenant não está bindado no schema esperado", 500);
        }

        String normUsername = username == null ? null : username.trim().toLowerCase();
        String normEmail = email == null ? null : email.trim().toLowerCase();

        if (!StringUtils.hasText(normUsername)) {
            throw new ApiException("INVALID_USERNAME", "Username é obrigatório", 400);
        }
        if (!StringUtils.hasText(normEmail)) {
            throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
        }

        boolean existsUser = tenantUserRepository.existsByUsernameAndAccountId(normUsername, account.getId());
        boolean existsEmail = tenantUserRepository.existsByEmailAndAccountId(normEmail, account.getId());

        if (existsUser) throw new ApiException("ADMIN_EXISTS", "Já existe usuário com este username", 409);
        if (existsEmail) throw new ApiException("ADMIN_EXISTS", "Já existe usuário com este email", 409);

        TenantUser admin = TenantUser.builder()
                .accountId(account.getId())
                .name("Administrador")
                .username(normUsername)
                .email(normEmail)
                .password(passwordEncoder.encode(rawPassword))
                .role(TenantRole.TENANT_ACCOUNT_OWNER)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .timezone(account.getTimezone() != null ? account.getTimezone() : "America/Sao_Paulo")
                .locale(account.getLocale() != null ? account.getLocale() : "pt_BR")
                .build();

        return tenantUserRepository.save(admin);
    }
}
package brito.com.multitenancy001.tenant.application.user.admin;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.application.user.TenantUserTxService;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantUserAdminService {

    private final TenantUserTxService tenantUserTxService;
    private final SecurityUtils securityUtils;

    private void runInTenant(String schema, Runnable action) {
        TenantContext.bind(schema);
        try {
            action.run();
        } finally {
            TenantContext.clear();
        }
    }

    public void setUserSuspendedByAdmin(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () ->
                tenantUserTxService.setSuspendedByAdmin(userId, accountId, suspended)
        );
    }
}
package brito.com.multitenancy001.tenant.application.user;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.tenant.domain.security.TenantRole;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantUserService {

	private final TenantUserApiMapper tenantUserApiMapper;

	
    private final TenantUserTxService tenantUserTxService; // ✅ novo
    private final AccountRepository accountRepository; // PUBLIC
    private final JwtTokenProvider jwtTokenProvider;
    private final SecurityUtils securityUtils;

    // ===== helpers =====
    private <T> T runInTenant(String schema, java.util.concurrent.Callable<T> action) {
        TenantContext.bind(schema);
        try {
            return action.call();
        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            TenantContext.clear();
        }
    }

    private void runInTenant(String schema, Runnable action) {
        TenantContext.bind(schema);
        try {
            action.run();
        } finally {
            TenantContext.clear();
        }
    }

   public TenantUserDetailsResponse createTenantUser(TenantUserCreateRequest tenantUserCreateRequest) {
    Long accountId = securityUtils.getCurrentAccountId();
    String schema = securityUtils.getCurrentSchema();

    validateCreateRequest(tenantUserCreateRequest);

    String username = tenantUserCreateRequest.username().trim().toLowerCase();
    String email = tenantUserCreateRequest.email().trim().toLowerCase();

    return runInTenant(schema, () -> toDetails(
            tenantUserTxService.createTenantUser(
                    accountId,
                    tenantUserCreateRequest.name().trim(),
                    username,
                    email,
                    tenantUserCreateRequest.password(),
                    tenantUserCreateRequest.role(),
                    tenantUserCreateRequest.phone(),
                    tenantUserCreateRequest.avatarUrl(),
                    tenantUserCreateRequest.permissions()
            )
    ));
}
   
   public void softDeleteTenantUser(Long userId) {
	    Long accountId = securityUtils.getCurrentAccountId();
	    String schema = securityUtils.getCurrentSchema();

	    TenantUser actor = loadActor(accountId, schema);
	    TenantUser target = loadTarget(accountId, schema, userId);

	    assertCanDeleteTarget(actor, target);

	    runInTenant(schema, () -> tenantUserTxService.softDelete(userId, accountId));
	}



   public List<TenantUserSummaryResponse> listTenantUsers() {
	    Long accountId = securityUtils.getCurrentAccountId();
	    String schema = securityUtils.getCurrentSchema();

	    return runInTenant(schema, () ->
	            tenantUserTxService.listUsers(accountId).stream()
	                    .map(this::toSummary)
	                    .toList()
	    );
	}

    
    

   public List<TenantUserSummaryResponse> listActiveTenantUsers() {
	    Long accountId = securityUtils.getCurrentAccountId();
	    String schema = securityUtils.getCurrentSchema();

	    return runInTenant(schema, () ->
	            tenantUserTxService.listActiveUsers(accountId).stream()
	                    .map(this::toSummary)
	                    .toList()
	    );
	}

    public TenantUserDetailsResponse getTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> toDetails(tenantUserTxService.getUser(userId, accountId)));
    }

    
    
    private TenantUserSummaryResponse toSummary(TenantUser u) {
        return tenantUserApiMapper.toSummary(u);
    }



    private TenantUserDetailsResponse toDetails(TenantUser u) {
        return TenantUserDetailsResponse.from(u);
    }
    

    public TenantUserSummaryResponse updateTenantUserStatus(Long userId, boolean active) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> toSummary(
                tenantUserTxService.updateStatus(userId, accountId, active)
        ));
    }


    public TenantUserSummaryResponse restoreTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> toSummary(
                tenantUserTxService.restore(userId, accountId)
        ));
    }
    
    
    public TenantUserSummaryResponse resetTenantUserPassword(Long userId, String newPassword) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> toSummary(
                tenantUserTxService.resetPassword(userId, accountId, newPassword)
        ));
    }
    

    public void hardDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        TenantUser actor = loadActor(accountId, schema);
        TenantUser target = loadTarget(accountId, schema, userId);

        assertCanDeleteTarget(actor, target);

        runInTenant(schema, () -> tenantUserTxService.hardDelete(userId, accountId));
    }


    // ===== PASSWORD RESET (PUBLIC + TENANT) =====
    public String generatePasswordResetToken(String slug, String email) {
        if (!StringUtils.hasText(slug)) throw new ApiException("INVALID_SLUG", "Slug é obrigatório", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);

        // PUBLIC (sem @Transactional tenant)
        TenantContext.clear();
        Account account = accountRepository.findBySlugAndDeletedFalse(slug)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
        if (!account.isActive()) throw new ApiException("ACCOUNT_INACTIVE", "Conta inativa", 403);

        String schema = account.getSchemaName();
        String normalizedEmail = email.trim().toLowerCase();

        return runInTenant(schema, () -> {
//            
            TenantUser user = tenantUserTxService.getByEmailActive(account.getId(), normalizedEmail);

            if (user.isSuspendedByAccount() || user.isDeleted()) throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);

            String token = jwtTokenProvider.generatePasswordResetToken(
                    user.getUsername(),
                    schema,
                    account.getId()
            );

            // Atualizar token precisa ser TX TENANT também — ideal: criar método tx.setResetToken(...)
            user.setPasswordResetToken(token);
            user.setPasswordResetExpires(LocalDateTime.now().plusHours(1));

            tenantUserTxService.save(user);
            return token;
        });
    }
    
    
    public void resetPasswordWithToken(String token, String newPassword) {
        if (!StringUtils.hasText(token)) {
            throw new ApiException("INVALID_TOKEN", "Token é obrigatório", 400);
        }
        if (!StringUtils.hasText(newPassword)) {
            throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);
        }

        if (!jwtTokenProvider.validateToken(token) || !jwtTokenProvider.isPasswordResetToken(token)) {
            throw new ApiException("INVALID_TOKEN", "Token inválido", 400);
        }

        String schema = jwtTokenProvider.getContextFromToken(token);
        Long accountId = jwtTokenProvider.getAccountIdFromToken(token);
        String username = jwtTokenProvider.getUsernameFromToken(token);

        if (!StringUtils.hasText(schema) || accountId == null || !StringUtils.hasText(username)) {
            throw new ApiException("INVALID_TOKEN", "Token incompleto", 400);
        }

        // ✅ bind antes da TX (por isso usamos runInTenant)
        runInTenant(schema, () -> {
            tenantUserTxService.resetPasswordWithToken(accountId, username, token, newPassword);
        });
    }
 
    
    
    
    

    private void validateCreateRequest(TenantUserCreateRequest r) { /* mantém seu método */ }
    
    
  private TenantUser loadActor(Long accountId, String schema) {
    Long actorId = securityUtils.getCurrentUserId();
    return runInTenant(schema, () -> tenantUserTxService.getUser(actorId, accountId));
}

private TenantUser loadTarget(Long accountId, String schema, Long targetUserId) {
    return runInTenant(schema, () -> tenantUserTxService.getUser(targetUserId, accountId));
}

private void assertCanDeleteTarget(TenantUser actor, TenantUser target) {
    if (target.getRole() == TenantRole.TENANT_ACCOUNT_OWNER && actor.getRole() != TenantRole.TENANT_ACCOUNT_OWNER) {
        throw new ApiException("FORBIDDEN", "Somente TENANT_ACCOUNT_OWNER pode excluir/alterar um TENANT_ACCOUNT_ADMIN", 403);
    }
}

private void assertCanTransferTenantOwner(TenantUser actor, TenantUser newAdmin) {
    if (actor.getRole() != TenantRole.TENANT_ACCOUNT_OWNER) {
        throw new ApiException("FORBIDDEN", "Apenas TENANT_ACCOUNT_OWNER pode transferir a administração", 403);
    }
    if (newAdmin.getRole() != TenantRole.TENANT_ACCOUNT_ADMIN) {
        throw new ApiException("INVALID_TARGET", "Somente um TENANT_ACCOUNT_ADMIN pode receber TENANT_ACCOUNT_OWNER", 400);
    }
}

public void transferTenantOwner(Long targetAdminUserId) {
    Long accountId = securityUtils.getCurrentAccountId();
    String schema = securityUtils.getCurrentSchema();

    TenantUser actor = loadActor(accountId, schema); // quem está logado
    TenantUser newAdmin = loadTarget(accountId, schema, targetAdminUserId);

    assertCanTransferTenantOwner(actor, newAdmin);

    runInTenant(schema, () -> {
        tenantUserTxService.transferTenantOwnerRole(accountId, actor.getId(), newAdmin.getId());
    });
}




}



package brito.com.multitenancy001.tenant.application.user;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.security.PermissionNormalizer;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.domain.security.TenantRole;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "tenantTransactionManager")
public class TenantUserTxService {

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;

    // =========================
    // CREATE
    // =========================
    public TenantUser createTenantUser(
            Long accountId,
            String name,
            String username,
            String email,
            String rawPassword,
            String role,
            String phone,
            String avatarUrl,
            LinkedHashSet<String> permissions
    ) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);

        if (!StringUtils.hasText(name)) throw new ApiException("INVALID_NAME", "Nome obrigatório", 400);
        if (!StringUtils.hasText(username)) throw new ApiException("INVALID_USERNAME", "Username obrigatório", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email obrigatório", 400);

        if (!StringUtils.hasText(rawPassword) || !rawPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inválida", 400);
        }

        String u = username.trim().toLowerCase();
        String e = email.trim().toLowerCase();

        if (tenantUserRepository.existsByUsernameAndAccountId(u, accountId)) {
            throw new ApiException("USERNAME_ALREADY_EXISTS", "Username já existe nesta conta", 409);
        }
        if (tenantUserRepository.existsByEmailAndAccountId(e, accountId)) {
            throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já existe nesta conta", 409);
        }

        TenantRole parsedRole = parseTenantRole(role);
     // ✅ normaliza e valida permissions AQUI (fonte de verdade)
        final Set<String> normalizedPermissions;
        try {
            normalizedPermissions = PermissionNormalizer.normalizeTenant(permissions);
        } catch (IllegalArgumentException e1) {
            throw new ApiException("INVALID_PERMISSION", e1.getMessage(), 400);
        }
        
        TenantUser user = TenantUser.builder()
                .accountId(accountId)
                .name(name.trim())
                .username(u)
                .email(e)
                .password(passwordEncoder.encode(rawPassword))
                .role(parsedRole)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .phone(phone)
                .avatarUrl(avatarUrl)
                .timezone("America/Sao_Paulo")
                .locale("pt_BR")
                // ❌ remova createdAt daqui (o Hibernate já seta via @CreationTimestamp no entity)
                .build();

     // ✅ Se request trouxe permissions válidas e não vazias, respeita.
     // Se veio vazio/null: deixa o @PrePersist do entity aplicar defaults por role.
        if (!normalizedPermissions.isEmpty()) {
            user.setPermissions(new LinkedHashSet<>(normalizedPermissions));
        }


        return tenantUserRepository.save(user);
    }
    
    public TenantUser setSuspendedByAdmin(Long userId, Long accountId, boolean suspended) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_DELETED", "Usuário está deletado", 409);

        user.setSuspendedByAdmin(suspended);
        user.setUpdatedAt(LocalDateTime.now());
        return tenantUserRepository.save(user);
    }
 
    
    
    
    @Transactional(transactionManager = "tenantTransactionManager")
    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
        if (updated == 0) {
            throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado ou removido", 404);
        }
    }

    
    

    // =========================
    // LIST / GET
    // =========================
    @Transactional(readOnly = true)
    public List<TenantUser> listUsers(Long accountId) {
        return tenantUserRepository.findByAccountIdAndDeletedFalse(accountId);
    }

    @Transactional(readOnly = true)
    public List<TenantUser> listActiveUsers(Long accountId) {
        // CORREÇÃO: Use o novo método customizado
        return tenantUserRepository.findActiveUsersByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public TenantUser getUser(Long userId, Long accountId) {
        return tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));
    }

    // usado em login/validações (sem deleted=true)
    @Transactional(readOnly = true)
    public TenantUser getByUsername(Long accountId, String username) {
        return tenantUserRepository.findByUsernameAndAccountIdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));
    }

    // ✅ isto substitui seu "getByEmailActive"
    @Transactional(readOnly = true)
    public TenantUser getByEmailActive(Long accountId, String email) {
        TenantUser user = tenantUserRepository.findByEmailAndAccountIdAndDeletedFalse(email, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
            throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
        }
        return user;
    }

    // =========================
    // UPDATE STATUS 
    // =========================
    public TenantUser updateStatus(Long userId, Long accountId, boolean active) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_DELETED", "Usuário está deletado", 409);

        // ✅ ação do admin: suspende/reativa manualmente
        user.setSuspendedByAdmin(!active);

        // ✅ NÃO mexe em suspendedByAccount aqui (quem manda é o status da conta)
        user.setUpdatedAt(LocalDateTime.now());
        return tenantUserRepository.save(user);
    }
    
    // =========================
    // CONTAGEM
    // =========================
    @Transactional(readOnly = true)
    public long countActiveUsers(Long accountId) {
        return tenantUserRepository.countActiveUsersByAccount(accountId);
    }

    public void softDelete(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_ALREADY_DELETED", "Usuário já removido", 409);

        user.softDelete();
        user.setUpdatedAt(LocalDateTime.now());
        tenantUserRepository.save(user);
    }

    public TenantUser restore(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (!user.isDeleted()) throw new ApiException("USER_NOT_DELETED", "Usuário não está removido", 409);

        user.restore();
        user.setUpdatedAt(LocalDateTime.now());
        return tenantUserRepository.save(user);
    }

    public void hardDelete(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));
        tenantUserRepository.delete(user);
    }

   
    public TenantUser resetPassword(Long userId, Long accountId, String newPassword) {
        if (!StringUtils.hasText(newPassword) || !newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inválida", 400);
        }

        TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(LocalDateTime.now());
        user.setMustChangePassword(false);
        user.setUpdatedAt(LocalDateTime.now());

        return tenantUserRepository.save(user);
    }

    // =========================
    // RESET PASSWORD (TOKEN)
    // =========================
    public void resetPasswordWithToken(Long accountId, String username, String token, String newPassword) {
        if (!StringUtils.hasText(newPassword) || !newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inválida", 400);
        }

        TenantUser user = tenantUserRepository.findByUsernameAndAccountId(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

        if (user.getPasswordResetToken() == null || !user.getPasswordResetToken().equals(token)) {
            throw new ApiException("INVALID_TOKEN", "Token não confere", 400);
        }
        if (user.getPasswordResetExpires() == null || user.getPasswordResetExpires().isBefore(LocalDateTime.now())) {
            throw new ApiException("TOKEN_EXPIRED", "Token expirado", 400);
        }

        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(LocalDateTime.now());
        user.setMustChangePassword(false);

        user.setPasswordResetToken(null);
        user.setPasswordResetExpires(null);

        user.setUpdatedAt(LocalDateTime.now());
        tenantUserRepository.save(user);
    }

    // usado no generatePasswordResetToken
    public TenantUser save(TenantUser user) {
        user.setUpdatedAt(LocalDateTime.now());
        return tenantUserRepository.save(user);
    }
    private TenantRole parseTenantRole(String role) {
        if (!StringUtils.hasText(role)) {
            throw new ApiException("INVALID_ROLE", "Role obrigatória", 400);
        }
        try {
            return TenantRole.valueOf(role.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new ApiException("INVALID_ROLE", "Role inválida: " + role, 400);
        }
    }

    
    
    
public void transferTenantOwnerRole(Long accountId, Long fromUserId, Long toUserId) {
    TenantUser from = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(fromUserId, accountId)
            .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "TENANT_ACCOUNT_OWNER não encontrado", 404));

    TenantUser to = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(toUserId, accountId)
            .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "TENANT_ACCOUNT_ADMIN alvo não encontrado", 404));

    // Aqui NÃO valida regra de negócio (isso fica no service de cima),
    // apenas aplica a troca.
    from.setRole(TenantRole.TENANT_ACCOUNT_ADMIN);
    to.setRole(TenantRole.TENANT_ACCOUNT_OWNER);

    from.setUpdatedAt(LocalDateTime.now());
    to.setUpdatedAt(LocalDateTime.now());

    tenantUserRepository.save(from);
    tenantUserRepository.save(to);
}
  


    
}package brito.com.multitenancy001.tenant.application.username.generator;

import java.util.UUID;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.shared.domain.username.UsernamePolicy;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class UsernameGeneratorService {

	private static final int SUFFIX_LEN = 8;

	private final UsernamePolicy policy;
	private final TenantUserRepository tenantUserRepository;

	/**
	 * Gera username baseado no email, garantindo: - normalização - limite máximo
	 * (sem cortar sufixo) - unicidade por accountId (best-effort + fallback)
	 */
	public String generateFromEmail(String email, Long accountId) {
    if (accountId == null) {
        throw new IllegalArgumentException("accountId is required");
    }
    if (email == null || !email.contains("@")) {
        throw new IllegalArgumentException("Invalid email");
    }

    String local = email.split("@", 2)[0].toLowerCase();
    String base = policy.normalizeBase(local);

    for (int attempt = 0; attempt < 10; attempt++) {
        String candidate = policy.build(base, randomSuffix(SUFFIX_LEN));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    for (int counter = 2; counter < 200; counter++) {
        String candidate = policy.build(base, String.valueOf(counter));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    throw new IllegalStateException("Could not generate a unique username after multiple attempts");
}

public String ensureUnique(String initialUsername, Long accountId) {
    if (accountId == null) {
        throw new IllegalArgumentException("accountId is required");
    }

    if (policy.isValid(initialUsername) &&
        !tenantUserRepository.existsByUsernameAndAccountId(initialUsername, accountId)) {
        return initialUsername;
    }

    String base = policy.extractBase(initialUsername);

    for (int attempt = 0; attempt < 10; attempt++) {
        String candidate = policy.build(base, randomSuffix(SUFFIX_LEN));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    for (int counter = 2; counter < 200; counter++) {
        String candidate = policy.build(base, String.valueOf(counter));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    throw new IllegalStateException("Could not ensure unique username after multiple attempts");
}


	
	private String randomSuffix(int len) {
		return UUID.randomUUID().toString().replace("-", "").substring(0, len);
	}
}
// ===============================
// Category.java
// ===============================
package brito.com.multitenancy001.tenant.domain.category;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
    name = "categories",
    uniqueConstraints = @UniqueConstraint(
        name = "uk_categories_name",
        columnNames = "name"
    )
)
@Getter
@Setter
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable=false, length=100)
    private String name;

    @Column(nullable=false)
    private Boolean active = true;

    @Column(nullable=false)
    private Boolean deleted = false;
}
// ===============================
// Subcategory.java
// ===============================
package brito.com.multitenancy001.tenant.domain.category;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
    name="subcategories",
    uniqueConstraints = @UniqueConstraint(
        name="uk_subcategories_name_category",
        columnNames={"category_id","name"}
    )
)
@Getter
@Setter
public class Subcategory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional=false)
    @JoinColumn(
        name="category_id",
        nullable=false,
        foreignKey=@ForeignKey(name="fk_subcategories_category")
    )
    private Category category;

    @Column(nullable=false, length=100)
    private String name;

    @Column(nullable=false)
    private Boolean active = true;

    @Column(nullable=false)
    private Boolean deleted = false;
}
package brito.com.multitenancy001.tenant.domain.product;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "products", indexes = {
    @Index(name = "idx_product_name", columnList = "name"),
    @Index(name = "idx_product_sku", columnList = "sku", unique = true),
    @Index(name = "idx_product_supplier", columnList = "supplier_id"),
    @Index(name = "idx_product_created_at", columnList = "created_at"),
    @Index(name = "idx_products_category_id", columnList = "category_id"),
    @Index(name = "idx_products_subcategory_id", columnList = "subcategory_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"supplier", "category", "subcategory"})
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(unique = true, length = 100)
    private String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    @Builder.Default
    private Integer stockQuantity = 0;

    @Column(name = "min_stock")
    private Integer minStock;

    @Column(name = "max_stock")
    private Integer maxStock;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    @Column(name = "profit_margin", precision = 5, scale = 2)
    private BigDecimal profitMargin;

    // ✅ FK simples (category_id) - obrigatório
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
        name = "category_id",
        nullable = false,
        foreignKey = @ForeignKey(name = "fk_products_category")
    )
    private Category category;

    // ✅ CORREÇÃO: FK simples para subcategory (REMOVER a composta)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
        name = "subcategory_id",
        foreignKey = @ForeignKey(name = "fk_products_subcategory")
    )
    private Subcategory subcategory;

    @Column(name = "brand", length = 100)
    private String brand;

    @Column(name = "weight_kg", precision = 8, scale = 3)
    private BigDecimal weightKg;

    @Column(name = "dimensions", length = 50)
    private String dimensions;

    @Column(name = "barcode", length = 50)
    private String barcode;

    @Column(name = "active")
    @Builder.Default
    private Boolean active = true;

    @Column(name = "images_json", columnDefinition = "TEXT")
    private String imagesJson;

    @Column(name = "attributes_json", columnDefinition = "TEXT")
    private String attributesJson;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", foreignKey = @ForeignKey(name = "fk_product_supplier"))
    private Supplier supplier;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted")
    @Builder.Default
    private Boolean deleted = false;

    @PrePersist
    protected void onCreate() {
       
        if (this.stockQuantity == null) this.stockQuantity = 0;
        if (this.active == null) this.active = true;
        calculateProfitMargin();
    }

    @PreUpdate
    protected void onUpdate() {
        calculateProfitMargin();
    }

    private void calculateProfitMargin() {
        if (this.costPrice != null && this.costPrice.compareTo(BigDecimal.ZERO) > 0 && this.price != null) {
            BigDecimal profit = this.price.subtract(this.costPrice);
            this.profitMargin = profit
                .divide(this.costPrice, 4, RoundingMode.HALF_UP)
                .multiply(BigDecimal.valueOf(100));
        }
    }

    public void softDelete() {
        this.deleted = true;
        this.deletedAt = LocalDateTime.now();
        this.active = false;
    }

    public void updatePrice(BigDecimal newPrice) {
        if (newPrice == null || newPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Preço inválido");
        }
        this.price = newPrice;
        calculateProfitMargin();
    }

    public void updateCostPrice(BigDecimal newCostPrice) {
        this.costPrice = newCostPrice;
        calculateProfitMargin();
    }
    
    public void addToStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;
        this.stockQuantity += quantity;
    }

    public void removeFromStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;

        if (this.stockQuantity < quantity) {
            throw new IllegalStateException("Estoque insuficiente. Disponível: " + this.stockQuantity);
        }
        this.stockQuantity -= quantity;
    }
}package brito.com.multitenancy001.tenant.domain.sale;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import jakarta.persistence.*;
import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "sales")
public class Sale {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "sale_date", nullable = false)
    private LocalDateTime saleDate;

    @OneToMany(
            mappedBy = "sale",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    @Builder.Default
    private List<SaleItem> items = new ArrayList<>();

    @Column(name = "total_amount", precision = 10, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "customer_name", length = 200)
    private String customerName;

    @Column(name = "customer_email", length = 150)
    private String customerEmail;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", length = 20)
    private SaleStatus status;

    public enum SaleStatus {
        PENDING, COMPLETED, CANCELLED, REFUNDED
    }

    // ✅ helpers opcionais (mantém consistência do agregado)
    public void addItem(SaleItem item) {
        if (item == null) return;
        items.add(item);
        item.setSale(this);
    }

    public void removeItem(SaleItem item) {
        if (item == null) return;
        items.remove(item);
        item.setSale(null);
    }
}
package brito.com.multitenancy001.tenant.domain.sale;

import java.math.BigDecimal;
import java.util.UUID;

import jakarta.persistence.*;
import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "sale_items")
public class SaleItem {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "sale_id", nullable = false)
    private Sale sale;

    @Column(name = "product_id")
    private UUID productId;

    @Column(name = "product_name", length = 200)
    private String productName;

    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalPrice;

    @PrePersist
    @PreUpdate
    private void validateAndComputeTotals() {
        if (quantity == null || quantity <= 0) {
            throw new IllegalStateException("quantity must be > 0");
        }
        if (unitPrice == null) {
            throw new IllegalStateException("unitPrice is required");
        }
        if (totalPrice == null) {
            totalPrice = unitPrice.multiply(BigDecimal.valueOf(quantity));
        }
    }
}
package brito.com.multitenancy001.tenant.domain.security;

import brito.com.multitenancy001.shared.security.PermissionAuthority;

public enum TenantPermission implements PermissionAuthority {

    TEN_USER_READ,
    TEN_USER_CREATE,
    TEN_USER_UPDATE,
    TEN_USER_SUSPEND,
    TEN_USER_RESTORE,
    TEN_USER_DELETE,

    TEN_ROLE_TRANSFER, 

    TEN_PRODUCT_READ,
    TEN_PRODUCT_WRITE,

    TEN_CATEGORY_READ,
    TEN_CATEGORY_WRITE,

    TEN_SUPPLIER_READ,
    TEN_SUPPLIER_WRITE,

    TEN_SALE_READ,
    TEN_SALE_WRITE,
    TEN_SALE_ISSUES_READ,

    TEN_REPORT_SALES_READ,

    TEN_BILLING_READ,
    TEN_BILLING_WRITE,

    TEN_SETTINGS_READ,
    TEN_SETTINGS_WRITE,
	
	TEN_INVENTORY_READ,
	TEN_INVENTORY_WRITE;

    @Override
    public String asAuthority() {
        return name();
    }
}
package brito.com.multitenancy001.tenant.domain.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum TenantRole implements RoleAuthority {

    TENANT_ACCOUNT_OWNER,
    TENANT_ACCOUNT_ADMIN,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isTenantOwner() {
        return this == TENANT_ACCOUNT_OWNER;
    }
}
package brito.com.multitenancy001.tenant.domain.security;

import java.util.EnumSet;
import java.util.Set;

public final class TenantRolePermissions {

    private TenantRolePermissions() {}

    public static Set<TenantPermission> permissionsFor(TenantRole role) {
        return switch (role) {
            case TENANT_ACCOUNT_OWNER -> EnumSet.allOf(TenantPermission.class);

            case TENANT_ACCOUNT_ADMIN -> EnumSet.of(
                    TenantPermission.TEN_USER_READ,
                    TenantPermission.TEN_USER_CREATE,
                    TenantPermission.TEN_USER_UPDATE,
                    TenantPermission.TEN_USER_SUSPEND,
                    TenantPermission.TEN_USER_RESTORE,
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_PRODUCT_WRITE,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_BILLING_READ,
                    TenantPermission.TEN_SETTINGS_READ,
                    TenantPermission.TEN_SETTINGS_WRITE,
                    TenantPermission.TEN_INVENTORY_WRITE
            );

            case TENANT_PRODUCT_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_PRODUCT_WRITE,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_INVENTORY_WRITE
            );

            case TENANT_SALES_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_SALE_READ,
                    TenantPermission.TEN_SALE_WRITE
            );

            case TENANT_BILLING_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_BILLING_READ,
                    TenantPermission.TEN_BILLING_WRITE
            );

            case TENANT_READ_ONLY -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_USER_READ
            );

            case TENANT_OPERATOR -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ
            );
        };
    }
}
package brito.com.multitenancy001.tenant.domain.supplier;



import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.tenant.domain.product.Product;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "suppliers", indexes = {
    @Index(name = "idx_supplier_name", columnList = "name"),
    @Index(name = "idx_supplier_document", columnList = "document", unique = true),
    @Index(name = "idx_supplier_email", columnList = "email")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"products"})
public class Supplier {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(nullable = false, length = 200)
    private String name;
    
    @Column(name = "contact_person", length = 100)
    private String contactPerson;
    
    @Column(length = 150)
    private String email;
    
    @Column(length = 20)
    private String phone;
    
    @Column(columnDefinition = "TEXT")
    private String address;
    
    @Column(length = 20, unique = true)
    private String document; // CNPJ/CPF
    
    @Column(name = "document_type", length = 10)
    private String documentType; // CNPJ, CPF, etc.
    
    @Column(name = "website", length = 200)
    private String website;
    
    @Column(name = "payment_terms", length = 100)
    private String paymentTerms;
    
    @Column(name = "lead_time_days")
    private Integer leadTimeDays;
    
    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating;
    
    @Column(name = "active")
    @Builder.Default
    private Boolean active = true;
    
    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;
    
    @OneToMany(mappedBy = "supplier", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @Builder.Default
    private List<Product> products = new ArrayList<>();
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
   
    
    
}package brito.com.multitenancy001.tenant.domain.user;

import brito.com.multitenancy001.shared.security.PermissionNormalizer;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.domain.security.TenantRole;
import brito.com.multitenancy001.tenant.domain.security.TenantRolePermissions;
import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(
    name = "users_tenant",
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_users_tenant_username_account", columnNames = {"username", "account_id"}),
        @UniqueConstraint(name = "uk_users_tenant_email_account", columnNames = {"email", "account_id"})
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "password")
public class TenantUser {

    private static final int USERNAME_MAX_LEN = 100;
    private static final int EMAIL_MAX_LEN = 150;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = USERNAME_MAX_LEN)
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inválido.")
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false, length = EMAIL_MAX_LEN)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private TenantRole role;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @ElementCollection
    @CollectionTable(
        name = "user_tenant_permissions",
        joinColumns = @JoinColumn(name = "user_tenant_id")
    )
    @Column(name = "permission", length = 120)
    @Builder.Default

    private LinkedHashSet<String> permissions = new LinkedHashSet<>();

    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts", nullable = false)
    @Builder.Default
    private Integer failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private Boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    @Column(name = "timezone", nullable = false, length = 50)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", nullable = false, length = 10)
    @Builder.Default
    private String locale = "pt_BR";

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

   @PrePersist
@PreUpdate
protected void onSave() {
    if (permissions == null) permissions = new LinkedHashSet<>();
    if (role == null) throw new IllegalStateException("Role is required");

    if (username != null) username = username.toLowerCase().trim();
    if (email != null) email = email.toLowerCase().trim();

    // 1) se não veio nada, aplica defaults por role via TenantRolePermissions
    if (permissions.isEmpty()) {
        permissions = new LinkedHashSet<>(
                TenantRolePermissions
                        .permissionsFor(role)
                        .stream()
                        .map(Enum::name)
                        .toList()
        );
    }

    // 2) normaliza SEMPRE (trim, prefix TEN_, remove duplicadas, bloqueia CP_)
    Set<String> normalized = PermissionNormalizer.normalizeTenant(permissions);

    // 3) volta para LinkedHashSet preservando ordem (se quiser preservar)
    permissions = new LinkedHashSet<>(new LinkedHashSet<>(normalized));
}



    public boolean isAccountNonLocked(LocalDateTime now) {
    	var accountLocked = (lockedUntil != null && lockedUntil.isAfter(now));
        return !accountLocked;
    }

    public boolean isEnabledForLogin() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    public boolean isEnabledForLogin(LocalDateTime now) {
        return isEnabledForLogin() && isAccountNonLocked(now);
    }

    public void softDelete() {
        if (deleted) return;

        deleted = true;
        deletedAt = LocalDateTime.now();

        suspendedByAccount = true;
        suspendedByAdmin = true;

        String ts = String.valueOf(System.currentTimeMillis());

        // ✅ username: normaliza para ficar compatível com o pattern e preserva o sufixo (timestamp)
        {
            String prefix = "deleted_";
            String suffix = "_" + ts;

            String middle = (username == null ? "user" : username)
                .toLowerCase()
                .trim()
                .replaceAll("[^a-z0-9._-]", "_")
                .replaceAll("_{2,}", "_")
                .replaceAll("^_|_$", "");

            if (middle.isBlank()) middle = "user";

            int maxMiddleLen = USERNAME_MAX_LEN - prefix.length() - suffix.length();
            if (maxMiddleLen < 1) maxMiddleLen = 1;

            if (middle.length() > maxMiddleLen) {
                middle = middle.substring(0, maxMiddleLen);
                middle = middle.replaceAll("_+$", "");
                if (middle.isBlank()) middle = "u";
            }

            username = prefix + middle + suffix;
        }

        // ✅ email: preserva o sufixo e respeita o tamanho máximo (não precisa normalizar como username)
        {
            String prefix = "deleted_";
            String suffix = "_" + ts;

            String middle = (email == null ? "deleted" : email).trim();

            int maxMiddleLen = EMAIL_MAX_LEN - prefix.length() - suffix.length();
            if (maxMiddleLen < 1) maxMiddleLen = 1;

            if (middle.length() > maxMiddleLen) {
                middle = middle.substring(0, maxMiddleLen);
            }

            email = prefix + middle + suffix;
        }
    }

    public void restore() {
        if (!deleted) return;
        deleted = false;
        deletedAt = null;

        // ao restaurar: admin deixa de bloquear; account status segue mandando
        suspendedByAdmin = false;
        // não altera suspendedByAccount aqui
    }
}
package brito.com.multitenancy001.tenant.persistence.category;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.category.Category;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {}package brito.com.multitenancy001.tenant.persistence.category;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.category.Subcategory;

import java.util.Optional;

@Repository
public interface SubcategoryRepository extends JpaRepository<Subcategory, Long> {

    @Query("select s from Subcategory s join fetch s.category where s.id = :id")
    Optional<Subcategory> findByIdWithCategory(@Param("id") Long id);
}
package brito.com.multitenancy001.tenant.persistence.product;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.product.Product;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface ProductRepository extends JpaRepository<Product, UUID> {

	List<Product> findByCategory_Id(Long categoryId);

	List<Product> findBySubcategory_Id(Long subcategoryId);

	@Query("""
			SELECT p FROM Product p
			WHERE p.category.id = :categoryId
			  AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
			""")
	List<Product> findByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
			@Param("subcategoryId") Long subcategoryId);

	List<Product> findByNameContainingIgnoreCase(String name);

	Optional<Product> findBySku(String sku);

	List<Product> findByStockQuantityLessThan(Integer quantity);

	List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

	List<Product> findBySupplier_Id(UUID supplierId);

	Page<Product> findByNameContainingIgnoreCase(String name, Pageable pageable);

	@Query("SELECT p FROM Product p WHERE "
			+ "(:name IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :name, '%'))) AND "
			+ "(:minPrice IS NULL OR p.price >= :minPrice) AND " + "(:maxPrice IS NULL OR p.price <= :maxPrice) AND "
			+ "(:minStock IS NULL OR p.stockQuantity >= :minStock) AND "
			+ "(:maxStock IS NULL OR p.stockQuantity <= :maxStock)")
	List<Product> searchProducts(@Param("name") String name, @Param("minPrice") BigDecimal minPrice,
			@Param("maxPrice") BigDecimal maxPrice, @Param("minStock") Integer minStock,
			@Param("maxStock") Integer maxStock);

	List<Product> findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(String name, BigDecimal minPrice,
			BigDecimal maxPrice, Integer minStock, Integer maxStock);

	@Query("SELECT COUNT(p) FROM Product p WHERE p.stockQuantity <= :threshold")
	Long countLowStock(@Param("threshold") Integer threshold);

	@Query("SELECT SUM(p.stockQuantity * p.price) FROM Product p")
	BigDecimal calculateTotalInventoryValue();

	@Query("SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id")
	List<Object[]> countProductsBySupplier();
}package brito.com.multitenancy001.tenant.persistence.supplier;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.supplier.Supplier;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface SupplierRepository extends JpaRepository<Supplier, UUID> {
    
    Optional<Supplier> findByDocument(String document);
    
    List<Supplier> findByNameContainingIgnoreCase(String name);
    
    List<Supplier> findByEmail(String email);
}package brito.com.multitenancy001.tenant.persistence.user;

import jakarta.transaction.Transactional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.user.TenantUser;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantUserRepository extends JpaRepository<TenantUser, Long> {
	
	
	 // ✅ Suspende por CONTA (sem mexer na suspensão por admin)
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = true
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int suspendAllByAccount(@Param("accountId") Long accountId);

    // ✅ Reativa por CONTA (sem mexer na suspensão por admin)
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = false
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int unsuspendAllByAccount(@Param("accountId") Long accountId);

  
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAdmin = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAdmin(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

  

	
    
    Optional<TenantUser> findByPasswordResetTokenAndAccountId(String passwordResetToken, Long accountId);

    Optional<TenantUser> findByUsernameAndDeletedFalse(String username);

    Optional<TenantUser> findByEmailAndAccountId(String email, Long accountId);

    Optional<TenantUser> findByEmailAndAccountIdAndDeletedFalse(String email, Long accountId);

    Optional<TenantUser> findByUsernameAndAccountId(String username, Long accountId);

    // (se você quiser filtrar deletados no login)
    Optional<TenantUser> findByUsernameAndAccountIdAndDeletedFalse(String username, Long accountId);

    boolean existsByUsernameAndAccountId(String username, Long accountId);

    boolean existsByEmailAndAccountId(String email, Long accountId);

    boolean existsByEmailAndAccountIdAndIdNot(String email, Long accountId, Long id);

    // ==========================
    // Listagens (Tenant)
    // ==========================
    List<TenantUser> findByAccountId(Long accountId);

    List<TenantUser> findByAccountIdAndDeletedFalse(Long accountId);

    // CORREÇÃO: Removido o método que usa "ActiveTrue" pois não existe na entidade
    // List<TenantUser> findByAccountIdAndActiveTrueAndDeletedFalse(Long accountId);
    
    // NOVO: Método para buscar usuários ativos usando lógica customizada
    @Query("SELECT u FROM TenantUser u WHERE u.accountId = :accountId " +
           "AND u.deleted = false " +
           "AND u.suspendedByAccount = false " +
           "AND u.suspendedByAdmin = false")
    List<TenantUser> findActiveUsersByAccount(@Param("accountId") Long accountId);

    // ==========================
    // Contagem / Limites
    // ==========================
    // CORREÇÃO: Removido método que não funciona
    // long countByAccountIdAndActiveTrueAndDeletedFalse(Long accountId);
    
    // NOVO: Contagem de usuários ativos
    @Query("SELECT COUNT(u) FROM TenantUser u WHERE u.accountId = :accountId " +
           "AND u.deleted = false " +
           "AND u.suspendedByAccount = false " +
           "AND u.suspendedByAdmin = false")
    long countActiveUsersByAccount(@Param("accountId") Long accountId);

    // ==========================
    // Busca por ID com scoping de conta
    // ==========================
    Optional<TenantUser> findByIdAndAccountId(Long id, Long accountId);

    // (se quiser reforçar deletado false)
    Optional<TenantUser> findByIdAndAccountIdAndDeletedFalse(Long id, Long accountId);
}-- V1__create_accounts.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS accounts (
    id BIGSERIAL PRIMARY KEY,

    -- Flag para identificar contas do sistema
    is_system_account BOOLEAN NOT NULL DEFAULT false,

    name VARCHAR(150) NOT NULL,

    -- Infra
    schema_name VARCHAR(100) NOT NULL,
    slug VARCHAR(50) NOT NULL,

    -- Status / Plano
    status VARCHAR(50) NOT NULL,
    subscription_plan VARCHAR(50) DEFAULT 'FREE',

    max_users INTEGER DEFAULT 5,
    max_products INTEGER DEFAULT 100,
    max_storage_mb INTEGER DEFAULT 100,

    -- Identidade da empresa (CRÍTICO)
    company_doc_type VARCHAR(10) NOT NULL,
    company_doc_number VARCHAR(20) NOT NULL,
    company_email VARCHAR(150) NOT NULL,

    company_phone VARCHAR(20),
    company_address VARCHAR(500),
    company_city VARCHAR(100),
    company_state VARCHAR(50),
    company_country VARCHAR(50) DEFAULT 'Brasil',

    -- Localização
    timezone VARCHAR(50) DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(10) DEFAULT 'pt_BR',
    currency VARCHAR(3) DEFAULT 'BRL',

    -- Datas
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    trial_end_date TIMESTAMP,
    payment_due_date TIMESTAMP,
    next_billing_date TIMESTAMP,

    settings_json TEXT,
    metadata_json TEXT,

    deleted BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP
);

-- Unicidade de documento por conta ativa
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_company_doc_active
ON accounts (company_doc_type, company_doc_number)
WHERE deleted = false;

-- Unicidade de email por conta ativa
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_company_email_active
ON accounts (company_email)
WHERE deleted = false;

-- Unicidade de schema (global)
CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_schema_name
ON accounts (schema_name);

-- Unicidade de slug (global)
CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_slug
ON accounts (slug);

-- V2__create_controlplane_users.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_users (
    id BIGSERIAL PRIMARY KEY,

    name VARCHAR(100) NOT NULL,
    username VARCHAR(100) NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(150) NOT NULL,

    role VARCHAR(50) NOT NULL,

    account_id BIGINT NOT NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,

    timezone VARCHAR(50) DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(10) DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP,
    deleted BOOLEAN NOT NULL DEFAULT false,

    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    CONSTRAINT fk_controlplane_users_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE,

    CONSTRAINT ux_controlplane_users_username UNIQUE (account_id, username),
    CONSTRAINT ux_controlplane_users_email UNIQUE (account_id, email)
);

-- V3__create_controlplane_user_permissions.sql
CREATE TABLE IF NOT EXISTS public.controlplane_user_permissions (
    user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (user_id, permission),

    CONSTRAINT fk_controlplane_user_permissions_user
        FOREIGN KEY (user_id)
        REFERENCES public.controlplane_users(id)
        ON DELETE CASCADE
);

-- V3__insert_controlplane_account.sql
SET search_path TO public;

INSERT INTO accounts (
    is_system_account,
    name,
    schema_name,
    slug,
    status,
    subscription_plan,
    company_doc_type,
    company_doc_number,
    company_email,
    company_country,
    deleted
)
SELECT
    true,
    'ControlPlane',
    'public',
    'controlplane',
    'ACTIVE',
    'FREE',
    'CNPJ',
    '00000000000000',
    'controlplane@system.com',
    'Brasil',
    false
WHERE NOT EXISTS (
    SELECT 1
    FROM accounts
    WHERE slug = 'controlplane'
);
-- V4__insert_controlplane_super_admin.sql
SET search_path TO public;

INSERT INTO controlplane_users (
    name,
    username,
    email,
    password,
    role,
    account_id,
    suspended_by_account,
    suspended_by_admin
)
SELECT
    'ControlPlane Super Admin',
    'superadmin',
    'admin@controlplane.com',
    '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
    'PLATFORM_OWNER',
    a.id,
    false,
    false
FROM accounts a
WHERE a.slug = 'controlplane'
AND NOT EXISTS (
    SELECT 1
    FROM controlplane_users u
    WHERE u.account_id = a.id
      AND (u.username = 'superadmin' OR u.email = 'admin@controlplane.com')
);

-- V5__create_payments.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS payments (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,

    payment_date TIMESTAMP NOT NULL,
    valid_until TIMESTAMP,

    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',

    transaction_id VARCHAR(100) UNIQUE,
    payment_method VARCHAR(50),
    payment_gateway VARCHAR(50),
    currency VARCHAR(3) DEFAULT 'BRL',

    description VARCHAR(500),
    metadata_json TEXT,

    invoice_url TEXT,
    receipt_url TEXT,

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,

    refunded_at TIMESTAMP,
    refund_amount NUMERIC(10,2),
    refund_reason VARCHAR(500),

    CONSTRAINT fk_payments_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_payment_account ON payments(account_id);
CREATE INDEX IF NOT EXISTS idx_payment_status ON payments(status);
CREATE UNIQUE INDEX IF NOT EXISTS idx_payment_transaction ON payments(transaction_id) WHERE transaction_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_payment_date ON payments(payment_date);
-- V1__create_tenants_users.sql

CREATE TABLE IF NOT EXISTS users_tenant (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    account_id BIGINT NOT NULL,

    name VARCHAR(100) NOT NULL,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(150) NOT NULL,
    password VARCHAR(255) NOT NULL,

    role VARCHAR(50) NOT NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    timezone VARCHAR(50) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(10) NOT NULL DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,

    deleted BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP,

    CONSTRAINT uk_users_tenant_username_account UNIQUE (username, account_id),
    CONSTRAINT uk_users_tenant_email_account UNIQUE (email, account_id)
);

CREATE INDEX IF NOT EXISTS idx_users_tenant_account_id ON users_tenant(account_id);
CREATE INDEX IF NOT EXISTS idx_users_tenant_username ON users_tenant(username);
CREATE INDEX IF NOT EXISTS idx_users_tenant_email ON users_tenant(email);
CREATE INDEX IF NOT EXISTS idx_users_tenant_deleted ON users_tenant(deleted) WHERE deleted = false;

-- V2__create_tenant_users_permissions.sql
CREATE TABLE IF NOT EXISTS user_tenant_permissions (
    user_tenant_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (user_tenant_id, permission),

    CONSTRAINT fk_user_tenant_permissions_user
        FOREIGN KEY (user_tenant_id)
        REFERENCES users_tenant(id)
        ON DELETE CASCADE
);-- V3__create_categories.sql

CREATE TABLE IF NOT EXISTS categories (
  id BIGSERIAL PRIMARY KEY,

  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  CONSTRAINT uk_categories_name UNIQUE (name)
);

CREATE INDEX IF NOT EXISTS idx_categories_active  ON categories(active);
CREATE INDEX IF NOT EXISTS idx_categories_deleted ON categories(deleted) WHERE deleted = false;
-- V4__create_subcategories.sql

CREATE TABLE IF NOT EXISTS subcategories (
  id BIGSERIAL PRIMARY KEY,

  category_id BIGINT NOT NULL,
  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  CONSTRAINT fk_subcategories_category
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE,

  CONSTRAINT uk_subcategories_name_category UNIQUE (category_id, name)
);

CREATE INDEX IF NOT EXISTS idx_subcategories_category_id ON subcategories(category_id);
CREATE INDEX IF NOT EXISTS idx_subcategories_active      ON subcategories(active);
CREATE INDEX IF NOT EXISTS idx_subcategories_deleted     ON subcategories(deleted) WHERE deleted = false;
-- V5__create_suppliers.sql

CREATE TABLE IF NOT EXISTS suppliers (
  id UUID PRIMARY KEY,

  name VARCHAR(200) NOT NULL,
  contact_person VARCHAR(100),

  email VARCHAR(150),
  phone VARCHAR(20),
  address TEXT,

  document VARCHAR(20),
  document_type VARCHAR(10),

  website VARCHAR(200),
  payment_terms VARCHAR(100),

  lead_time_days INTEGER,
  rating NUMERIC(3,2),

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  notes TEXT,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP
);

-- document único somente para fornecedores ativos e com documento preenchido
CREATE UNIQUE INDEX IF NOT EXISTS ux_suppliers_document_active
ON suppliers(document)
WHERE document IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_supplier_name   ON suppliers(name);
CREATE INDEX IF NOT EXISTS idx_supplier_email  ON suppliers(email);
CREATE INDEX IF NOT EXISTS idx_supplier_active ON suppliers(active);
CREATE INDEX IF NOT EXISTS idx_supplier_deleted ON suppliers(deleted) WHERE deleted = false;
-- V6__create_products.sql

CREATE TABLE IF NOT EXISTS products (
  id UUID PRIMARY KEY,

  name VARCHAR(200) NOT NULL,
  description TEXT,

  sku VARCHAR(100),
  price NUMERIC(10,2) NOT NULL,

  stock_quantity INT NOT NULL DEFAULT 0,
  min_stock INT,
  max_stock INT,

  cost_price NUMERIC(10,2),
  profit_margin NUMERIC(5,2),

  category_id BIGINT NOT NULL,
  subcategory_id BIGINT NULL,

  brand VARCHAR(100),
  weight_kg NUMERIC(8,3),
  dimensions VARCHAR(50),
  barcode VARCHAR(50),

  active BOOLEAN NOT NULL DEFAULT true,

  images_json TEXT,
  attributes_json TEXT,

  supplier_id UUID NULL,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  CONSTRAINT fk_products_category
    FOREIGN KEY (category_id) REFERENCES categories(id),

  CONSTRAINT fk_products_subcategory
    FOREIGN KEY (subcategory_id) REFERENCES subcategories(id),

  CONSTRAINT fk_product_supplier
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);

-- sku único apenas quando preenchido e produto ativo
CREATE UNIQUE INDEX IF NOT EXISTS ux_products_sku_active
ON products(sku)
WHERE sku IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_product_name       ON products(name);
CREATE INDEX IF NOT EXISTS idx_product_supplier   ON products(supplier_id);
CREATE INDEX IF NOT EXISTS idx_product_created_at ON products(created_at);

CREATE INDEX IF NOT EXISTS idx_products_category_id    ON products(category_id);
CREATE INDEX IF NOT EXISTS idx_products_subcategory_id ON products(subcategory_id);

CREATE INDEX IF NOT EXISTS idx_products_deleted ON products(deleted) WHERE deleted = false;
-- V7__create_sales.sql

CREATE TABLE IF NOT EXISTS sales (
    id UUID PRIMARY KEY,
    sale_date TIMESTAMP NOT NULL,
    total_amount NUMERIC(10,2),
    customer_name VARCHAR(200),
    customer_email VARCHAR(150),
    status VARCHAR(20)
);

CREATE INDEX IF NOT EXISTS idx_sales_sale_date ON sales (sale_date);
CREATE INDEX IF NOT EXISTS idx_sales_status ON sales (status);
CREATE INDEX IF NOT EXISTS idx_sales_customer_email ON sales (customer_email);
-- V8__create_sales_items.sql

CREATE TABLE IF NOT EXISTS sale_items (
    id UUID PRIMARY KEY,
    sale_id UUID NOT NULL,
    product_id UUID NULL,
    product_name VARCHAR(200),
    quantity INTEGER NOT NULL,
    unit_price NUMERIC(10,2) NOT NULL,
    total_price NUMERIC(10,2) NOT NULL,

    CONSTRAINT fk_sale_items_sale
        FOREIGN KEY (sale_id) REFERENCES sales(id)
        ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_sale_items_sale_id ON sale_items (sale_id);
CREATE INDEX IF NOT EXISTS idx_sale_items_product_id ON sale_items (product_id);
package brito.com.multitenancy001;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Multitenancy001ApplicationTests {

	@Test
	void contextLoads() {
	}

}
