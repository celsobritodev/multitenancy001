package brito.com.multitenancy001.controlplane.api.controller.accounts.admin;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/accounts")
@RequiredArgsConstructor
@Slf4j
public class AccountAdminController {

    private final AccountLifecycleService accountLifecycleService;

    @GetMapping
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountResponse>> listAllAccounts() {
        log.info("Listando todas as contas");
        return ResponseEntity.ok(accountLifecycleService.listAllAccounts());
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountResponse> getAccountById(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.getAccountById(id));
    }

    @GetMapping("/{id}/details")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountAdminDetailsResponse> getAccountByIdDetails(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.getAccountAdminDetails(id));
    }

    @GetMapping("/{id}/users")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountTenantUserSummaryResponse>> listUsersByAccount(@PathVariable Long id) {
        log.info("Listando Usu√°rios por conta");
        return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, false));
    }

    @GetMapping("/{id}/users/active")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountTenantUserSummaryResponse>> listActiveUsersByAccount(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, true));
    }

    @PatchMapping("/{id}/status")
    @PreAuthorize("hasAnyAuthority('CP_TENANT_SUSPEND','CP_TENANT_ACTIVATE')")
    public ResponseEntity<AccountStatusChangeResponse> changeStatusAccount(
            @PathVariable Long id,
            @Valid @RequestBody AccountStatusChangeRequest accountStatusChangeRequest
    ) {
        return ResponseEntity.ok(accountLifecycleService.changeAccountStatus(id, accountStatusChangeRequest));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('CP_TENANT_DELETE')")
    public ResponseEntity<Void> softDeleteAccount(@PathVariable Long id) {
        accountLifecycleService.softDeleteAccount(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('CP_TENANT_ACTIVATE')")
    public ResponseEntity<Void> restoreAccount(@PathVariable Long id) {
        accountLifecycleService.restoreAccount(id);
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.controlplane.api.controller.auth;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.application.AdminAuthService;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/auth")
@RequiredArgsConstructor
public class AdminAuthController {

	private final AdminAuthService adminAuthService;

	@PostMapping("/login")
	public ResponseEntity<JwtResponse> loginControlPlaneUser(@Valid @RequestBody ControlPlaneAdminLoginRequest request) {

		JwtResponse response = adminAuthService.loginSuperAdmin(request);
		return ResponseEntity.ok(response);
	}
}
package brito.com.multitenancy001.controlplane.api.controller.billing;

import brito.com.multitenancy001.controlplane.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.application.billing.PaymentService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/admin/billing/payments")
@RequiredArgsConstructor
@Validated
public class ControlPlanePaymentController {

    private final PaymentService paymentService;

    // =========================================================
    // ADMIN / CROSS-TENANT
    // =========================================================

    @PostMapping("/by-account/{accountId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> processPaymentForAccount(
            @PathVariable Long accountId,
            @Valid @RequestBody AdminPaymentRequest body
    ) {
        // Garante que o accountId do path manda (evita inconsist√™ncia)
        AdminPaymentRequest adminPaymentRequest = new AdminPaymentRequest(
                accountId,
                body.amount(),
                body.paymentMethod(),
                body.paymentGateway(),
                body.description()
        );

        PaymentResponse response = paymentService.processPaymentForAccount(adminPaymentRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/by-account/{accountId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getPaymentsByAccountAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(paymentService.getPaymentsByAccount(accountId));
    }

    @GetMapping("/by-account/{accountId}/active")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<Boolean> hasActivePaymentAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(paymentService.hasActivePayment(accountId));
    }

    @PostMapping("/{paymentId}/complete-manual")
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> completeManually(@PathVariable Long paymentId) {
        return ResponseEntity.ok(paymentService.completePaymentManually(paymentId));
    }

    @PostMapping("/{paymentId}/refund")
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> refund(
            @PathVariable Long paymentId,
            @Valid @RequestBody RefundRequest refundRequest
    ) {
        PaymentResponse response =
                paymentService.refundPayment(paymentId, refundRequest.amount(), refundRequest.reason());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/revenue")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<BigDecimal> getRevenue(
            @RequestParam("start")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam("end")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate
    ) {
        return ResponseEntity.ok(paymentService.getTotalRevenue(startDate, endDate));
    }

    public record RefundRequest(
            @DecimalMin(value = "0.01", message = "amount deve ser > 0 quando informado")
            BigDecimal amount,

            @NotBlank(message = "reason √© obrigat√≥rio")
            String reason
    ) {}
}

package brito.com.multitenancy001.controlplane.api.controller.signup;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/signup")
@RequiredArgsConstructor
public class AccountSignupController {
    
    private final AccountLifecycleService accountLifecycleService;

    @PostMapping
    public ResponseEntity<AccountResponse> signup(
            @Valid @RequestBody SignupRequest request) {
        AccountResponse response = accountLifecycleService.createAccount( request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}package brito.com.multitenancy001.controlplane.api.controller.users;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.application.user.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/controlplane-users")
@RequiredArgsConstructor
public class ControlPlaneUserAdminController {

    private final ControlPlaneUserService controlPlaneUserService;

    @PostMapping
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> createControlPlaneUser(@Valid @RequestBody ControlPlaneUserCreateRequest request) {
        ControlPlaneUserDetailsResponse response = controlPlaneUserService.createControlPlaneUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listControlPlaneUsers() {
        return ResponseEntity.ok(controlPlaneUserService.listControlPlaneUsers());
    }

    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getControlPlaneUser(userId));
    }

    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUserStatus(
            @PathVariable Long userId,
            @RequestParam boolean active) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUserStatus(userId, active));
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_DELETE')")
    public ResponseEntity<Void> deleteControlPlaneUser(@PathVariable Long userId) {
        controlPlaneUserService.softDeleteControlPlaneUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> restoreControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.restoreControlPlaneUser(userId));
    }
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;
import java.time.LocalDateTime;

public record AccountAdminDetailsResponse(

    // Identifica√ß√£o
    Long id,
    String name,
    String slug,
    String schemaName,
    String status,

    // Dados legais (sempre em conjunto)
    DocumentType companyDocType,
    String companyDocNumber,

    // Datas
    LocalDateTime createdAt,
    LocalDateTime trialEndDate,
    LocalDateTime paymentDueDate,
    LocalDateTime deletedAt,

    // Flags calculadas
    boolean inTrial,
    boolean trialExpired,
    long trialDaysRemaining,

    // Admin da conta
    ControlPlaneAdminUserSummaryResponse admin,

    // Indicadores
    long totalControlPlaneUsers,
    boolean active
) {

   
}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import java.time.LocalDateTime;

public record AccountResponse(
	    Long id,
	    String name,
	    String slug,
	    String schemaName,
	    String status,
	    String accountType,
	    LocalDateTime createdAt,
	    LocalDateTime trialEndDate,
	    ControlPlaneAdminUserSummaryResponse platformAdmin
	) {}
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public record AccountStatusChangeRequest(
		@NotNull(message = "status √© obrigat√≥rio")
        AccountStatus status,
        @Size(max = 255, message = "reason deve ter no m√°ximo 255 caracteres")
        String reason
) {    }
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import java.time.LocalDateTime;

public record AccountStatusChangeResponse(
        Long id,
        String status,
        String previousStatus,
        LocalDateTime effectiveAt,
        String tenantSchema,
        SideEffects sideEffects
) {
    public record SideEffects(
            boolean tenantUsersUpdated,
            String action,     // "SUSPEND_BY_ACCOUNT" | "UNSUSPEND_BY_ACCOUNT" | "CANCELLED" | "NONE"
            int tenantUsersCount
    ) {}
}
package brito.com.multitenancy001.controlplane.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record ControlPlaneAdminLoginRequest(
	    @NotBlank String username,
	    @NotBlank String password
	) {}package brito.com.multitenancy001.controlplane.api.dto.billing;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record AdminPaymentRequest(

        @NotNull
        Long accountId,

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotBlank
        String paymentMethod,

        @NotBlank
        String paymentGateway,

        String description
) {}
package brito.com.multitenancy001.controlplane.api.dto.billing;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record PaymentRequest(

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotBlank
        String paymentMethod,

        @NotBlank
        String paymentGateway,

        String description
) {}
package brito.com.multitenancy001.controlplane.api.dto.billing;



import java.math.BigDecimal;
import java.time.LocalDateTime;

public record PaymentResponse(
	    Long id,
	    Long accountId,
	    BigDecimal amount,
	    LocalDateTime paymentDate,
	    LocalDateTime validUntil,
	    String status,
	    String transactionId,
	    String paymentMethod,
	    String paymentGateway,
	    String description,
	    LocalDateTime createdAt,
	    LocalDateTime updatedAt
	) {}
// src/main/java/brito/com/multitenancy001/dtos/SignupRequest.java
package brito.com.multitenancy001.controlplane.api.dto.signup;

import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record SignupRequest(

    @NotBlank(message = "Nome da empresa √© obrigat√≥rio")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    String name,

    @NotBlank(message = "Email da empresa √© obrigat√≥rio")
    @Email(message = "Email inv√°lido")
    String companyEmail,

    @NotNull(message = "Tipo de documento √© obrigat√≥rio (CPF ou CNPJ)")
    DocumentType companyDocType,

    @NotBlank(message = "N√∫mero do documento √© obrigat√≥rio")
    String companyDocNumber,

    @NotBlank(message = "Senha √© obrigat√≥ria")
    @Pattern(
        regexp = ValidationPatterns.PASSWORD_PATTERN,
        message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas e n√∫meros"
    )
    String password,

    @NotBlank(message = "Confirma√ß√£o de senha √© obrigat√≥ria")
    String confirmPassword
) 
	{
		   @AssertTrue(message = "As senhas n√£o coincidem")
		   public boolean isPasswordMatching() {
		      if (password == null || confirmPassword == null) return true; // deixa @NotBlank fazer o trabalho
		      return password.equals(confirmPassword);
		   }
}
package brito.com.multitenancy001.controlplane.api.dto.users;

public record ControlPlaneAdminUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {
   
}
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.List;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

@Builder
public record ControlPlaneUserCreateRequest(
    
    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String name,
    
    @NotBlank(message = "Username √© obrigat√≥rio")
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inv√°lido...")
    @Size(min = 3, max = 50, message = "Username deve ter entre 3 e 50 caracteres")
    String username,

 
    
    @NotBlank(message = "Email √© obrigat√≥rio")
    @Email(message = "Email inv√°lido")
    @Size(max = 150, message = "Email n√£o pode exceder 150 caracteres")
    String email,
    
    @NotBlank(message = "Senha √© obrigat√≥ria")
    @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, 
             message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas, n√∫meros e caracteres especiais")
    String password,
    
    @NotNull(message = "Role √© obrigat√≥ria")
    ControlPlaneRole role,

    
    List<String> permissions,
    

    @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, 
             message = "Telefone inv√°lido")
    @Size(max = 20, message = "Telefone n√£o pode exceder 20 caracteres")
    String phone,
    
    @Size(max = 500, message = "URL do avatar n√£o pode exceder 500 caracteres")
    String avatarUrl
    
) {
    
    public ControlPlaneUserCreateRequest {
        if (phone != null) {
            phone = phone.trim();
        }
        if (avatarUrl != null) {
            avatarUrl = avatarUrl.trim();
        }
    }
}package brito.com.multitenancy001.controlplane.api.dto.users;



import java.time.LocalDateTime;
import java.util.List;

public record ControlPlaneUserDetailsResponse(
    Long id,
    String username,
    String name,
    String email,
    String role,
    boolean suspendedByAccount,
    boolean suspendedByAdmin,
    LocalDateTime createdAt,
    LocalDateTime updatedAt,
    Long accountId,
    List<String> permissions
) {
    public ControlPlaneUserDetailsResponse {
        if (permissions == null) {
            permissions = List.of();
        }
    }
}package brito.com.multitenancy001.controlplane.api.dto.users.summary;

public record AccountTenantUserSummaryResponse(
        Long id,
        Long accountId,
        String name,
        String username,
        String email,
        String role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}
package brito.com.multitenancy001.controlplane.api.mapper;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.time.AppClock;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

@Component
public class AccountAdminDetailsApiMapper {

    private final AppClock appClock;
    private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;

    public AccountAdminDetailsApiMapper(AppClock appClock, ControlPlaneUserApiMapper controlPlaneUserApiMapper) {
        this.appClock = appClock;
        this.controlPlaneUserApiMapper = controlPlaneUserApiMapper;
    }

    public AccountAdminDetailsResponse toResponse(Account account, ControlPlaneUser admin, long totalUsers) {
        LocalDateTime now = appClock.now();
        LocalDate today = now.toLocalDate();
        LocalDate end = account.getTrialEndDate() != null ? account.getTrialEndDate().toLocalDate() : null;

        boolean inTrial = account.getTrialEndDate() != null && now.isBefore(account.getTrialEndDate());
        boolean trialExpired = account.getTrialEndDate() != null && now.isAfter(account.getTrialEndDate());

        long trialDaysRemaining = 0;
        if (inTrial && end != null) {
            trialDaysRemaining = ChronoUnit.DAYS.between(today, end);
        }

        return new AccountAdminDetailsResponse(
                account.getId(),
                account.getName(),
                account.getSlug(),
                account.getSchemaName(),
                account.getStatus().name(),

                account.getCompanyDocType(),
                account.getCompanyDocNumber(),

                account.getCreatedAt(),
                account.getTrialEndDate(),
                account.getPaymentDueDate(),
                account.getDeletedAt(),

                inTrial,
                trialExpired,
                trialDaysRemaining,

                admin != null ? controlPlaneUserApiMapper.toAdminSummary(admin) : null,

                totalUsers,
                account.isActive(now) // ‚úÖ agora clock-aware
        );
    }
}
package brito.com.multitenancy001.controlplane.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class AccountApiMapper {
	
	private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;
	
	

	public AccountResponse toResponse(Account account) {
	    return new AccountResponse(
	        account.getId(),
	        account.getName(),
	        account.getSlug(),
	        account.getSchemaName(),
	        account.getStatus().name(),
	        account.getType().name(),
	        account.getCreatedAt(),
	        account.getTrialEndDate(),
	        null
	    );
	}


   public AccountResponse toResponse(Account account, ControlPlaneUser adminUser) {
    ControlPlaneAdminUserSummaryResponse adminResponse =
            adminUser != null ? controlPlaneUserApiMapper.toAdminSummary(adminUser) : null;

    return new AccountResponse(
            account.getId(),
            account.getName(),
            account.getSlug(),
            account.getSchemaName(),
            account.getStatus().name(),
            account.getType().name(),
            account.getCreatedAt(),
            account.getTrialEndDate(),
            adminResponse
    );
}

}
package brito.com.multitenancy001.controlplane.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;

@Component
public class AccountUserApiMapper {

    public AccountTenantUserSummaryResponse toAccountUserSummary(UserSummaryData user) {

        boolean enabled =
                !user.deleted()
                && !user.suspendedByAccount()
                && !user.suspendedByAdmin();

        return new AccountTenantUserSummaryResponse(
                user.id(),
                user.accountId(),
                user.name(),
                user.username(),
                user.email(),
                user.role(),
                user.suspendedByAccount(),
                user.suspendedByAdmin(),
                enabled
        );
    }
}
package brito.com.multitenancy001.controlplane.api.mapper;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.time.AppClock;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
public class ControlPlaneUserApiMapper {

    private final AppClock appClock;

    public ControlPlaneUserApiMapper(AppClock appClock) {
        this.appClock = appClock;
    }

    public ControlPlaneAdminUserSummaryResponse toAdminSummary(ControlPlaneUser user) {
        LocalDateTime now = appClock.now();
        boolean enabled = user.isEnabledForLogin(now);

        return new ControlPlaneAdminUserSummaryResponse(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                enabled
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import brito.com.multitenancy001.controlplane.persistence.account.AccountEntitlementsRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsProvisioningService {

    private final AccountEntitlementsRepository entitlementsRepository;

    @Transactional(transactionManager = "publicTransactionManager")
    public void ensureDefaultEntitlementsForTenant(Account account) {
        if (account == null || account.getId() == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "Conta √© obrigat√≥ria", 400);
        }

        if (account.isSystemAccount()) {
            // SYSTEM n√£o tem entitlements
            return;
        }

        if (entitlementsRepository.existsById(account.getId())) {
            return;
        }

        AccountEntitlements ent = AccountEntitlements.builder()
                .account(account)
                .maxUsers(5)
                .maxProducts(100)
                .maxStorageMb(100)
                .build();

        entitlementsRepository.save(ent);
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.mapper.AccountAdminDetailsApiMapper;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.executor.PublicExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountLifecycleService {

	private final ControlPlaneUserRepository controlPlaneUserRepository;
	private final AccountAdminDetailsApiMapper accountAdminDetailsApiMapper;
	private final AccountApiMapper accountApiMapper;
	private final PublicExecutor publicExecutor;
	private final AccountRepository accountRepository;
	private final AccountOnboardingService accountOnboardingService;
	private final AccountStatusService accountStatusService;
	private final AccountTenantUserService accountTenantUserService;

	/*
	 * ========================================================= 1. ONBOARDING /
	 * SIGNUP =========================================================
	 */

	public AccountResponse createAccount(SignupRequest signupRequest) {
		return accountOnboardingService.createAccount(signupRequest);
	}

	/*
	 * ========================================================= 2. CONSULTAS
	 * (PUBLIC) =========================================================
	 */

	@Transactional(readOnly = true)
	public List<AccountResponse> listAllAccounts() {
		return publicExecutor.run(
				() -> accountRepository.findAllByDeletedFalse().stream().map(accountApiMapper::toResponse).toList());
	}

	@Transactional(readOnly = true)
	public AccountResponse getAccountById(Long accountId) {
		return publicExecutor.run(() -> {
			Account account = accountRepository.findByIdAndDeletedFalse(accountId)
					.orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));
			return accountApiMapper.toResponse(account);
		});
	}

	@Transactional(readOnly = true)
	public AccountAdminDetailsResponse getAccountAdminDetails(Long accountId) {
		return publicExecutor.run(() -> {
			Account account = accountRepository.findByIdAndDeletedFalse(accountId)
					.orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));

			long totalUsers = controlPlaneUserRepository.countByAccountIdAndDeletedFalse(accountId);

			return accountAdminDetailsApiMapper.toResponse(account, null, totalUsers);
		});
	}

	/*
	 * ========================================================= 3. STATUS / SOFT
	 * DELETE / RESTORE =========================================================
	 */

	public AccountStatusChangeResponse changeAccountStatus(Long accountId,
			AccountStatusChangeRequest accountStatusChangeRequest) {
		return accountStatusService.changeAccountStatus(accountId, accountStatusChangeRequest);
	}

	public void softDeleteAccount(Long accountId) {
		accountStatusService.softDeleteAccount(accountId);
	}

	public void restoreAccount(Long accountId) {
		accountStatusService.restoreAccount(accountId);
	}

	public List<AccountTenantUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyActive) {
		return accountTenantUserService.listTenantUsers(accountId, onlyActive);
	}

	public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
		accountTenantUserService.setUserSuspendedByAdmin(accountId, userId, suspended);
	}
}
package brito.com.multitenancy001.controlplane.application;

import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.executor.PublicExecutor;
import brito.com.multitenancy001.infrastructure.executor.TxExecutor;
import brito.com.multitenancy001.infrastructure.tenant.TenantProvisioningBridge;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserAdminBridge;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountOnboardingService {

    private final AccountApiMapper accountApiMapper;
    private final PublicExecutor publicExecutor;
    private final TxExecutor txExecutor;
    private final PublicAccountService publicAccountService;
    private final TenantProvisioningBridge tenantProvisioningBridge;
    private final TenantUserAdminBridge tenantUserAdminBridge;
    private final AccountRepository accountRepository;

    public AccountResponse createAccount(SignupRequest signupRequest) {
        validateSignupRequest(signupRequest);

        log.info("Tentando criar conta");

        Account account = txExecutor.publicTx(() ->
            publicExecutor.run(() -> publicAccountService.createAccountFromSignup(signupRequest))
        );

        tenantProvisioningBridge.ensureSchemaExistsAndMigrate(account.getSchemaName());

        tenantUserAdminBridge.createTenantOwner(
            account.getSchemaName(),
            account.getId(),
            signupRequest.companyEmail(),
            signupRequest.password()
        );

        log.info("‚úÖ Account criada | accountId={} | schema={} | slug={}",
                account.getId(), account.getSchemaName(), account.getSlug());

        return accountApiMapper.toResponse(account);
    }

    private void validateSignupRequest(SignupRequest signupRequest) {
        if (!StringUtils.hasText(signupRequest.name())) {
            throw new ApiException("INVALID_COMPANY_NAME", "Nome da empresa √© obrigat√≥rio", 400);
        }

        if (!StringUtils.hasText(signupRequest.companyEmail())) {
            throw new ApiException("INVALID_EMAIL", "Email √© obrigat√≥rio", 400);
        }

        if (!signupRequest.companyEmail().contains("@")) {
            throw new ApiException("INVALID_EMAIL", "Email inv√°lido", 400);
        }

        if (signupRequest.companyDocType() == null) {
            throw new ApiException("INVALID_COMPANY_DOC_TYPE", "Tipo de documento √© obrigat√≥rio", 400);
        }

        if (!StringUtils.hasText(signupRequest.companyDocNumber())) {
            throw new ApiException("INVALID_COMPANY_DOC_NUMBER", "N√∫mero do documento √© obrigat√≥rio", 400);
        }

        if (!StringUtils.hasText(signupRequest.password()) || !StringUtils.hasText(signupRequest.confirmPassword())) {
            throw new ApiException("INVALID_PASSWORD", "Senha e confirma√ß√£o s√£o obrigat√≥rias", 400);
        }

        if (!signupRequest.password().equals(signupRequest.confirmPassword())) {
            throw new ApiException("PASSWORD_MISMATCH", "As senhas n√£o coincidem", 400);
        }

        if (accountRepository.existsByCompanyEmailAndDeletedFalse(signupRequest.companyEmail())) {
            throw new ApiException("EMAIL_ALREADY_REGISTERED", "Email j√° cadastrado na plataforma", 409);
        }

        if (accountRepository.existsByCompanyDocTypeAndCompanyDocNumberAndDeletedFalse(
                signupRequest.companyDocType(), signupRequest.companyDocNumber()
        )) {
            throw new ApiException("DOC_ALREADY_REGISTERED", "Documento j√° cadastrado na plataforma", 409);
        }
    }
}
package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.executor.PublicExecutor;
import brito.com.multitenancy001.infrastructure.executor.TxExecutor;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserAdminBridge;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountStatusService {

    private final PublicExecutor publicExecutor;
    private final TxExecutor txExecutor;
    private final AccountRepository accountRepository;
    private final TenantUserAdminBridge tenantUserAdminBridge;
    private final AppClock appClock;

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        return txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = accountRepository.findById(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));

            AccountStatus previous = account.getStatus();

            account.setStatus(req.status());
            if (req.status() == AccountStatus.ACTIVE) {
                account.setDeletedAt(null);
            }
            accountRepository.save(account);

            int affected = 0;
            boolean applied = false;
            String action = "NONE";

            if (req.status() == AccountStatus.SUSPENDED) {
                affected = suspendTenantUsersByAccount(account);
                applied = true;
                action = "SUSPEND_BY_ACCOUNT";
            } else if (req.status() == AccountStatus.ACTIVE) {
                affected = unsuspendTenantUsersByAccount(account);
                applied = true;
                action = "UNSUSPEND_BY_ACCOUNT";
            } else if (req.status() == AccountStatus.CANCELLED) {
                affected = cancelAccount(account);
                applied = true;
                action = "CANCELLED";
            }

            return buildStatusChangeResponse(account, previous, applied, action, affected);
        }));
    }

    protected int suspendTenantUsersByAccount(Account account) {
        return tenantUserAdminBridge.suspendAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    protected int unsuspendTenantUsersByAccount(Account account) {
        return tenantUserAdminBridge.unsuspendAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    private int cancelAccount(Account account) {
        txExecutor.publicRequiresNew(() -> publicExecutor.run(() -> {
            account.setDeletedAt(appClock.now());
            accountRepository.save(account);
            return null;
        }));

        return tenantUserAdminBridge.softDeleteAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    private void softDeleteTenantUsers(Long accountId) {
        Account account = txExecutor.publicReadOnlyTx(() ->
                publicExecutor.run(() -> getAccountByIdRaw(accountId))
        );
        tenantUserAdminBridge.softDeleteAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    private void restoreTenantUsers(Long accountId) {
        Account account = txExecutor.publicReadOnlyTx(() ->
                publicExecutor.run(() -> getAccountByIdRaw(accountId))
        );
        tenantUserAdminBridge.restoreAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    public void softDeleteAccount(Long accountId) {
        txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isSystemAccount()) {
                throw new ApiException("SYSTEM_ACCOUNT_PROTECTED",
                        "N√£o √© permitido excluir contas do sistema", 403);
            }

            account.softDelete(appClock.now());
            accountRepository.save(account);

            softDeleteTenantUsers(accountId);

            return null;
        }));
    }

    public void restoreAccount(Long accountId) {
        txExecutor.publicTx(() -> publicExecutor.run(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isSystemAccount() && account.isDeleted()) {
                throw new ApiException("SYSTEM_ACCOUNT_PROTECTED",
                        "Contas do sistema n√£o podem ser restauradas via este endpoint", 403);
            }

            account.restore();
            accountRepository.save(account);

            restoreTenantUsers(accountId);

            return null;
        }));
    }

    private Account getAccountByIdRaw(Long accountId) {
        return accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));
    }

    private AccountStatusChangeResponse buildStatusChangeResponse(
            Account account,
            AccountStatus previous,
            boolean tenantUsersUpdated,
            String action,
            int count
    ) {
        return new AccountStatusChangeResponse(
                account.getId(),
                account.getStatus().name(),
                previous.name(),
                appClock.now(),
                account.getSchemaName(),
                new AccountStatusChangeResponse.SideEffects(tenantUsersUpdated, action, count)
        );
    }
}
package brito.com.multitenancy001.controlplane.application;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.mapper.AccountUserApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.executor.PublicExecutor;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserAdminBridge;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountTenantUserService {

    private final PublicExecutor publicExecutor;
    private final AccountRepository accountRepository;
    private final TenantUserAdminBridge tenantUserAdminBridge;
    private final AccountUserApiMapper accountUserApiMapper;

    public List<AccountTenantUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyActive) {

        Account account = publicExecutor.run(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404))
        );

        List<UserSummaryData> data = tenantUserAdminBridge
                .listUserSummaries(account.getSchemaName(), account.getId(), onlyActive);

        return data.stream()
                .map(accountUserApiMapper::toAccountUserSummary)
                .toList();
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {

        Account account = publicExecutor.run(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404))
        );

        tenantUserAdminBridge.setSuspendedByAdmin(account.getSchemaName(), account.getId(), userId, suspended);
    }
}
package brito.com.multitenancy001.controlplane.application;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AdminAuthService {

    private static final String DEFAULT_SCHEMA = "public";
	private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final ControlPlaneUserRepository controlPlaneUserRepository;

    public JwtResponse loginSuperAdmin(ControlPlaneAdminLoginRequest controlPlaneAdminLoginRequest) {


        TenantContext.clear();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByUsernameAndDeletedFalse(controlPlaneAdminLoginRequest.username())
                .orElseThrow(() -> new ApiException(
                        "USER_NOT_FOUND",
                        "Super admin n√£o encontrado",
                        404
                ));

        // üîí Regras de neg√≥cio
        if (user.isSuspendedByAccount() ) {
            throw new ApiException(
                    "ACCESS_DENIED",
                    "Usu√°rio n√£o autorizado",
                    403
            );
        }

        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        controlPlaneAdminLoginRequest.username(),
                        controlPlaneAdminLoginRequest.password()
                )
        );

        String accessToken = jwtTokenProvider.generateControlPlaneToken(
                authentication,
                user.getAccount().getId(),
                DEFAULT_SCHEMA
        );

        String refreshToken = jwtTokenProvider.generateRefreshToken(
                user.getUsername(),
                DEFAULT_SCHEMA
        );

        return new JwtResponse(
                accessToken,
                refreshToken,
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getRole().name(),
                user.getAccount().getId(),
                DEFAULT_SCHEMA
        );
    }
}
package brito.com.multitenancy001.controlplane.application.billing;

import brito.com.multitenancy001.controlplane.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.billing.PaymentRepository;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentService {

    private final AccountRepository accountRepository;
    private final PaymentRepository paymentRepository;
    private final SecurityUtils securityUtils;
    private final AppClock appClock;

    @Scheduled(cron = "${app.payment.check-cron:0 0 0 * * *}")
    public void checkPayments() {
        log.info("Iniciando verifica√ß√£o de pagamentos...");
        LocalDateTime now = appClock.now();

        List<Account> expiredTrials = accountRepository.findByStatus(AccountStatus.FREE_TRIAL).stream()
                .filter(account -> account.getTrialEndDate() != null && account.getTrialEndDate().isBefore(now))
                .collect(Collectors.toList());

        for (Account account : expiredTrials) {
            suspendAccount(account, "Trial expirado");
        }

        List<Account> overdueAccounts = accountRepository.findByPaymentDueDateBefore(now);

        for (Account account : overdueAccounts) {
            if (account.getStatus() == AccountStatus.ACTIVE) {
                suspendAccount(account, "Pagamento atrasado");
            }
        }

        checkExpiredPendingPayments(now);
    }

    private void suspendAccount(Account account, String reason) {
        account.setStatus(AccountStatus.SUSPENDED);
        accountRepository.save(account);
        sendSuspensionEmail(account, reason);
    }

    private void checkExpiredPendingPayments(LocalDateTime now) {
        LocalDateTime thirtyMinutesAgo = now.minusMinutes(30);

        List<Payment> expiredPayments = paymentRepository.findByStatusAndCreatedAtBefore(
                PaymentStatus.PENDING, thirtyMinutesAgo
        );

        for (Payment payment : expiredPayments) {
            payment.setStatus(PaymentStatus.EXPIRED);
            paymentRepository.save(payment);
        }
    }

    @Transactional
    public PaymentResponse processPaymentForAccount(AdminPaymentRequest adminPaymentRequest) {

        if (adminPaymentRequest.accountId() == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "accountId √© obrigat√≥rio", 400);
        }

        Account account = accountRepository.findById(adminPaymentRequest.accountId())
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));

        LocalDateTime now = appClock.now();
        validatePayment(account, adminPaymentRequest.amount(), now);

        Payment payment = Payment.builder()
                .account(account)
                .amount(adminPaymentRequest.amount())
                .paymentMethod(adminPaymentRequest.paymentMethod())
                .paymentGateway(adminPaymentRequest.paymentGateway())
                .description(adminPaymentRequest.description())
                .status(PaymentStatus.PENDING)
                .paymentDate(now)
                .build();

        payment = paymentRepository.save(payment);

        boolean ok = processWithPaymentGateway(
                payment,
                new PaymentRequest(
                        adminPaymentRequest.amount(),
                        adminPaymentRequest.paymentMethod(),
                        adminPaymentRequest.paymentGateway(),
                        adminPaymentRequest.description()
                )
        );

        if (ok) {
            completePayment(payment, account, now);
            return mapToResponse(payment);
        }

        failPayment(payment, "Falha no processamento do pagamento");
        throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
    }

    @Transactional
    public PaymentResponse processPaymentForMyAccount(PaymentRequest paymentRequest) {
        Long accountId = securityUtils.getCurrentAccountId();
        Account account = findAccountOrThrow(accountId);

        LocalDateTime now = appClock.now();
        validatePayment(account, paymentRequest.amount(), now);

        Payment payment = Payment.builder()
                .account(account)
                .amount(paymentRequest.amount())
                .paymentMethod(paymentRequest.paymentMethod())
                .paymentGateway(paymentRequest.paymentGateway())
                .description(paymentRequest.description())
                .status(PaymentStatus.PENDING)
                .paymentDate(now)
                .build();

        payment = paymentRepository.save(payment);

        boolean ok = processWithPaymentGateway(payment, paymentRequest);

        if (ok) {
            completePayment(payment, account, now);
            return mapToResponse(payment);
        }

        failPayment(payment, "Falha no processamento do pagamento");
        throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentByIdForMyAccount(Long paymentId) {
        Long accountId = securityUtils.getCurrentAccountId();

        Payment payment = paymentRepository.findByIdAndAccountId(paymentId, accountId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento n√£o encontrado", 404));

        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByMyAccount() {
        Long accountId = securityUtils.getCurrentAccountId();
        return getPaymentsByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public boolean hasActivePaymentMyAccount() {
        Long accountId = securityUtils.getCurrentAccountId();
        return hasActivePayment(accountId);
    }

    @Transactional(readOnly = true)
    public List<PaymentResponse> getPaymentsByAccount(Long accountId) {
        return paymentRepository.findByAccountId(accountId).stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public boolean hasActivePayment(Long accountId) {
        return paymentRepository.findActivePayment(accountId, appClock.now()).isPresent();
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentById(Long paymentId) {
        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento n√£o encontrado", 404));
        return mapToResponse(payment);
    }

    @Transactional
    public PaymentResponse completePaymentManually(Long paymentId) {

        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento n√£o encontrado", 404));

        if (payment.getStatus() != PaymentStatus.PENDING) {
            throw new ApiException("INVALID_PAYMENT_STATUS", "Pagamento n√£o est√° pendente", 409);
        }

        LocalDateTime now = appClock.now();
        completePayment(payment, payment.getAccount(), now);
        return mapToResponse(payment);
    }

    @Transactional
    public PaymentResponse refundPayment(Long paymentId, BigDecimal amount, String reason) {

        Payment payment = paymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento n√£o encontrado", 404));

        LocalDateTime now = appClock.now();

        if (!payment.canBeRefunded(now)) {
            throw new ApiException("PAYMENT_NOT_REFUNDABLE", "Pagamento n√£o pode ser reembolsado", 409);
        }

        if (amount == null) {
            payment.refundFully(now, reason);
        } else {
            payment.refundPartially(now, amount, reason);
        }

        paymentRepository.save(payment);
        return mapToResponse(payment);
    }

    @Transactional(readOnly = true)
    public BigDecimal getTotalRevenue(LocalDateTime startDate, LocalDateTime endDate) {
        List<Object[]> revenueByAccount = paymentRepository.getRevenueByAccount(startDate, endDate);

        return revenueByAccount.stream()
                .map(obj -> (BigDecimal) obj[1])
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /*
     * ========================================================= PRIVATE HELPERS
     * =========================================================
     */

    private Account findAccountOrThrow(Long accountId) {
        return accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));
    }

    private void completePayment(Payment payment, Account account, LocalDateTime now) {
        payment.markAsCompleted(now);
        paymentRepository.save(payment);

        account.setStatus(AccountStatus.ACTIVE);
        account.setPaymentDueDate(calculateNextDueDate(payment.getValidUntil(), now));
        accountRepository.save(account);

        sendPaymentConfirmationEmail(account, payment);
    }

    private void failPayment(Payment payment, String reason) {
        payment.markAsFailed(reason);
        paymentRepository.save(payment);
    }

    private void validatePayment(Account account, BigDecimal amount, LocalDateTime now) {

        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new ApiException("INVALID_AMOUNT", "Valor do pagamento inv√°lido", 400);
        }

        if (account.isDeleted()) {
            throw new ApiException("ACCOUNT_DELETED", "Conta deletada", 410);
        }

        Optional<Payment> activePayment = paymentRepository.findActivePayment(account.getId(), now);

        if (activePayment.isPresent()) {
            throw new ApiException("PAYMENT_ALREADY_EXISTS", "J√° existe um pagamento ativo para esta conta", 409);
        }
    }

    private PaymentResponse mapToResponse(Payment payment) {
        return new PaymentResponse(
                payment.getId(),
                payment.getAccount().getId(),
                payment.getAmount(),
                payment.getPaymentDate(),
                payment.getValidUntil(),
                payment.getStatus().name(),
                payment.getTransactionId(),
                payment.getPaymentMethod(),
                payment.getPaymentGateway(),
                payment.getDescription(),
                payment.getCreatedAt(),
                payment.getUpdatedAt()
        );
    }

    private void sendSuspensionEmail(Account account, String reason) {
        log.info("Enviando email de suspens√£o para: {}", account.getCompanyEmail());
    }

    private void sendPaymentConfirmationEmail(Account account, Payment payment) {
        log.info("Enviando confirma√ß√£o de pagamento para: {}", account.getCompanyEmail());
    }

    private LocalDateTime calculateNextDueDate(LocalDateTime validUntil, LocalDateTime now) {
        return validUntil != null ? validUntil : now.plusMonths(1);
    }

    private boolean processWithPaymentGateway(Payment payment, PaymentRequest paymentRequest) {

        log.info("Processando pagamento com gateway: {}", paymentRequest.paymentGateway());

        try {
            Thread.sleep(1000);
            return Math.random() < 0.9;

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Erro ao processar pagamento no gateway", e);
            return false;
        }
    }
}
package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.AccountType;
import brito.com.multitenancy001.controlplane.persistence.account.AccountEntitlementsRepository;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "publicTransactionManager")
public class PublicAccountService {

	private final AccountRepository accountRepository;
	private final AccountEntitlementsRepository entitlementsRepository;
	private final AppClock appClock;

	public Account createAccountFromSignup(SignupRequest signupRequest) {
		TenantContext.clear();

		int maxAttempts = 5;
		for (int attempt = 1; attempt <= maxAttempts; attempt++) {
			String slug = generateSlug(signupRequest.name());
			String schemaName = generateSchemaName(signupRequest.name());

			try {
				LocalDateTime now = appClock.now();

				Account account = new Account();
				account.setType(AccountType.TENANT);
				account.setName(signupRequest.name());
				account.setSlug(slug);
				account.setSchemaName(schemaName);

				account.setCompanyEmail(signupRequest.companyEmail());
				account.setCompanyDocType(signupRequest.companyDocType());
				account.setCompanyDocNumber(signupRequest.companyDocNumber());

				account.setTrialEndDate(now.plusDays(30));
				account.setStatus(AccountStatus.FREE_TRIAL);

				account.setSubscriptionPlan("FREE");
				account.setCompanyCountry("Brasil");
				account.setTimezone("America/Sao_Paulo");
				account.setLocale("pt_BR");
				account.setCurrency("BRL");

				Account saved = accountRepository.save(account);

				// ‚úÖ Entitlements s√≥ para TENANT
				AccountEntitlements ent = AccountEntitlements.builder().account(saved).maxUsers(5).maxProducts(100)
						.maxStorageMb(100).build();

				entitlementsRepository.save(ent);

				return saved;

			} catch (DataIntegrityViolationException e) {
				if (!isSlugOrSchemaUniqueViolation(e))
					throw e;
				log.warn("‚ö†Ô∏è Colis√£o (tentativa {}/{}) | slug={} | schema={}", attempt, maxAttempts, slug, schemaName);
			}
		}

		throw new ApiException("ACCOUNT_CREATE_FAILED",
				"N√£o foi poss√≠vel criar conta (colis√£o de identificadores). Tente novamente.", 409);
	}

	private String generateSlug(String name) {
		String base = (name == null ? "conta" : name.toLowerCase()).replaceAll("[^a-z0-9]+", "-").replaceAll("(^-|-$)",
				"");

		String slug = base;
		int i = 1;

		while (accountRepository.findBySlugAndDeletedFalse(slug).isPresent()) {
			slug = base + "-" + (i++);
		}
		return slug;
	}

	private String generateSchemaName(String name) {
		String base = (name == null ? "tenant" : name.toLowerCase()).replaceAll("[^a-z0-9]", "_");
		return "tenant_" + base + "_" + UUID.randomUUID().toString().substring(0, 8);
	}

	private boolean isSlugOrSchemaUniqueViolation(Throwable e) {
		Throwable t = e;
		while (t.getCause() != null)
			t = t.getCause();
		String msg = (t.getMessage() == null) ? "" : t.getMessage().toLowerCase();

		return msg.contains("ux_accounts_slug_active") || msg.contains("uk_accounts_slug")
				|| msg.contains("uk_accounts_schema_name") || msg.contains("accounts_slug_key")
				|| msg.contains("accounts_schema_name_key") || msg.contains("company_email");
	}
}
package brito.com.multitenancy001.controlplane.application.user;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.List;

@Service
@Transactional
@RequiredArgsConstructor
public class ControlPlaneUserService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final AccountRepository accountRepository;
    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;

    private Account getControlPlaneAccount() {
        TenantContext.clear(); // PUBLIC
        return accountRepository.findBySlugAndDeletedFalse("controlplane")
                .orElseThrow(() -> new ApiException(
                        "CONTROLPLANE_ACCOUNT_NOT_FOUND",
                        "Conta controlplane n√£o encontrada. Rode a migration V3__insert_controlplane_account.sql",
                        500
                ));
    }

    public ControlPlaneUserDetailsResponse createControlPlaneUser(ControlPlaneUserCreateRequest req) {
        TenantContext.clear();

        Account controlPlaneAccount = getControlPlaneAccount();

        if (req.username() == null || req.username().isBlank()) {
            throw new ApiException("INVALID_USERNAME", "Username √© obrigat√≥rio", 400);
        }
        if (!req.username().matches(ValidationPatterns.USERNAME_PATTERN)) {
            throw new ApiException("INVALID_USERNAME", "Username inv√°lido", 400);
        }

        String username = req.username().toLowerCase().trim();

        // ‚úÖ role j√° tipada
        ControlPlaneRole roleEnum = req.role();

        if (controlPlaneUserRepository.existsByUsernameAndAccountId(username, controlPlaneAccount.getId())) {
            throw new ApiException("USERNAME_ALREADY_EXISTS", "Username j√° existe", 409);
        }
        if (controlPlaneUserRepository.existsByEmailAndAccountId(req.email(), controlPlaneAccount.getId())) {
            throw new ApiException("EMAIL_ALREADY_EXISTS", "Email j√° existe", 409);
        }

        LinkedHashSet<String> normalizedPermissions;
        try {
            normalizedPermissions = PermissionScopeValidator.normalizeControlPlane(req.permissions());
        } catch (IllegalArgumentException e) {
            throw new ApiException("INVALID_PERMISSION", e.getMessage(), 400);
        }

        ControlPlaneUser user = ControlPlaneUser.builder()
                .name(req.name())
                .username(username)
                .email(req.email())
                .password(passwordEncoder.encode(req.password()))
                .role(roleEnum)
                .account(controlPlaneAccount)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .permissions(normalizedPermissions)
                .build();

        return mapToResponse(controlPlaneUserRepository.save(user));
    }

    @Transactional(readOnly = true)
    public List<ControlPlaneUserDetailsResponse> listControlPlaneUsers() {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();
        return controlPlaneUserRepository.findByAccountId(controlPlaneAccount.getId()).stream()
                .filter(u -> !u.isDeleted())
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    public ControlPlaneUserDetailsResponse getControlPlaneUser(Long userId) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404);
        }

        return mapToResponse(user);
    }

    public ControlPlaneUserDetailsResponse updateControlPlaneUserStatus(Long userId, boolean active) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_DELETED", "Usu√°rio est√° removido", 409);
        }

        // ‚úÖ a√ß√£o manual do admin da plataforma
        user.setSuspendedByAdmin(!active);

        return mapToResponse(controlPlaneUserRepository.save(user));
    }

    public void softDeleteControlPlaneUser(Long userId) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404));

        if (user.isDeleted()) {
            throw new ApiException("USER_ALREADY_DELETED", "Usu√°rio j√° removido", 409);
        }

        LocalDateTime now = appClock.now();
        long suffix = appClock.epochMillis();

        user.softDelete(now, suffix);
        controlPlaneUserRepository.save(user);
    }

    public ControlPlaneUserDetailsResponse restoreControlPlaneUser(Long userId) {
        TenantContext.clear();
        Account controlPlaneAccount = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findByIdAndAccountId(userId, controlPlaneAccount.getId())
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio de plataforma n√£o encontrado", 404));

        if (!user.isDeleted()) {
            throw new ApiException("USER_NOT_DELETED", "Usu√°rio n√£o est√° removido", 409);
        }

        user.restore();
        return mapToResponse(controlPlaneUserRepository.save(user));
    }

    private ControlPlaneUserDetailsResponse mapToResponse(ControlPlaneUser user) {
        return new ControlPlaneUserDetailsResponse(
                user.getId(),
                user.getUsername(),
                user.getName(),
                user.getEmail(),
                user.getRole().name(),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.getCreatedAt(),
                user.getUpdatedAt(),
                user.getAccount().getId(),
                user.getPermissions() == null
                        ? List.of()
                        : user.getPermissions().stream().sorted().toList()
        );
    }
}
package brito.com.multitenancy001.controlplane.domain.account;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.UUID;
import java.util.ArrayList;


@Entity
@Table(name = "accounts")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Account {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_type", nullable = false, length = 20)
    @Builder.Default
    private AccountType type = AccountType.TENANT;

    @Column(nullable = false, length = 150)
    private String name;

    @Column(name = "schema_name", nullable = false, unique = true, length = 100)
    private String schemaName;

    @Column(name = "slug", nullable = false, unique = true, length = 50)
    private String slug;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    @Builder.Default
    private AccountStatus status = AccountStatus.FREE_TRIAL;

    // Auditoria (t√©cnico)
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // Datas de neg√≥cio
    @Column(name = "trial_end_date")
    private LocalDateTime trialEndDate;

    @Column(name = "payment_due_date")
    private LocalDateTime paymentDueDate;

    @Column(name = "next_billing_date")
    private LocalDateTime nextBillingDate;

    @Column(name = "subscription_plan", nullable = false, length = 50)
    @Builder.Default
    private String subscriptionPlan = "FREE";

    // Identidade empresa
    @Column(name = "company_email", nullable = false, length = 150)
    private String companyEmail;

    @Enumerated(EnumType.STRING)
    @Column(name = "company_doc_type", nullable = false, length = 10)
    private DocumentType companyDocType;

    @Column(name = "company_doc_number", nullable = false, length = 20)
    private String companyDocNumber;
    
    @Column(name = "company_phone", length = 20)
    private String companyPhone;

    @Column(name = "company_address", length = 500)
    private String companyAddress;

    @Column(name = "company_city", length = 100)
    private String companyCity;

    @Column(name = "company_state", length = 50)
    private String companyState; 
    

    // Localiza√ß√£o
    @Column(name = "company_country", length = 50, nullable = false)
    @Builder.Default
    private String companyCountry = "Brasil";
    
    
    @Column(name = "timezone", length = 50, nullable = false)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", length = 10, nullable = false)
    @Builder.Default
    private String locale = "pt_BR";
    

    @Column(name = "currency", length = 3, nullable = false)
    @Builder.Default
    private String currency = "BRL";
    
    @OneToMany(mappedBy = "account", fetch = FetchType.LAZY,
            cascade = { CascadeType.PERSIST, CascadeType.MERGE })
    @Builder.Default
    @ToString.Exclude
    private List<ControlPlaneUser> controlPlaneUsers = new ArrayList<>();
    
    
    @Column(name = "settings_json", columnDefinition = "TEXT")
    private String settingsJson;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;


    // Soft delete
    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    @PrePersist
    protected void onCreate() {
        // ‚úÖ aqui N√ÉO usar tempo
        // slug
        if (this.slug == null || this.slug.isBlank()) {
            this.slug = (this.name == null ? "conta" : this.name)
                    .toLowerCase()
                    .replaceAll("[^a-z0-9]+", "-")
                    .replaceAll("(^-|-$)", "");
        }

        // schemaName
        if (this.schemaName == null || this.schemaName.isBlank()) {
            this.schemaName =
                    "tenant_" +
                    this.slug.replace("-", "_") +
                    "_" +
                    UUID.randomUUID().toString().substring(0, 8);
        }
    }
    
    
    
    
    

    // =========================
    // Sem√¢ntica / helpers
    // =========================

    public boolean isTenantAccount() {
        return type == AccountType.TENANT;
    }

    public boolean isSystemAccount() {
        return type == AccountType.SYSTEM;
    }

    public boolean isDeleted() {
        return deleted || deletedAt != null;
    }

    public boolean isTrialActive(LocalDateTime now) {
        return this.status == AccountStatus.FREE_TRIAL
                && this.trialEndDate != null
                && now != null
                && this.trialEndDate.isAfter(now);
    }

    public boolean isActive(LocalDateTime now) {
        if (isDeleted()) return false;
        // SYSTEM sempre ativa (a menos que voc√™ queira permitir suspens√£o do system)
        if (isSystemAccount()) return true;

        return this.status == AccountStatus.ACTIVE
                || (this.status == AccountStatus.FREE_TRIAL && isTrialActive(now));
    }

    public boolean isPaymentOverdue(LocalDateTime now) {
        return this.paymentDueDate != null
                && now != null
                && this.paymentDueDate.isBefore(now);
    }

    public long getDaysRemainingInTrial(LocalDateTime now) {
        if (now == null) return 0;
        if (!isTrialActive(now)) return 0;
        return ChronoUnit.DAYS.between(now.toLocalDate(), this.trialEndDate.toLocalDate());
    }

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.status = AccountStatus.CANCELLED;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;

        // para TENANT restaurado: volta ACTIVE (padr√£o seu)
        // para SYSTEM: continua ACTIVE
        this.status = AccountStatus.ACTIVE;
    }
}
package brito.com.multitenancy001.controlplane.domain.account;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "account_entitlements")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AccountEntitlements {

    @Id
    @Column(name = "account_id")
    private Long accountId;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id")
    private Account account;

    @Column(name = "max_users", nullable = false)
    private Integer maxUsers;

    @Column(name = "max_products", nullable = false)
    private Integer maxProducts;

    @Column(name = "max_storage_mb", nullable = false)
    private Integer maxStorageMb;
}
package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountStatus {
    FREE_TRIAL("Trial Gratuito"),
    ACTIVE("Ativa"),
    SUSPENDED("Suspensa"),
    CANCELLED("Cancelada"),
    EXPIRED("Expirada");
    
    private final String description;
    
    AccountStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * Verifica se o status permite opera√ß√µes
     */
    public boolean isOperational() {
        return this == FREE_TRIAL || this == ACTIVE;
    }
    
    /**
     * Verifica se o status est√° em trial
     */
    public boolean isTrial() {
        return this == FREE_TRIAL;
    }
    
    /**
     * Verifica se o status est√° ativo
     */
    public boolean isActive() {
        return this == ACTIVE;
    }
    
    /**
     * Verifica se o status est√° suspenso
     */
    public boolean isSuspended() {
        return this == SUSPENDED;
    }
    
    /**
     * Verifica se o status est√° cancelado
     */
    public boolean isCancelled() {
        return this == CANCELLED || this == EXPIRED;
    }
}package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountType {
    TENANT,
    SYSTEM
}
package brito.com.multitenancy001.controlplane.domain.account;

import lombok.Getter;

@Getter
public enum DocumentType {
    CPF,
    CNPJ;

   
    }
package brito.com.multitenancy001.controlplane.domain.billing;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "payments", indexes = {
    @Index(name = "idx_payment_account", columnList = "account_id"),
    @Index(name = "idx_payment_status", columnList = "status"),
    @Index(name = "idx_payment_date", columnList = "payment_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    // ‚úÖ NEG√ìCIO
    @Column(name = "payment_date", nullable = false)
    private LocalDateTime paymentDate;

    // ‚úÖ NEG√ìCIO
    @Column(name = "valid_until")
    private LocalDateTime validUntil;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private PaymentStatus status = PaymentStatus.PENDING;

    @Column(name = "transaction_id", unique = true, length = 100)
    private String transactionId;

    @Column(name = "payment_method", length = 50)
    private String paymentMethod;

    @Column(name = "payment_gateway", length = 50)
    private String paymentGateway;

    @Column(name = "currency", length = 3, nullable = false)
    @Builder.Default
    private String currency = "BRL";

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    @Column(name = "invoice_url", columnDefinition = "TEXT")
    private String invoiceUrl;

    @Column(name = "receipt_url", columnDefinition = "TEXT")
    private String receiptUrl;

    // ‚úÖ AUDITORIA (t√©cnico)
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // ‚úÖ NEG√ìCIO
    @Column(name = "refunded_at")
    private LocalDateTime refundedAt;

    @Column(name = "refund_amount", precision = 10, scale = 2)
    private BigDecimal refundAmount;

    @Column(name = "refund_reason", length = 500)
    private String refundReason;

    @PrePersist
    protected void onCreate() {
        if (this.transactionId == null) {
            this.transactionId = "PAY_" + UUID.randomUUID().toString()
                    .replace("-", "")
                    .substring(0, 16)
                    .toUpperCase();
        }

        // ‚ö†Ô∏è N√ÉO setar tempo aqui. paymentDate deve vir do service com Clock.
        if (this.paymentDate == null) {
            throw new IllegalStateException("paymentDate deve ser definido pela aplica√ß√£o (Clock/AppClock).");
        }

        // Se j√° est√° completed e n√£o veio validUntil, calcula baseado no paymentDate (determin√≠stico)
        if (this.status == PaymentStatus.COMPLETED && this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    private LocalDateTime calculateDefaultValidUntil(LocalDateTime baseDate) {
        return baseDate.plusDays(30);
    }

    // ---------------------------
    // Transi√ß√µes de estado (dom√≠nio)
    // ---------------------------

    /** Use quando o pagamento √© marcado como conclu√≠do no "agora" do app. */
    public void markAsCompleted(LocalDateTime now) {
        this.status = PaymentStatus.COMPLETED;

        // Se paymentDate ainda n√£o foi setado, seta com o "agora" vindo de fora (Clock/AppClock)
        if (this.paymentDate == null) {
            this.paymentDate = now;
        }

        if (this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    /** Mantido por compatibilidade: exige que paymentDate j√° tenha sido definido externamente. */
    public void markAsCompleted() {
        this.status = PaymentStatus.COMPLETED;
        if (this.paymentDate == null) {
            throw new IllegalStateException("paymentDate deve ser definido antes de marcar como COMPLETED.");
        }
        if (this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    public void markAsFailed(String reason) {
        this.status = PaymentStatus.FAILED;
        if (this.metadataJson == null) {
            this.metadataJson = "{\"failure_reason\":\"" + reason + "\"}";
        }
    }

    public void refundPartially(LocalDateTime now, BigDecimal amount, String reason) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0 || amount.compareTo(this.amount) > 0) {
            throw new IllegalArgumentException("Valor de reembolso inv√°lido");
        }
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento n√£o pode ser reembolsado");
        }

        this.refundAmount = amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }

    public void refundFully(LocalDateTime now, String reason) {
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento n√£o pode ser reembolsado");
        }

        this.refundAmount = this.amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }

    // ---------------------------
    // Regras (parametrizadas por "agora")
    // ---------------------------

    public boolean isActive(LocalDateTime now) {
        return this.status == PaymentStatus.COMPLETED
                && (this.validUntil == null || this.validUntil.isAfter(now));
    }

    public boolean canBeRefunded(LocalDateTime now) {
        if (this.status != PaymentStatus.COMPLETED) return false;
        if (this.refundedAt != null) return false;
        if (this.paymentDate == null) return false;

        // Exemplo original: at√© 90 dias ap√≥s paymentDate (regra determin√≠stica)
        // (equivalente a: paymentDate.isAfter(now.minusDays(90)))
        return this.paymentDate.isAfter(now.minusDays(90));
    }
}
package brito.com.multitenancy001.controlplane.domain.billing;



public enum PaymentStatus {
    PENDING("Pendente"),
    COMPLETED("Conclu√≠do"),
    FAILED("Falhou"),
    REFUNDED("Reembolsado"),
    CANCELLED("Cancelado"),
    EXPIRED("Expirado");
    
    private final String description;
    
    PaymentStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * Verifica se o status indica pagamento bem-sucedido
     */
    public boolean isSuccessful() {
        return this == COMPLETED;
    }
    
    /**
     * Verifica se o status indica pagamento finalizado (n√£o pendente)
     */
    public boolean isFinal() {
        return this != PENDING;
    }
    
    /**
     * Converte string para PaymentStatus
     */
    public static PaymentStatus fromString(String status) {
        if (status == null) {
            return PENDING;
        }
        try {
            return PaymentStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            return PENDING;
        }
    }
}package brito.com.multitenancy001.controlplane.domain.user;

import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(
    name = "controlplane_users",
    schema = "public",
    uniqueConstraints = {
        @UniqueConstraint(name = "ux_controlplane_users_username", columnNames = {"account_id", "username"}),
        @UniqueConstraint(name = "ux_controlplane_users_email", columnNames = {"account_id", "email"})
    }
)
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @Builder
@ToString(exclude = { "account", "password" })
public class ControlPlaneUser {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(name = "username", nullable = false, length = 100)
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inv√°lido.")
    private String username;

    @Column(name = "password", nullable = false, length = 255)
    private String password;

    @Column(name = "email", nullable = false, length = 150)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 50)
    private ControlPlaneRole role;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    // üîê SEGURAN√áA
    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts", nullable = false)
    @Builder.Default
    private Integer failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private Boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    // ‚úÖ ESTES CAMPOS EXISTEM NA MIGRATION
    @Column(name = "timezone", nullable=false,length = 50)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", nullable=false,length = 10)
    @Builder.Default
    private String locale = "pt_BR";

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    // üßæ AUDITORIA
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
        name = "controlplane_user_permissions",
        schema = "public",
        joinColumns = @JoinColumn(name = "user_id")
    )
    @Column(name = "permission", nullable = false, length = 120)
    @Builder.Default
    private Set<String> permissions = new LinkedHashSet<>();

    
    @PrePersist
    @PreUpdate
    private void normalizePermissions() {
        // garante Set n√£o nulo
        if (permissions == null) permissions = new LinkedHashSet<>();

        // normaliza prefixo/trim e bloqueia TEN_ no controlplane
        permissions = PermissionScopeValidator.normalizeControlPlane(permissions);
    }


    

    // ‚úÖ se lockedUntil estiver no futuro: lock
    public boolean isAccountNonLocked(LocalDateTime now) {
        return lockedUntil == null || !lockedUntil.isAfter(now);
    }

    // ‚úÖ enabled ‚Äúpuro‚Äù (n√£o deletado / n√£o suspenso)
    public boolean isEnabledForLogin() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    // ‚úÖ decis√£o final de login (enabled + lock)
    public boolean isEnabledForLogin(LocalDateTime now) {
        return isEnabledForLogin() && isAccountNonLocked(now);
    }

    public void softDelete(LocalDateTime now, long uniqueSuffix) {
        if (deleted) return;
        deleted = true;
        deletedAt = now;

        suspendedByAccount = true;
        suspendedByAdmin = true;

        username = "deleted_" + username + "_" + uniqueSuffix;
        email = "deleted_" + email + "_" + uniqueSuffix;
    }

    public void restore() {
        this.deleted = false;
        this.deletedAt = null;
        this.suspendedByAccount = false;
        this.suspendedByAdmin = false;
    }
}
package brito.com.multitenancy001.controlplane.persistence.account;

import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AccountEntitlementsRepository extends JpaRepository<AccountEntitlements, Long> {
}
package brito.com.multitenancy001.controlplane.persistence.account;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.DocumentType;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
	
   

    Optional<Account> findBySlugAndDeletedFalseIgnoreCase(String slug);
	
    boolean existsByCompanyEmailAndDeletedFalse(String companyEmail);

    // ‚úÖ docType + docNumber juntos
    boolean existsByCompanyDocTypeAndCompanyDocNumberAndDeletedFalse(DocumentType companyDocType, String companyDocNumber);

    List<Account> findAllByDeletedFalse();
    List<Account> findByDeletedFalseOrderByCreatedAtDesc();

    Optional<Account> findBySlugAndDeletedFalse(String slug);
    Optional<Account> findByIdAndDeletedFalse(Long id);

    List<Account> findByStatus(AccountStatus status);
    List<Account> findByStatusAndDeletedFalse(AccountStatus status);
    List<Account> findByPaymentDueDateBefore(LocalDateTime date);

    @Query("SELECT a FROM Account a WHERE a.trialEndDate <= :date AND a.status = :status")
    List<Account> findExpiredTrials(@Param("date") LocalDateTime date, @Param("status") AccountStatus status);

    @Query("SELECT COUNT(a) FROM Account a WHERE a.deleted = false")
    Long countActiveAccounts();

    @Query("SELECT a FROM Account a WHERE a.status = :status AND a.paymentDueDate < :today")
    List<Account> findOverdueAccounts(@Param("status") AccountStatus status, @Param("today") LocalDateTime today);

    boolean existsByNameAndDeletedFalse(String name);
    boolean existsBySchemaNameAndDeletedFalse(String schemaName);

    @Query("SELECT a FROM Account a WHERE a.createdAt BETWEEN :startDate AND :endDate")
    List<Account> findAccountsCreatedBetween(@Param("startDate") LocalDateTime startDate,
                                                   @Param("endDate") LocalDateTime endDate);

    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.status IN :statuses")
    List<Account> findByStatuses(@Param("statuses") List<AccountStatus> statuses);

    @Query("SELECT a FROM Account a WHERE LOWER(a.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) AND a.deleted = false")
    List<Account> searchByName(@Param("searchTerm") String searchTerm);
}
package brito.com.multitenancy001.controlplane.persistence.billing;



import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface PaymentRepository extends JpaRepository<Payment, Long> {
	
	Optional<Payment> findByIdAndAccountId(Long id, Long accountId);
	
	boolean existsByIdAndAccountId(Long id, Long accountId);

    
    List<Payment> findByAccountId(Long accountId);
    
    List<Payment> findByAccountIdAndStatus(Long accountId, PaymentStatus status);
    
    Page<Payment> findByAccountId(Long accountId, Pageable pageable);
    
    Optional<Payment> findByTransactionId(String transactionId);
    
    List<Payment> findByStatus(PaymentStatus status);
    
    List<Payment> findByStatusAndCreatedAtBefore(PaymentStatus status, LocalDateTime date);
    
    List<Payment> findByValidUntilBeforeAndStatus(LocalDateTime date, PaymentStatus status);
    
    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' ORDER BY p.paymentDate DESC")
    List<Payment> findCompletedPaymentsByAccount(@Param("accountId") Long accountId);
    
    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.validUntil > :now AND p.status = 'COMPLETED'")
    Optional<Payment> findActivePayment(@Param("accountId") Long accountId, @Param("now") LocalDateTime now);
    
    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalPaidInPeriod(@Param("accountId") Long accountId, 
                                   @Param("startDate") LocalDateTime startDate, 
                                   @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT COUNT(p) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED'")
    Long countCompletedPayments(@Param("accountId") Long accountId);
    
    @Query("SELECT p FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate")
    List<Payment> findPaymentsInPeriod(@Param("startDate") LocalDateTime startDate, 
                                      @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT p.account.id, SUM(p.amount) FROM Payment p WHERE p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate GROUP BY p.account.id")
    List<Object[]> getRevenueByAccount(@Param("startDate") LocalDateTime startDate, 
                                      @Param("endDate") LocalDateTime endDate);
    
    boolean existsByTransactionId(String transactionId);
}package brito.com.multitenancy001.controlplane.persistence.user;



import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;

import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlaneUserRepository extends JpaRepository<ControlPlaneUser, Long> {
	
	Optional<ControlPlaneUser> findByUsernameAndAccount_IdAndDeletedFalse(String username, Long accountId);


	long countByAccountIdAndDeletedFalse(Long accountId);
	
	Optional<ControlPlaneUser> findFirstByAccountIdAndDeletedFalse(Long accountId);
    
    Optional<ControlPlaneUser> findByUsername(String username);
    
    Optional<ControlPlaneUser> findByEmail(String email);
    
    List<ControlPlaneUser> findByAccountId(Long accountId);
    
    @Query("SELECT (COUNT(u) > 0) FROM ControlPlaneUser u " +
    	       "WHERE u.username = :username AND u.account.id = :accountId AND u.deleted = false")
    	boolean existsByUsernameAndAccountId(@Param("username") String username,
    	                                     @Param("accountId") Long accountId);
    
    
    
    @Query("SELECT (COUNT(u) > 0) FROM ControlPlaneUser u " +
    	       "WHERE u.email = :email AND u.account.id = :accountId AND u.deleted = false")
    	boolean existsByEmailAndAccountId(@Param("email") String email,
    	                                  @Param("accountId") Long accountId);    
    Optional<ControlPlaneUser> findByIdAndAccountId(Long id, Long accountId);
    
    Optional<ControlPlaneUser> findByUsernameAndDeletedFalse(String username);
    
    Optional<ControlPlaneUser> findByEmailAndDeletedFalse(String email);
}package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.PermissionAuthority;

public enum ControlPlanePermission implements PermissionAuthority {

    CP_TENANT_READ,
    CP_TENANT_SUSPEND,
    CP_TENANT_ACTIVATE,
    CP_TENANT_DELETE,

    CP_BILLING_READ,
    CP_BILLING_WRITE,

    CP_SUPPORT_RESET_PASSWORD,

    CP_USER_READ,
    CP_USER_WRITE,
    CP_USER_DELETE;

    @Override
    public String asAuthority() {
        return name();
    }
}
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum ControlPlaneRole implements RoleAuthority {

    CONTROLPLANE_OWNER,
    CONTROLPLANE_BILLING_MANAGER,  
    CONTROLPLANE_SUPPORT,
    CONTROLPLANE_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isControlPlaneOwner() {
        return this == CONTROLPLANE_OWNER;
    }

    public boolean isBillingManager() {
        return this == CONTROLPLANE_BILLING_MANAGER;
    }
}
package brito.com.multitenancy001.controlplane.security;

import java.util.EnumSet;
import java.util.Set;

public final class ControlPlaneRolePermissions {

    private ControlPlaneRolePermissions() {}

    public static Set<ControlPlanePermission> permissionsFor(ControlPlaneRole role) {
        if (role == null) return Set.of();

        return switch (role) {
            case CONTROLPLANE_OWNER -> EnumSet.allOf(ControlPlanePermission.class);

            case CONTROLPLANE_BILLING_MANAGER -> EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_TENANT_SUSPEND,
                ControlPlanePermission.CP_TENANT_ACTIVATE,
                ControlPlanePermission.CP_BILLING_READ,
                ControlPlanePermission.CP_BILLING_WRITE,
                ControlPlanePermission.CP_SUPPORT_RESET_PASSWORD
            );

            case CONTROLPLANE_SUPPORT -> EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_TENANT_SUSPEND,
                ControlPlanePermission.CP_TENANT_ACTIVATE,
                ControlPlanePermission.CP_USER_READ,
                ControlPlanePermission.CP_USER_WRITE,
                ControlPlanePermission.CP_SUPPORT_RESET_PASSWORD
            );

            case CONTROLPLANE_OPERATOR -> EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_USER_READ,
                ControlPlanePermission.CP_SUPPORT_RESET_PASSWORD
            );
        };
    }
}
package brito.com.multitenancy001.infrastructure.config.time;

import java.time.Clock;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TimeConfig {

    @Bean
    public Clock systemClock() {
        return Clock.systemDefaultZone();
    }
}
package brito.com.multitenancy001.infrastructure.executor;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Component
public class PublicExecutor {

    public <T> T run(Supplier<T> supplier) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            return supplier.get();
        }
    }

    public void run(Runnable runnable) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            runnable.run();
        }
    }
}
package brito.com.multitenancy001.infrastructure.executor;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;

@Component
public class TenantExecutor {

    private final TenantSchemaProvisioningService tenantSchemaService;

    public TenantExecutor(TenantSchemaProvisioningService tenantSchemaService) {
        this.tenantSchemaService = tenantSchemaService;
    }

    public <T> T run(String schema, Supplier<T> fn) {
        if (schema == null || "public".equals(schema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inv√°lido", 404);
        }

        // ‚úÖ padronizado: nada de bind/clear manual
        try (TenantContext.Scope ignored = TenantContext.scope(schema)) {
            return fn.get();
        }
    }

    public void run(String schema, Runnable fn) {
        run(schema, () -> { fn.run(); return null; });
    }

    /** Retorna defaultValue se schema/tabela n√£o existir (bom p/ side-effects). */
    public <T> T runIfReady(String schema, String requiredTable, Supplier<T> fn, T defaultValue) {
        if (schema == null || "public".equals(schema)) return defaultValue;
        if (!tenantSchemaService.schemaExists(schema)) return defaultValue;
        if (requiredTable != null && !tenantSchemaService.tableExists(schema, requiredTable)) return defaultValue;
        return run(schema, fn);
    }

    /** Lan√ßa ApiException se schema/tabela n√£o existir (bom p/ endpoints admin). */
    public void assertReadyOrThrow(String schema, String requiredTable) {
        if (schema == null || "public".equals(schema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inv√°lido", 404);
        }
        if (!tenantSchemaService.schemaExists(schema)) {
            throw new ApiException("TENANT_SCHEMA_NOT_FOUND", "Schema do tenant n√£o existe", 404);
        }
        if (requiredTable != null && !tenantSchemaService.tableExists(schema, requiredTable)) {
            throw new ApiException("TENANT_TABLE_NOT_FOUND", "Tabela " + requiredTable + " n√£o existe no tenant", 404);
        }
    }

    public <T> T runOrThrow(String schema, String requiredTable, Supplier<T> fn) {
        assertReadyOrThrow(schema, requiredTable);
        return run(schema, fn);
    }
}
package brito.com.multitenancy001.infrastructure.executor;

import java.util.function.Supplier;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

@Component
public class TxExecutor {

    private final TransactionTemplate publicTx;
    private final TransactionTemplate publicRequiresNew;

    private final TransactionTemplate publicReadOnlyTx;
    private final TransactionTemplate publicRequiresNewReadOnly;

    private final TransactionTemplate tenantTx;
    private final TransactionTemplate tenantRequiresNew;

    private final TransactionTemplate tenantReadOnlyTx;
    private final TransactionTemplate tenantRequiresNewReadOnly;

    public TxExecutor(
            @Qualifier("publicTransactionManager") PlatformTransactionManager publicTm,
            @Qualifier("tenantTransactionManager") PlatformTransactionManager tenantTm
    ) {
        // PUBLIC - REQUIRED
        this.publicTx = new TransactionTemplate(publicTm);
        this.publicTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // PUBLIC - REQUIRES_NEW
        this.publicRequiresNew = new TransactionTemplate(publicTm);
        this.publicRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // PUBLIC - REQUIRED READONLY
        this.publicReadOnlyTx = new TransactionTemplate(publicTm);
        this.publicReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.publicReadOnlyTx.setReadOnly(true);

        // PUBLIC - REQUIRES_NEW READONLY
        this.publicRequiresNewReadOnly = new TransactionTemplate(publicTm);
        this.publicRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.publicRequiresNewReadOnly.setReadOnly(true);

        // TENANT - REQUIRED
        this.tenantTx = new TransactionTemplate(tenantTm);
        this.tenantTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // TENANT - REQUIRES_NEW
        this.tenantRequiresNew = new TransactionTemplate(tenantTm);
        this.tenantRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // TENANT - REQUIRED READONLY
        this.tenantReadOnlyTx = new TransactionTemplate(tenantTm);
        this.tenantReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.tenantReadOnlyTx.setReadOnly(true);

        // TENANT - REQUIRES_NEW READONLY
        this.tenantRequiresNewReadOnly = new TransactionTemplate(tenantTm);
        this.tenantRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.tenantRequiresNewReadOnly.setReadOnly(true);
    }

    // ---------- PUBLIC ----------
    public <T> T publicTx(Supplier<T> fn) {
        return publicTx.execute(status -> fn.get());
    }
    public void publicTx(Runnable fn) {
        publicTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNew(Supplier<T> fn) {
        return publicRequiresNew.execute(status -> fn.get());
    }
    public void publicRequiresNew(Runnable fn) {
        publicRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicReadOnlyTx(Supplier<T> fn) {
        return publicReadOnlyTx.execute(status -> fn.get());
    }
    public void publicReadOnlyTx(Runnable fn) {
        publicReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNewReadOnly(Supplier<T> fn) {
        return publicRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void publicRequiresNewReadOnly(Runnable fn) {
        publicRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }

    // ---------- TENANT ----------
    public <T> T tenantTx(Supplier<T> fn) {
        return tenantTx.execute(status -> fn.get());
    }
    public void tenantTx(Runnable fn) {
        tenantTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNew(Supplier<T> fn) {
        return tenantRequiresNew.execute(status -> fn.get());
    }
    public void tenantRequiresNew(Runnable fn) {
        tenantRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantReadOnlyTx(Supplier<T> fn) {
        return tenantReadOnlyTx.execute(status -> fn.get());
    }
    public void tenantReadOnlyTx(Runnable fn) {
        tenantReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNewReadOnly(Supplier<T> fn) {
        return tenantRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void tenantRequiresNewReadOnly(Runnable fn) {
        tenantRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }
}
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PublicFlywayConfig {

    @Bean
    public Flyway flywayPublic(DataSource dataSource) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas("public")
                .locations("classpath:db/migration/accounts")
                .baselineOnMigrate(true)
                .load();

      
        return flyway;
    }
}
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import org.flywaydb.core.Flyway;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Component
@RequiredArgsConstructor
@Slf4j
public class PublicFlywayRunner implements ApplicationRunner {

	private final Flyway flywayPublic;

	@Override
	public void run(ApplicationArguments args) {

		log.info("üöÄ Executando Flyway ACCOUNT (schema public)");
		flywayPublic.migrate();
	}
}
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class PublicSchemaVerifier {
    
    private final JdbcTemplate jdbc;
    
    @EventListener(ApplicationReadyEvent.class)
    public void verifyTables() {
        log.info("üîç Verificando tabelas criadas pelo Flyway...");
        
        try {
            // Apenas VERIFICA, n√£o cria
            Integer accountsCount = jdbc.queryForObject(
                "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'accounts'", 
                Integer.class
            );
            
            Integer usersCount = jdbc.queryForObject(
            	    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'controlplane_users'",
            	    Integer.class
            	);

            
            log.info("‚úÖ Verifica√ß√£o OK! Tabelas encontradas: accounts={}, controlplane_users={}", accountsCount, usersCount);

        } catch (Exception e) {
            log.error("‚ö†Ô∏è Aviso na verifica√ß√£o: {}", e.getMessage());
        }
    }
}package brito.com.multitenancy001.infrastructure.flyway.tenantschema;

import lombok.RequiredArgsConstructor;
import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;

@Service
@RequiredArgsConstructor
public class TenantSchemaFlywayMigrationService {

    private final DataSource dataSource;

    public void migrateTenantSchema(String schemaName) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas(schemaName)
                .defaultSchema(schemaName) // üî• ESSENCIAL
                .createSchemas(false)
                .locations("classpath:db/migration/tenants")
                .baselineOnMigrate(true)
                .load();

        flyway.migrate();
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.extern.slf4j.Slf4j;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

@Slf4j
@Component
public class CurrentTenantSchemaResolver
        implements CurrentTenantIdentifierResolver<String> {

    private static final String DEFAULT_SCHEMA = "public";
    private static final ThreadLocal<String> TENANT_THREAD_LOCAL = new ThreadLocal<>();

    /**
     * Bind do tenant na thread atual.
     * - Se vier vazio/nulo: remove o tenant (fica "sem tenant", e o resolver decide fallback).
     * - Se vier preenchido: seta no ThreadLocal.
     */
    public static void bindTenantToCurrentThread(String tenantId) {
        String previous = TENANT_THREAD_LOCAL.get();

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (StringUtils.hasText(normalized)) {
            TENANT_THREAD_LOCAL.set(normalized);
            if (!normalized.equals(previous)) {
                log.info("üîÑ Tenant bindado √† thread: {} -> {}", previous, normalized);
            } else {
                log.debug("üîÑ Tenant j√° estava bindado: {}", normalized);
            }
        } else {
            TENANT_THREAD_LOCAL.remove();
            if (previous != null) {
                log.info("üßπ Tenant removido da thread (anterior: {})", previous);
            } else {
                log.debug("üßπ Tenant j√° estava vazio (nada para remover)");
            }
        }
    }

    /**
     * Retorna o tenant REALMENTE bindado.
     * ‚úÖ Importante: aqui retornamos null quando n√£o h√° tenant,
     * pra n√£o mascarar estado e facilitar debug.
     */
    public static String resolveBoundTenantOrNull() {
        String t = TENANT_THREAD_LOCAL.get();
        return StringUtils.hasText(t) ? t : null;
    }

    /**
     * Mant√©m compatibilidade com seu c√≥digo atual (ex.: logs do provider).
     * Use isso somente quando voc√™ quer um fallback expl√≠cito para public.
     */
    public static String resolveBoundTenantOrDefault() {
        String t = resolveBoundTenantOrNull();
        return (t != null ? t : DEFAULT_SCHEMA);
    }

    public static void unbindTenantFromCurrentThread() {
        String previous = TENANT_THREAD_LOCAL.get();
        TENANT_THREAD_LOCAL.remove();
        if (previous != null) {
            log.info("üßπ Tenant desbindado da thread (anterior: {})", previous);
        } else {
            log.debug("üßπ Tenant desbindado (j√° estava vazio)");
        }
    }

    /**
     * O Hibernate sempre precisa de um tenant v√°lido.
     * ‚úÖ Aqui sim a gente aplica fallback para DEFAULT_SCHEMA.
     */
    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenant = resolveBoundTenantOrNull();
        String resolved = (tenant != null ? tenant : DEFAULT_SCHEMA);

        if (log.isDebugEnabled()) {
            log.debug("üè∑Ô∏è Hibernate resolveu tenant={} (bound={}, default={})",
                    resolved, tenant, DEFAULT_SCHEMA);
        }
        return resolved;
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return false;
    }

    @Override
    public boolean isRoot(String tenantIdentifier) {
        return DEFAULT_SCHEMA.equals(tenantIdentifier);
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.sql.DataSource;
import java.sql.*;

@Slf4j
@Component
@RequiredArgsConstructor
public class TenantSchemaConnectionProvider
        extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String> {

    private static final long serialVersionUID = 1L;
    private static final String DEFAULT_SCHEMA = "public";

    private final DataSource dataSource;

    @Override
    protected DataSource selectAnyDataSource() {
        return dataSource;
    }

    @Override
    protected DataSource selectDataSource(String tenantIdentifier) {
        return dataSource;
    }

    @Override
    public Connection getConnection(String tenantIdentifier) throws SQLException {

        long threadId = Thread.currentThread().threadId();
        String threadTenant = CurrentTenantSchemaResolver.resolveBoundTenantOrDefault();

        String effectiveTenant = StringUtils.hasText(tenantIdentifier)
                ? tenantIdentifier
                : DEFAULT_SCHEMA;

        if (!StringUtils.hasText(tenantIdentifier)) {
            log.warn("‚ö†Ô∏è [MT] tenantIdentifier vazio ‚Üí usando DEFAULT ({}) | threadTenant={}",
                    DEFAULT_SCHEMA, threadTenant);
        }

        validateSchemaName(effectiveTenant);

        Connection connection = dataSource.getConnection();

        try (Statement stmt = connection.createStatement()) {

            if (!DEFAULT_SCHEMA.equals(effectiveTenant)) {
                ensureSchemaExists(connection, effectiveTenant);

                String quotedTenant = quoteIdentifier(effectiveTenant);

                String setSearchPath = "SET search_path TO " + quotedTenant + ", public";
                log.info("üéØ [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL={}",
                        threadId, tenantIdentifier, threadTenant, setSearchPath);

                stmt.execute(setSearchPath);

            } else {
                log.info("üè† [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL=SET search_path TO public;",
                        threadId, tenantIdentifier, threadTenant);

                stmt.execute("SET search_path TO public;");
            }

            return connection;

        } catch (SQLException e) {
            log.error("‚ùå [MT] Erro configurando conex√£o | effectiveTenant={}", effectiveTenant, e);
            try { connection.close(); } catch (SQLException ignore) {}
            throw e;
        }
    }

    @Override
    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
        if (connection == null || connection.isClosed()) return;

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("SET search_path TO public;");
        } finally {
            connection.close();
        }
    }

    private void ensureSchemaExists(Connection connection, String schemaName) throws SQLException {
        String quotedSchema = quoteIdentifier(schemaName);

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE SCHEMA IF NOT EXISTS " + quotedSchema);
        }

        try (PreparedStatement ps = connection.prepareStatement(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = ?")) {
            ps.setString(1, schemaName);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    throw new SQLException("Schema " + schemaName + " n√£o encontrado ap√≥s CREATE");
                }
            }
        }
    }

    private void validateSchemaName(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new IllegalArgumentException("schemaName vazio");
        }
        if (!schemaName.matches("[A-Za-z_][A-Za-z0-9_]*")) {
            throw new IllegalArgumentException("schemaName inv√°lido: " + schemaName);
        }
    }

    private String quoteIdentifier(String identifier) {
        return "\"" + identifier + "\"";
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class TenantSchemaHibernateConfig {

    private final DataSource dataSource;
    private final TenantSchemaConnectionProvider multiTenantConnectionProvider;
    private final CurrentTenantSchemaResolver tenantResolver;

    @Bean(name = "tenantEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        // Entidades do TENANT
        emf.setPackagesToScan("brito.com.multitenancy001.tenant.domain");

        emf.setPersistenceUnitName("TENANT_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);

        // Multi-tenancy por schema
        props.put("hibernate.multiTenancy", "SCHEMA");
        props.put("hibernate.multi_tenant_connection_provider", multiTenantConnectionProvider);
        props.put("hibernate.tenant_identifier_resolver", tenantResolver);

        emf.setJpaPropertyMap(props);
        return emf;
    }

    @Bean(name = "tenantTransactionManager")
    public PlatformTransactionManager tenantTransactionManager(
            @Qualifier("tenantEntityManagerFactory") jakarta.persistence.EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
public class TransactionManagementConfig {
}
package brito.com.multitenancy001.infrastructure.multitenancy.observability;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;

@Aspect
@Component
@Slf4j
public class TenantContextMonitor {
    
    @Around("@within(org.springframework.stereotype.Service)")
    public Object monitorServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        String currentTenant = TenantContext.getOrNull();
        
        log.debug("üèÅ IN√çCIO {} - Tenant: {}", methodName, currentTenant);
        
        try {
            Object result = joinPoint.proceed();
            log.debug("‚úÖ FIM {} - Tenant: {}", methodName, TenantContext.getOrNull());
            return result;
        } catch (Exception e) {
            log.error("‚ùå ERRO {} - Tenant: {} - Erro: {}", 
                     methodName, currentTenant, e.getMessage());
            throw e;
        }
    }
}package brito.com.multitenancy001.infrastructure.persistence;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Persist√™ncia do schema PUBLIC (ControlPlane).
 * Usa o EntityManagerFactory default do Spring Boot (bean: "entityManagerFactory")
 * e cria um alias sem√¢ntico: "publicEntityManagerFactory".
 */
@Configuration
@EnableJpaRepositories(
        basePackages = "brito.com.multitenancy001.controlplane.persistence",
        entityManagerFactoryRef = "publicEntityManagerFactory",
        transactionManagerRef = "publicTransactionManager"
)
public class PublicPersistenceConfig {

    @Bean(name = "publicEntityManagerFactory")
    @Primary
    public EntityManagerFactory publicEntityManagerFactory(
            @Qualifier("entityManagerFactory") EntityManagerFactory emf
    ) {
        return emf;
    }

    @Bean(name = "publicTransactionManager")
    @Primary
    public PlatformTransactionManager publicTransactionManager(
            @Qualifier("publicEntityManagerFactory") EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}
package brito.com.multitenancy001.infrastructure.persistence;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class PublicSchemaHibernateConfig {

    private final DataSource dataSource;

    /**
     * ‚úÖ EMF "default" que o Spring Boot normalmente criaria.
     * Como voc√™ criou um EMF manual (tenantEntityManagerFactory),
     * o Boot recuou e N√ÉO criou mais o entityManagerFactory.
     *
     * Ent√£o criamos explicitamente aqui.
     */
    @Bean(name = "entityManagerFactory")
    @Primary
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        // Entidades do PUBLIC (ControlPlane)
        emf.setPackagesToScan("brito.com.multitenancy001.controlplane.domain");

        emf.setPersistenceUnitName("PUBLIC_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);

        // opcional (Postgres): garantir que o default √© public
        props.put("hibernate.default_schema", "public");

        emf.setJpaPropertyMap(props);
        return emf;
    }
}
package brito.com.multitenancy001.infrastructure.persistence;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@Configuration
@EnableJpaRepositories(
        basePackages = "brito.com.multitenancy001.tenant.persistence",
        entityManagerFactoryRef = "tenantEntityManagerFactory",
        transactionManagerRef = "tenantTransactionManager"
)
public class TenantPersistenceConfig {
}
package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;

@Getter
public class AuthenticatedUserContext implements UserDetails {

    private static final long serialVersionUID = 1L;

    private final Long userId;
    private final String username;
    private final String email;
    private final String password;

    private final boolean enabled;
    private final boolean accountNonLocked;

    private final Long accountId;
    private final String schemaName;

    // opcional: manter role para debug/claims (N√ÉO entra em authorities)
    private final String roleAuthority;

    // ‚úÖ permission-only
    private final Collection<? extends GrantedAuthority> authorities;

    public AuthenticatedUserContext(
            ControlPlaneUser user,
            String schemaName,
            LocalDateTime now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.password = user.getPassword();

        this.accountId = user.getAccount().getId();
        this.schemaName = schemaName;

        this.roleAuthority = user.getRole() != null ? user.getRole().asAuthority() : null;

        this.authorities = authorities;

        this.enabled = user.isEnabledForLogin();
        this.accountNonLocked = user.isAccountNonLocked(now);
    }

    public AuthenticatedUserContext(
            TenantUser user,
            String schemaName,
            LocalDateTime now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        this.userId = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.password = user.getPassword();

        this.accountId = user.getAccountId();
        this.schemaName = schemaName;

        this.roleAuthority = user.getRole() != null ? user.getRole().asAuthority() : null;

        this.authorities = authorities;

        this.enabled = !user.isDeleted() && !user.isSuspendedByAccount() && !user.isSuspendedByAdmin();
        this.accountNonLocked = user.getLockedUntil() == null || !user.getLockedUntil().isAfter(now);
    }

    @Override public Collection<? extends GrantedAuthority> getAuthorities() { return authorities; }
    @Override public String getPassword() { return password; }
    @Override public String getUsername() { return username; }

    @Override public boolean isAccountNonExpired() { return true; }
    @Override public boolean isAccountNonLocked() { return accountNonLocked; }
    @Override public boolean isCredentialsNonExpired() { return true; }
    @Override public boolean isEnabled() { return enabled; }
}
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.infrastructure.security.filter.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz

                // =========================
                // üîì PUBLIC
                // =========================
                .requestMatchers("/actuator/health").permitAll()

                // =========================
                // üîì AUTH CONTROLPLANE (admin)
                // =========================
                .requestMatchers(
                    "/api/admin/auth/login",
                    "/api/admin/auth/refresh"
                ).permitAll()

                // =========================
                // üîì AUTH TENANT
                // =========================
                .requestMatchers(
                    "/api/tenant/auth/login",
                    "/api/tenant/auth/refresh"
                ).permitAll()

                // =========================
                // üîì PASSWORD RESET TENANT
                // =========================
                .requestMatchers(
                    "/api/tenant/password/forgot",
                    "/api/tenant/password/reset"
                ).permitAll()

                // =========================
                // üîì SIGNUP / CHECKUSER
                // =========================
                .requestMatchers(
                    "/api/accounts/auth/checkuser",
                    "/api/signup"
                ).permitAll()

                // =========================
                // ‚úÖ BOUNDARIES OFICIAIS
                // =========================
                .requestMatchers("/api/admin/**").authenticated()
                .requestMatchers("/api/controlplane/**").authenticated()
                .requestMatchers("/api/tenant/**").authenticated()

                // =========================
                // ‚ùå Qualquer rota fora disso √© erro de arquitetura
                // =========================
                .anyRequest().denyAll()
            );

        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }
}
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final MultiContextUserDetailsService multiContextUserDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest httpServletRequest,
            @NonNull HttpServletResponse httpServletResponse,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        boolean bound = false;

        try {
            final String authHeader = httpServletRequest.getHeader("Authorization");

            // "Bearer ..." √© esquema HTTP, n√£o √© dom√≠nio do token
            if (!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            final String jwt = authHeader.substring(7);

            if (!jwtTokenProvider.validateToken(jwt)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            // ‚úÖ agora √© claro: authDomain = TENANT/CONTROLPLANE/...
            final String authDomain = jwtTokenProvider.getAuthDomain(jwt);
            final String username = jwtTokenProvider.getUsernameFromToken(jwt);

            // ‚úÖ TRAVA: token tem que bater com a rota
            if (requiresControlPlane(httpServletRequest) && !"CONTROLPLANE".equals(authDomain)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }
            if (requiresTenant(httpServletRequest) && !"TENANT".equals(authDomain)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            // s√≥ aceitamos TENANT / CONTROLPLANE aqui
            if (!"TENANT".equals(authDomain) && !"CONTROLPLANE".equals(authDomain)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            if (!StringUtils.hasText(username)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            if (SecurityContextHolder.getContext().getAuthentication() == null) {

                UserDetails userDetails;

                if ("TENANT".equals(authDomain)) {
                    final String tenantSchema = jwtTokenProvider.getTenantSchemaFromToken(jwt);

                    if (!StringUtils.hasText(tenantSchema) || "public".equalsIgnoreCase(tenantSchema)) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    if (!tenantSchema.matches("^[a-zA-Z0-9_]+$")) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    TenantContext.bind(tenantSchema);
                    bound = true;

                    Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
                    if (accountId == null) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    userDetails = multiContextUserDetailsService.loadTenantUser(username, accountId);

                } else { // CONTROLPLANE
                    String context = jwtTokenProvider.getContextFromToken(jwt);
                    if (StringUtils.hasText(context) && !"public".equalsIgnoreCase(context)) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
                    if (accountId == null) {
                        filterChain.doFilter(httpServletRequest, httpServletResponse);
                        return;
                    }

                    userDetails = multiContextUserDetailsService.loadControlPlaneUser(username, accountId);
                }

                UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities()
                        );

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(httpServletRequest));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }

            filterChain.doFilter(httpServletRequest, httpServletResponse);

        } finally {
            if (bound) {
                TenantContext.clear();
            }
        }
    }

    private boolean requiresControlPlane(HttpServletRequest httpServletRequest) {
        String path = httpServletRequest.getRequestURI();
        return path.startsWith("/api/admin/") || path.startsWith("/api/controlplane/");
    }

    private boolean requiresTenant(HttpServletRequest httpServletRequest) {
        String path = httpServletRequest.getRequestURI();
        return path.startsWith("/api/tenant/");
    }
}
package brito.com.multitenancy001.infrastructure.security.jwt;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.time.AppClock;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtTokenProvider {

    public static final String CLAIM_AUTHORITIES = "authorities";
    public static final String CLAIM_AUTH_DOMAIN = "authDomain"; // <-- NOVO
    public static final String CLAIM_CONTEXT = "context";
    public static final String CLAIM_ACCOUNT_ID = "accountId";
    public static final String CLAIM_USER_ID = "userId";

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private long jwtExpirationInMs;

    @Value("${app.jwt.refresh.expiration}")
    private long refreshExpirationInMs;

    private final AppClock appClock;
    private SecretKey key;

    public JwtTokenProvider(AppClock appClock) {
        this.appClock = appClock;
    }

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            throw new IllegalArgumentException("JWT secret must be at least 256 bits (32 chars)");
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    private Date issuedAt() {
        return Date.from(appClock.instant());
    }

    private Date expiresAtInMs(long ttlMillis) {
        Instant exp = appClock.instant().plusMillis(ttlMillis);
        return Date.from(exp);
    }

    /* =========================
       ACCESS TOKEN - CONTROLPLANE
       ========================= */
    public String generateControlPlaneToken(Authentication authentication, Long accountId, String context) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getUsername())
                .claim(CLAIM_AUTHORITIES, user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim(CLAIM_AUTH_DOMAIN, "CONTROLPLANE") // <-- NOVO
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, user.getUserId())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       ACCESS TOKEN - TENANT
       ========================= */
    public String generateTenantToken(Authentication authentication, Long accountId, String context) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getUsername())
                .claim(CLAIM_AUTHORITIES, user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim(CLAIM_AUTH_DOMAIN, "TENANT") // <-- NOVO
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, user.getUserId())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       REFRESH TOKEN
       ========================= */
    public String generateRefreshToken(String username, String context) {
        return Jwts.builder()
                .subject(username)
                .claim(CLAIM_AUTH_DOMAIN, "REFRESH") // <-- NOVO
                .claim(CLAIM_CONTEXT, context)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(refreshExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       PASSWORD RESET TOKEN
       ========================= */
    public String generatePasswordResetToken(String username, String context, Long accountId) {
        long oneHourMs = 3_600_000L;

        return Jwts.builder()
                .subject(username)
                .claim(CLAIM_AUTH_DOMAIN, "PASSWORD_RESET") // <-- NOVO
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(oneHourMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /* =========================
       LEITURA DE CLAIMS
       ========================= */
    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    public String getUsernameFromToken(String token) {
        return getAllClaimsFromToken(token).getSubject();
    }

    /**
     * Obt√©m o contexto do token (antigo tenantSchema)
     * Mant√©m compatibilidade retornando "tenantSchema" se "context" n√£o existir
     */
    public String getContextFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String context = claims.get(CLAIM_CONTEXT, String.class);
        if (context == null) {
            context = claims.get("tenantSchema", String.class);
        }

        String authDomain = getAuthDomain(token);

        if ("TENANT".equals(authDomain) && "public".equalsIgnoreCase(context)) {
            throw new JwtException("Invalid context for TENANT token: public");
        }

        return context;
    }

    public String getTenantSchemaFromToken(String token) {
        return getContextFromToken(token);
    }

    public Long getAccountIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ACCOUNT_ID, Long.class);
    }

    /**
     * ‚úÖ NOVO: authDomain = TENANT/CONTROLPLANE/REFRESH/PASSWORD_RESET
     * ‚úÖ Compat√≠vel: se n√£o existir, cai para claim antiga "type"
     */
    public String getAuthDomain(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authDomain = claims.get(CLAIM_AUTH_DOMAIN, String.class);
        if (!StringUtils.hasText(authDomain)) {
            authDomain = claims.get("type", String.class); // compat tokens antigos
        }

        return authDomain;
    }

    // Se voc√™ tinha o m√©todo getTokenType, mantenha como alias (opcional)
    public String getTokenType(String token) {
        return getAuthDomain(token);
    }

    public Long getUserIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_USER_ID, Long.class);
    }

    public List<String> getAuthoritiesFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authorities = claims.get(CLAIM_AUTHORITIES, String.class);
        if (!StringUtils.hasText(authorities)) {
            authorities = claims.get("roles", String.class); // compat tokens antigos
        }

        return splitCsv(authorities);
    }

    private List<String> splitCsv(String csv) {
        if (!StringUtils.hasText(csv)) return List.of();

        return Arrays.stream(csv.split(","))
                .map(String::trim)
                .filter(StringUtils::hasText)
                .distinct()
                .toList();
    }

    public boolean isTokenExpired(String token) {
        try {
            Claims claims = getAllClaimsFromToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(Date.from(appClock.instant()));
        } catch (Exception e) {
            return true;
        }
    }

    public boolean validateToken(String token) {
        try {
            getAllClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public boolean isControlPlaneToken(String token) {
        return "CONTROLPLANE".equals(getAuthDomain(token));
    }

    public boolean isTenantToken(String token) {
        return "TENANT".equals(getAuthDomain(token));
    }

    public boolean isRefreshToken(String token) {
        return "REFRESH".equals(getAuthDomain(token));
    }

    public boolean isPasswordResetToken(String token) {
        return "PASSWORD_RESET".equals(getAuthDomain(token));
    }

    public boolean isTokenInContext(String token, String expectedContext) {
        String actualContext = getContextFromToken(token);
        return expectedContext.equals(actualContext);
    }

    public boolean isControlPlaneContextToken(String token) {
        String context = getContextFromToken(token);
        return "public".equals(context);
    }
}
package brito.com.multitenancy001.infrastructure.security;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.api.error.ApiException;

@Component
@RequiredArgsConstructor
public class SecurityUtils {
    
    public Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUserId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usu√°rio n√£o autenticado", 401);
    }
    
    public Long getCurrentAccountId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getAccountId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usu√°rio n√£o autenticado", 401);
    }
    
    public String getCurrentSchema() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getSchemaName();
        }
        throw new ApiException("UNAUTHENTICATED", "Usu√°rio n√£o autenticado", 401);
    }
    
    public String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUsername();
        }
        return authentication != null ? authentication.getName() : null;
    }
}package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRolePermissions;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.Collection;
import java.util.LinkedHashSet;

public final class AuthoritiesFactory {

    private AuthoritiesFactory() {}

    public static Collection<? extends GrantedAuthority> forControlPlane(ControlPlaneUser user) {
    	LinkedHashSet<String> permissions = new LinkedHashSet<>();

        // 1) role -> permissions (enum -> name)
        ControlPlaneRolePermissions.permissionsFor(user.getRole())
                .forEach(p -> permissions.add(p.name()));

        // 2) permissions expl√≠citas do user
        if (user.getPermissions() != null) {
            permissions.addAll(user.getPermissions());
        }

        // 3) normaliza CP_ e bloqueia TEN_
        LinkedHashSet<String> normalized = PermissionScopeValidator.normalizeControlPlane(permissions);

        return normalized.stream()
                .map(SimpleGrantedAuthority::new)
                .toList();
    }

    public static Collection<? extends GrantedAuthority> forTenant(TenantUser user) {
    	LinkedHashSet<String> permissions = new LinkedHashSet<>();

        // 1) role -> permissions (enum -> name)
        TenantRolePermissions.permissionsFor(user.getRole())
                .forEach(p -> permissions.add(p.name()));

        // 2) permissions expl√≠citas do user (List<String>)
        if (user.getPermissions() != null) {
            permissions.addAll(user.getPermissions());
        }

        // 3) normaliza TEN_ e bloqueia CP_
        LinkedHashSet<String> normalized = PermissionScopeValidator.normalizeTenant(permissions);

        return normalized.stream()
                .map(SimpleGrantedAuthority::new)
                .toList();
    }
}
package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class MultiContextUserDetailsService implements UserDetailsService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final TenantUserRepository tenantUserRepository;
    private final AppClock appClock;

    private LocalDateTime now() {
        return appClock.now();
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String schemaName = TenantContext.getOrNull();

        if (schemaName == null || "public".equalsIgnoreCase(schemaName)) {
            return loadControlPlaneUser(username);
        }

        LocalDateTime now = now();

        TenantUser user = tenantUserRepository.findByUsernameAndDeletedFalse(username)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado no tenant", 404));

        var authorities = AuthoritiesFactory.forTenant(user);
        return new AuthenticatedUserContext(user, schemaName, now, authorities);
    }

    public UserDetails loadControlPlaneUser(String username, Long accountId) {
        LocalDateTime now = now();

        if (accountId == null) {
            throw new ApiException(
                    "ACCOUNT_REQUIRED",
                    "accountId √© obrigat√≥rio para autenticar usu√°rio da controlplane",
                    400
            );
        }

        ControlPlaneUser user = controlPlaneUserRepository
                .findByUsernameAndAccount_IdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException(
                        "USER_NOT_FOUND",
                        "Usu√°rio controlplane n√£o encontrado para esta conta",
                        404
                ));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return new AuthenticatedUserContext(user, "public", now, authorities);
    }

    public UserDetails loadControlPlaneUser(String username) {
        LocalDateTime now = now();

        ControlPlaneUser user = controlPlaneUserRepository.findByUsernameAndDeletedFalse(username)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio controlplane n√£o encontrado", 404));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return new AuthenticatedUserContext(user, "public", now, authorities);
    }

    public UserDetails loadTenantUser(String username, Long accountId) {
        String schema = TenantContext.getOrNull();
        if (schema == null || "public".equalsIgnoreCase(schema)) {
            throw new ApiException(
                    "TENANT_CONTEXT_REQUIRED",
                    "TenantContext n√£o est√° bindado para autenticar usu√°rio tenant",
                    401
            );
        }

        if (accountId == null) {
            throw new ApiException(
                    "ACCOUNT_REQUIRED",
                    "accountId √© obrigat√≥rio para autenticar usu√°rio tenant",
                    400
            );
        }

        LocalDateTime now = now();

        TenantUser user = tenantUserRepository
                .findByUsernameAndAccountIdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado no tenant", 404));

        var authorities = AuthoritiesFactory.forTenant(user);
        return new AuthenticatedUserContext(user, schema, now, authorities);
    }
}
package brito.com.multitenancy001.infrastructure.tenant;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.tenant.application.provisioning.TenantSchemaProvisioningService;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantProvisioningBridge {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public void ensureSchemaExistsAndMigrate(String schemaName) {
        tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(schemaName);
    }
}
package brito.com.multitenancy001.infrastructure.tenant;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.executor.TenantExecutor;
import brito.com.multitenancy001.infrastructure.executor.TxExecutor;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.application.username.generator.UsernameGeneratorService;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import brito.com.multitenancy001.tenant.security.TenantRole;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantUserAdminBridge {

    private static final String TENANT_USERS_TABLE = "tenant_users";

    private final TenantExecutor tenantExecutor;
    private final TxExecutor txExecutor;

    private final TenantUserRepository tenantUserRepository;
    private final UsernameGeneratorService usernameGenerator;
    private final PasswordEncoder passwordEncoder;

    private final AppClock appClock;

    public List<UserSummaryData> listUserSummaries(String schemaName, Long accountId, boolean onlyActive) {
        tenantExecutor.assertReadyOrThrow(schemaName, TENANT_USERS_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantReadOnlyTx(() -> {

                    var users = onlyActive
                            ? tenantUserRepository.findActiveUsersByAccount(accountId)
                            : tenantUserRepository.findByAccountId(accountId);

                    return users.stream()
                            .map(u -> new UserSummaryData(
                                    u.getId(),
                                    u.getAccountId(),
                                    u.getName(),
                                    u.getUsername(),
                                    u.getEmail(),
                                    u.getRole() == null ? null : u.getRole().name(),
                                    u.isSuspendedByAccount(),
                                    u.isSuspendedByAdmin(),
                                    u.isDeleted()
                            ))
                            .toList();
                })
        );
    }

    public TenantUser createTenantOwner(String schemaName, Long accountId, String email, String rawPassword) {
        tenantExecutor.assertReadyOrThrow(schemaName, TENANT_USERS_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantTx(() -> {

                    boolean emailExists = tenantUserRepository.existsByEmailAndAccountId(email, accountId);
                    if (emailExists) {
                        throw new ApiException("EMAIL_ALREADY_EXISTS", "Email j√° cadastrado nesta conta", 409);
                    }

                    TenantUser u = new TenantUser();
                    u.setAccountId(accountId);
                    u.setName("Administrador");
                    u.setEmail(email);
                    u.setPassword(passwordEncoder.encode(rawPassword));
                    u.setRole(TenantRole.TENANT_ACCOUNT_OWNER);
                    u.setSuspendedByAccount(false);
                    u.setSuspendedByAdmin(false);

                    
                    u.setTimezone("America/Sao_Paulo");
                    u.setLocale("pt_BR");

                    for (int attempt = 0; attempt < 5; attempt++) {
                        u.setUsername(usernameGenerator.generateFromEmail(email, accountId));
                        try {
                            return tenantUserRepository.save(u);
                        } catch (DataIntegrityViolationException e) {
                            log.warn("Colis√£o de username ao criar admin. Tentativa {}. accountId={} email={}",
                                    attempt + 1, accountId, email);
                        }
                    }

                    throw new IllegalStateException("Failed to create tenant admin due to repeated username collisions");
                })
        );
    }

    public List<TenantUser> listUsers(String schemaName, Long accountId, boolean onlyActive) {
        tenantExecutor.assertReadyOrThrow(schemaName, TENANT_USERS_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantReadOnlyTx(() -> onlyActive
                        ? tenantUserRepository.findActiveUsersByAccount(accountId)
                        : tenantUserRepository.findByAccountId(accountId)
                )
        );
    }

    public void setSuspendedByAdmin(String schemaName, Long accountId, Long userId, boolean suspended) {
        tenantExecutor.assertReadyOrThrow(schemaName, TENANT_USERS_TABLE);

        tenantExecutor.run(schemaName, () ->
                txExecutor.tenantTx(() -> {
                    int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
                    if (updated == 0) {
                        throw new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado ou removido", 404);
                    }
                    return null;
                })
        );
    }

    public int suspendAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName, TENANT_USERS_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.suspendAllByAccount(accountId)),
                0
        );
    }

    public int unsuspendAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName, TENANT_USERS_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.unsuspendAllByAccount(accountId)),
                0
        );
    }

    public int softDeleteAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName, TENANT_USERS_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> {
                    List<TenantUser> users = tenantUserRepository.findByAccountId(accountId);

                    // ‚úÖ congela o "agora" uma vez (consist√™ncia)
                    LocalDateTime now = appClock.now();
                    long base = appClock.epochMillis();

                    long seq = 0;
                    for (TenantUser u : users) {
                        if (!u.isDeleted()) {
                            // ‚úÖ sufixo por usu√°rio para evitar colis√£o de username/email
                            u.softDelete(now, base + (seq++));
                            u.setUpdatedAt(now);
                        }
                    }

                    tenantUserRepository.saveAll(users);
                    return users.size();
                }),
                0
        );
    }

    public int restoreAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName, TENANT_USERS_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> {
                    List<TenantUser> users = tenantUserRepository.findByAccountId(accountId);

                    LocalDateTime now = appClock.now();

                    for (TenantUser u : users) {
                        if (u.isDeleted()) {
                            u.restore();
                            u.setUpdatedAt(now);
                        }
                    }

                    tenantUserRepository.saveAll(users);
                    return users.size();
                }),
                0
        );
    }
}
package brito.com.multitenancy001;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
//@EnableCaching
@EnableScheduling
public class Multitenancy001Application {

	public static void main(String[] args) {
		SpringApplication.run(Multitenancy001Application.class, args);
	}

}
package brito.com.multitenancy001.shared.account;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import brito.com.multitenancy001.controlplane.persistence.account.AccountEntitlementsRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsService {

    private final AccountEntitlementsRepository entitlementsRepository;

    /**
     * Resolve entitlements efetivos da conta:
     * - SYSTEM => ilimitado
     * - TENANT => l√™ de account_entitlements
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public AccountEntitlementsSnapshot resolveEffective(Account account) {
        if (account == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "Conta √© obrigat√≥ria", 400);
        }

        if (account.isSystemAccount()) {
            return AccountEntitlementsSnapshot.ofUnlimited();
        }

        AccountEntitlements ent = entitlementsRepository.findById(account.getId())
                .orElseThrow(() -> new ApiException(
                        "ENTITLEMENTS_NOT_FOUND",
                        "Entitlements n√£o encontrados para a conta " + account.getId(),
                        500
                ));

        Integer maxUsers = safePositive(ent.getMaxUsers(), "maxUsers");
        Integer maxProducts = safePositive(ent.getMaxProducts(), "maxProducts");
        Integer maxStorageMb = safePositive(ent.getMaxStorageMb(), "maxStorageMb");

        return AccountEntitlementsSnapshot.ofLimited(maxUsers, maxProducts, maxStorageMb);
    }

    /**
     * Valida quota para cria√ß√£o de usu√°rio.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public boolean canCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        return currentUsers < eff.maxUsers();
    }

    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);

        if (currentUsers >= eff.maxUsers()) {
            throw new ApiException(
                    "QUOTA_MAX_USERS_REACHED",
                    "Limite de usu√°rios atingido para este plano",
                    403
            );
        }
    }

    /**
     * Valida quota para cria√ß√£o de produtos.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanCreateProduct(Account account, long currentProducts) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);

        if (currentProducts >= eff.maxProducts()) {
            throw new ApiException(
                    "QUOTA_MAX_PRODUCTS_REACHED",
                    "Limite de produtos atingido para este plano",
                    403
            );
        }
    }

    /**
     * Valida quota de armazenamento.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanConsumeStorage(Account account, long currentStorageMb, long deltaMb) {
        if (deltaMb < 0) {
            throw new ApiException("INVALID_STORAGE_DELTA", "deltaMb n√£o pode ser negativo", 400);
        }

        AccountEntitlementsSnapshot eff = resolveEffective(account);
        long after = currentStorageMb + deltaMb;

        if (after > eff.maxStorageMb()) {
            throw new ApiException(
                    "QUOTA_MAX_STORAGE_REACHED",
                    "Limite de armazenamento atingido para este plano",
                    403
            );
        }
    }

    // =========================
    // Helpers
    // =========================

    private Integer safePositive(Integer value, String field) {
        if (value == null || value <= 0) {
            throw new ApiException(
                    "INVALID_ENTITLEMENT",
                    "Entitlement inv√°lido: " + field,
                    500
            );
        }
        return value;
    }
}
package brito.com.multitenancy001.shared.account;

public record AccountEntitlementsSnapshot(
        int maxUsers,
        int maxProducts,
        int maxStorageMb,
        boolean unlimited
) {

    public static AccountEntitlementsSnapshot ofUnlimited() {
        return new AccountEntitlementsSnapshot(
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                true
        );
    }

    public static AccountEntitlementsSnapshot ofLimited(int maxUsers, int maxProducts, int maxStorageMb) {
        return new AccountEntitlementsSnapshot(maxUsers, maxProducts, maxStorageMb, false);
    }
}
package brito.com.multitenancy001.shared.account;

import java.time.LocalDateTime;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountResolver {

	private final AccountRepository accountRepository;
	private final AppClock appClock;

	/**
	 * Resolve conta no schema PUBLIC e j√° valida se existe e se est√° ativa. Retorna
	 * apenas um snapshot m√≠nimo (sem expor o dom√≠nio do controlplane).
	 */
	public AccountSnapshot resolveActiveAccountBySlug(String slug) {
		LocalDateTime now = appClock.now();
		TenantContext.clear(); // garante PUBLIC

		Account account = accountRepository.findBySlugAndDeletedFalse(slug)
				.orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta n√£o encontrada", 404));

		if (!account.isActive(now)) {
			throw new ApiException("ACCOUNT_INACTIVE", "Conta inativa", 403);
		}

		return new AccountSnapshot(account.getId(), account.getSchemaName(), account.getStatus().name());
	}
}
package brito.com.multitenancy001.shared.account;

public record AccountSnapshot(
        Long id,
        String schemaName,
        String status
) {}
package brito.com.multitenancy001.shared.api.dto.auth;

public record JwtResponse(
    String accessToken,
    String refreshToken,
    /**
     * HTTP Authorization scheme (ex: "Bearer").
     * N√ÉO confundir com o "authDomain" do JWT (TENANT/CONTROLPLANE/etc).
     */
    String tokenType,
    Long userId,
    String username,
    String email,
    String role,
    Long accountId,
    String tenantSchema
) {
    public JwtResponse {
        if (tokenType == null || tokenType.isEmpty()) {
            tokenType = "Bearer";
        }
    }

    public JwtResponse(
            String accessToken, String refreshToken,
            Long userId, String username, String email,
            String role, Long accountId, String tenantSchema
    ) {
        this(accessToken, refreshToken, "Bearer",
             userId, username, email, role, accountId, tenantSchema);
    }
}
package brito.com.multitenancy001.shared.api.error;



import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiEnumErrorResponse {
    private LocalDateTime timestamp;
    private String error;
    private String message;
    private String field;
    private String invalidValue;
    private List<String> allowedValues;
}package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
public class ApiErrorResponse {

    private LocalDateTime timestamp;
    private String error;
    private String message;

    // üî• novo campo (opcional)
    private List<String> details;
}
package brito.com.multitenancy001.shared.api.error;

import lombok.Getter;

@Getter
public class ApiException extends RuntimeException {

    private static final long serialVersionUID = 1L;
    private final String error;
    private final int status;
    private final Object details;
    private final Object[] allowedValues; // üî• NOVO CAMPO

    // Construtor sem allowedValues
    public ApiException(String error, String message, int status) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = null;
        this.allowedValues = null;
    }

    // Construtor com details
    public ApiException(String error, String message, int status, Object details) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = details;
        this.allowedValues = null;
    }

    // üî• NOVO CONSTRUTOR com allowedValues
    public ApiException(String error, String message, int status, Object details, Object[] allowedValues) {
        super(message);
        this.error = error;
        this.status = status;
        this.details = details;
        this.allowedValues = allowedValues;
    }

    // M√©todo para obter allowedValues
    public Object[] getAllowedValues() {
        return allowedValues;
    }

    // M√©todo para verificar se tem allowedValues
    public boolean hasAllowedValues() {
        return allowedValues != null && allowedValues.length > 0;
    }
}package brito.com.multitenancy001.shared.api.error;

import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RestControllerAdvice
@RequiredArgsConstructor
@Slf4j
public class GlobalExceptionHandler {

    private final AppClock appClock;

    private LocalDateTime now() {
        return appClock.now();
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleNotReadable(HttpMessageNotReadableException ex) {

        Throwable cause = ex.getCause();

        if (cause instanceof InvalidFormatException ife) {
            Class<?> targetType = ife.getTargetType();

            if (targetType != null && targetType.isEnum()) {
                String fieldName = ife.getPath().isEmpty() ? "status" : ife.getPath().get(0).getFieldName();
                String invalidValue = ife.getValue() != null ? ife.getValue().toString() : "null";

                List<String> allowedValues = Arrays.stream(targetType.getEnumConstants())
                        .map(Object::toString)
                        .toList();

                return ResponseEntity.badRequest().body(
                        ApiEnumErrorResponse.builder()
                                .timestamp(now())
                                .error("INVALID_ENUM")
                                .message("Valor inv√°lido para o campo " + fieldName)
                                .field(fieldName)
                                .invalidValue(invalidValue)
                                .allowedValues(allowedValues)
                                .build()
                );
            }
        }

        return ResponseEntity.badRequest().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INVALID_REQUEST_BODY")
                        .message("Corpo da requisi√ß√£o inv√°lido")
                        .build()
        );
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {

        String errorMessage = ex.getMostSpecificCause() != null ? ex.getMostSpecificCause().getMessage() : ex.getMessage();
        if (!StringUtils.hasText(errorMessage)) errorMessage = "";

        log.debug("DataIntegrityViolationException: {}", errorMessage);

        if (errorMessage.contains("company_doc_number")) {
            String cnpj = extractValue(errorMessage, "company_doc_number");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_CNPJ")
                            .message("J√° existe uma conta com o CNPJ " + cnpj)
                            .field("companyDocNumber")
                            .invalidValue(cnpj)
                            .build()
            );
        }

        if (errorMessage.contains("company_email")) {
            String email = extractValue(errorMessage, "company_email");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_EMAIL")
                            .message("J√° existe uma conta com o email " + email)
                            .field("companyEmail")
                            .invalidValue(email)
                            .build()
            );
        }

        if (errorMessage.contains("slug")) {
            String slug = extractValue(errorMessage, "slug");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_SLUG")
                            .message("J√° existe uma conta com o slug " + slug)
                            .field("slug")
                            .invalidValue(slug)
                            .build()
            );
        }

        if (errorMessage.contains("schema_name")) {
            String schema = extractValue(errorMessage, "schema_name");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_SCHEMA")
                            .message("Erro interno: schema " + schema + " j√° existe")
                            .build()
            );
        }

        return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("DUPLICATE_ENTRY")
                        .message("Registro duplicado. Verifique os dados informados.")
                        .build()
        );
    }

    private String extractValue(String message, String fieldName) {
        try {
            // PostgreSQL pt-BR: "Chave (company_doc_number)=(...) j√° existe."
            Pattern pattern = Pattern.compile("\\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher = pattern.matcher(message);
            if (matcher.find()) return matcher.group(1);

            // Alternativo EN: "Key (company_doc_number)=(...) already exists."
            Pattern pattern2 = Pattern.compile("Key \\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher2 = pattern2.matcher(message);
            if (matcher2.find()) return matcher2.group(1);

        } catch (Exception e) {
            log.debug("Erro ao extrair valor do erro de constraint: {}", e.getMessage());
        }

        return "n√£o identificado";
    }

    @ExceptionHandler(ApiException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleApi(ApiException ex) {
        return ResponseEntity.status(ex.getStatus()).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error(ex.getError())
                        .message(ex.getMessage())
                        .build()
        );
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .toList();

        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(now())
                .error("VALIDATION_ERROR")
                .message("Erro de valida√ß√£o")
                .details(errors)
                .build();

        return ResponseEntity.badRequest().body(errorResponse);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiEnumErrorResponse> handleGeneric(Exception ex) {
        // log s√≥ o suficiente (sem stacktrace enorme por padr√£o)
        log.error("Unhandled exception: {}", ex.getMessage(), ex);

        return ResponseEntity.internalServerError().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INTERNAL_SERVER_ERROR")
                        .message("Erro interno inesperado. Contate o suporte.")
                        .build()
        );
    }
}
package brito.com.multitenancy001.shared.context;

import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.infrastructure.multitenancy.hibernate.CurrentTenantSchemaResolver;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TenantContext {

    public static String getOrNull() {
        return CurrentTenantSchemaResolver.resolveBoundTenantOrDefault();
    }

    public static void bind(String tenantId) {
        if (TransactionSynchronizationManager.isActualTransactionActive()) {
            log.error("üî• ERRO GRAVE: bindTenant chamado DENTRO de transa√ß√£o! tenant={}", tenantId);
        }

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (!StringUtils.hasText(normalized)) {
            CurrentTenantSchemaResolver.bindTenantToCurrentThread(null);
            log.info("üîÑ Tenant limpo (sem tenant) | thread={}", Thread.currentThread().threadId());
            return;
        }

        CurrentTenantSchemaResolver.bindTenantToCurrentThread(normalized);
        log.info("üîÑ Tenant bindado | thread={} | tenant={}",
                Thread.currentThread().threadId(),
                normalized);
    }

    public static void clear() {
        CurrentTenantSchemaResolver.unbindTenantFromCurrentThread();
        log.info("üßπ Tenant desbindado | thread={}", Thread.currentThread().threadId());
    }

    // ‚úÖ NOVO: escopo seguro
    public static Scope scope(String tenantId) {
        bind(tenantId);
        return new Scope();
    }

    // ‚úÖ NOVO: escopo PUBLIC expl√≠cito (garante que n√£o ficou tenant pendurado)
    public static Scope publicScope() {
        clear();
        return new Scope();
    }

    public static final class Scope implements AutoCloseable {
        private boolean closed = false;

        private Scope() {}

        @Override
        public void close() {
            if (!closed) {
                TenantContext.clear();
                closed = true;
            }
        }
    }
}
package brito.com.multitenancy001.shared.contracts;

public record UserSummaryData(
        Long id,
        Long accountId,
        String name,
        String username,
        String email,
        String role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted
) {}
package brito.com.multitenancy001.shared.domain.username;

import java.text.Normalizer;
import java.util.Objects;
import java.util.regex.Pattern;

import org.springframework.stereotype.Component;


@Component
public class UsernamePolicy {

	public static final String USERNAME_REGEX = "^[a-z0-9._-]+$";
    public static final int USERNAME_MAX_LENGTH = 100;
    private static final Pattern USERNAME_PATTERN = Pattern.compile("^[a-z0-9._-]+$");

    private static final String FALLBACK_BASE = "user";
    private static final String SEPARATOR = "_";

    public String normalizeBase(String raw) {
        if (raw == null || raw.isBlank()) return FALLBACK_BASE;

        String base = raw.toLowerCase();
        // opcional: remover acentos (se voc√™ quiser aplicar em nome tamb√©m)
        base = Normalizer.normalize(base, Normalizer.Form.NFD).replaceAll("\\p{M}", "");

        base = base.replaceAll("[^a-z0-9._-]", "_")
                   .replaceAll("_{2,}", "_")
                   .replaceAll("^_|_$", "");

        return base.isBlank() ? FALLBACK_BASE : base;
    }

    public boolean isValid(String username) {
        if (username == null) return false;
        if (username.length() < 3 || username.length() > USERNAME_MAX_LENGTH) return false;
        return USERNAME_PATTERN.matcher(username).matches();
    }

    /** Monta base + "_" + suffix respeitando max length, cortando s√≥ base */
    public String build(String base, String suffix) {
        Objects.requireNonNull(suffix, "suffix");

        int maxBaseLen = USERNAME_MAX_LENGTH - SEPARATOR.length() - suffix.length();
        if (maxBaseLen <= 0) {
            base = "u";
            maxBaseLen = 1;
        }

        base = normalizeBase(base);

        if (base.length() > maxBaseLen) {
            base = base.substring(0, maxBaseLen).replaceAll("_+$", "");
            if (base.isBlank()) base = "u";
        }

        return base + SEPARATOR + suffix;
    }

    public String extractBase(String username) {
        if (username == null) return FALLBACK_BASE;
        int idx = username.lastIndexOf(SEPARATOR);
        if (idx <= 0) return normalizeBase(username);
        return normalizeBase(username.substring(0, idx));
    }
}
package brito.com.multitenancy001.shared.security;

public interface PermissionAuthority {
    String asAuthority(); // ex: "CP_USER_READ" ou "TEN_USER_READ"
}
package brito.com.multitenancy001.shared.security;

import java.util.Collection;
import java.util.LinkedHashSet;

public final class PermissionScopeValidator {

    private PermissionScopeValidator() {}

    public static LinkedHashSet<String> normalizeTenant(Collection<String> perms) {
    	LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;
        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            // bloqueia perm de control plane no tenant
            if (x.startsWith("CP_")) {
                throw new IllegalArgumentException("Permission de Control Plane n√£o √© permitida no Tenant: " + x);
            }

            // se n√£o tiver prefixo TEN_, adiciona
            if (!x.startsWith("TEN_")) x = "TEN_" + x;
            out.add(x);
        }
        return out;
    }

    public static LinkedHashSet<String> normalizeControlPlane(Collection<String> perms) {
        LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;
        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            // bloqueia perm de tenant no control plane
            if (x.startsWith("TEN_")) {
                throw new IllegalArgumentException("Permission de Tenant n√£o √© permitida no Control Plane: " + x);
            }

            if (!x.startsWith("CP_")) x = "CP_" + x;
            out.add(x);
        }
        return out;
    }
}
package brito.com.multitenancy001.shared.security;

/**
 * Contrato comum para roles da plataforma e do tenant
 * Permite unifica√ß√£o no Spring Security (GrantedAuthority)
 */
public interface RoleAuthority {

    /**
     * Retorna a authority no padr√£o Spring Security
     *
     */
    String asAuthority();

    /**
     * Helper padr√£o (opcional)
     */
    default boolean isAdmin() {
        return false;
    }
}
package brito.com.multitenancy001.shared.time;

import java.time.Clock;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;

public interface AppClock {

    Clock clock();

    default Instant instant() {
        return Instant.now(clock());
    }

    default LocalDateTime now() {
        return LocalDateTime.now(clock());
    }

    default ZoneId zone() {
        return clock().getZone();
    }

    default long epochMillis() {
        return instant().toEpochMilli();
    }
}
package brito.com.multitenancy001.shared.time;

import java.time.Clock;
import org.springframework.stereotype.Component;

@Component
public class SystemAppClock implements AppClock {

    private final Clock clock;

    public SystemAppClock(Clock clock) {
        this.clock = clock;
    }

    @Override
    public Clock clock() {
        return clock;
    }
}
package brito.com.multitenancy001.shared.validation; // ou .validation

import brito.com.multitenancy001.shared.domain.username.UsernamePolicy;

/**
 * Padr√µes de valida√ß√£o reutiliz√°veis em todo o sistema
 */
public final class ValidationPatterns {
    
    // Username: 3-50 caracteres, letras, n√∫meros, ponto, underscore, h√≠fen
   // public static final String USERNAME_PATTERN = "^[a-zA-Z0-9._-]{3,50}$";
	
	
	// usado pra facilidar no desenvolvimento
	// Username: 3-50 caracteres, APENAS letras (a-z, A-Z) e n√∫meros (0-9)
	public static final String USERNAME_PATTERN = UsernamePolicy.USERNAME_REGEX;
    
    // Password: m√≠nimo 8 caracteres, pelo menos 1 letra mai√∫scula, 1 min√∫scula e 1 n√∫mero
   // public static final String PASSWORD_PATTERN = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$";

    
    
 // ‚ö†Ô∏è APENAS PARA TESTE/DEV - NUNCA EM PRODU√á√ÉO!
    // Password: m√≠nimo 3 caracteres, apenas letras (mai√∫sculas/min√∫sculas)
    // N√£o precisa de n√∫meros nem caracteres especiais
	  public static final String PASSWORD_PATTERN = "^[a-zA-Z0-9]{3,}$";
    
    
    
    
    
    
    // Email: valida√ß√£o b√°sica (Spring j√° tem @Email, mas para refer√™ncia)
    public static final String EMAIL_PATTERN = "^[A-Za-z0-9+_.-]+@(.+)$";
    
    // Nome: apenas letras, espa√ßos e alguns caracteres especiais
    public static final String NAME_PATTERN = "^[a-zA-Z√Ä-√ø\\s'-]{2,100}$";
    
    // Telefone: formato brasileiro
    public static final String PHONE_PATTERN = "^(\\(?\\d{2}\\)?)?\\s?\\d{4,5}-?\\d{4}$";
    
    // CNPJ: formato brasileiro
    public static final String CNPJ_PATTERN = "^\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}$";
    
    // CPF: formato brasileiro
    public static final String CPF_PATTERN = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$";
    
    // CEP: formato brasileiro
    public static final String CEP_PATTERN = "^\\d{5}-\\d{3}$";
    
    // URL: para avatar_url, website, etc.
    public static final String URL_PATTERN = "^(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?$";
    
    // Timezone: formato padr√£o (America/Sao_Paulo)
    public static final String TIMEZONE_PATTERN = "^[A-Za-z_]+/[A-Za-z_]+$";
    
    // Locale: pt_BR, en_US, etc.
    public static final String LOCALE_PATTERN = "^[a-z]{2}_[A-Z]{2}$";
    
    // Currency: BRL, USD, EUR (3 letras)
    public static final String CURRENCY_PATTERN = "^[A-Z]{3}$";
    
    // Hex color: #FFFFFF ou #FFF
    public static final String COLOR_PATTERN = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
    
    // IP Address
    public static final String IP_PATTERN = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
    
    // UUID
    public static final String UUID_PATTERN = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";
    
    // Permiss√µes: UPPER_CASE_WITH_UNDERSCORE
    public static final String PERMISSION_PATTERN = "^[A-Z_]+$";
    
    private ValidationPatterns() {
        // Construtor privado para classe utilit√°ria
        throw new UnsupportedOperationException("Classe utilit√°ria - n√£o instanci√°vel");
    }
    
    /**
     * Valida se um valor corresponde ao padr√£o
     */
    public static boolean isValid(String value, String pattern) {
        return value != null && value.matches(pattern);
    }
    
    /**
     * Valida username com mensagem descritiva
     */
    public static void validateUsername(String username) {
        if (username == null || !username.matches(USERNAME_PATTERN)) {
            throw new IllegalArgumentException(
                "Username deve ter 3-50 caracteres e conter apenas: " +
                "letras (a-z, A-Z), n√∫meros (0-9), ponto (.), underscore (_), h√≠fen (-)"
            );
        }
    }
    
    /**
     * Valida password com mensagem descritiva
     */
    public static void validatePassword(String password) {
        if (password == null || !password.matches(PASSWORD_PATTERN)) {
            throw new IllegalArgumentException(
                "Senha deve ter pelo menos 8 caracteres contendo: " +
                "1 letra mai√∫scula, 1 letra min√∫scula e 1 n√∫mero"
            );
        }
    }
}package brito.com.multitenancy001.tenant.api.controller.auth;

import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.application.auth.TenantAuthService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantAuthController {

    private final TenantAuthService tenantAuthService;

    @PostMapping("/login")
    public ResponseEntity<JwtResponse> loginTenant(@Valid @RequestBody TenantLoginRequest tenantLoginRequest) {
        JwtResponse jwtResponse = tenantAuthService.loginTenant(tenantLoginRequest);
        return ResponseEntity.ok(jwtResponse);
    }
}
package brito.com.multitenancy001.tenant.api.controller.auth;

import brito.com.multitenancy001.tenant.api.dto.auth.ForgotPasswordRequest;
import brito.com.multitenancy001.tenant.api.dto.auth.ResetPasswordRequest;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/password")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantPasswordController {

    private final TenantUserService tenantUserService;

    @PostMapping("/forgot")
    public ResponseEntity<String> forgotPassword(@Valid @RequestBody ForgotPasswordRequest forgotPasswordRequest) {
        tenantUserService.generatePasswordResetToken(forgotPasswordRequest.slug(), forgotPasswordRequest.email());
        return ResponseEntity.ok("Token gerado");
    }

    @PostMapping("/reset")
    public ResponseEntity<String> resetPassword(@Valid @RequestBody ResetPasswordRequest resetPasswordRequest) {
        tenantUserService.resetPasswordWithToken(resetPasswordRequest.token(), resetPasswordRequest.newPassword());
        return ResponseEntity.ok("Senha redefinida com sucesso");
    }
}
package brito.com.multitenancy001.tenant.api.controller.billing;

import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.controlplane.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.controlplane.application.billing.PaymentService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/billing/payments")
@RequiredArgsConstructor
public class TenantPaymentController {

    private final PaymentService paymentService;

    // =========================
    // MY TENANT (SAFE DEFAULT)
    // =========================

    @PostMapping
    @PreAuthorize("hasAuthority('TEN_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> processPayment(@Valid @RequestBody PaymentRequest paymentRequest) {
        PaymentResponse response = paymentService.processPaymentForMyAccount(paymentRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/{paymentId}")
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<PaymentResponse> getById(@PathVariable Long paymentId) {
        return ResponseEntity.ok(paymentService.getPaymentByIdForMyAccount(paymentId));
    }

    @GetMapping
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getMyPayments() {
        return ResponseEntity.ok(paymentService.getPaymentsByMyAccount());
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<Boolean> hasActivePaymentMyAccount() {
        return ResponseEntity.ok(paymentService.hasActivePaymentMyAccount());
    }
}
package brito.com.multitenancy001.tenant.api.controller.products;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.api.dto.products.ProductUpsertRequest;
import brito.com.multitenancy001.tenant.api.mapper.ProductApiMapper;
import brito.com.multitenancy001.tenant.application.product.TenantProductService;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.product.Product;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/tenant/products")
@RequiredArgsConstructor
public class TenantProductController {

    private final ProductApiMapper productApiMapper;
    private final TenantProductService tenantProductService;

    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByCategory(@PathVariable Long categoryId) {
        List<Product> products = tenantProductService.findByCategoryId(categoryId);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/brand/{brand}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByBrand(@PathVariable String brand) {
        List<Product> products = tenantProductService.findByBrand(brand);
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getActiveProducts() {
        List<Product> products = tenantProductService.findActiveProducts();
        List<ProductResponse> dtos = products.stream().map(productApiMapper::toResponse).toList();
        return ResponseEntity.ok(dtos);
    }

    @PatchMapping("/{id}/cost-price")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> updateCostPrice(
            @PathVariable UUID id,
            @RequestParam BigDecimal costPrice
    ) {
        Product updatedProduct = tenantProductService.updateCostPrice(id, costPrice);
        return ResponseEntity.ok(productApiMapper.toResponse(updatedProduct));
    }

    @GetMapping("/inventory-value")
    @PreAuthorize("hasAuthority('TEN_INVENTORY_READ')")
    public ResponseEntity<BigDecimal> getTotalInventoryValue() {
        BigDecimal value = tenantProductService.calculateTotalInventoryValue();
        return ResponseEntity.ok(value != null ? value : BigDecimal.ZERO);
    }

    @GetMapping("/low-stock/count")
    @PreAuthorize("hasAuthority('TEN_INVENTORY_READ')")
    public ResponseEntity<Long> countLowStockProducts(@RequestParam(defaultValue = "10") Integer threshold) {
        Long count = tenantProductService.countLowStockProducts(threshold);
        return ResponseEntity.ok(count != null ? count : 0L);
    }

    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> toggleActive(@PathVariable UUID id) {
        Product product = tenantProductService.findById(id);
        product.setActive(!Boolean.TRUE.equals(product.getActive()));
        tenantProductService.create(product);
        return ResponseEntity.ok(productApiMapper.toResponse(product));
    }

    @PostMapping("/detailed")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> createDetailedProduct(@Valid @RequestBody ProductUpsertRequest productUpsertRequest) {

        Product product = new Product();
        product.setName(productUpsertRequest.name());
        product.setDescription(productUpsertRequest.description());
        product.setSku(productUpsertRequest.sku());
        product.setPrice(productUpsertRequest.price());
        product.setStockQuantity(productUpsertRequest.stockQuantity());
        product.setMinStock(productUpsertRequest.minStock());
        product.setMaxStock(productUpsertRequest.maxStock());
        product.setCostPrice(productUpsertRequest.costPrice());
        product.setBrand(productUpsertRequest.brand());
        product.setWeightKg(productUpsertRequest.weightKg());
        product.setDimensions(productUpsertRequest.dimensions());
        product.setBarcode(productUpsertRequest.barcode());
        product.setActive(productUpsertRequest.active());

        Category category = new Category();
        category.setId(productUpsertRequest.categoryId());
        product.setCategory(category);

        if (productUpsertRequest.subcategoryId() != null) {
            Subcategory sub = new Subcategory();
            sub.setId(productUpsertRequest.subcategoryId());
            product.setSubcategory(sub);
        }

        if (productUpsertRequest.supplierId() != null) {
            Supplier supplier = new Supplier();
            supplier.setId(productUpsertRequest.supplierId());
            product.setSupplier(supplier);
        }

        Product savedProduct = tenantProductService.create(product);
        return ResponseEntity.status(HttpStatus.CREATED).body(productApiMapper.toResponse(savedProduct));
    }
}
package brito.com.multitenancy001.tenant.api.controller.users.admin;

import brito.com.multitenancy001.tenant.api.dto.users.admin.TenantUserAdminSuspendRequest;
import brito.com.multitenancy001.tenant.application.user.admin.TenantUserAdminService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/admin/users")
@RequiredArgsConstructor
public class TenantUserAdminController {

    private final TenantUserAdminService tenantUserAdminService;

    @PatchMapping("/{userId}/suspend")
    @PreAuthorize("hasAuthority('TEN_USER_SUSPEND')")
    public ResponseEntity<Void> suspendUser(
            @PathVariable Long userId,
            @RequestBody TenantUserAdminSuspendRequest tenantUserAdminSuspendRequest
    ) {
        tenantUserAdminService.setUserSuspendedByAdmin(userId, tenantUserAdminSuspendRequest.suspended());
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.tenant.api.controller.users;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/users")
@RequiredArgsConstructor
public class TenantUserController {

    private final TenantUserService tenantUserService;

    @PatchMapping("/{userId}/transfer-admin")
    @PreAuthorize("hasAuthority('TEN_ROLE_TRANSFER')")
    public ResponseEntity<Void> transferTenantOwner(@PathVariable Long userId) {
        tenantUserService.transferTenantOwner(userId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping
    @PreAuthorize("hasAuthority('TEN_USER_CREATE')")
    public ResponseEntity<TenantUserDetailsResponse> createTenantUser(@Valid @RequestBody TenantUserCreateRequest tenantUserCreateRequest) {
        TenantUserDetailsResponse response = tenantUserService.createTenantUser(tenantUserCreateRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<List<TenantUserSummaryResponse>> listTenantUsers() {
        List<TenantUserSummaryResponse> users = tenantUserService.listTenantUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<List<TenantUserSummaryResponse>> listActiveTenantUsers() {
        List<TenantUserSummaryResponse> users = tenantUserService.listActiveTenantUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<TenantUserDetailsResponse> getTenantUser(@PathVariable Long userId) {
        TenantUserDetailsResponse user = tenantUserService.getTenantUser(userId);
        return ResponseEntity.ok(user);
    }

    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAuthority('TEN_USER_UPDATE')")
    public ResponseEntity<TenantUserSummaryResponse> updateTenantUserStatus(
            @PathVariable Long userId,
            @RequestParam boolean active
    ) {
        TenantUserSummaryResponse response = tenantUserService.updateTenantUserStatus(userId, active);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_DELETE')")
    public ResponseEntity<Void> deleteTenantUser(@PathVariable Long userId) {
        tenantUserService.softDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority('TEN_USER_RESTORE')")
    public ResponseEntity<TenantUserSummaryResponse> restoreTenantUser(@PathVariable Long userId) {
        TenantUserSummaryResponse response = tenantUserService.restoreTenantUser(userId);
        return ResponseEntity.ok(response);
    }

    @PatchMapping("/{userId}/password")
    @PreAuthorize("hasAuthority('TEN_USER_UPDATE')")
    public ResponseEntity<TenantUserSummaryResponse> resetTenantUserPassword(
            @PathVariable Long userId,
            @RequestParam
            @Pattern(
                    regexp = ValidationPatterns.PASSWORD_PATTERN,
                    message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas e n√∫meros"
            )
            String newPassword
    ) {
        TenantUserSummaryResponse response = tenantUserService.resetTenantUserPassword(userId, newPassword);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{userId}/hard")
    @PreAuthorize("hasAuthority('TEN_USER_DELETE')")
    public ResponseEntity<Void> hardDeleteTenantUser(@PathVariable Long userId) {
        tenantUserService.hardDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }
}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ForgotPasswordRequest(
        @NotBlank String slug,
        @NotBlank @Email String email
) {}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record ResetPasswordRequest(
        @NotBlank String token,
        @NotBlank
        @Pattern(
          regexp = ValidationPatterns.PASSWORD_PATTERN,
          message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas, n√∫meros e caracteres especiais"
        )
        String newPassword
) {}
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record TenantLoginRequest(
	    @NotBlank String username,
	    @NotBlank String password,
	    @NotBlank String slug
	) {}
package brito.com.multitenancy001.tenant.api.dto.products;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

public record ProductResponse(
        UUID id,
        @NotBlank String name,
        String description,
        String sku,
        @NotNull @PositiveOrZero BigDecimal price,
        @PositiveOrZero Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        BigDecimal profitMargin,

        Long categoryId,
        String categoryName,
        Long subcategoryId,
        String subcategoryName,

        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,

        UUID supplierId,
        String supplierName,

        LocalDateTime createdAt,
        LocalDateTime updatedAt
) {
    public ProductResponse {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }

  
}
package brito.com.multitenancy001.tenant.api.dto.products;

import java.math.BigDecimal;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

// Record para cria√ß√£o/atualiza√ß√£o expandido (com Category/Subcategory por ID)
public record ProductUpsertRequest(
     @NotBlank String name,
     String description,
     String sku,
     @NotNull @PositiveOrZero BigDecimal price,
     @PositiveOrZero Integer stockQuantity,
     Integer minStock,
     Integer maxStock,
     BigDecimal costPrice,

     @NotNull Long categoryId,     // ‚úÖ obrigat√≥rio
     Long subcategoryId,           // ‚úÖ opcional

     String brand,
     BigDecimal weightKg,
     String dimensions,
     String barcode,
     Boolean active,
     UUID supplierId
) {
    public ProductUpsertRequest {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}
package brito.com.multitenancy001.tenant.api.dto.users.admin;

public record TenantUserAdminSuspendRequest(boolean suspended) {}package brito.com.multitenancy001.tenant.api.dto.users;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.LinkedHashSet;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantRole;

@Builder
public record TenantUserCreateRequest(
    
    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String name,
    
    @NotBlank(message = "Username √© obrigat√≥rio")
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inv√°lido...")
    @Size(min = 3, max = 50, message = "Username inv√°lido. Use apenas letras, n√∫meros, . e _")
    String username,

    
    @NotBlank(message = "Email √© obrigat√≥rio")
    @Email(message = "Email inv√°lido")
    @Size(max = 150, message = "Email n√£o pode exceder 150 caracteres")
    String email,
    
    @NotBlank(message = "Senha √© obrigat√≥ria")
    @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, 
             message = "Senha fraca. Use pelo menos 8 caracteres com letras mai√∫sculas, min√∫sculas, n√∫meros e caracteres especiais")
    String password,
    
    @NotNull(message = "Role √© obrigat√≥ria")
    TenantRole role,
    
    LinkedHashSet<String> permissions,
    
    // üîπ CAMPOS NOVOS para UserTenant
    @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, 
             message = "Telefone inv√°lido")
    @Size(max = 20, message = "Telefone n√£o pode exceder 20 caracteres")
    String phone,
    
    @Size(max = 500, message = "URL do avatar n√£o pode exceder 500 caracteres")
    String avatarUrl
    
) {
    
	public TenantUserCreateRequest {
	    if (name != null) name = name.trim();
	    if (username != null) username = username.trim();
	    if (email != null) email = email.trim();

	    if (phone != null) phone = phone.trim();
	    if (avatarUrl != null) avatarUrl = avatarUrl.trim();
	}

}package brito.com.multitenancy001.tenant.api.dto.users;

public record TenantUserDetailsResponse(
        Long id,
        Long accountId,
        String name,
        String username,
        String email,
        String role,
        String phone,
        String avatarUrl,
        String timezone,
        String locale,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}
package brito.com.multitenancy001.tenant.api.dto.users;

public record TenantUserSummaryResponse(
        Long id,
        String username,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.domain.product.Product;

@Component
public class ProductApiMapper {

    public ProductResponse toResponse(Product product) {
        return new ProductResponse(
            product.getId(),
            product.getName(),
            product.getDescription(),
            product.getSku(),
            product.getPrice(),
            product.getStockQuantity(),
            product.getMinStock(),
            product.getMaxStock(),
            product.getCostPrice(),
            product.getProfitMargin(),

            product.getCategory() != null ? product.getCategory().getId() : null,
            product.getCategory() != null ? product.getCategory().getName() : null,
            product.getSubcategory() != null ? product.getSubcategory().getId() : null,
            product.getSubcategory() != null ? product.getSubcategory().getName() : null,

            product.getBrand(),
            product.getWeightKg(),
            product.getDimensions(),
            product.getBarcode(),
            product.getActive(),

            product.getSupplier() != null ? product.getSupplier().getId() : null,
            product.getSupplier() != null ? product.getSupplier().getName() : null,

            product.getCreatedAt(),
            product.getUpdatedAt()
        );
    }
}
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;

@Component
public class TenantUserApiMapper {

    public TenantUserSummaryResponse toSummary(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantUserSummaryResponse(
                tenantUser.getId(),
                tenantUser.getUsername(),
                tenantUser.getEmail(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                enabled
        );
    }

    public TenantUserDetailsResponse toDetails(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantUserDetailsResponse(
                tenantUser.getId(),
                tenantUser.getAccountId(),
                tenantUser.getName(),
                tenantUser.getUsername(),
                tenantUser.getEmail(),
                tenantUser.getRole() != null ? tenantUser.getRole().name() : null,
                tenantUser.getPhone(),
                tenantUser.getAvatarUrl(),
                tenantUser.getTimezone(),
                tenantUser.getLocale(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                tenantUser.isDeleted(),
                enabled
        );
    }
}
package brito.com.multitenancy001.tenant.application.auth;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.account.AccountResolver;
import brito.com.multitenancy001.shared.account.AccountSnapshot;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantAuthService {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final AccountResolver accountResolver;

    private final TenantUserRepository tenantUserRepository;

    public JwtResponse loginTenant(TenantLoginRequest tenantLoginRequest) {

        // 1Ô∏è‚É£ PUBLIC ‚Äî resolve conta
        TenantContext.clear();

        AccountSnapshot account = accountResolver.resolveActiveAccountBySlug(tenantLoginRequest.slug());

        

        // 2Ô∏è‚É£ TENANT ‚Äî bind correto
        TenantContext.bind(account.schemaName());

        try {
            Authentication authentication =
                    authenticationManager.authenticate(
                            new UsernamePasswordAuthenticationToken(
                                    tenantLoginRequest.username(),
                                    tenantLoginRequest.password()
                            )
                    );

            TenantUser user = tenantUserRepository
                    .findByUsernameAndAccountId(
                            tenantLoginRequest.username(),
                            account.id()
                    )
                    .orElseThrow(() -> new ApiException(
                            "USER_NOT_FOUND",
                            "Usu√°rio n√£o encontrado",
                            404
                    ));


            if (user.isSuspendedByAccount() || user.isDeleted()) {
                throw new ApiException(
                        "USER_INACTIVE",
                        "Usu√°rio inativo",
                        403
                );
            }

            String accessToken = tokenProvider.generateTenantToken(
                    authentication,
                    account.id(),
                    account.schemaName()
            );
            
            
            String refreshToken = tokenProvider.generateRefreshToken(
                    user.getUsername(),
                    account.schemaName()
            );


            return new JwtResponse(
                    accessToken,
                    refreshToken,
                    user.getId(),
                    user.getUsername(),
                    user.getEmail(),
                    user.getRole().name(),
                    account.id(),
                    account.schemaName()
            );

        } finally {
            TenantContext.clear();
        }
    }
}
// ===============================
// ProductService.java
// (corrigido: resolveCategoryAndSubcategory sem duplica√ß√£o,
//  update limpando subcategory quando vier null,
//  usando findByIdWithCategory pra validar)
// ===============================
package brito.com.multitenancy001.tenant.application.product;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.product.Product;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import brito.com.multitenancy001.tenant.persistence.category.CategoryRepository;
import brito.com.multitenancy001.tenant.persistence.category.SubcategoryRepository;
import brito.com.multitenancy001.tenant.persistence.product.ProductRepository;
import brito.com.multitenancy001.tenant.persistence.supplier.SupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProductService {

    private final ProductRepository productRepository;
    private final SupplierRepository supplierRepository;
    private final CategoryRepository categoryRepository;
    private final SubcategoryRepository subcategoryRepository;
    private final AppClock appClock;

    @Transactional(readOnly = true)
    public Page<Product> findAll(Pageable pageable) {
        return productRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    public Product findById(UUID id) {
        return productRepository.findById(id)
            .orElseThrow(() -> new ApiException("PRODUCT_NOT_FOUND",
                "Produto n√£o encontrado com ID: " + id, 404));
    }

    @Transactional
    public Product create(Product product) {
        validateProduct(product);

        resolveCategoryAndSubcategory(product);
        resolveSupplier(product);
        validateSubcategoryBelongsToCategory(product);

        return productRepository.save(product);
    }

    @Transactional
    public Product update(UUID id, Product productDetails) {
        Product existingProduct = findById(id);

        if (StringUtils.hasText(productDetails.getName())) {
            existingProduct.setName(productDetails.getName());
        }

        if (productDetails.getDescription() != null) {
            existingProduct.setDescription(productDetails.getDescription());
        }

        if (StringUtils.hasText(productDetails.getSku())) {
            Optional<Product> productWithSku = productRepository.findBySku(productDetails.getSku());
            if (productWithSku.isPresent() && !productWithSku.get().getId().equals(id)) {
                throw new ApiException("SKU_ALREADY_EXISTS",
                    "SKU j√° cadastrado: " + productDetails.getSku(), 409);
            }
            existingProduct.setSku(productDetails.getSku());
        }

        if (productDetails.getPrice() != null) {
            validatePrice(productDetails.getPrice());
            existingProduct.setPrice(productDetails.getPrice());
        }

        if (productDetails.getStockQuantity() != null) {
            existingProduct.setStockQuantity(productDetails.getStockQuantity());
        }

        // ‚úÖ category
        if (productDetails.getCategory() != null && productDetails.getCategory().getId() != null) {
            Category category = categoryRepository.findById(productDetails.getCategory().getId())
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria n√£o encontrada", 404));
            existingProduct.setCategory(category);
        }

        // ‚úÖ subcategory (se veio ID)
        if (productDetails.getSubcategory() != null && productDetails.getSubcategory().getId() != null) {
            Subcategory sub = subcategoryRepository.findByIdWithCategory(productDetails.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria n√£o encontrada", 404));
            existingProduct.setSubcategory(sub);
        }

        // ‚úÖ se veio explicitamente subcategory = null -> limpa
        if (productDetails.getSubcategory() == null) {
            existingProduct.setSubcategory(null);
        }

        // ‚úÖ supplier
        if (productDetails.getSupplier() != null && productDetails.getSupplier().getId() != null) {
            Supplier supplier = supplierRepository.findById(productDetails.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND", "Fornecedor n√£o encontrado", 404));
            existingProduct.setSupplier(supplier);
        }

        validateSubcategoryBelongsToCategory(existingProduct);

        return productRepository.save(existingProduct);
    }

    private void resolveSupplier(Product product) {
        if (product.getSupplier() != null && product.getSupplier().getId() != null) {
            UUID supplierId = product.getSupplier().getId();
            Supplier supplier = supplierRepository.findById(product.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                    "Fornecedor n√£o encontrado com ID: " + supplierId, 404));
            product.setSupplier(supplier);
        }
    }


    private void resolveCategoryAndSubcategory(Product product) {
        // ‚úÖ category obrigat√≥ria
        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria √© obrigat√≥ria", 400);
        }

        Category category = categoryRepository.findById(product.getCategory().getId())
            .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria n√£o encontrada", 404));
        product.setCategory(category);

        // ‚úÖ subcategory opcional
        if (product.getSubcategory() != null && product.getSubcategory().getId() != null) {
            Subcategory sub = subcategoryRepository.findByIdWithCategory(product.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria n√£o encontrada", 404));
            product.setSubcategory(sub);
        } else {
            product.setSubcategory(null);
        }
    }

    private void validateSubcategoryBelongsToCategory(Product product) {
        if (product.getSubcategory() == null) return;

        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria √© obrigat√≥ria", 400);
        }

        if (product.getSubcategory().getCategory() == null
            || product.getSubcategory().getCategory().getId() == null) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria sem categoria associada (cadastro inconsistente)", 409);
        }

        Long subCatCategoryId = product.getSubcategory().getCategory().getId();
        Long productCategoryId = product.getCategory().getId();

        if (!subCatCategoryId.equals(productCategoryId)) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria n√£o pertence √† categoria informada", 409);
        }
    }

    // ======= outros m√©todos =======

    @Transactional(readOnly = true)
    public List<Product> searchProducts(String name, String sku, BigDecimal minPrice,
                                        BigDecimal maxPrice, Integer minStock, Integer maxStock) {
        return productRepository.searchProducts(name, minPrice, maxPrice, minStock, maxStock);
    }

    @Transactional(readOnly = true)
    public List<Product> findLowStock(Integer threshold) {
        return productRepository.findByStockQuantityLessThan(threshold);
    }

    @Transactional
    public Product updateStock(UUID id, Integer quantityChange) {
        Product product = findById(id);
        if (quantityChange > 0) product.addToStock(quantityChange);
        else if (quantityChange < 0) product.removeFromStock(Math.abs(quantityChange));
        return productRepository.save(product);
    }

    @Transactional
    public Product updatePrice(UUID id, BigDecimal newPrice) {
        validatePrice(newPrice);
        Product product = findById(id);
        product.updatePrice(newPrice);
        return productRepository.save(product);
    }

    @Transactional
    public void delete(UUID id) {
        Product product = findById(id);
        product.softDelete(appClock.now());
        productRepository.save(product);
    }

    private void validateProduct(Product product) {
        if (!StringUtils.hasText(product.getName())) {
            throw new ApiException("PRODUCT_NAME_REQUIRED", "Nome do produto √© obrigat√≥rio", 400);
        }
        if (product.getPrice() == null) {
            throw new ApiException("PRODUCT_PRICE_REQUIRED", "Pre√ßo do produto √© obrigat√≥rio", 400);
        }
        validatePrice(product.getPrice());

        if (product.getStockQuantity() == null) product.setStockQuantity(0);
        if (product.getStockQuantity() < 0) {
            throw new ApiException("INVALID_STOCK", "Quantidade em estoque n√£o pode ser negativa", 400);
        }
    }

    private void validatePrice(BigDecimal price) {
        if (price == null) throw new ApiException("INVALID_PRICE", "Pre√ßo n√£o pode ser nulo", 400);
        if (price.compareTo(BigDecimal.ZERO) < 0) throw new ApiException("INVALID_PRICE", "Pre√ßo n√£o pode ser negativo", 400);
        if (price.compareTo(BigDecimal.valueOf(1_000_000)) > 0) {
            throw new ApiException("PRICE_TOO_HIGH", "Pre√ßo muito alto. Valor m√°ximo permitido: 1.000.000", 400);
        }
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryId(Long categoryId) {
        return productRepository.findByCategory_Id(categoryId);
    }

    @Transactional(readOnly = true)
    public List<Product> findByBrand(String brand) {
        return productRepository.findAll().stream()
            .filter(p -> brand.equals(p.getBrand()))
            .toList();
    }

    @Transactional(readOnly = true)
    public List<Product> findActiveProducts() {
        return productRepository.findAll().stream()
            .filter(p -> Boolean.TRUE.equals(p.getActive()) && !Boolean.TRUE.equals(p.getDeleted()))
            .toList();
    }

    @Transactional
    public Product updateCostPrice(UUID id, BigDecimal costPrice) {
        Product product = findById(id);
        product.updateCostPrice(costPrice);
        return productRepository.save(product);
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateTotalInventoryValue() {
        return productRepository.calculateTotalInventoryValue();
    }

    @Transactional(readOnly = true)
    public Long countLowStockProducts(Integer threshold) {
        return productRepository.countLowStock(threshold);
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProvisioningService {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public void createSchemaAndMigrate(String schemaName) {
        tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(schemaName);
    }
}
package brito.com.multitenancy001.tenant.application.provisioning;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.infrastructure.flyway.tenantschema.TenantSchemaFlywayMigrationService;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import brito.com.multitenancy001.tenant.security.TenantRole;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.regex.Pattern;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Slf4j
@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningService {

    private final JdbcTemplate jdbcTemplate;
    private final TenantSchemaFlywayMigrationService tenantSchemaMigrationService;
    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;
    
    
    private static final Pattern SCHEMA_PATTERN = Pattern.compile("^[a-zA-Z0-9_]+$");
    
   

    

    private void validateSchemaNameOrThrow(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new ApiException("INVALID_SCHEMA", "Schema inv√°lido", 400);
        }

        String trimmed = schemaName.trim();

        if ("public".equalsIgnoreCase(trimmed)) {
            throw new ApiException("INVALID_SCHEMA", "Schema 'public' n√£o √© permitido", 400);
        }

        if (!SCHEMA_PATTERN.matcher(trimmed).matches()) {
            throw new ApiException(
                    "INVALID_SCHEMA",
                    "Schema inv√°lido: use apenas letras, n√∫meros e _ (underscore)",
                    400
            );
        }
    }

    

    public boolean schemaExists(String schemaName) {
        if (!StringUtils.hasText(schemaName)) return false;

        String normalized = schemaName.trim();

        if ("public".equalsIgnoreCase(normalized)) return false;

        String sql = "SELECT EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = ?)";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, normalized);
        return Boolean.TRUE.equals(exists);
    }

   

    public boolean tableExists(String schemaName, String tableName) {
        if (!StringUtils.hasText(schemaName) || !StringUtils.hasText(tableName)) return false;

        String sql =
                "SELECT EXISTS(" +
                "  SELECT 1 FROM information_schema.tables " +
                "  WHERE table_schema = ? AND table_name = ?" +
                ")";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, schemaName, tableName);
        return Boolean.TRUE.equals(exists);
    }

    public void ensureSchemaExistsAndMigrate(String schemaName) {
        validateSchemaNameOrThrow(schemaName);

        String normalized = schemaName.trim().toLowerCase();


        if (!schemaExists(normalized)) {
            log.info("üì¶ Criando schema {}", normalized);
            jdbcTemplate.execute("CREATE SCHEMA IF NOT EXISTS \"" + normalized + "\"");
        }

        log.info("üß¨ Rodando migrations do tenant: {}", normalized);
        tenantSchemaMigrationService.migrateTenantSchema(normalized);
    }

    /**
     * Deve ser chamado com TenantContext j√° bindado no schema do tenant
     */
    public TenantUser tenantOwnerBootstrapService(Account account, String username, String email, String rawPassword) {
        String bound = TenantContext.getOrNull();
        if (bound == null || !bound.equals(account.getSchemaName())) {
            throw new ApiException("TENANT_NOT_BOUND", "Tenant n√£o est√° bindado no schema esperado", 500);
        }

        String normUsername = username == null ? null : username.trim().toLowerCase();
        String normEmail = email == null ? null : email.trim().toLowerCase();

        if (!StringUtils.hasText(normUsername)) {
            throw new ApiException("INVALID_USERNAME", "Username √© obrigat√≥rio", 400);
        }
        if (!StringUtils.hasText(normEmail)) {
            throw new ApiException("INVALID_EMAIL", "Email √© obrigat√≥rio", 400);
        }

        boolean existsUser = tenantUserRepository.existsByUsernameAndAccountId(normUsername, account.getId());
        boolean existsEmail = tenantUserRepository.existsByEmailAndAccountId(normEmail, account.getId());

        if (existsUser) throw new ApiException("ADMIN_EXISTS", "J√° existe usu√°rio com este username", 409);
        if (existsEmail) throw new ApiException("ADMIN_EXISTS", "J√° existe usu√°rio com este email", 409);

        TenantUser admin = TenantUser.builder()
                .accountId(account.getId())
                .name("Administrador")
                .username(normUsername)
                .email(normEmail)
                .password(passwordEncoder.encode(rawPassword))
                .role(TenantRole.TENANT_ACCOUNT_OWNER)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .timezone(account.getTimezone() != null ? account.getTimezone() : "America/Sao_Paulo")
                .locale(account.getLocale() != null ? account.getLocale() : "pt_BR")
                .build();

        return tenantUserRepository.save(admin);
    }
}
package brito.com.multitenancy001.tenant.application.user.admin;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.application.user.TenantUserTxService;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantUserAdminService {

    private final TenantUserTxService tenantUserTxService;
    private final SecurityUtils securityUtils;

    private void runInTenant(String schema, Runnable action) {
        TenantContext.bind(schema);
        try {
            action.run();
        } finally {
            TenantContext.clear();
        }
    }

    public void setUserSuspendedByAdmin(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () ->
                tenantUserTxService.setSuspendedByAdmin(userId, accountId, suspended)
        );
    }
}
package brito.com.multitenancy001.tenant.application.user;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.account.AccountResolver;
import brito.com.multitenancy001.shared.account.AccountSnapshot;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.LinkedHashSet;
import java.util.List;
import java.util.concurrent.Callable;

@Service
@RequiredArgsConstructor
public class TenantUserService {

    private final TenantUserApiMapper tenantUserApiMapper;

    private final TenantUserTxService tenantUserTxService;
    private final AccountResolver accountResolver;
    private final JwtTokenProvider jwtTokenProvider;
    private final SecurityUtils securityUtils;
    private final AppClock appClock;


    // ===== helpers =====
    private <T> T runInTenant(String schema, Callable<T> action) {
        TenantContext.bind(schema);
        try {
            return action.call();
        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            TenantContext.clear();
        }
    }

    private void runInTenant(String schema, Runnable action) {
        TenantContext.bind(schema);
        try {
            action.run();
        } finally {
            TenantContext.clear();
        }
    }

    // =========================================================
    // CONTROLLER METHODS
    // =========================================================

    public void transferTenantOwner(Long toUserId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long fromUserId = securityUtils.getCurrentUserId();

        runInTenant(schema, () ->
                tenantUserTxService.transferTenantOwnerRole(accountId, fromUserId, toUserId)
        );
    }

    public TenantUserDetailsResponse createTenantUser(TenantUserCreateRequest tenantUserCreateRequest) {
    Long accountId = securityUtils.getCurrentAccountId();
    String schema = securityUtils.getCurrentSchema();

  

    String name = tenantUserCreateRequest.name().trim();
    String username = tenantUserCreateRequest.username().trim().toLowerCase();
    String email = tenantUserCreateRequest.email().trim().toLowerCase();


    final LinkedHashSet<String> perms =
            (tenantUserCreateRequest.permissions() == null || tenantUserCreateRequest.permissions().isEmpty())
                    ? null
                    : new LinkedHashSet<>(tenantUserCreateRequest.permissions());

    return runInTenant(schema, () -> {
    	TenantUser created = tenantUserTxService.createTenantUser(
    	        accountId,
    	        name,                             // j√° trimado
    	        username,
    	        email,
    	        tenantUserCreateRequest.password(),
    	        tenantUserCreateRequest.role(),
    	        tenantUserCreateRequest.phone(),
    	        tenantUserCreateRequest.avatarUrl(),
    	        perms
    	);


        return tenantUserApiMapper.toDetails(created);
    });
}


    public List<TenantUserSummaryResponse> listTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () ->
                tenantUserTxService.listUsers(accountId)
                        .stream()
                        .map(tenantUserApiMapper::toSummary)
                        .toList()
        );
    }

    public List<TenantUserSummaryResponse> listActiveTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () ->
                tenantUserTxService.listActiveUsers(accountId)
                        .stream()
                        .map(tenantUserApiMapper::toSummary)
                        .toList()
        );
    }

    public TenantUserDetailsResponse getTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> {
            TenantUser user = tenantUserTxService.getUser(userId, accountId);
            return tenantUserApiMapper.toDetails(user);
        });
    }

    public TenantUserSummaryResponse updateTenantUserStatus(Long userId, boolean active) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> {
            TenantUser updated = tenantUserTxService.updateStatus(userId, accountId, active);
            return tenantUserApiMapper.toSummary(updated);
        });
    }

    public void softDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () -> tenantUserTxService.softDelete(userId, accountId));
    }

    public TenantUserSummaryResponse restoreTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> {
            TenantUser restored = tenantUserTxService.restore(userId, accountId);
            return tenantUserApiMapper.toSummary(restored);
        });
    }

    public TenantUserSummaryResponse resetTenantUserPassword(Long userId, String newPassword) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return runInTenant(schema, () -> {
            TenantUser updated = tenantUserTxService.resetPassword(userId, accountId, newPassword);
            return tenantUserApiMapper.toSummary(updated);
        });
    }

    public void hardDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        runInTenant(schema, () -> tenantUserTxService.hardDelete(userId, accountId));
    }

    // =========================================================
    // PASSWORD RESET (PUBLIC -> TENANT)
    // =========================================================

    public String generatePasswordResetToken(String slug, String usernameOrEmail) {
        if (!StringUtils.hasText(slug)) throw new ApiException("INVALID_SLUG", "Slug √© obrigat√≥rio", 400);
        if (!StringUtils.hasText(usernameOrEmail)) throw new ApiException("INVALID_LOGIN", "Username/Email √© obrigat√≥rio", 400);

        AccountSnapshot account = accountResolver.resolveActiveAccountBySlug(slug);

        return runInTenant(account.schemaName(), () -> {
            TenantUser user = tenantUserTxService.getUserByUsernameOrEmail(usernameOrEmail, account.id());

            if (user.isDeleted() || user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
                throw new ApiException("USER_INACTIVE", "Usu√°rio inativo", 403);
            }

            String token = jwtTokenProvider.generatePasswordResetToken(
                    user.getUsername(),
                    account.schemaName(),
                    account.id()
            );

            user.setPasswordResetToken(token);
            user.setPasswordResetExpires(appClock.now().plusHours(1));
            tenantUserTxService.save(user);

            return token;
        });
    }

    public void resetPasswordWithToken(String token, String newPassword) {
        if (!StringUtils.hasText(token)) throw new ApiException("INVALID_TOKEN", "Token inv√°lido", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException("INVALID_PASSWORD", "Nova senha √© obrigat√≥ria", 400);

        String schema = jwtTokenProvider.getTenantSchemaFromToken(token);
        Long accountId = jwtTokenProvider.getAccountIdFromToken(token);
        String username = jwtTokenProvider.getUsernameFromToken(token);

        runInTenant(schema, () ->
                tenantUserTxService.resetPasswordWithToken(accountId, username, token, newPassword)
        );
    }

    // =========================================================
    // MY PROFILE (agora existe no TxService)
    // =========================================================

    public TenantUserDetailsResponse updateMyProfile(String name, String phone, String locale, String timezone) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long userId = securityUtils.getCurrentUserId();

        return runInTenant(schema, () -> {
            TenantUser updated = tenantUserTxService.updateProfile(
                    userId,
                    accountId,
                    name,
                    phone,
                    locale,
                    timezone,
                    appClock.now()

            );
            return tenantUserApiMapper.toDetails(updated);
        });
    }
}
package brito.com.multitenancy001.tenant.application.user;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import brito.com.multitenancy001.tenant.security.TenantRole;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "tenantTransactionManager")
public class TenantUserTxService {

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;

    private LocalDateTime now() {
        return appClock.now();
    }

    // =========================
    // CREATE
    // =========================
    public TenantUser createTenantUser(
            Long accountId,
            String name,
            String username,
            String email,
            String rawPassword,
            TenantRole roleEnum,
            String phone,
            String avatarUrl,
            LinkedHashSet<String> permissions
    ) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigat√≥rio", 400);

        if (!StringUtils.hasText(name)) throw new ApiException("INVALID_NAME", "Nome obrigat√≥rio", 400);
        if (!StringUtils.hasText(username)) throw new ApiException("INVALID_USERNAME", "Username obrigat√≥rio", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email obrigat√≥rio", 400);

        if (!StringUtils.hasText(rawPassword) || !rawPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inv√°lida", 400);
        }

        String usernameNew = username.trim().toLowerCase();
        String emailNew = email.trim().toLowerCase();

        if (tenantUserRepository.existsByUsernameAndAccountId(usernameNew, accountId)) {
            throw new ApiException("USERNAME_ALREADY_EXISTS", "Username j√° existe nesta conta", 409);
        }
        if (tenantUserRepository.existsByEmailAndAccountId(emailNew, accountId)) {
            throw new ApiException("EMAIL_ALREADY_EXISTS", "Email j√° existe nesta conta", 409);
        }

        // ‚úÖ normaliza e valida permissions AQUI (fonte de verdade)
        final LinkedHashSet<String> normalizedPermissions;
        try {
            normalizedPermissions = PermissionScopeValidator.normalizeTenant(
                    permissions == null ? new LinkedHashSet<>() : permissions
            );
        } catch (IllegalArgumentException e1) {
            throw new ApiException("INVALID_PERMISSION", e1.getMessage(), 400);
        }

        TenantUser user = TenantUser.builder()
                .accountId(accountId)
                .name(name.trim())
                .username(usernameNew)
                .email(emailNew)
                .password(passwordEncoder.encode(rawPassword))
                .role(roleEnum)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .phone(phone)
                .avatarUrl(avatarUrl)
                .timezone("America/Sao_Paulo")
                .locale("pt_BR")
                .build();

        // ‚úÖ Se trouxe permissions v√°lidas e n√£o vazias, respeita.
        // Se veio vazio/null: deixa o @PrePersist do entity aplicar defaults por role.
        if (!normalizedPermissions.isEmpty()) {
            user.setPermissions(new LinkedHashSet<>(normalizedPermissions));
        }

        return tenantUserRepository.save(user);
    }

    public TenantUser setSuspendedByAdmin(Long userId, Long accountId, boolean suspended) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_DELETED", "Usu√°rio est√° deletado", 409);

        LocalDateTime now = now();
        user.setSuspendedByAdmin(suspended);
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    @Transactional(readOnly = true)
    public TenantUser getUserByUsernameOrEmail(String usernameOrEmail, Long accountId) {
        if (accountId == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigat√≥rio", 400);
        }
        if (!StringUtils.hasText(usernameOrEmail)) {
            throw new ApiException("INVALID_LOGIN", "Username/Email √© obrigat√≥rio", 400);
        }

        String login = usernameOrEmail.trim().toLowerCase();

        if (login.contains("@")) {
            return tenantUserRepository.findByEmailAndAccountIdAndDeletedFalse(login, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
        }

        return tenantUserRepository.findByUsernameAndAccountIdAndDeletedFalse(login, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
    }

    public TenantUser updateProfile(
            Long userId,
            Long accountId,
            String name,
            String phone,
            String locale,
            String timezone,
            LocalDateTime nowParam
    ) {
        if (userId == null) throw new ApiException("USER_REQUIRED", "UserId obrigat√≥rio", 400);
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigat√≥rio", 400);

        TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (StringUtils.hasText(name)) user.setName(name.trim());
        if (phone != null) user.setPhone(phone);
        if (StringUtils.hasText(locale)) user.setLocale(locale.trim());
        if (StringUtils.hasText(timezone)) user.setTimezone(timezone.trim());

        LocalDateTime now = (nowParam != null ? nowParam : now());
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    @Transactional(transactionManager = "tenantTransactionManager")
    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
        if (updated == 0) {
            throw new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado ou removido", 404);
        }
    }

    // =========================
    // LIST / GET
    // =========================
    @Transactional(readOnly = true)
    public List<TenantUser> listUsers(Long accountId) {
        return tenantUserRepository.findByAccountIdAndDeletedFalse(accountId);
    }

    @Transactional(readOnly = true)
    public List<TenantUser> listActiveUsers(Long accountId) {
        return tenantUserRepository.findActiveUsersByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public TenantUser getUser(Long userId, Long accountId) {
        return tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
    }

    @Transactional(readOnly = true)
    public TenantUser getByUsername(Long accountId, String username) {
        return tenantUserRepository.findByUsernameAndAccountIdAndDeletedFalse(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
    }

    @Transactional(readOnly = true)
    public TenantUser getByEmailActive(Long accountId, String email) {
        TenantUser user = tenantUserRepository.findByEmailAndAccountIdAndDeletedFalse(email, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
            throw new ApiException("USER_INACTIVE", "Usu√°rio inativo", 403);
        }
        return user;
    }

    // =========================
    // UPDATE STATUS
    // =========================
    public TenantUser updateStatus(Long userId, Long accountId, boolean active) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_DELETED", "Usu√°rio est√° deletado", 409);

        LocalDateTime now = now();

        user.setSuspendedByAdmin(!active);
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    // =========================
    // CONTAGEM
    // =========================
    @Transactional(readOnly = true)
    public long countActiveUsers(Long accountId) {
        return tenantUserRepository.countActiveUsersByAccount(accountId);
    }

    public void softDelete(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.isDeleted()) throw new ApiException("USER_ALREADY_DELETED", "Usu√°rio j√° removido", 409);

        LocalDateTime now = now();
        user.softDelete(now, appClock.epochMillis()); // ‚úÖ novo m√©todo clock-aware
        user.setUpdatedAt(now);

        tenantUserRepository.save(user);
    }

    public TenantUser restore(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (!user.isDeleted()) throw new ApiException("USER_NOT_DELETED", "Usu√°rio n√£o est√° removido", 409);

        LocalDateTime now = now();

        user.restore();
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    public void hardDelete(Long userId, Long accountId) {
        TenantUser user = tenantUserRepository.findByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));
        tenantUserRepository.delete(user);
    }

    public TenantUser resetPassword(Long userId, Long accountId, String newPassword) {
        if (!StringUtils.hasText(newPassword) || !newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inv√°lida", 400);
        }

        TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        LocalDateTime now = now();

        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(now);
        user.setMustChangePassword(false);
        user.setUpdatedAt(now);

        return tenantUserRepository.save(user);
    }

    // =========================
    // RESET PASSWORD (TOKEN)
    // =========================
    public void resetPasswordWithToken(Long accountId, String username, String token, String newPassword) {
        if (!StringUtils.hasText(newPassword) || !newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("INVALID_PASSWORD", "Senha fraca / inv√°lida", 400);
        }

        TenantUser user = tenantUserRepository.findByUsernameAndAccountId(username, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usu√°rio n√£o encontrado", 404));

        if (user.getPasswordResetToken() == null || !user.getPasswordResetToken().equals(token)) {
            throw new ApiException("INVALID_TOKEN", "Token n√£o confere", 400);
        }

        LocalDateTime now = now();

        if (user.getPasswordResetExpires() == null || user.getPasswordResetExpires().isBefore(now)) {
            throw new ApiException("TOKEN_EXPIRED", "Token expirado", 400);
        }

        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(now);
        user.setMustChangePassword(false);

        user.setPasswordResetToken(null);
        user.setPasswordResetExpires(null);

        user.setUpdatedAt(now);
        tenantUserRepository.save(user);
    }

    // usado no generatePasswordResetToken
    public TenantUser save(TenantUser user) {
        LocalDateTime now = now();
        user.setUpdatedAt(now);
        return tenantUserRepository.save(user);
    }

    public void transferTenantOwnerRole(Long accountId, Long fromUserId, Long toUserId) {
        TenantUser from = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(fromUserId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "TENANT_ACCOUNT_OWNER n√£o encontrado", 404));

        TenantUser to = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(toUserId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "TENANT_ACCOUNT_ADMIN alvo n√£o encontrado", 404));

        LocalDateTime now = now();

        from.setRole(TenantRole.TENANT_ACCOUNT_ADMIN);
        to.setRole(TenantRole.TENANT_ACCOUNT_OWNER);

        from.setUpdatedAt(now);
        to.setUpdatedAt(now);

        tenantUserRepository.save(from);
        tenantUserRepository.save(to);
    }
}
package brito.com.multitenancy001.tenant.application.username.generator;

import java.util.UUID;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.shared.domain.username.UsernamePolicy;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class UsernameGeneratorService {

	private static final int SUFFIX_LEN = 8;

	private final UsernamePolicy policy;
	private final TenantUserRepository tenantUserRepository;

	/**
	 * Gera username baseado no email, garantindo: - normaliza√ß√£o - limite m√°ximo
	 * (sem cortar sufixo) - unicidade por accountId (best-effort + fallback)
	 */
	public String generateFromEmail(String email, Long accountId) {
    if (accountId == null) {
        throw new IllegalArgumentException("accountId is required");
    }
    if (email == null || !email.contains("@")) {
        throw new IllegalArgumentException("Invalid email");
    }

    String local = email.split("@", 2)[0].toLowerCase();
    String base = policy.normalizeBase(local);

    for (int attempt = 0; attempt < 10; attempt++) {
        String candidate = policy.build(base, randomSuffix(SUFFIX_LEN));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    for (int counter = 2; counter < 200; counter++) {
        String candidate = policy.build(base, String.valueOf(counter));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    throw new IllegalStateException("Could not generate a unique username after multiple attempts");
}

public String ensureUnique(String initialUsername, Long accountId) {
    if (accountId == null) {
        throw new IllegalArgumentException("accountId is required");
    }

    if (policy.isValid(initialUsername) &&
        !tenantUserRepository.existsByUsernameAndAccountId(initialUsername, accountId)) {
        return initialUsername;
    }

    String base = policy.extractBase(initialUsername);

    for (int attempt = 0; attempt < 10; attempt++) {
        String candidate = policy.build(base, randomSuffix(SUFFIX_LEN));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    for (int counter = 2; counter < 200; counter++) {
        String candidate = policy.build(base, String.valueOf(counter));
        if (!tenantUserRepository.existsByUsernameAndAccountId(candidate, accountId)) {
            return candidate;
        }
    }

    throw new IllegalStateException("Could not ensure unique username after multiple attempts");
}


	
	private String randomSuffix(int len) {
		return UUID.randomUUID().toString().replace("-", "").substring(0, len);
	}
}
package brito.com.multitenancy001.tenant.domain.category;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "categories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_categories_name",
                columnNames = "name"
        )
)
@Getter
@Setter
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}
package brito.com.multitenancy001.tenant.domain.category;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "subcategories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_subcategories_name_category",
                columnNames = {"category_id", "name"}
        )
)
@Getter
@Setter
public class Subcategory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_subcategories_category")
    )
    private Category category;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}
package brito.com.multitenancy001.tenant.domain.product;

import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "products", indexes = {
        @Index(name = "idx_product_name", columnList = "name"),
        @Index(name = "idx_product_supplier", columnList = "supplier_id"),
        @Index(name = "idx_product_created_at", columnList = "created_at"),
        @Index(name = "idx_products_category_id", columnList = "category_id"),
        @Index(name = "idx_products_subcategory_id", columnList = "subcategory_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"supplier", "category", "subcategory"})
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(length = 100, nullable = false)
    private String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    @Builder.Default
    private Integer stockQuantity = 0;

    @Column(name = "min_stock")
    private Integer minStock;

    @Column(name = "max_stock")
    private Integer maxStock;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    @Column(name = "profit_margin", precision = 5, scale = 2)
    private BigDecimal profitMargin;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_products_category")
    )
    private Category category;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
            name = "subcategory_id",
            foreignKey = @ForeignKey(name = "fk_products_subcategory")
    )
    private Subcategory subcategory;

    @Column(name = "brand", length = 100)
    private String brand;

    @Column(name = "weight_kg", precision = 8, scale = 3)
    private BigDecimal weightKg;

    @Column(name = "dimensions", length = 50)
    private String dimensions;

    @Column(name = "barcode", length = 50)
    private String barcode;

    @Column(name = "active", nullable = false)
    @Builder.Default
    private Boolean active = true;

    @Column(name = "images_json", columnDefinition = "TEXT")
    private String imagesJson;

    @Column(name = "attributes_json", columnDefinition = "TEXT")
    private String attributesJson;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", foreignKey = @ForeignKey(name = "fk_product_supplier"))
    private Supplier supplier;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private Boolean deleted = false;

    @PrePersist
    protected void onCreate() {
        if (this.stockQuantity == null) this.stockQuantity = 0;
        if (this.active == null) this.active = true;
        if (this.deleted == null) this.deleted = false;
        calculateProfitMargin();
    }

    @PreUpdate
    protected void onUpdate() {
        calculateProfitMargin();
    }

    private void calculateProfitMargin() {
        if (this.costPrice != null && this.costPrice.compareTo(BigDecimal.ZERO) > 0 && this.price != null) {
            BigDecimal profit = this.price.subtract(this.costPrice);
            this.profitMargin = profit
                    .divide(this.costPrice, 4, RoundingMode.HALF_UP)
                    .multiply(BigDecimal.valueOf(100));
        }
    }

    // =====================
    // Regras de dom√≠nio
    // =====================

    public void softDelete(LocalDateTime now) {
        if (Boolean.TRUE.equals(this.deleted)) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!Boolean.TRUE.equals(this.deleted)) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }

    public void updatePrice(BigDecimal newPrice) {
        if (newPrice == null || newPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Pre√ßo inv√°lido");
        }
        this.price = newPrice;
        calculateProfitMargin();
    }

    public void updateCostPrice(BigDecimal newCostPrice) {
        this.costPrice = newCostPrice;
        calculateProfitMargin();
    }

    public void addToStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;
        this.stockQuantity += quantity;
    }

    public void removeFromStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;

        if (this.stockQuantity < quantity) {
            throw new IllegalStateException("Estoque insuficiente. Dispon√≠vel: " + this.stockQuantity);
        }
        this.stockQuantity -= quantity;
    }
}
package brito.com.multitenancy001.tenant.domain.sale;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "sales", indexes = {
        @Index(name = "idx_sales_sale_date", columnList = "sale_date"),
        @Index(name = "idx_sales_status", columnList = "status")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "items")
public class Sale {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    @Column(name = "sale_date", nullable = false)
    private LocalDateTime saleDate;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "customer_name", length = 200)
    private String customerName;

    @Column(name = "customer_document", length = 20)
    private String customerDocument;

    @Column(name = "customer_email", length = 150)
    private String customerEmail;

    @Column(name = "customer_phone", length = 20)
    private String customerPhone;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private SaleStatus status;

    @OneToMany(
            mappedBy = "sale",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            orphanRemoval = true,
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<SaleItem> items = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public void addItem(SaleItem item) {
        if (item == null) return;
        item.setSale(this);
        this.items.add(item);
        recalcTotal();
    }

    public void removeItem(SaleItem item) {
        if (item == null) return;
        this.items.remove(item);
        item.setSale(null);
        recalcTotal();
    }

    public void recalcTotal() {
        BigDecimal sum = BigDecimal.ZERO;
        for (SaleItem it : items) {
            if (it.getTotalPrice() != null) {
                sum = sum.add(it.getTotalPrice());
            }
        }
        this.totalAmount = sum;
    }

    public void cancel() {
        this.status = SaleStatus.CANCELLED;
    }
}
package brito.com.multitenancy001.tenant.domain.sale;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.util.UUID;

@Entity
@Table(name = "sale_items", indexes = {
        @Index(name = "idx_sale_items_sale_id", columnList = "sale_id"),
        @Index(name = "idx_sale_items_product_id", columnList = "product_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "sale")
public class SaleItem {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "sale_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_sale_items_sale")
    )
    private Sale sale;

    // Sem FK para products. Refer√™ncia fraca (hist√≥rico)
    @Column(name = "product_id")
    private UUID productId;

    // Snapshot obrigat√≥rio do produto no momento da venda
    @Column(name = "product_name", nullable = false, length = 255)
    private String productName;

    @Column(name = "quantity", nullable = false, precision = 12, scale = 3)
    private BigDecimal quantity;

    @Column(name = "unit_price", nullable = false, precision = 12, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_price", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalPrice;

    public void recalcTotal() {
        if (quantity == null || unitPrice == null) {
            this.totalPrice = BigDecimal.ZERO;
            return;
        }
        this.totalPrice = unitPrice.multiply(quantity);
    }
}
package brito.com.multitenancy001.tenant.domain.sale;


public enum SaleStatus {
    DRAFT,
    CONFIRMED,
    PAID,
    CANCELLED
}
package brito.com.multitenancy001.tenant.domain.supplier;

import brito.com.multitenancy001.tenant.domain.product.Product;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "suppliers", indexes = {
        @Index(name = "idx_supplier_name", columnList = "name"),
        @Index(name = "idx_supplier_email", columnList = "email")
        // N√ÉO declare unique index de document aqui (√© parcial no DB)
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"products"})
public class Supplier {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", updatable = false, nullable = false)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(name = "contact_person", length = 100)
    private String contactPerson;

    @Column(length = 150)
    private String email;

    @Column(length = 20)
    private String phone;

    @Column(columnDefinition = "TEXT")
    private String address;

    @Column(length = 20)
    private String document;

    @Column(name = "document_type", length = 10)
    private String documentType;

    @Column(name = "website", length = 200)
    private String website;

    @Column(name = "payment_terms", length = 100)
    private String paymentTerms;

    @Column(name = "lead_time_days")
    private Integer leadTimeDays;

    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating;

    @Builder.Default
    @Column(name = "active", nullable = false)
    private boolean active = true;

    @Builder.Default
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @OneToMany(
            mappedBy = "supplier",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<Product> products = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // =====================
    // Regras de dom√≠nio
    // =====================

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}
package brito.com.multitenancy001.tenant.domain.user;

import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(
    name = "tenant_users",
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_tenant_users_username_account", columnNames = {"username", "account_id"}),
        @UniqueConstraint(name = "uk_tenant_users_email_account", columnNames = {"email", "account_id"})
    }
)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "password")
public class TenantUser {

    private static final int USERNAME_MAX_LEN = 100;
    private static final int EMAIL_MAX_LEN = 150;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = USERNAME_MAX_LEN)
    @Pattern(regexp = ValidationPatterns.USERNAME_PATTERN, message = "Username inv√°lido.")
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false, length = EMAIL_MAX_LEN)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private TenantRole role;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @ElementCollection
    @CollectionTable(
        name = "tenant_user_permissions",
        joinColumns = @JoinColumn(name = "tenant_user_id")
    )
    @Column(name = "permission", nullable = false, length = 120)
    @Builder.Default
    private Set<String> permissions = new LinkedHashSet<>();

    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts", nullable = false)
    @Builder.Default
    private Integer failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private Boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    @Column(name = "timezone", nullable = false, length = 50)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", nullable = false, length = 10)
    @Builder.Default
    private String locale = "pt_BR";

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @PrePersist
    @PreUpdate
    protected void onSave() {
        if (role == null) throw new IllegalStateException("Role is required");
        if (permissions == null) permissions = new LinkedHashSet<>();

        if (username != null) username = username.toLowerCase().trim();
        if (email != null) email = email.toLowerCase().trim();

        // 1) defaults por role (somente se vier vazio)
        if (permissions.isEmpty()) {
            permissions = new LinkedHashSet<>(
                TenantRolePermissions.permissionsFor(role).stream()
                    .map(Enum::name)
                    .toList()
            );
        }

        // 2) normaliza SEMPRE (trim, prefix TEN_, remove duplicadas, bloqueia CP_)
        permissions = new LinkedHashSet<>(PermissionScopeValidator.normalizeTenant(permissions));
    }

    public boolean isAccountNonLocked(LocalDateTime now) {
        return lockedUntil == null || !lockedUntil.isAfter(now);
    }

    public boolean isEnabledForLogin() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    public boolean isEnabledForLogin(LocalDateTime now) {
        return isEnabledForLogin() && isAccountNonLocked(now);
    }

    /**
     * ‚úÖ Clock-aware: agora o tempo vem de fora (AppClock).
     * Chamada t√≠pica: user.softDelete(appClock.now(), appClock.epochMillis());
     */
    public void softDelete(LocalDateTime now, long suffixEpochMillis) {
        if (deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        deleted = true;
        deletedAt = now;

        suspendedByAccount = true;
        suspendedByAdmin = true;

        String ts = String.valueOf(suffixEpochMillis);

        renameUsernameForDelete(ts);
        renameEmailForDelete(ts);
    }

    private void renameUsernameForDelete(String ts) {
        String prefix = "deleted_";
        String suffix = "_" + ts;

        String middle = (username == null ? "user" : username)
                .toLowerCase()
                .trim()
                .replaceAll("[^a-z0-9._-]", "_")
                .replaceAll("_{2,}", "_")
                .replaceAll("^_|_$", "");

        if (middle.isBlank()) middle = "user";

        int maxMiddleLen = USERNAME_MAX_LEN - prefix.length() - suffix.length();
        if (maxMiddleLen < 1) maxMiddleLen = 1;

        if (middle.length() > maxMiddleLen) {
            middle = middle.substring(0, maxMiddleLen).replaceAll("_+$", "");
            if (middle.isBlank()) middle = "u";
        }

        username = prefix + middle + suffix;
    }

    private void renameEmailForDelete(String ts) {
        String prefix = "deleted_";
        String suffix = "_" + ts;

        String middle = (email == null ? "deleted" : email).trim();

        int maxMiddleLen = EMAIL_MAX_LEN - prefix.length() - suffix.length();
        if (maxMiddleLen < 1) maxMiddleLen = 1;

        if (middle.length() > maxMiddleLen) {
            middle = middle.substring(0, maxMiddleLen);
        }

        email = prefix + middle + suffix;
    }

    public void restore() {
        if (!deleted) return;

        deleted = false;
        deletedAt = null;

        // ao restaurar: admin deixa de bloquear; account status segue mandando
        suspendedByAdmin = false;
        // n√£o altera suspendedByAccount aqui
    }
}
package brito.com.multitenancy001.tenant.persistence.category;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.category.Category;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {}package brito.com.multitenancy001.tenant.persistence.category;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.category.Subcategory;

import java.util.Optional;

@Repository
public interface SubcategoryRepository extends JpaRepository<Subcategory, Long> {

    @Query("select s from Subcategory s join fetch s.category where s.id = :id")
    Optional<Subcategory> findByIdWithCategory(@Param("id") Long id);
}
package brito.com.multitenancy001.tenant.persistence.product;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.product.Product;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface ProductRepository extends JpaRepository<Product, UUID> {

	List<Product> findByCategory_Id(Long categoryId);

	List<Product> findBySubcategory_Id(Long subcategoryId);

	@Query("""
			SELECT p FROM Product p
			WHERE p.category.id = :categoryId
			  AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
			""")
	List<Product> findByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
			@Param("subcategoryId") Long subcategoryId);

	List<Product> findByNameContainingIgnoreCase(String name);

	Optional<Product> findBySku(String sku);

	List<Product> findByStockQuantityLessThan(Integer quantity);

	List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

	List<Product> findBySupplier_Id(UUID supplierId);

	Page<Product> findByNameContainingIgnoreCase(String name, Pageable pageable);

	@Query("SELECT p FROM Product p WHERE "
			+ "(:name IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :name, '%'))) AND "
			+ "(:minPrice IS NULL OR p.price >= :minPrice) AND " + "(:maxPrice IS NULL OR p.price <= :maxPrice) AND "
			+ "(:minStock IS NULL OR p.stockQuantity >= :minStock) AND "
			+ "(:maxStock IS NULL OR p.stockQuantity <= :maxStock)")
	List<Product> searchProducts(@Param("name") String name, @Param("minPrice") BigDecimal minPrice,
			@Param("maxPrice") BigDecimal maxPrice, @Param("minStock") Integer minStock,
			@Param("maxStock") Integer maxStock);

	List<Product> findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(String name, BigDecimal minPrice,
			BigDecimal maxPrice, Integer minStock, Integer maxStock);

	@Query("SELECT COUNT(p) FROM Product p WHERE p.stockQuantity <= :threshold")
	Long countLowStock(@Param("threshold") Integer threshold);

	@Query("SELECT SUM(p.stockQuantity * p.price) FROM Product p")
	BigDecimal calculateTotalInventoryValue();

	@Query("SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id")
	List<Object[]> countProductsBySupplier();
}package brito.com.multitenancy001.tenant.persistence.supplier;


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.supplier.Supplier;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface SupplierRepository extends JpaRepository<Supplier, UUID> {
    
    Optional<Supplier> findByDocument(String document);
    
    List<Supplier> findByNameContainingIgnoreCase(String name);
    
    List<Supplier> findByEmail(String email);
}package brito.com.multitenancy001.tenant.persistence.user;

import jakarta.transaction.Transactional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.domain.user.TenantUser;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantUserRepository extends JpaRepository<TenantUser, Long> {
	
	
	 // ‚úÖ Suspende por CONTA (sem mexer na suspens√£o por admin)
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = true
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int suspendAllByAccount(@Param("accountId") Long accountId);

    // ‚úÖ Reativa por CONTA (sem mexer na suspens√£o por admin)
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = false
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int unsuspendAllByAccount(@Param("accountId") Long accountId);

  
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAdmin = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAdmin(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

  

	
    
    Optional<TenantUser> findByPasswordResetTokenAndAccountId(String passwordResetToken, Long accountId);

    Optional<TenantUser> findByUsernameAndDeletedFalse(String username);

    Optional<TenantUser> findByEmailAndAccountId(String email, Long accountId);

    Optional<TenantUser> findByEmailAndAccountIdAndDeletedFalse(String email, Long accountId);

    Optional<TenantUser> findByUsernameAndAccountId(String username, Long accountId);

    // (se voc√™ quiser filtrar deletados no login)
    Optional<TenantUser> findByUsernameAndAccountIdAndDeletedFalse(String username, Long accountId);

    boolean existsByUsernameAndAccountId(String username, Long accountId);

    boolean existsByEmailAndAccountId(String email, Long accountId);

    boolean existsByEmailAndAccountIdAndIdNot(String email, Long accountId, Long id);

    // ==========================
    // Listagens (Tenant)
    // ==========================
    List<TenantUser> findByAccountId(Long accountId);

    List<TenantUser> findByAccountIdAndDeletedFalse(Long accountId);

    // CORRE√á√ÉO: Removido o m√©todo que usa "ActiveTrue" pois n√£o existe na entidade
    // List<TenantUser> findByAccountIdAndActiveTrueAndDeletedFalse(Long accountId);
    
    // NOVO: M√©todo para buscar usu√°rios ativos usando l√≥gica customizada
    @Query("SELECT u FROM TenantUser u WHERE u.accountId = :accountId " +
           "AND u.deleted = false " +
           "AND u.suspendedByAccount = false " +
           "AND u.suspendedByAdmin = false")
    List<TenantUser> findActiveUsersByAccount(@Param("accountId") Long accountId);

    // ==========================
    // Contagem / Limites
    // ==========================
    // CORRE√á√ÉO: Removido m√©todo que n√£o funciona
    // long countByAccountIdAndActiveTrueAndDeletedFalse(Long accountId);
    
    // NOVO: Contagem de usu√°rios ativos
    @Query("SELECT COUNT(u) FROM TenantUser u WHERE u.accountId = :accountId " +
           "AND u.deleted = false " +
           "AND u.suspendedByAccount = false " +
           "AND u.suspendedByAdmin = false")
    long countActiveUsersByAccount(@Param("accountId") Long accountId);

    // ==========================
    // Busca por ID com scoping de conta
    // ==========================
    Optional<TenantUser> findByIdAndAccountId(Long id, Long accountId);

    // (se quiser refor√ßar deletado false)
    Optional<TenantUser> findByIdAndAccountIdAndDeletedFalse(Long id, Long accountId);
}package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.PermissionAuthority;

public enum TenantPermission implements PermissionAuthority {

    TEN_USER_READ,
    TEN_USER_CREATE,
    TEN_USER_UPDATE,
    TEN_USER_SUSPEND,
    TEN_USER_RESTORE,
    TEN_USER_DELETE,

    TEN_ROLE_TRANSFER, 

    TEN_PRODUCT_READ,
    TEN_PRODUCT_WRITE,

    TEN_CATEGORY_READ,
    TEN_CATEGORY_WRITE,

    TEN_SUPPLIER_READ,
    TEN_SUPPLIER_WRITE,

    TEN_SALE_READ,
    TEN_SALE_WRITE,
    TEN_SALE_ISSUES_READ,

    TEN_REPORT_SALES_READ,

    TEN_BILLING_READ,
    TEN_BILLING_WRITE,

    TEN_SETTINGS_READ,
    TEN_SETTINGS_WRITE,
	
	TEN_INVENTORY_READ,
	TEN_INVENTORY_WRITE;

    @Override
    public String asAuthority() {
        return name();
    }
}
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum TenantRole implements RoleAuthority {

    TENANT_ACCOUNT_OWNER,
    TENANT_ACCOUNT_ADMIN,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isTenantOwner() {
        return this == TENANT_ACCOUNT_OWNER;
    }
}
package brito.com.multitenancy001.tenant.security;

import java.util.EnumSet;
import java.util.Set;

public final class TenantRolePermissions {

    private TenantRolePermissions() {}

    public static Set<TenantPermission> permissionsFor(TenantRole role) {
        return switch (role) {
            case TENANT_ACCOUNT_OWNER -> EnumSet.allOf(TenantPermission.class);

            case TENANT_ACCOUNT_ADMIN -> EnumSet.of(
                    TenantPermission.TEN_USER_READ,
                    TenantPermission.TEN_USER_CREATE,
                    TenantPermission.TEN_USER_UPDATE,
                    TenantPermission.TEN_USER_SUSPEND,
                    TenantPermission.TEN_USER_RESTORE,
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_PRODUCT_WRITE,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_BILLING_READ,
                    TenantPermission.TEN_SETTINGS_READ,
                    TenantPermission.TEN_SETTINGS_WRITE,
                    TenantPermission.TEN_INVENTORY_WRITE
            );

            case TENANT_PRODUCT_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_PRODUCT_WRITE,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_INVENTORY_WRITE
            );

            case TENANT_SALES_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_SALE_READ,
                    TenantPermission.TEN_SALE_WRITE
            );

            case TENANT_BILLING_MANAGER -> EnumSet.of(
                    TenantPermission.TEN_BILLING_READ,
                    TenantPermission.TEN_BILLING_WRITE
            );

            case TENANT_READ_ONLY -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ,
                    TenantPermission.TEN_INVENTORY_READ,
                    TenantPermission.TEN_USER_READ
            );

            case TENANT_OPERATOR -> EnumSet.of(
                    TenantPermission.TEN_PRODUCT_READ
            );
        };
    }
}
-- V1__create_accounts.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS accounts (
    id BIGSERIAL PRIMARY KEY,

    account_type VARCHAR(20) NOT NULL DEFAULT 'TENANT',

    name VARCHAR(150) NOT NULL,

    schema_name VARCHAR(100) NOT NULL,
    slug VARCHAR(50) NOT NULL,

    status VARCHAR(50) NOT NULL DEFAULT 'FREE_TRIAL',
    subscription_plan VARCHAR(50) NOT NULL DEFAULT 'FREE',

    company_doc_type VARCHAR(10) NOT NULL,
    company_doc_number VARCHAR(20) NOT NULL,
    company_email VARCHAR(150) NOT NULL,

    company_phone VARCHAR(20),
    company_address VARCHAR(500),
    company_city VARCHAR(100),
    company_state VARCHAR(50),
    company_country VARCHAR(60),

    timezone VARCHAR(60),
    locale VARCHAR(20),
    currency VARCHAR(10),

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,

    trial_end_date TIMESTAMP,
    payment_due_date TIMESTAMP,
    next_billing_date TIMESTAMP,

    settings_json TEXT,
    metadata_json TEXT,

    deleted BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP
);

-- Opcional (recomendado): garante valores v√°lidos do enum no banco
ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_account_type
    CHECK (account_type IN ('TENANT', 'SYSTEM'));

-- Unicidade de documento por conta ativa
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_company_doc_active
ON accounts (company_doc_type, company_doc_number)
WHERE deleted = false;

-- Unicidade de email por conta ativa
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_company_email_active
ON accounts (company_email)
WHERE deleted = false;

-- Unicidade de schema (global)
CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_schema_name
ON accounts (schema_name);

-- Unicidade de slug (global)
CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_slug
ON accounts (slug);
-- V2__create_account_entitlements.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS account_entitlements (
  account_id BIGINT PRIMARY KEY REFERENCES accounts(id) ON DELETE CASCADE,
  max_users INT NOT NULL,
  max_products INT NOT NULL,
  max_storage_mb INT NOT NULL
);

-- (opcional) coer√™ncia b√°sica
ALTER TABLE account_entitlements
    ADD CONSTRAINT chk_entitlements_positive
    CHECK (max_users > 0 AND max_products > 0 AND max_storage_mb > 0);
-- V3__create_controlplane_users.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_users (
    id BIGSERIAL PRIMARY KEY,

    name VARCHAR(100) NOT NULL,
    username VARCHAR(100) NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(150) NOT NULL,

    role VARCHAR(50) NOT NULL,

    account_id BIGINT NOT NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,

    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(20) NOT NULL DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP,
    deleted BOOLEAN NOT NULL DEFAULT false,

    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    CONSTRAINT fk_controlplane_users_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- Unicidade por conta (apenas ativos)
CREATE UNIQUE INDEX IF NOT EXISTS ux_cp_users_username_active
ON controlplane_users (account_id, username)
WHERE deleted = false;

CREATE UNIQUE INDEX IF NOT EXISTS ux_cp_users_email_active
ON controlplane_users (account_id, email)
WHERE deleted = false;
-- V4__seed_controlplane_account.sql
SET search_path TO public;

-- Cria 4 usu√°rios padr√£o do Control Plane no account SYSTEM (slug controlplane)
-- Se j√° existirem (ativos) com o mesmo username/email, n√£o duplica.

WITH cp_account AS (
    SELECT id
    FROM accounts
    WHERE slug = 'controlplane'
    LIMIT 1
)
INSERT INTO controlplane_users (
    name,
    username,
    email,
    password,
    role,
    account_id,
    suspended_by_account,
    suspended_by_admin,
    must_change_password
)
SELECT
    u.name,
    u.username,
    u.email,
    u.password,
    u.role,
    a.id,
    false,
    false,
    u.must_change_password
FROM cp_account a
JOIN (
    VALUES
      -- OWNER (superadmin)
      ('ControlPlane Super Admin', 'superadmin', 'admin@controlplane.com',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OWNER', false),

      -- BILLING MANAGER
      ('ControlPlane Billing Manager', 'billing', 'billing@controlplane.com',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_BILLING_MANAGER', true),

      -- SUPPORT
      ('ControlPlane Support', 'support', 'support@controlplane.com',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_SUPPORT', true),

      -- OPERATOR
      ('ControlPlane Operator', 'operator', 'operator@controlplane.com',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OPERATOR', true)

) AS u(name, username, email, password, role, must_change_password)
ON TRUE
WHERE NOT EXISTS (
    SELECT 1
    FROM controlplane_users existing
    WHERE existing.account_id = a.id
      AND existing.deleted = false
      AND (existing.username = u.username OR existing.email = u.email)
);
-- V5__create_controlplane_user_permissions.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_user_permissions (
    user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (user_id, permission),

    CONSTRAINT fk_cp_user_permissions_user
        FOREIGN KEY (user_id)
        REFERENCES controlplane_users(id)
        ON DELETE CASCADE
);
-- V7__create_payments.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS payments (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,

    payment_date TIMESTAMP NOT NULL,
    valid_until TIMESTAMP,

    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',

    transaction_id VARCHAR(100) UNIQUE,
    payment_method VARCHAR(50),
    payment_gateway VARCHAR(50),
    currency VARCHAR(3) NOT NULL DEFAULT 'BRL',

    description VARCHAR(500),
    metadata_json TEXT,

    invoice_url TEXT,
    receipt_url TEXT,

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,

    refunded_at TIMESTAMP,
    refund_amount NUMERIC(10,2),
    refund_reason VARCHAR(500),

    CONSTRAINT fk_payments_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_payment_account ON payments(account_id);
CREATE INDEX IF NOT EXISTS idx_payment_status ON payments(status);

CREATE INDEX IF NOT EXISTS idx_payment_date ON payments(payment_date);
-- V1__create_tenants_users.sql

CREATE TABLE IF NOT EXISTS tenant_users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    account_id BIGINT NOT NULL,

    name VARCHAR(100) NOT NULL,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(150) NOT NULL,
    password VARCHAR(255) NOT NULL,

    role VARCHAR(50) NOT NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    timezone VARCHAR(50) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(10) NOT NULL DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,

    deleted BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP,

    CONSTRAINT uk_tenant_users_username_account UNIQUE (username, account_id),
    CONSTRAINT uk_tenant_users_email_account UNIQUE (email, account_id)
);

CREATE INDEX IF NOT EXISTS idx_tenant_users_account_id ON tenant_users(account_id);

CREATE INDEX IF NOT EXISTS idx_tenant_users_deleted ON tenant_users(deleted) WHERE deleted = false;

-- V2__create_tenant_users_permissions.sql
CREATE TABLE IF NOT EXISTS tenant_user_permissions (
    tenant_user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (tenant_user_id, permission),

    CONSTRAINT fk_tenant_user_permissions_user
        FOREIGN KEY (tenant_user_id)
        REFERENCES tenant_users(id)
        ON DELETE CASCADE
);-- V3__create_categories.sql

CREATE TABLE IF NOT EXISTS categories (
  id BIGSERIAL PRIMARY KEY,

  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  CONSTRAINT uk_categories_name UNIQUE (name)
);

CREATE INDEX IF NOT EXISTS idx_categories_active  ON categories(active);
CREATE INDEX IF NOT EXISTS idx_categories_deleted ON categories(deleted) WHERE deleted = false;
-- V4__create_subcategories.sql

CREATE TABLE IF NOT EXISTS subcategories (
  id BIGSERIAL PRIMARY KEY,

  category_id BIGINT NOT NULL,
  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  CONSTRAINT fk_subcategories_category
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE,

  CONSTRAINT uk_subcategories_name_category UNIQUE (category_id, name)
);


CREATE INDEX IF NOT EXISTS idx_subcategories_active      ON subcategories(active);
CREATE INDEX IF NOT EXISTS idx_subcategories_deleted     ON subcategories(deleted) WHERE deleted = false;
-- V5__create_suppliers.sql

-- 1) Habilita fun√ß√£o de UUID (Postgres)
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 2) Tabela suppliers com UUID gerado automaticamente
CREATE TABLE IF NOT EXISTS suppliers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  contact_person VARCHAR(100),

  email VARCHAR(150),
  phone VARCHAR(20),
  address TEXT,

  document VARCHAR(20),
  document_type VARCHAR(10),

  website VARCHAR(200),
  payment_terms VARCHAR(100),

  lead_time_days INTEGER,
  rating NUMERIC(3,2),

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  notes TEXT,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP
);

-- 3) document √∫nico somente para fornecedores ativos (n√£o deletados) e com documento preenchido
CREATE UNIQUE INDEX IF NOT EXISTS ux_suppliers_document_active
ON suppliers(document)
WHERE document IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_supplier_name    ON suppliers(name);
CREATE INDEX IF NOT EXISTS idx_supplier_email   ON suppliers(email);
CREATE INDEX IF NOT EXISTS idx_supplier_active  ON suppliers(active);
CREATE INDEX IF NOT EXISTS idx_supplier_deleted ON suppliers(deleted) WHERE deleted = false;
-- V6__create_products.sql

CREATE TABLE IF NOT EXISTS products (
  id UUID PRIMARY KEY,

  name VARCHAR(200) NOT NULL,
  description TEXT,

  sku VARCHAR(100) NOT NULL,
  price NUMERIC(10,2) NOT NULL,

  stock_quantity INT NOT NULL DEFAULT 0,
  min_stock INT,
  max_stock INT,

  cost_price NUMERIC(10,2),
  profit_margin NUMERIC(5,2),

  category_id BIGINT NOT NULL,
  subcategory_id BIGINT NULL,

  brand VARCHAR(100),
  weight_kg NUMERIC(8,3),
  dimensions VARCHAR(50),
  barcode VARCHAR(50),

  active BOOLEAN NOT NULL DEFAULT true,

  images_json TEXT,
  attributes_json TEXT,

  supplier_id UUID NULL,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  CONSTRAINT fk_products_category
    FOREIGN KEY (category_id) REFERENCES categories(id),

  CONSTRAINT fk_products_subcategory
    FOREIGN KEY (subcategory_id) REFERENCES subcategories(id),

  CONSTRAINT fk_product_supplier
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);

-- sku √∫nico apenas quando preenchido e produto ativo
CREATE UNIQUE INDEX IF NOT EXISTS ux_products_sku_active
ON products(sku)
WHERE deleted = false;

CREATE INDEX IF NOT EXISTS idx_product_name       ON products(name);
CREATE INDEX IF NOT EXISTS idx_product_supplier   ON products(supplier_id);
CREATE INDEX IF NOT EXISTS idx_product_created_at ON products(created_at);

CREATE INDEX IF NOT EXISTS idx_products_category_id    ON products(category_id);
CREATE INDEX IF NOT EXISTS idx_products_subcategory_id ON products(subcategory_id);

CREATE INDEX IF NOT EXISTS idx_products_deleted ON products(deleted) WHERE deleted = false;
-- V7__create_sales.sql

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS sales (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_date TIMESTAMP NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL,

  customer_name VARCHAR(200),
  customer_document VARCHAR(20),
  customer_email VARCHAR(150),
  customer_phone VARCHAR(20),

  status VARCHAR(20) NOT NULL,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_sales_sale_date ON sales(sale_date);
CREATE INDEX IF NOT EXISTS idx_sales_status ON sales(status);
-- V8__create_sales_items.sql

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE IF NOT EXISTS sale_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_id UUID NOT NULL,
  product_id UUID,
  product_name VARCHAR(255) NOT NULL,

  quantity NUMERIC(12,3) NOT NULL,
  unit_price NUMERIC(12,2) NOT NULL,
  total_price NUMERIC(12,2) NOT NULL,

  CONSTRAINT fk_sale_items_sale
    FOREIGN KEY (sale_id) REFERENCES sales(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_sale_items_sale_id ON sale_items(sale_id);
CREATE INDEX IF NOT EXISTS idx_sale_items_product_id ON sale_items(product_id);
package brito.com.multitenancy001;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Multitenancy001ApplicationTests {

	@Test
	void contextLoads() {
	}

}
