============================================================
// FILE: ./main/java/brito/com/multitenancy001/Multitenancy001Application.java
============================================================
package brito.com.multitenancy001;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
//@EnableCaching
@EnableScheduling
public class Multitenancy001Application {

	public static void main(String[] args) {
		SpringApplication.run(Multitenancy001Application.class, args);
	}

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/admin/accounts/ControlPlaneAccountController.java
============================================================
package brito.com.multitenancy001.controlplane.api.admin.accounts;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.shared.api.error.ApiException;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/admin/accounts")
@RequiredArgsConstructor
@Slf4j
public class ControlPlaneAccountController {

    private final AccountLifecycleService accountLifecycleService;

    private static final int DEFAULT_PAGE_SIZE = 20;
    private static final int MAX_PAGE_SIZE = 100;

    private Pageable pageableOrDefault(Pageable pageable) {
        if (pageable == null) {
            return PageRequest.of(0, DEFAULT_PAGE_SIZE);
        }

        int page = Math.max(0, pageable.getPageNumber());
        int size = pageable.getPageSize();

        if (size <= 0) size = DEFAULT_PAGE_SIZE;
        if (size > MAX_PAGE_SIZE) size = MAX_PAGE_SIZE;

        return PageRequest.of(page, size, pageable.getSort());
    }

    // Lista contas (não deletadas) com paginação, ordenadas por criação (mais recentes primeiro).
    @GetMapping("/latest")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Page<AccountResponse>> listAccountsLatest(Pageable pageable) {
        Pageable p = pageableOrDefault(pageable);
        return ResponseEntity.ok(accountLifecycleService.listAccountsLatest(p));
    }

    // Lista todas as contas (não deletadas) sem paginação.
    @GetMapping
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountResponse>> listAccounts() {
        log.info("Listando todas as contas");
        return ResponseEntity.ok(accountLifecycleService.listAccounts());
    }

    // Busca uma conta (não deletada) por ID.
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountResponse> getAccount(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.getAccount(id));
    }

    // Busca detalhes administrativos de uma conta (inclui contagem de usuários da plataforma vinculados).
    @GetMapping("/{id}/details")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountAdminDetailsResponse> getAccountDetails(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.getAccountAdminDetails(id));
    }

    // Lista usuários TENANT vinculados à conta (opcionalmente apenas operacionais).
    @GetMapping("/{id}/users")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountTenantUserSummaryResponse>> listUsersByAccount(@PathVariable Long id) {
        log.info("Listando Usuários por conta");
        return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, false));
    }

    // Lista usuários TENANT operacionais vinculados à conta (ex.: não suspensos/operacionais conforme regra do serviço).
    @GetMapping("/{id}/users/operational")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountTenantUserSummaryResponse>> listOperationalUsersByAccount(@PathVariable Long id) {
        return ResponseEntity.ok(accountLifecycleService.listTenantUsers(id, true));
    }

    // Busca uma conta (não deletada) por slug (case-insensitive).
    @GetMapping("/by-slug/{slug}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountResponse> getBySlugIgnoreCase(@PathVariable String slug) {
        return ResponseEntity.ok(accountLifecycleService.getAccountBySlugIgnoreCase(slug));
    }

    // Lista contas por status (não deletadas) com paginação.
    @GetMapping("/by-status/{status}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Page<AccountResponse>> listByStatus(@PathVariable AccountStatus status, Pageable pageable) {
        Pageable p = pageableOrDefault(pageable);
        return ResponseEntity.ok(accountLifecycleService.listAccountsByStatus(status, p));
    }

    // Lista contas por múltiplos status (não deletadas) sem paginação.
    @GetMapping("/by-statuses")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountResponse>> listByStatuses(@RequestParam("statuses") List<AccountStatus> statuses) {
        return ResponseEntity.ok(accountLifecycleService.listAccountsByStatuses(statuses));
    }

    // Busca contas por termo em displayName/legalName (não deletadas) com paginação explícita.
    @GetMapping("/search")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Page<AccountResponse>> searchByDisplayName(
            @RequestParam("term") String term,
            @RequestParam("page") int page,
            @RequestParam("size") int size
    ) {
        if (page < 0) page = 0;

        if (size <= 0) {
            throw new ApiException("INVALID_PAGINATION", "size deve ser > 0", 400);
        }
        if (size > MAX_PAGE_SIZE) {
            throw new ApiException("INVALID_PAGINATION", "size máximo é " + MAX_PAGE_SIZE, 400);
        }

        Pageable p = PageRequest.of(page, size);
        return ResponseEntity.ok(accountLifecycleService.searchAccountsByDisplayName(term, p));
    }

    // Lista contas criadas entre duas datas (não deletadas) com paginação.
    @GetMapping("/created-between")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Page<AccountResponse>> listCreatedBetween(
            @RequestParam("start") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime start,
            @RequestParam("end") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime end,
            Pageable pageable
    ) {
        Pageable p = pageableOrDefault(pageable);
        return ResponseEntity.ok(accountLifecycleService.listAccountsCreatedBetween(start, end, p));
    }

    // Conta quantas contas (não deletadas) existem em um status.
    @GetMapping("/count/by-status/{status}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Long> countByStatus(@PathVariable AccountStatus status) {
        return ResponseEntity.ok(accountLifecycleService.countAccountsByStatus(status));
    }

    // Conta quantas contas operacionais existem (definição centralizada no service/repository).
    @GetMapping("/count/operational")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Long> countOperationalAccounts() {
        return ResponseEntity.ok(accountLifecycleService.countOperationalAccounts());
    }

    // Lista contas com trial vencido (opcionalmente informando data/status; defaults no service).
    @GetMapping("/expired-trials")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountResponse>> listExpiredTrials(
            @RequestParam(value = "date", required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime date,
            @RequestParam(value = "status", required = false) AccountStatus status
    ) {
        return ResponseEntity.ok(accountLifecycleService.listExpiredTrials(date, status));
    }

    // Lista contas com pagamento vencido (opcionalmente informando data/status; defaults no service).
    @GetMapping("/overdue")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountResponse>> listOverdue(
            @RequestParam(value = "today", required = false)
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime today,
            @RequestParam(value = "status", required = false) AccountStatus status
    ) {
        return ResponseEntity.ok(accountLifecycleService.listOverdueAccounts(today, status));
    }

    // Altera o status de uma conta e executa efeitos colaterais (ex.: suspender/reativar usuários TENANT).
    @PatchMapping("/{id}/status")
    @PreAuthorize("hasAnyAuthority('CP_TENANT_SUSPEND','CP_TENANT_RESUME')")
    public ResponseEntity<AccountStatusChangeResponse> changeAccountStatus(
            @PathVariable Long id,
            @Valid @RequestBody AccountStatusChangeRequest accountStatusChangeRequest
    ) {
        return ResponseEntity.ok(accountLifecycleService.changeAccountStatus(id, accountStatusChangeRequest));
    }

    // Executa soft delete em uma conta (e efeitos colaterais associados).
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('CP_TENANT_DELETE')")
    public ResponseEntity<Void> softDeleteAccount(@PathVariable Long id) {
        accountLifecycleService.softDeleteAccount(id);
        return ResponseEntity.noContent().build();
    }

    // Restaura uma conta previamente deletada (e efeitos colaterais associados).
    @PostMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('CP_TENANT_RESUME')")
    public ResponseEntity<Void> restoreAccount(@PathVariable Long id) {
        accountLifecycleService.restoreAccount(id);
        return ResponseEntity.noContent().build();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/admin/accounts/ControlPlaneAccountQueryController.java
============================================================
package brito.com.multitenancy001.controlplane.api.admin.accounts;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.application.query.ControlPlaneAccountQueryService;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/admin/accounts/query")
@RequiredArgsConstructor
public class ControlPlaneAccountQueryController {

    private final ControlPlaneAccountQueryService controlPlaneAccountQueryService;

    // AccountRepository.findEnabledById
    @GetMapping("/{id}/enabled")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountResponse> getEnabledById(@PathVariable Long id) {
        return ResponseEntity.ok(controlPlaneAccountQueryService.getEnabledById(id));
    }

    // AccountRepository.findAnyById (inclui deleted)
    @GetMapping("/{id}/any")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<AccountResponse> getAnyById(@PathVariable Long id) {
        return ResponseEntity.ok(controlPlaneAccountQueryService.getAnyById(id));
    }

    // AccountRepository.countByStatusesAndDeletedFalse
    // Exemplo: /api/admin/accounts/query/count?statuses=ACTIVE&statuses=FREE_TRIAL
    @GetMapping("/count")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Long> countByStatuses(@RequestParam List<AccountStatus> statuses) {
        return ResponseEntity.ok(controlPlaneAccountQueryService.countByStatusesNotDeleted(statuses));
    }

    // AccountRepository.findByPaymentDueDateBeforeAndDeletedFalse
    // Exemplo: /api/admin/accounts/query/payment-due/before?date=2026-01-01T00:00:00
    @GetMapping("/payment-due/before")
    @PreAuthorize("hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<List<AccountResponse>> findPaymentDueBefore(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime date
    ) {
        return ResponseEntity.ok(controlPlaneAccountQueryService.findPaymentDueBeforeNotDeleted(date));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/admin/auth/ControlPlaneAuthController.java
============================================================
package brito.com.multitenancy001.controlplane.api.admin.auth;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.application.ControlPlaneAuthService;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/auth")
@RequiredArgsConstructor
public class ControlPlaneAuthController {

    private final ControlPlaneAuthService controlPlaneAuthService;

    // Autentica um usuário do Control Plane e retorna um JWT para chamadas administrativas.
    @PostMapping("/login")
    public ResponseEntity<JwtResponse> loginControlPlaneUser(@Valid @RequestBody ControlPlaneAdminLoginRequest request) {
        JwtResponse response = controlPlaneAuthService.loginControlPlaneUser(request);
        return ResponseEntity.ok(response);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/admin/billing/ControlPlanePaymentController.java
============================================================
package brito.com.multitenancy001.controlplane.api.admin.billing;

import brito.com.multitenancy001.controlplane.application.billing.ControlPlanePaymentService;
import brito.com.multitenancy001.shared.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import jakarta.validation.Valid;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/admin/billing/payments")
@RequiredArgsConstructor
@Validated
public class ControlPlanePaymentController {

    private final ControlPlanePaymentService controlPlanePaymentService;

    // Cria/processa um pagamento manual para uma conta (cross-tenant) e aplica efeitos no billing da conta.
    @PostMapping("/by-account/{accountId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> processPaymentForAccount(
            @PathVariable Long accountId,
            @Valid @RequestBody AdminPaymentRequest body
    ) {
        AdminPaymentRequest adminPaymentRequest = new AdminPaymentRequest(
                accountId,
                body.amount(),
                body.paymentMethod(),
                body.paymentGateway(),
                body.description()
        );

        PaymentResponse response = controlPlanePaymentService.processPaymentForAccount(adminPaymentRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    // Lista pagamentos de uma conta (cross-tenant).
    @GetMapping("/by-account/{accountId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getPaymentsByAccountAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByAccount(accountId));
    }

    // Informa se existe um pagamento COMPLETED vigente para a conta (cross-tenant).
    @GetMapping("/by-account/{accountId}/active")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<Boolean> hasCurrentPaymentAdmin(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentService.hasActivePayment(accountId));
    }

    // Verifica se um paymentId pertence a um accountId (cross-tenant).
    @GetMapping("/by-account/{accountId}/exists/{paymentId}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<Boolean> existsByIdAndAccountId(
            @PathVariable Long accountId,
            @PathVariable Long paymentId
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.paymentExistsForAccount(paymentId, accountId));
    }

    // Lista pagamentos de uma conta filtrados por status (cross-tenant).
    @GetMapping("/by-account/{accountId}/status/{status}")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getPaymentsByAccountAndStatus(
            @PathVariable Long accountId,
            @PathVariable PaymentStatus status
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByAccountAndStatus(accountId, status));
    }

    // Busca pagamento por transactionId (admin global).
    @GetMapping("/by-transaction/{transactionId}")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<PaymentResponse> getByTransactionId(@PathVariable String transactionId) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentByTransactionId(transactionId));
    }

    // Informa se existe pagamento com transactionId (admin global).
    @GetMapping("/exists/by-transaction/{transactionId}")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<Boolean> existsByTransactionId(@PathVariable String transactionId) {
        return ResponseEntity.ok(controlPlanePaymentService.existsByTransactionId(transactionId));
    }

    // Lista pagamentos por status cujo validUntil é anterior a uma data (admin global).
    @GetMapping("/valid-until-before")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> listByValidUntilBeforeAndStatus(
            @RequestParam("date")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime date,
            @RequestParam("status") PaymentStatus status
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsByValidUntilBeforeAndStatus(date, status));
    }

    // Lista pagamentos COMPLETED de uma conta, ordenados por data de pagamento (cross-tenant).
    @GetMapping("/by-account/{accountId}/completed")
    @PreAuthorize("hasAuthority('CP_TENANT_READ') and hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> getCompletedPaymentsByAccount(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentService.getCompletedPaymentsByAccount(accountId));
    }

    // Lista pagamentos dentro de um período (admin global).
    @GetMapping("/period")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> listPaymentsInPeriod(
            @RequestParam("start")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam("end")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getPaymentsInPeriod(startDate, endDate));
    }

    // Soma a receita (pagamentos COMPLETED) no período informado (admin global).
    @GetMapping("/revenue")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<BigDecimal> getRevenue(
            @RequestParam("start")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam("end")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.getTotalRevenue(startDate, endDate));
    }

    // Marca um pagamento PENDING como COMPLETED manualmente (admin global) e aplica efeitos na conta.
    @PostMapping("/{paymentId}/complete-manual")
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> completeManually(@PathVariable Long paymentId) {
        return ResponseEntity.ok(controlPlanePaymentService.completePaymentManually(paymentId));
    }

    // Reembolsa um pagamento elegível (total ou parcial) registrando o motivo (admin global).
    @PostMapping("/{paymentId}/refund")
    @PreAuthorize("hasAuthority('CP_BILLING_WRITE')")
    public ResponseEntity<PaymentResponse> refund(
            @PathVariable Long paymentId,
            @Valid @RequestBody RefundRequest refundRequest
    ) {
        PaymentResponse response =
                controlPlanePaymentService.refundPayment(paymentId, refundRequest.amount(), refundRequest.reason());
        return ResponseEntity.ok(response);
    }

    public record RefundRequest(
            @DecimalMin(value = "0.01", message = "amount deve ser > 0 quando informado")
            BigDecimal amount,
            @NotBlank(message = "reason é obrigatório")
            String reason
    ) {}
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/admin/billing/ControlPlanePaymentQueryController.java
============================================================
package brito.com.multitenancy001.controlplane.api.admin.billing;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import brito.com.multitenancy001.controlplane.application.billing.ControlPlanePaymentQueryService;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/admin/billing/payments/query")
@RequiredArgsConstructor
public class ControlPlanePaymentQueryController {

    private final ControlPlanePaymentQueryService controlPlanePaymentQueryService;

    // ControlPlanePaymentRepository.findByStatus
    @GetMapping("/status/{status}")
    @PreAuthorize("hasAuthority('CP_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> findByStatus(@PathVariable PaymentStatus status) {
        return ResponseEntity.ok(controlPlanePaymentQueryService.findByStatus(status));
    }

    // ControlPlanePaymentRepository.getTotalPaidInPeriod
    @GetMapping("/accounts/{accountId}/total-paid")
    @PreAuthorize("hasAuthority('CP_BILLING_READ') and hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<BigDecimal> totalPaid(
            @PathVariable Long accountId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate
    ) {
        return ResponseEntity.ok(controlPlanePaymentQueryService.getTotalPaidInPeriod(accountId, startDate, endDate));
    }

    // ControlPlanePaymentRepository.countCompletedPayments
    @GetMapping("/accounts/{accountId}/count-completed")
    @PreAuthorize("hasAuthority('CP_BILLING_READ') and hasAuthority('CP_TENANT_READ')")
    public ResponseEntity<Long> countCompleted(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentQueryService.countCompletedPayments(accountId));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/admin/me/ControlPlaneMeController.java
============================================================
package brito.com.multitenancy001.controlplane.api.admin.me;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneChangeMyPasswordRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneMeResponse;
import brito.com.multitenancy001.controlplane.application.user.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/me")
@RequiredArgsConstructor
public class ControlPlaneMeController {

    private final ControlPlaneUserService controlPlaneUserService;

    // Retorna os dados do usuário autenticado (inclui authorities), mesmo quando mustChangePassword=true.
    @GetMapping
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<ControlPlaneMeResponse> me() {
        return ResponseEntity.ok(controlPlaneUserService.getMe());
    }

    // Permite que o usuário autenticado altere a própria senha.
    @PatchMapping("/password")
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<Void> changeMyPassword(@Valid @RequestBody ControlPlaneChangeMyPasswordRequest request) {
        controlPlaneUserService.changeMyPassword(request);
        return ResponseEntity.noContent().build();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/admin/users/ControlPlaneUserController.java
============================================================
package brito.com.multitenancy001.controlplane.api.admin.users;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserPasswordResetRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserPermissionsUpdateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserUpdateRequest;
import brito.com.multitenancy001.controlplane.application.user.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/controlplane-users")
@RequiredArgsConstructor
public class ControlPlaneUserController {

    private final ControlPlaneUserService controlPlaneUserService;

    // Cria um novo usuário do Control Plane (Admin), aplicando validações e regras de negócio (ex.: email único, role/permissões válidas).
    @PostMapping
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> createControlPlaneUser(
            @Valid @RequestBody ControlPlaneUserCreateRequest request
    ) {
        ControlPlaneUserDetailsResponse response = controlPlaneUserService.createControlPlaneUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    // Lista todos os usuários do Control Plane (Admin), incluindo estados (suspensões/deleção) conforme regras do serviço.
    @GetMapping
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listControlPlaneUsers() {
        return ResponseEntity.ok(controlPlaneUserService.listControlPlaneUsers());
    }

    // Obtém os detalhes de um usuário do Control Plane (Admin) pelo id (pode incluir usuário suspenso/deletado, conforme regras do serviço).
    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getControlPlaneUser(userId));
    }

    // Atualiza dados do usuário do Control Plane (Admin) pelo id (ex.: nome, email, role, flags e/ou campos permitidos), conforme validações do serviço.
    @PatchMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUser(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserUpdateRequest request
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUser(userId, request));
    }

    // Atualiza o conjunto de permissões explícitas (overrides) do usuário do Control Plane (Admin), validando escopo e consistência (somente CP_*).
    @PatchMapping("/{userId}/permissions")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUserPermissions(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserPermissionsUpdateRequest request
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUserPermissions(userId, request));
    }

    // Reseta/define uma nova senha para o usuário do Control Plane (Admin) (ação administrativa), conforme política de senha e regras do serviço.
    @PatchMapping("/{userId}/reset-password")
    @PreAuthorize("hasAuthority('CP_USER_PASSWORD_RESET')")
    public ResponseEntity<Void> resetPassword(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserPasswordResetRequest request
    ) {
        controlPlaneUserService.resetControlPlaneUserPassword(userId, request);
        return ResponseEntity.noContent().build();
    }

    // Realiza soft delete do usuário do Control Plane (Admin) pelo id (marca como deleted, preservando histórico/auditoria).
    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('CP_USER_DELETE')")
    public ResponseEntity<Void> deleteControlPlaneUser(@PathVariable Long userId) {
        controlPlaneUserService.softDeleteControlPlaneUser(userId);
        return ResponseEntity.noContent().build();
    }

    // Restaura (undelete) um usuário do Control Plane (Admin) previamente soft-deletado, conforme regras do serviço.
    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority('CP_USER_WRITE')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> restoreControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.restoreControlPlaneUser(userId));
    }

    // Lista apenas usuários "habilitados" para operação: não deletados e não suspensos (nem por admin nem por conta), conforme regra do serviço.
    @GetMapping("/enabled")
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listEnabled() {
        return ResponseEntity.ok(controlPlaneUserService.listEnabledControlPlaneUsers());
    }

    // Obtém usuário "habilitado" pelo id: retorna apenas se estiver apto para operar (não deletado e não suspenso), conforme regra do serviço.
    @GetMapping("/{userId}/enabled")
    @PreAuthorize("hasAuthority('CP_USER_READ')")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getEnabled(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getEnabledControlPlaneUser(userId));
    }

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/accounts/AccountAdminDetailsResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.AccountType;
import brito.com.multitenancy001.controlplane.domain.account.SubscriptionPlan;
import brito.com.multitenancy001.controlplane.domain.account.TaxIdType;

import java.time.LocalDateTime;

public record AccountAdminDetailsResponse(

        // Identificação
        Long id,
        String displayName,
        String slug,
        String schemaName,
        AccountStatus status,
        AccountType accountType,
        SubscriptionPlan subscriptionPlan,

        // Dados legais (sempre em conjunto)
        TaxIdType taxIdType,
        String taxIdNumber,

        // Datas
        LocalDateTime createdAt,
        LocalDateTime trialEndDate,
        LocalDateTime paymentDueDate,
        LocalDateTime deletedAt,

        // Flags calculadas
        boolean inTrial,
        boolean trialExpired,
        long trialDaysRemaining,

        // Admin da conta
        ControlPlaneAdminUserSummaryResponse admin,

        // Indicadores
        long totalControlPlaneUsers,
        boolean operational
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/accounts/AccountResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.AccountType;
import brito.com.multitenancy001.controlplane.domain.account.SubscriptionPlan;

import java.time.LocalDateTime;

public record AccountResponse(
        Long id,
        String displayName,
        String slug,
        String schemaName,
        AccountStatus status,
        AccountType accountType,
        SubscriptionPlan subscriptionPlan,
        LocalDateTime createdAt,
        LocalDateTime trialEndDate
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/accounts/AccountStatusChangeRequest.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public record AccountStatusChangeRequest(
        @NotNull(message = "status é obrigatório")
        AccountStatus status,

        @Size(max = 255, message = "reason deve ter no máximo 255 caracteres")
        String reason
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/accounts/AccountStatusChangeResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.accounts;

import java.time.LocalDateTime;

public record AccountStatusChangeResponse(
        Long id,
        String status,
        String previousStatus,
        LocalDateTime effectiveAt,
        String schemaName,
        SideEffects sideEffects
) {
    public record SideEffects(
            boolean tenantUsersUpdated,
            String action,     // "SUSPEND_BY_ACCOUNT" | "UNSUSPEND_BY_ACCOUNT" | "CANCELLED" | "NONE"
            int tenantUsersCount
    ) {}
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/auth/ControlPlaneAdminLoginRequest.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record ControlPlaneAdminLoginRequest(
        @NotBlank String email,
        @NotBlank String password
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/signup/SignupRequest.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.signup;

import brito.com.multitenancy001.controlplane.domain.account.TaxIdType;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public record SignupRequest(
        @NotBlank(message = "Nome da empresa é obrigatório")
        @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
        String displayName,

        @NotBlank(message = "Email da empresa é obrigatório")
        @Email(message = "Email inválido")
        String loginEmail,

        @NotNull(message = "Tipo de documento é obrigatório (CPF ou CNPJ)")
        TaxIdType taxIdType,

        @NotBlank(message = "Número do documento é obrigatório")
        String taxIdNumber,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
                regexp = ValidationPatterns.PASSWORD_PATTERN,
                message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas e números"
        )
        String password,

        @NotBlank(message = "Confirmação de senha é obrigatória")
        String confirmPassword
) {
    @AssertTrue(message = "As senhas não coincidem")
    public boolean isPasswordMatching() {
        if (password == null || confirmPassword == null) return true;
        return password.equals(confirmPassword);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/signup/SignupResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.signup;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;

public record SignupResponse(
        AccountResponse account,
        TenantAdminResponse tenantAdmin
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/signup/TenantAdminResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.signup;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * DTO do ControlPlane (Signup).
 *
 * Mantém role tipada sem depender do enum do contexto Tenant.
 */
public record TenantAdminResponse(
        Long id,
        String email,
        TenantRoleName role
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/ControlPlaneAdminUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users;

public record ControlPlaneAdminUserSummaryResponse(
        Long id,

        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/ControlPlaneChangeMyPasswordRequest.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record ControlPlaneChangeMyPasswordRequest(
        @NotBlank(message = "Senha atual é obrigatória")
        @Size(min = 8, max = 72, message = "Senha atual deve ter entre 8 e 72 caracteres")
        String currentPassword,

        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, max = 72, message = "Nova senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar senha é obrigatório")
        @Size(min = 8, max = 72, message = "Confirmar senha deve ter entre 8 e 72 caracteres")
        String confirmPassword
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/ControlPlaneMeResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users;

public record ControlPlaneMeResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        String role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/ControlPlaneUserCreateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.List;

@Builder
public record ControlPlaneUserCreateRequest(

        @NotBlank(message = "Nome é obrigatório")
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @NotBlank(message = "Email é obrigatório")
        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email não pode exceder 150 caracteres")
        String email,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
                regexp = ValidationPatterns.PASSWORD_PATTERN,
                message = "Senha fraca / inválida"
        )
        String password,

        @NotNull(message = "Role é obrigatória")
        ControlPlaneRole role,

        List<String> permissions,

        @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, message = "Telefone inválido")
        @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
        String phone,

        @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
        String avatarUrl
) {
    public ControlPlaneUserCreateRequest {
        if (phone != null) phone = phone.trim();
        if (avatarUrl != null) avatarUrl = avatarUrl.trim();
        if (email != null) email = email.trim().toLowerCase();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/ControlPlaneUserDetailsResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users;

import java.time.LocalDateTime;

public record ControlPlaneUserDetailsResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        String role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled,
        LocalDateTime createdAt
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/ControlPlaneUserPasswordResetRequest.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record ControlPlaneUserPasswordResetRequest(
        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, max = 72, message = "Senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar senha é obrigatório")
        @Size(min = 8, max = 72, message = "Confirmar senha deve ter entre 8 e 72 caracteres")
        String confirmPassword
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/ControlPlaneUserPermissionsUpdateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Pattern;

import java.util.List;

public record ControlPlaneUserPermissionsUpdateRequest(
        @NotEmpty(message = "Lista de permissões não pode ser vazia")
        List<
                @Pattern(
                        regexp = "^CP_[A-Z0-9_]+$",
                        message = "Permissões de ControlPlane devem começar com CP_"
                )
                        String
                > permissions
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/ControlPlaneUserUpdateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

import java.util.List;

public record ControlPlaneUserUpdateRequest(
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email deve ter no máximo 150 caracteres")
        String email,

        ControlPlaneRole role,

        List<
                @Pattern(
                        regexp = "^CP_[A-Z0-9_]+$",
                        message = "Permissões de ControlPlane devem começar com CP_"
                )
                String
        > permissions
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/dto/users/summary/AccountTenantUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.controlplane.api.dto.users.summary;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Resumo de usuário de uma conta (visão ControlPlane).
 *
 * Role é tipada usando TenantRoleName (contrato compartilhado),
 * sem dependência do enum interno do Tenant.
 */
public record AccountTenantUserSummaryResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRoleName role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/mapper/AccountAdminDetailsApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.api.mapper;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.time.AppClock;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

@Component
public class AccountAdminDetailsApiMapper {

    private final AppClock appClock;
    private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;

    public AccountAdminDetailsApiMapper(AppClock appClock, ControlPlaneUserApiMapper controlPlaneUserApiMapper) {
        this.appClock = appClock;
        this.controlPlaneUserApiMapper = controlPlaneUserApiMapper;
    }

    public AccountAdminDetailsResponse toResponse(Account account, ControlPlaneUser admin, long totalUsers) {
        LocalDateTime now = appClock.now();
        LocalDate today = now.toLocalDate();
        LocalDate end = account.getTrialEndDate() != null ? account.getTrialEndDate().toLocalDate() : null;

        boolean inTrial = account.getTrialEndDate() != null && now.isBefore(account.getTrialEndDate());
        boolean trialExpired = account.getTrialEndDate() != null && now.isAfter(account.getTrialEndDate());

        long trialDaysRemaining = 0;
        if (inTrial && end != null) {
            trialDaysRemaining = ChronoUnit.DAYS.between(today, end);
        }

        return new AccountAdminDetailsResponse(
                // Identificação
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getSchemaName(),
                account.getStatus(),
                account.getType(),               // ✅ NOVO (AccountType)
                account.getSubscriptionPlan(),    // ✅ NOVO (SubscriptionPlan)

                // Dados legais
                account.getTaxIdType(),
                account.getTaxIdNumber(),

                // Datas
                account.getCreatedAt(),
                account.getTrialEndDate(),
                account.getPaymentDueDate(),
                account.getDeletedAt(),

                // Flags calculadas
                inTrial,
                trialExpired,
                trialDaysRemaining,

                // Admin
                admin != null ? controlPlaneUserApiMapper.toAdminSummary(admin) : null,

                // Indicadores
                totalUsers,
                account.isOperational(now) // ✅ clock-aware
        );
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/mapper/AccountApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.api.mapper;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import org.springframework.stereotype.Component;

@Component
public class AccountApiMapper {

    public AccountResponse toResponse(Account account) {
        return new AccountResponse(
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getSchemaName(),
                account.getStatus(),            // enum direto
                account.getType(),              // enum direto
                account.getSubscriptionPlan(),  // enum direto
                account.getCreatedAt(),
                account.getTrialEndDate()
        );
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/mapper/AccountUserApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;

@Component
public class AccountUserApiMapper {

    public AccountTenantUserSummaryResponse toAccountUserSummary(UserSummaryData user) {

        boolean enabled =
                !user.deleted()
                && !user.suspendedByAccount()
                && !user.suspendedByAdmin();

        return new AccountTenantUserSummaryResponse(
                user.id(),
                user.accountId(),
                user.name(),
                user.email(),
                user.role(),
                user.suspendedByAccount(),
                user.suspendedByAdmin(),
                enabled
        );
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/mapper/ControlPlaneUserApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.api.mapper;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import org.springframework.stereotype.Component;

@Component
public class ControlPlaneUserApiMapper {

    public ControlPlaneAdminUserSummaryResponse toAdminSummary(ControlPlaneUser controlPlaneUser) {
        return new ControlPlaneAdminUserSummaryResponse(
                controlPlaneUser.getId(),
   
                controlPlaneUser.getEmail(),
                controlPlaneUser.isSuspendedByAccount(),
                controlPlaneUser.isSuspendedByAdmin()
        );
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/api/publicsignup/AccountSignupController.java
============================================================
package brito.com.multitenancy001.controlplane.api.publicsignup;

import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupResponse;
import brito.com.multitenancy001.controlplane.application.AccountLifecycleService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/signup")
@RequiredArgsConstructor
public class AccountSignupController {

    private final AccountLifecycleService accountLifecycleService;

    @PostMapping
    public ResponseEntity<SignupResponse> signup(@Valid @RequestBody SignupRequest signupRequest) {
        SignupResponse response = accountLifecycleService.createAccount(signupRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/AccountEntitlementsProvisioningService.java
============================================================
package brito.com.multitenancy001.controlplane.application;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import brito.com.multitenancy001.controlplane.persistence.account.AccountEntitlementsRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsProvisioningService {

    private final AccountEntitlementsRepository accountEntitlementsRepository;

    @Transactional(transactionManager = "publicTransactionManager")
    public void ensureDefaultEntitlementsForTenant(Account account) {
        if (account == null || account.getId() == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "Conta é obrigatória", 400);
        }

        if (account.isBuiltInAccount()) {
            // BUILTIN não tem entitlements
            return;
        }

        if (accountEntitlementsRepository.existsById(account.getId())) {
            return;
        }

        AccountEntitlements ent = AccountEntitlements.builder()
                .account(account)
                .maxUsers(5)
                .maxProducts(100)
                .maxStorageMb(100)
                .build();

        accountEntitlementsRepository.save(ent);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/AccountLifecycleService.java
============================================================
package brito.com.multitenancy001.controlplane.application;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.mapper.AccountAdminDetailsApiMapper;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountLifecycleService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final AccountAdminDetailsApiMapper accountAdminDetailsApiMapper;
    private final AccountApiMapper accountApiMapper;
    private final AccountRepository accountRepository;
    private final AccountOnboardingService accountOnboardingService;
    private final AccountStatusService accountStatusService;
    private final AccountTenantUserService accountTenantUserService;
    private final PublicUnitOfWork publicUnitOfWork;
    private final AppClock appClock;

    // =========================================================
    // 1) ONBOARDING / SIGNUP
    // =========================================================

    public SignupResponse createAccount(SignupRequest signupRequest) {
        return accountOnboardingService.createAccount(signupRequest);
    }


    // =========================================================
    // 2) CONSULTAS EXISTENTES
    // =========================================================

    public List<AccountResponse> listAccounts() {
        return publicUnitOfWork.readOnly(() ->
                accountRepository.findAllByDeletedFalse()
                        .stream()
                        .map(accountApiMapper::toResponse)
                        .toList()
        );
    }

    public AccountResponse getAccount(Long accountId) {
        return publicUnitOfWork.readOnly(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
            return accountApiMapper.toResponse(account);
        });
    }

    public AccountAdminDetailsResponse getAccountAdminDetails(Long accountId) {
        return publicUnitOfWork.readOnly(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            long totalUsers = controlPlaneUserRepository.countByAccount_IdAndDeletedFalse(accountId);

            return accountAdminDetailsApiMapper.toResponse(account, null, totalUsers);
        });
    }

    // =========================================================
    // 3) STATUS / SOFT DELETE / RESTORE (EXISTENTES)
    // =========================================================

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        return accountStatusService.changeAccountStatus(accountId, req);
    }

    public void softDeleteAccount(Long accountId) {
        accountStatusService.softDeleteAccount(accountId);
    }

    public void restoreAccount(Long accountId) {
        accountStatusService.restoreAccount(accountId);
    }

    public List<AccountTenantUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyOperational) {
        return accountTenantUserService.listTenantUsers(accountId, onlyOperational);
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        accountTenantUserService.setUserSuspendedByAdmin(accountId, userId, suspended);
    }

    // =========================================================
    // 4) CONSULTAS ADMIN (PAGINAÇÃO + LIMITES)
    // =========================================================

    private static final int DEFAULT_PAGE_SIZE = 20;
    private static final int MAX_PAGE_SIZE = 100;
    private static final long MAX_CREATED_BETWEEN_DAYS = 90;

    private Pageable normalizePageable(Pageable pageable) {
        if (pageable == null) {
            return PageRequest.of(0, DEFAULT_PAGE_SIZE);
        }

        int page = Math.max(0, pageable.getPageNumber());
        int size = pageable.getPageSize();

        if (size <= 0) size = DEFAULT_PAGE_SIZE;
        if (size > MAX_PAGE_SIZE) size = MAX_PAGE_SIZE;

        return PageRequest.of(page, size, pageable.getSort());
    }

    private void assertValidCreatedBetweenRange(LocalDateTime start, LocalDateTime end) {
        if (start == null || end == null) {
            throw new ApiException("INVALID_DATE_RANGE", "start e end são obrigatórios", 400);
        }
        if (end.isBefore(start)) {
            throw new ApiException("INVALID_DATE_RANGE", "end deve ser >= start", 400);
        }

        long days = Duration.between(start, end).toDays();
        if (days > MAX_CREATED_BETWEEN_DAYS) {
            throw new ApiException(
                    "DATE_RANGE_TOO_LARGE",
                    "Intervalo máximo permitido é de " + MAX_CREATED_BETWEEN_DAYS + " dias",
                    400
            );
        }
    }

    public Page<AccountResponse> listAccountsLatest(Pageable pageable) {
        Pageable p = normalizePageable(pageable);

        return publicUnitOfWork.readOnly(() ->
                accountRepository.findByDeletedFalseOrderByCreatedAtDesc(p)
                        .map(accountApiMapper::toResponse)
        );
    }

    public AccountResponse getAccountBySlugIgnoreCase(String slug) {
        if (slug == null || slug.isBlank()) {
            throw new ApiException("INVALID_SLUG", "slug é obrigatório", 400);
        }

        return publicUnitOfWork.readOnly(() -> {
            Account account = accountRepository.findBySlugAndDeletedFalseIgnoreCase(slug.trim())
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
            return accountApiMapper.toResponse(account);
        });
    }

    public Page<AccountResponse> listAccountsByStatus(AccountStatus status, Pageable pageable) {
        if (status == null) {
            throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
        }

        Pageable p = normalizePageable(pageable);

        return publicUnitOfWork.readOnly(() ->
                accountRepository.findByStatusAndDeletedFalse(status, p)
                        .map(accountApiMapper::toResponse)
        );
    }

    public Page<AccountResponse> listAccountsCreatedBetween(LocalDateTime start, LocalDateTime end, Pageable pageable) {
        assertValidCreatedBetweenRange(start, end);

        Pageable p = normalizePageable(pageable);

        return publicUnitOfWork.readOnly(() ->
                accountRepository.findAccountsCreatedBetween(start, end, p)
                        .map(accountApiMapper::toResponse)
        );
    }

    public Page<AccountResponse> searchAccountsByDisplayName(String term, Pageable pageable) {
        if (term == null || term.isBlank()) {
            throw new ApiException("INVALID_SEARCH", "term é obrigatório", 400);
        }

        Pageable p = normalizePageable(pageable);

        return publicUnitOfWork.readOnly(() ->
                accountRepository.searchByDisplayName(term.trim(), p)
                        .map(accountApiMapper::toResponse)
        );
    }

    // =========================================================
    // 5) QUERIES ADMIN (usar métodos do AccountRepository)
    // =========================================================

    public long countAccountsByStatus(AccountStatus status) {
        if (status == null) {
            throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
        }
        return publicUnitOfWork.readOnly(() -> accountRepository.countByStatusAndDeletedFalse(status));
    }

    public List<AccountResponse> listAccountsByStatuses(List<AccountStatus> statuses) {
        if (statuses == null || statuses.isEmpty()) {
            throw new ApiException("INVALID_STATUS_LIST", "statuses é obrigatório", 400);
        }

        return publicUnitOfWork.readOnly(() ->
                accountRepository.findByStatuses(statuses)
                        .stream()
                        .map(accountApiMapper::toResponse)
                        .toList()
        );
    }

    public List<AccountResponse> listExpiredTrials(LocalDateTime date, AccountStatus status) {
        LocalDateTime d = (date != null ? date : appClock.now());
        AccountStatus st = (status != null ? status : AccountStatus.FREE_TRIAL);

        return publicUnitOfWork.readOnly(() ->
                accountRepository.findExpiredTrialsNotDeleted(d, st)
                        .stream()
                        .map(accountApiMapper::toResponse)
                        .toList()
        );
    }


    public List<AccountResponse> listOverdueAccounts(LocalDateTime today, AccountStatus status) {
        LocalDateTime t = (today != null ? today : appClock.now());
        AccountStatus st = (status != null ? status : AccountStatus.ACTIVE);

        return publicUnitOfWork.readOnly(() ->
                accountRepository.findOverdueAccountsNotDeleted(st, t)
                        .stream()
                        .map(accountApiMapper::toResponse)
                        .toList()
        );
    }


    public long countOperationalAccounts() {
        return publicUnitOfWork.readOnly(accountRepository::countOperationalAccounts);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/AccountOnboardingService.java
============================================================
package brito.com.multitenancy001.controlplane.application;

import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.api.dto.signup.SignupResponse;
import brito.com.multitenancy001.controlplane.api.dto.signup.TenantAdminResponse;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.tenant.TenantSchemaProvisioningFacade;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserProvisioningFacade;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountOnboardingService {

    private final AccountApiMapper accountApiMapper;
    private final PublicAccountCreationService publicAccountCreationService;

    private final TenantSchemaProvisioningFacade tenantSchemaProvisioningFacade;
    private final TenantUserProvisioningFacade tenantUserProvisioningFacade;

    private final AccountRepository accountRepository;
    private final PublicUnitOfWork publicUnitOfWork;

    public SignupResponse createAccount(SignupRequest signupRequest) {
        validateSignupRequest(signupRequest);

        log.info("Tentando criar conta");

        Account account = publicUnitOfWork.tx(() ->
                publicAccountCreationService.createAccountFromSignup(signupRequest)
        );

        tenantSchemaProvisioningFacade.ensureSchemaExistsAndMigrate(account.getSchemaName());

        UserSummaryData tenantOwner = tenantUserProvisioningFacade.createTenantOwner(
                account.getSchemaName(),
                account.getId(),
                account.getDisplayName(),
                signupRequest.loginEmail(),
                signupRequest.password()
        );

        log.info("✅ Account criada | accountId={} | schemaName={} | slug={}",
                account.getId(), account.getSchemaName(), account.getSlug());

        AccountResponse accountResponse = accountApiMapper.toResponse(account);

        TenantAdminResponse tenantAdminResponse = new TenantAdminResponse(
                tenantOwner.id(),
                tenantOwner.email(),
                tenantOwner.role()
        );



        return new SignupResponse(accountResponse, tenantAdminResponse);
    }

    private void validateSignupRequest(SignupRequest signupRequest) {
        if (signupRequest == null) {
            throw new ApiException("INVALID_REQUEST", "Requisição inválida", 400);
        }

        if (!StringUtils.hasText(signupRequest.displayName())) {
            throw new ApiException("INVALID_COMPANY_NAME", "Nome da empresa é obrigatório", 400);
        }

        if (!StringUtils.hasText(signupRequest.loginEmail())) {
            throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
        }

        String email = signupRequest.loginEmail().trim().toLowerCase();

        if (!email.contains("@")) {
            throw new ApiException("INVALID_EMAIL", "Email inválido", 400);
        }

        if (signupRequest.taxIdType() == null) {
            throw new ApiException("INVALID_COMPANY_DOC_TYPE", "Tipo de documento é obrigatório", 400);
        }

        if (!StringUtils.hasText(signupRequest.taxIdNumber())) {
            throw new ApiException("INVALID_COMPANY_DOC_NUMBER", "Número do documento é obrigatório", 400);
        }

        if (!StringUtils.hasText(signupRequest.password()) || !StringUtils.hasText(signupRequest.confirmPassword())) {
            throw new ApiException("INVALID_PASSWORD", "Senha e confirmação são obrigatórias", 400);
        }

        if (!signupRequest.password().equals(signupRequest.confirmPassword())) {
            throw new ApiException("PASSWORD_MISMATCH", "As senhas não coincidem", 400);
        }

        if (accountRepository.existsByLoginEmailAndDeletedFalse(email)) {
            throw new ApiException("EMAIL_ALREADY_REGISTERED", "Email já cadastrado na plataforma", 409);
        }

        if (accountRepository.existsByTaxIdTypeAndTaxIdNumberAndDeletedFalse(
                signupRequest.taxIdType(), signupRequest.taxIdNumber()
        )) {
            throw new ApiException("DOC_ALREADY_REGISTERED", "Documento já cadastrado na plataforma", 409);
        }

        // Se você quer travar especificamente "BR" aqui, ok.
        // Caso deseje tornar multi-país, troque para signupRequest.taxCountryCode().
        if (accountRepository.existsByTaxCountryCodeAndTaxIdTypeAndTaxIdNumberAndDeletedFalse(
                "BR", signupRequest.taxIdType(), signupRequest.taxIdNumber()
        )) {
            throw new ApiException("DOC_ALREADY_REGISTERED", "Documento já cadastrado na plataforma", 409);
        }
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/AccountStatusService.java
============================================================
package brito.com.multitenancy001.controlplane.application;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserProvisioningFacade;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountStatusService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final AccountRepository accountRepository;
    private final TenantUserProvisioningFacade tenantUserProvisioningFacade;
    private final AppClock appClock;

    public AccountStatusChangeResponse changeAccountStatus(Long accountId, AccountStatusChangeRequest req) {
        if (accountId == null) {
            throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);
        }
        if (req == null || req.status() == null) {
            throw new ApiException("STATUS_REQUIRED", "status é obrigatório", 400);
        }

        return publicUnitOfWork.tx(() -> {

            Account account = getAccountByIdRaw(accountId);
            AccountStatus previous = account.getStatus();

            AccountStatus newStatus = req.status();
            account.setStatus(newStatus);

            // Mantém seu comportamento atual:
            // - quando volta para ACTIVE, limpa deletedAt
            // OBS: se isso não for desejado, remova este bloco e use somente restoreAccount().
            if (newStatus == AccountStatus.ACTIVE) {
                account.setDeletedAt(null);
            }

            accountRepository.save(account);

            int affected = 0;
            boolean applied = false;
            AccountStatusSideEffect action = AccountStatusSideEffect.NONE;

            if (newStatus == AccountStatus.SUSPENDED) {
                affected = tenantUserProvisioningFacade.suspendAllUsersByAccount(account.getSchemaName(), account.getId());
                applied = true;
                action = AccountStatusSideEffect.SUSPEND_BY_ACCOUNT;
            } else if (newStatus == AccountStatus.ACTIVE) {
                affected = tenantUserProvisioningFacade.unsuspendAllUsersByAccount(account.getSchemaName(), account.getId());
                applied = true;
                action = AccountStatusSideEffect.UNSUSPEND_BY_ACCOUNT;
            } else if (newStatus == AccountStatus.CANCELLED) {
                affected = cancelAccount(account);
                applied = true;
                action = AccountStatusSideEffect.CANCELLED;
            }

            return buildStatusChangeResponse(account, previous, applied, action, affected);
        });
    }

    public void softDeleteAccount(Long accountId) {
        if (accountId == null) {
            throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);
        }

        publicUnitOfWork.tx(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isBuiltInAccount()) {
                throw new ApiException(
                        "BUILTIN_ACCOUNT_PROTECTED",
                        "Não é permitido excluir contas do sistema",
                        403
                );
            }

            account.softDelete(appClock.now());
            accountRepository.save(account);

            tenantUserProvisioningFacade.softDeleteAllUsersByAccount(account.getSchemaName(), account.getId());
        });
    }

    public void restoreAccount(Long accountId) {
        if (accountId == null) {
            throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);
        }

        publicUnitOfWork.tx(() -> {

            Account account = getAccountByIdRaw(accountId);

            if (account.isBuiltInAccount() && account.isDeleted()) {
                throw new ApiException(
                        "BUILTIN_ACCOUNT_PROTECTED",
                        "Contas do sistema não podem ser restauradas via este endpoint",
                        403
                );
            }

            account.restore();
            accountRepository.save(account);

            tenantUserProvisioningFacade.restoreAllUsersByAccount(account.getSchemaName(), account.getId());
        });
    }

    private int cancelAccount(Account account) {
        // Mantém sua ideia de "marca deleted_at" em TX separada.
        publicUnitOfWork.requiresNew(() -> {
            account.setDeletedAt(appClock.now());
            accountRepository.save(account);
        });

        return tenantUserProvisioningFacade.softDeleteAllUsersByAccount(account.getSchemaName(), account.getId());
    }

    private Account getAccountByIdRaw(Long accountId) {
        return accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
    }

    private AccountStatusChangeResponse buildStatusChangeResponse(
            Account account,
            AccountStatus previous,
            boolean tenantUsersUpdated,
            AccountStatusSideEffect action,
            int count
    ) {
        return new AccountStatusChangeResponse(
                account.getId(),
                account.getStatus().name(),
                previous == null ? null : previous.name(),
                appClock.now(),
                account.getSchemaName(),
                new AccountStatusChangeResponse.SideEffects(
                        tenantUsersUpdated,
                        action.name(),
                        count
                )
        );
    }

    /**
     * Side effect tipado para manter padrão de consistência.
     * Ainda é serializado como String no response (action.name()).
     */
    private enum AccountStatusSideEffect {
        NONE,
        SUSPEND_BY_ACCOUNT,
        UNSUSPEND_BY_ACCOUNT,
        CANCELLED
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/AccountTenantUserService.java
============================================================
package brito.com.multitenancy001.controlplane.application;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.users.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.api.mapper.AccountUserApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.infrastructure.tenant.TenantUserProvisioningFacade;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountTenantUserService {

    private final PublicUnitOfWork publicUnitOfWork;
    private final AccountRepository accountRepository;
    private final TenantUserProvisioningFacade tenantUserProvisioningFacade;
    private final AccountUserApiMapper accountUserApiMapper;

    public List<AccountTenantUserSummaryResponse> listTenantUsers(Long accountId, boolean onlyOperational) {

        Account account = publicUnitOfWork.readOnly(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );

        List<UserSummaryData> data = tenantUserProvisioningFacade
                .listUserSummaries(account.getSchemaName(), account.getId(), onlyOperational);

        return data.stream()
                .map(accountUserApiMapper::toAccountUserSummary)
                .toList();
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {

        Account account = publicUnitOfWork.readOnly(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404))
        );

        tenantUserProvisioningFacade.setSuspendedByAdmin(account.getSchemaName(), account.getId(), userId, suspended);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/ControlPlaneAuthService.java
============================================================
package brito.com.multitenancy001.controlplane.application;

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.api.dto.auth.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlaneAuthService {

    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final PublicExecutor publicExecutor;

    public JwtResponse loginControlPlaneUser(ControlPlaneAdminLoginRequest controlPlaneAdminLoginRequest) {

        return publicExecutor.run(() -> {

            // 1) busca user (public)
            ControlPlaneUser user = controlPlaneUserRepository
                    .findByEmailAndDeletedFalse(controlPlaneAdminLoginRequest.email())
                    .orElseThrow(() -> new ApiException(
                            "USER_NOT_FOUND",
                            "Usuário de plataforma não encontrado",
                            404
                    ));

            // 2) regra: suspenso por conta -> bloqueia
            if (user.isSuspendedByAccount()) {
                throw new ApiException("ACCESS_DENIED", "Usuário não autorizado", 403);
            }

            // 3) autentica de fato (senha)
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(controlPlaneAdminLoginRequest.email(), controlPlaneAdminLoginRequest.password())
            );

            // ✅ IMPORTANTE:
            // Não bloquear must_change_password no login.
            // O bloqueio de rotas deve acontecer no MustChangePasswordFilter,
            // permitindo apenas /api/admin/me/password.

            // 4) tokens
            String accessToken = jwtTokenProvider.generateControlPlaneToken(
                    authentication,
                    user.getAccount().getId(),
                    DEFAULT_SCHEMA
            );

            String refreshToken = jwtTokenProvider.generateRefreshToken(
                    user.getEmail(),
                    DEFAULT_SCHEMA
            );

            return JwtResponse.forEmailLogin(
                    accessToken,
                    refreshToken,
                    user.getId(),
                    user.getEmail(),
                    user.getRole().name(),
                    user.getAccount().getId(),
                    DEFAULT_SCHEMA
            );
        });
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/PublicAccountCreationService.java
============================================================
package brito.com.multitenancy001.controlplane.application;

import java.util.UUID;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.api.dto.signup.SignupRequest;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountOrigin;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.AccountType;
import brito.com.multitenancy001.controlplane.domain.account.SubscriptionPlan;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.domain.DomainException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(transactionManager = "publicTransactionManager")
public class PublicAccountCreationService {

    private final AccountRepository accountRepository;
    private final AccountEntitlementsProvisioningService accountEntitlementsProvisioningService;
    private final AppClock appClock;

    public Account createAccountFromSignup(SignupRequest signupRequest) {

        int maxAttempts = 5;
        for (int attempt = 1; attempt <= maxAttempts; attempt++) {
            String slug = generateSlug(signupRequest.displayName());
            String schemaName = generateSchemaName(signupRequest.displayName());

            try {
                Account account = new Account();
                account.setType(AccountType.TENANT);
                account.setOrigin(AccountOrigin.ADMIN);
                account.setDisplayName(signupRequest.displayName());
                account.setSlug(slug);
                account.setSchemaName(schemaName);

                account.setLoginEmail(signupRequest.loginEmail());
                account.setTaxIdType(signupRequest.taxIdType());
                account.setTaxIdNumber(signupRequest.taxIdNumber());

                // ✅ sem LocalDateTime variável -> sem import LocalDateTime
                account.setTrialEndDate(appClock.now().plusDays(30));
                account.setStatus(AccountStatus.FREE_TRIAL);
                account.setSubscriptionPlan(SubscriptionPlan.FREE);

                account.setCountry("Brasil");
                account.setTimezone("America/Sao_Paulo");
                account.setLocale("pt_BR");
                account.setCurrency("BRL");

                if (account.getType() == AccountType.PLATFORM
                        && accountRepository.existsByTypeAndDeletedFalse(AccountType.PLATFORM)) {
                    throw new DomainException("Only one PLATFORM account is allowed");
                }

                Account saved = accountRepository.save(account);

                accountEntitlementsProvisioningService.ensureDefaultEntitlementsForTenant(saved);

                return saved;

            } catch (DataIntegrityViolationException e) {
                log.warn("Tentativa {} falhou por conflito (slug/schema). Tentando novamente...", attempt);
            }
        }

        throw new RuntimeException("Falha ao criar conta após " + maxAttempts + " tentativas");
    }

    private String generateSlug(String displayName) {
        String base = displayName.trim().toLowerCase().replaceAll("[^a-z0-9]+", "-");
        base = base.replaceAll("(^-+|-+$)", "");
        if (base.length() < 3) base = "tenant";
        return base + "-" + UUID.randomUUID().toString().substring(0, 6);
    }

    private String generateSchemaName(String displayName) {
        String base = displayName.trim().toLowerCase().replaceAll("[^a-z0-9]+", "_");
        base = base.replaceAll("(^_+|_+$)", "");
        if (base.length() < 3) base = "tenant";
        return "t_" + base + "_" + UUID.randomUUID().toString().substring(0, 6);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/billing/ControlPlanePaymentQueryService.java
============================================================
package brito.com.multitenancy001.controlplane.application.billing;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.persistence.billing.ControlPlanePaymentRepository;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.billing.PaymentQueryFacade;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlanePaymentQueryService implements PaymentQueryFacade {

    private final ControlPlanePaymentRepository controlPlanePaymentRepository;
    private final brito.com.multitenancy001.shared.time.AppClock appClock;

    @Transactional(readOnly = true)
    @Override
    public List<PaymentResponse> findByStatus(PaymentStatus status) {
        if (status == null) throw new ApiException("PAYMENT_STATUS_REQUIRED", "status é obrigatório", 400);

        return controlPlanePaymentRepository.findByStatus(status)
                .stream()
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    @Override
    public BigDecimal getTotalPaidInPeriod(Long accountId, LocalDateTime startDate, LocalDateTime endDate) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);
        if (startDate == null || endDate == null) throw new ApiException("DATE_RANGE_REQUIRED", "startDate/endDate são obrigatórios", 400);

        BigDecimal total = controlPlanePaymentRepository.getTotalPaidInPeriod(accountId, startDate, endDate);
        return total != null ? total : BigDecimal.ZERO;
    }

    @Transactional(readOnly = true)
    @Override
    public long countCompletedPayments(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);

        Long count = controlPlanePaymentRepository.countCompletedPayments(accountId);
        return count != null ? count : 0L;
    }

    @Transactional(readOnly = true)
    @Override
    public List<PaymentResponse> listByAccount(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);

        return controlPlanePaymentRepository.findByAccountIdOrderByCreatedAtDesc(accountId)
                .stream()
                .map(this::mapToResponse)
                .toList();
    }

    @Transactional(readOnly = true)
    @Override
    public PaymentResponse getByAccount(Long accountId, Long paymentId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);
        if (paymentId == null) throw new ApiException("PAYMENT_ID_REQUIRED", "paymentId é obrigatório", 400);

        Payment payment = controlPlanePaymentRepository.findByIdAndAccountId(paymentId, accountId)
                .orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

        return mapToResponse(payment);
    }

    /**
     * "Active payment" no seu domínio: assume que significa
     * existir pagamento com status COMPLETED e validUntil >= now.
     * Ajuste aqui se sua regra for diferente (ex.: status=ACTIVE).
     */
    @Transactional(readOnly = true)
    @Override
    public boolean hasActivePayment(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "accountId é obrigatório", 400);

        return controlPlanePaymentRepository.existsActivePayment(accountId, appClock.now());
    }

    private PaymentResponse mapToResponse(Payment payment) {
        return new PaymentResponse(
                payment.getId(),
                payment.getAccount().getId(),
                payment.getAmount(),
                payment.getPaymentDate(),
                payment.getValidUntil(),
                payment.getStatus(),
                payment.getTransactionId(),
                payment.getPaymentMethod(),
                payment.getPaymentGateway(),
                payment.getDescription(),
                payment.getCreatedAt(),
                payment.getUpdatedAt()
        );
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/billing/ControlPlanePaymentService.java
============================================================
package brito.com.multitenancy001.controlplane.application.billing;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.application.AccountStatusService;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.billing.ControlPlanePaymentRepository;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ControlPlanePaymentService {

	private final AccountRepository accountRepository;
	private final ControlPlanePaymentRepository controlPlanePaymentRepository;
	private final SecurityUtils securityUtils;
	private final AppClock appClock;
	private final AccountStatusService accountStatusService;

	@Scheduled(cron = "${app.payment.check-cron:0 0 0 * * *}")
	public void checkPayments() {
		log.info("Iniciando verificação de pagamentos...");
		LocalDateTime now = appClock.now();

		// Trials expirados
		List<Account> expiredTrials = accountRepository.findExpiredTrialsNotDeleted(now, AccountStatus.FREE_TRIAL);

		for (Account account : expiredTrials) {
			if (account.getStatus() != AccountStatus.SUSPENDED) {
				suspendAccount(account, "Trial expirado");
			}
		}

		// Pagamentos vencidos
		List<Account> overdueAccounts = accountRepository.findOverdueAccountsNotDeleted(AccountStatus.ACTIVE, now);

		for (Account account : overdueAccounts) {
			if (account.getStatus() != AccountStatus.SUSPENDED) {
				suspendAccount(account, "Pagamento atrasado");
			}
		}

		checkExpiredPendingPayments(now);
	}

	private void suspendAccount(Account account, String reason) {
		// garante side effects (suspender tenant users)
		accountStatusService.changeAccountStatus(account.getId(),
				new AccountStatusChangeRequest(AccountStatus.SUSPENDED, reason));

		sendSuspensionEmail(account, reason);
	}

	private void checkExpiredPendingPayments(LocalDateTime now) {
		LocalDateTime thirtyMinutesAgo = now.minusMinutes(30);

		List<Payment> expiredPayments = controlPlanePaymentRepository.findByStatusAndCreatedAtBefore(PaymentStatus.PENDING,
				thirtyMinutesAgo);

		for (Payment payment : expiredPayments) {
			payment.setStatus(PaymentStatus.EXPIRED);
			controlPlanePaymentRepository.save(payment);
		}
	}

	@Transactional
	public PaymentResponse processPaymentForAccount(AdminPaymentRequest adminPaymentRequest) {

		if (adminPaymentRequest.accountId() == null) {
			throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
		}

		Account account = accountRepository.findById(adminPaymentRequest.accountId())
				.orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

		LocalDateTime now = appClock.now();
		validatePayment(account, adminPaymentRequest.amount(), now);

		Payment payment = Payment.builder()
		        .account(account)
		        .amount(adminPaymentRequest.amount())
		        .paymentMethod(adminPaymentRequest.paymentMethod())
		        .paymentGateway(adminPaymentRequest.paymentGateway())
		        .description(adminPaymentRequest.description())
		        .status(PaymentStatus.PENDING)
		        .paymentDate(now)
		        .build();


		payment = controlPlanePaymentRepository.save(payment);

		boolean ok = processWithPaymentGateway(payment,
				new PaymentRequest(adminPaymentRequest.amount(), adminPaymentRequest.paymentMethod(),
						adminPaymentRequest.paymentGateway(), adminPaymentRequest.description()));

		if (ok) {
			completePayment(payment, account, now);
			return mapToResponse(payment);
		}

		failPayment(payment, "Falha no processamento do pagamento");
		throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
	}

	@Transactional
	public PaymentResponse processPaymentForMyAccount(PaymentRequest paymentRequest) {
		Long accountId = securityUtils.getCurrentAccountId();
		Account account = findAccountOrThrow(accountId);

		LocalDateTime now = appClock.now();
		validatePayment(account, paymentRequest.amount(), now);

		Payment payment = Payment.builder()
		        .account(account)
		        .amount(paymentRequest.amount())
		        .paymentMethod(paymentRequest.paymentMethod())
		        .paymentGateway(paymentRequest.paymentGateway())
		        .description(paymentRequest.description())
		        .status(PaymentStatus.PENDING)
		        .paymentDate(now)
		        .build();


		payment = controlPlanePaymentRepository.save(payment);

		boolean ok = processWithPaymentGateway(payment, paymentRequest);

		if (ok) {
			completePayment(payment, account, now);
			return mapToResponse(payment);
		}

		failPayment(payment, "Falha no processamento do pagamento");
		throw new ApiException("PAYMENT_FAILED", "Falha no processamento do pagamento", 402);
	}

	@Transactional(readOnly = true)
	public PaymentResponse getPaymentByIdForMyAccount(Long paymentId) {
		Long accountId = securityUtils.getCurrentAccountId();

		Payment payment = controlPlanePaymentRepository.findScopedByIdAndAccountId(paymentId, accountId)
				.orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

		return mapToResponse(payment);
	}

	@Transactional(readOnly = true)
	public List<PaymentResponse> getPaymentsByMyAccount() {
		Long accountId = securityUtils.getCurrentAccountId();
		return getPaymentsByAccount(accountId);
	}

	@Transactional(readOnly = true)
	public boolean hasActivePaymentMyAccount() {
		Long accountId = securityUtils.getCurrentAccountId();
		return hasActivePayment(accountId);
	}

	@Transactional(readOnly = true)
	public List<PaymentResponse> getPaymentsByAccount(Long accountId) {
		return controlPlanePaymentRepository.findByAccountId(accountId).stream().map(this::mapToResponse)
				.collect(Collectors.toList());
	}

	@Transactional(readOnly = true)
	public boolean hasActivePayment(Long accountId) {
	    return controlPlanePaymentRepository.existsActivePayment(accountId, appClock.now());
	}


	@Transactional(readOnly = true)
	public PaymentResponse getPaymentById(Long paymentId) {
		Payment payment = controlPlanePaymentRepository.findById(paymentId)
				.orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));
		return mapToResponse(payment);
	}

	@Transactional
	public PaymentResponse completePaymentManually(Long paymentId) {

		Payment payment = controlPlanePaymentRepository.findById(paymentId)
				.orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

		if (payment.getStatus() != PaymentStatus.PENDING) {
			throw new ApiException("INVALID_PAYMENT_STATUS", "Pagamento não está pendente", 409);
		}

		LocalDateTime now = appClock.now();
		completePayment(payment, payment.getAccount(), now);
		return mapToResponse(payment);
	}

	@Transactional
	public PaymentResponse refundPayment(Long paymentId, BigDecimal amount, String reason) {

		Payment payment = controlPlanePaymentRepository.findById(paymentId)
				.orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

		LocalDateTime now = appClock.now();

		if (!payment.canBeRefunded(now)) {
			throw new ApiException("PAYMENT_NOT_REFUNDABLE", "Pagamento não pode ser reembolsado", 409);
		}

		if (amount == null) {
			payment.refundFully(now, reason);
		} else {
			payment.refundPartially(now, amount, reason);
		}

		controlPlanePaymentRepository.save(payment);
		return mapToResponse(payment);
	}

	@Transactional(readOnly = true)
	public BigDecimal getTotalRevenue(LocalDateTime startDate, LocalDateTime endDate) {
		List<Object[]> revenueByAccount = controlPlanePaymentRepository.getRevenueByAccount(startDate, endDate);

		return revenueByAccount.stream().map(obj -> (BigDecimal) obj[1]).reduce(BigDecimal.ZERO, BigDecimal::add);
	}

	/*
	 * ========================================================= PRIVATE HELPERS
	 * =========================================================
	 */

	private Account findAccountOrThrow(Long accountId) {
		return accountRepository.findById(accountId)
				.orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));
	}

	private void completePayment(Payment payment, Account account, LocalDateTime now) {
		payment.markAsCompleted(now);
		controlPlanePaymentRepository.save(payment);

		account.setStatus(AccountStatus.ACTIVE);
		account.setPaymentDueDate(calculateNextDueDate(payment.getValidUntil(), now));
		accountRepository.save(account);

		sendPaymentConfirmationEmail(account, payment);
	}

	private void failPayment(Payment payment, String reason) {
		payment.markAsFailed(reason);
		controlPlanePaymentRepository.save(payment);
	}

	private void validatePayment(Account account, BigDecimal amount, LocalDateTime now) {

		if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
			throw new ApiException("INVALID_AMOUNT", "Valor do pagamento inválido", 400);
		}

		if (account.isDeleted()) {
			throw new ApiException("ACCOUNT_DELETED", "Conta deletada", 410);
		}

		if (account.isBuiltInAccount()) {
			throw new ApiException("BUILTIN ACCOUNT_NO_BILLING", "Conta BUILTIN não possui billing", 409);
		}

		boolean hasActive = controlPlanePaymentRepository.existsActivePayment(account.getId(), now);

		if (hasActive) {
		    throw new ApiException("PAYMENT_ALREADY_EXISTS", "Já existe um pagamento ativo para esta conta", 409);
		}

			
			
		}
	

	// =========================================================
	// ✅ QUERIES / HELPERS para usar métodos do PaymentRepository
	// =========================================================

	@Transactional(readOnly = true)
	public boolean paymentExistsForAccount(Long paymentId, Long accountId) {
		if (paymentId == null) {
			throw new ApiException("PAYMENT_ID_REQUIRED", "paymentId é obrigatório", 400);
		}
		if (accountId == null) {
			throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
		}
		return controlPlanePaymentRepository.existsByIdAndAccountId(paymentId, accountId);
	}

	@Transactional(readOnly = true)
	public List<PaymentResponse> getPaymentsByAccountAndStatus(Long accountId, PaymentStatus status) {
		if (accountId == null) {
			throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
		}
		if (status == null) {
			throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
		}

		return controlPlanePaymentRepository.findByAccountIdAndStatus(accountId, status).stream().map(this::mapToResponse).toList();
	}

	@Transactional(readOnly = true)
	public PaymentResponse getPaymentByTransactionId(String transactionId) {
		if (transactionId == null || transactionId.isBlank()) {
			throw new ApiException("INVALID_TRANSACTION_ID", "transactionId é obrigatório", 400);
		}

		Payment payment = controlPlanePaymentRepository.findByTransactionId(transactionId.trim())
				.orElseThrow(() -> new ApiException("PAYMENT_NOT_FOUND", "Pagamento não encontrado", 404));

		return mapToResponse(payment);
	}

	@Transactional(readOnly = true)
	public boolean existsByTransactionId(String transactionId) {
		if (transactionId == null || transactionId.isBlank()) {
			throw new ApiException("INVALID_TRANSACTION_ID", "transactionId é obrigatório", 400);
		}
		return controlPlanePaymentRepository.existsByTransactionId(transactionId.trim());
	}

	@Transactional(readOnly = true)
	public List<PaymentResponse> getPaymentsByValidUntilBeforeAndStatus(LocalDateTime date, PaymentStatus status) {
		if (date == null) {
			throw new ApiException("INVALID_DATE", "date é obrigatório", 400);
		}
		if (status == null) {
			throw new ApiException("INVALID_STATUS", "status é obrigatório", 400);
		}

		return controlPlanePaymentRepository.findByValidUntilBeforeAndStatus(date, status).stream().map(this::mapToResponse)
				.toList();
	}

	@Transactional(readOnly = true)
	public List<PaymentResponse> getCompletedPaymentsByAccount(Long accountId) {
		if (accountId == null) {
			throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
		}

		return controlPlanePaymentRepository.findCompletedPaymentsByAccount(accountId).stream().map(this::mapToResponse).toList();
	}

	@Transactional(readOnly = true)
	public List<PaymentResponse> getPaymentsInPeriod(LocalDateTime startDate, LocalDateTime endDate) {
		if (startDate == null || endDate == null) {
			throw new ApiException("INVALID_DATE_RANGE", "startDate e endDate são obrigatórios", 400);
		}
		if (endDate.isBefore(startDate)) {
			throw new ApiException("INVALID_DATE_RANGE", "endDate deve ser >= startDate", 400);
		}

		return controlPlanePaymentRepository.findPaymentsInPeriod(startDate, endDate).stream().map(this::mapToResponse).toList();
	}

	private void sendSuspensionEmail(Account account, String reason) {
		log.info("Enviando email de suspensão para: {}", account.getLoginEmail());
	}

	private void sendPaymentConfirmationEmail(Account account, Payment payment) {
		log.info("Enviando confirmação de pagamento para: {}", account.getLoginEmail());
	}

	private LocalDateTime calculateNextDueDate(LocalDateTime validUntil, LocalDateTime now) {
		return validUntil != null ? validUntil : now.plusMonths(1);
	}

	private boolean processWithPaymentGateway(Payment payment, PaymentRequest paymentRequest) {

		log.info("Processando pagamento com gateway: {}", paymentRequest.paymentGateway());

		try {
			Thread.sleep(1000);
			return Math.random() < 0.9;

		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			log.error("Erro ao processar pagamento no gateway", e);
			return false;
		}
	}

	private PaymentResponse mapToResponse(Payment payment) {
	    return new PaymentResponse(
	            payment.getId(),
	            payment.getAccount().getId(),
	            payment.getAmount(),
	            payment.getPaymentDate(),
	            payment.getValidUntil(),
	            payment.getStatus(),
	            payment.getTransactionId(),
	            payment.getPaymentMethod(),
	            payment.getPaymentGateway(),
	            payment.getDescription(),
	            payment.getCreatedAt(),
	            payment.getUpdatedAt()
	    );
	}

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/query/ControlPlaneAccountQueryService.java
============================================================
package brito.com.multitenancy001.controlplane.application.query;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import brito.com.multitenancy001.controlplane.api.dto.accounts.AccountResponse;
import brito.com.multitenancy001.controlplane.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlaneAccountQueryService {

    private final AccountRepository accountRepository;
    private final AccountApiMapper accountApiMapper;

    @Transactional(readOnly = true)
    public AccountResponse getEnabledById(Long id) {
        if (id == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "id é obrigatório", 400);

        Account a = accountRepository.findEnabledById(id)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_ENABLED", "Conta não encontrada ou não operacional", 404));

        return accountApiMapper.toResponse(a);
    }

    @Transactional(readOnly = true)
    public AccountResponse getAnyById(Long id) {
        if (id == null) throw new ApiException("ACCOUNT_ID_REQUIRED", "id é obrigatório", 400);

        Account a = accountRepository.findAnyById(id)
                .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

        return accountApiMapper.toResponse(a);
    }

    @Transactional(readOnly = true)
    public long countByStatusesNotDeleted(List<AccountStatus> statuses) {
        if (statuses == null || statuses.isEmpty()) {
            throw new ApiException("ACCOUNT_STATUSES_REQUIRED", "statuses é obrigatório", 400);
        }
        return accountRepository.countByStatusesAndDeletedFalse(statuses);
    }

    @Transactional(readOnly = true)
    public List<AccountResponse> findPaymentDueBeforeNotDeleted(LocalDateTime date) {
        if (date == null) throw new ApiException("DATE_REQUIRED", "date é obrigatório", 400);

        return accountRepository.findByPaymentDueDateBeforeAndDeletedFalse(date)
                .stream()
                .map(accountApiMapper::toResponse)
                .toList();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/application/user/ControlPlaneUserService.java
============================================================
package brito.com.multitenancy001.controlplane.application.user;

import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneChangeMyPasswordRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneMeResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserCreateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserDetailsResponse;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserPasswordResetRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserPermissionsUpdateRequest;
import brito.com.multitenancy001.controlplane.api.dto.users.ControlPlaneUserUpdateRequest;
import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneBuiltInUsers;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUserOrigin;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.EnumSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

@Service
@RequiredArgsConstructor
public class ControlPlaneUserService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final AccountRepository accountRepository;
    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;
    private final SecurityUtils securityUtils;
    private final PublicUnitOfWork publicUnitOfWork;

    private Account getControlPlaneAccount() {
        return accountRepository.findBySlugAndDeletedFalse("controlplane")
                .orElseThrow(() -> new ApiException(
                        "CONTROLPLANE_ACCOUNT_NOT_FOUND",
                        "Conta controlplane não encontrada. Rode a migration V4__insert_controlplane_account.sql",
                        500
                ));
    }

    private static final Set<ControlPlaneRole> OWNER_CAN_CREATE = EnumSet.of(
            ControlPlaneRole.CONTROLPLANE_SUPPORT,
            ControlPlaneRole.CONTROLPLANE_OPERATOR,
            ControlPlaneRole.CONTROLPLANE_BILLING_MANAGER
    );

    private static final Set<ControlPlaneRole> SUPPORT_CAN_CREATE =
            EnumSet.of(ControlPlaneRole.CONTROLPLANE_OPERATOR);

    private void assertCanCreateRole(ControlPlaneRole creatorRole, ControlPlaneRole targetRole) {
        if (creatorRole == null) throw new ApiException("FORBIDDEN", "Role do criador não encontrada", 403);
        if (targetRole == null) throw new ApiException("INVALID_ROLE", "Role alvo é obrigatória", 400);

        if (creatorRole == ControlPlaneRole.CONTROLPLANE_OWNER) {
            if (targetRole == ControlPlaneRole.CONTROLPLANE_OWNER) {
                throw new ApiException("FORBIDDEN", "CONTROLPLANE_OWNER não pode criar outro CONTROLPLANE_OWNER", 403);
            }
            if (!OWNER_CAN_CREATE.contains(targetRole)) {
                throw new ApiException("FORBIDDEN", "CONTROLPLANE_OWNER não pode criar a role: " + targetRole, 403);
            }
            return;
        }

        if (creatorRole == ControlPlaneRole.CONTROLPLANE_SUPPORT) {
            if (targetRole == ControlPlaneRole.CONTROLPLANE_SUPPORT) {
                throw new ApiException("FORBIDDEN", "CONTROLPLANE_SUPPORT não pode criar outro CONTROLPLANE_SUPPORT", 403);
            }
            if (!SUPPORT_CAN_CREATE.contains(targetRole)) {
                throw new ApiException("FORBIDDEN", "CONTROLPLANE_SUPPORT não pode criar a role: " + targetRole, 403);
            }
            return;
        }

        throw new ApiException("FORBIDDEN", "Sua role não pode criar usuários de plataforma", 403);
    }

    // =========================
    // GUARDS
    // =========================

    /**
     * Trava somente os 4 emails reservados (readonly total, exceto senha).
     */
    private void assertReservedBuiltInReadonly(ControlPlaneUser user, String action) {
        if (user == null) return;

        if (ControlPlaneBuiltInUsers.isReservedEmail(user.getEmail())) {
            throw new ApiException(
                    "BUILTIN_USER_READONLY",
                    "Usuário administrativo reservado é readonly (exceto senha) e não pode sofrer ação: " + action,
                    409
            );
        }
    }

    private void assertOwnerOnly(String action) {
        ControlPlaneRole role = securityUtils.getCurrentControlPlaneRole();
        if (role != ControlPlaneRole.CONTROLPLANE_OWNER) {
            throw new ApiException("FORBIDDEN", "Apenas CONTROLPLANE_OWNER pode executar: " + action, 403);
        }
    }

    private void assertNotSelfTarget(Long targetUserId, String action) {
        Long meId = securityUtils.getCurrentUserId();
        if (meId != null && targetUserId != null && meId.equals(targetUserId)) {
            throw new ApiException("FORBIDDEN", "Você não pode executar esta ação em si mesmo: " + action, 409);
        }
    }

    /**
     * NOT_DELETED = deleted=false (não necessariamente "enabled")
     */
    private ControlPlaneUser loadNotDeletedUserOr404(Long userId, Long accountId) {
        return controlPlaneUserRepository.findNotDeletedByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));
    }

    private ControlPlaneUser loadUserAnyStatusOr404(Long userId, Long accountId) {
        return controlPlaneUserRepository.findAnyByIdAndAccountId(userId, accountId)
                .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário de plataforma não encontrado", 404));
    }

    // =========================
    // CREATE
    // =========================

    public ControlPlaneUserDetailsResponse createControlPlaneUser(ControlPlaneUserCreateRequest req) {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            if (req == null) throw new ApiException("INVALID_REQUEST", "Request inválido", 400);

            if (req.password() == null || req.password().isBlank()) {
                throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);
            }

            ControlPlaneRole roleEnum = req.role();
            ControlPlaneRole creatorRole = securityUtils.getCurrentControlPlaneRole();
            assertCanCreateRole(creatorRole, roleEnum);

            if (req.permissions() != null && !req.permissions().isEmpty()
                    && creatorRole != ControlPlaneRole.CONTROLPLANE_OWNER) {
                throw new ApiException("FORBIDDEN", "Apenas CONTROLPLANE_OWNER pode definir permissions explícitas", 403);
            }

            String email = (req.email() == null) ? null : req.email().trim().toLowerCase(Locale.ROOT);
            if (email == null || email.isBlank()) {
                throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
            }

            if (ControlPlaneBuiltInUsers.isReservedEmail(email)) {
                throw new ApiException("RESERVED_EMAIL", "Este email é reservado para o sistema", 409);
            }

            if (controlPlaneUserRepository.existsNotDeletedByEmailIgnoreCase(controlPlaneAccount.getId(), email)) {
                throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já existe", 409);
            }

            LinkedHashSet<ControlPlanePermission> normalizedPermissions =
                    normalizeControlPlanePermissionsStrict(req.permissions());

            ControlPlaneUser user = ControlPlaneUser.builder()
                    .name(req.name())
                    .email(email)
                    .password(passwordEncoder.encode(req.password()))
                    .role(roleEnum)
                    .account(controlPlaneAccount)
                    .origin(ControlPlaneUserOrigin.ADMIN)
                    .permissions(normalizedPermissions)
                    .mustChangePassword(true)
                    .passwordChangedAt(appClock.now())
                    .build();

            return mapToResponse(controlPlaneUserRepository.save(user));
        });
    }

    // =========================
    // LIST / GET
    // =========================

    public List<ControlPlaneUserDetailsResponse> listControlPlaneUsers() {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            List<ControlPlaneUser> users =
                    controlPlaneUserRepository.findNotDeletedByAccountId(controlPlaneAccount.getId());

            return users.stream().map(this::mapToResponse).toList();
        });
    }

    public ControlPlaneUserDetailsResponse getControlPlaneUser(Long userId) {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();
            ControlPlaneUser user = loadNotDeletedUserOr404(userId, controlPlaneAccount.getId());
            return mapToResponse(user);
        });
    }

    // =========================
    // UPDATE
    // =========================

    public ControlPlaneUserDetailsResponse updateControlPlaneUser(
            Long userId,
            ControlPlaneUserUpdateRequest req
    ) {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            assertOwnerOnly("UPDATE");

            ControlPlaneUser user = loadNotDeletedUserOr404(userId, controlPlaneAccount.getId());
            assertReservedBuiltInReadonly(user, "UPDATE");
            assertNotSelfTarget(userId, "UPDATE");

            if (req == null) throw new ApiException("INVALID_REQUEST", "Request inválido", 400);

            if (req.name() != null) {
                user.setName(req.name());
            }

            if (req.email() != null && !req.email().isBlank()) {
                String email = req.email().trim().toLowerCase(Locale.ROOT);

                if (ControlPlaneBuiltInUsers.isReservedEmail(email)) {
                    throw new ApiException("RESERVED_EMAIL", "Este email é reservado para o sistema", 409);
                }

                boolean existsOther = controlPlaneUserRepository.existsOtherNotDeletedByEmailIgnoreCase(
                        controlPlaneAccount.getId(), email, user.getId()
                );
                if (existsOther) throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já existe", 409);

                user.setEmail(email);
            }

            if (req.role() != null) {
                ControlPlaneRole creatorRole = securityUtils.getCurrentControlPlaneRole();
                assertCanCreateRole(creatorRole, req.role());
                user.setRole(req.role());
            }

            return mapToResponse(controlPlaneUserRepository.save(user));
        });
    }

    public ControlPlaneUserDetailsResponse updateControlPlaneUserPermissions(
            Long userId, ControlPlaneUserPermissionsUpdateRequest req
    ) {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            assertOwnerOnly("UPDATE_PERMISSIONS");

            ControlPlaneUser user = loadNotDeletedUserOr404(userId, controlPlaneAccount.getId());
            assertReservedBuiltInReadonly(user, "UPDATE_PERMISSIONS");

            LinkedHashSet<ControlPlanePermission> normalizedPermissions =
                    normalizeControlPlanePermissionsStrict(req.permissions());

            PermissionScopeValidator.assertNoTenantPermissionLeak(
                    normalizedPermissions.stream().map(Enum::name).toList()
            );

            user.setPermissions(normalizedPermissions);

            return mapToResponse(controlPlaneUserRepository.save(user));
        });
    }

    // =========================
    // SOFT DELETE / RESTORE / SUSPEND
    // =========================

    public void softDeleteControlPlaneUser(Long userId) {
        publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            assertOwnerOnly("SOFT_DELETE");
            assertNotSelfTarget(userId, "SOFT_DELETE");

            ControlPlaneUser user = loadNotDeletedUserOr404(userId, controlPlaneAccount.getId());
            assertReservedBuiltInReadonly(user, "SOFT_DELETE");

            user.softDelete(appClock.now());
            controlPlaneUserRepository.save(user);
        });
    }

    public ControlPlaneUserDetailsResponse restoreControlPlaneUser(Long userId) {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            assertOwnerOnly("RESTORE");

            ControlPlaneUser user = loadUserAnyStatusOr404(userId, controlPlaneAccount.getId());
            assertReservedBuiltInReadonly(user, "RESTORE");

            if (!user.isDeleted()) {
                throw new ApiException("USER_NOT_DELETED", "Usuário não está removido", 409);
            }

            assertRestoreNoNotDeletedCollision(controlPlaneAccount, user);

            user.restore();
            user.setSuspendedByAdmin(false);
            user.setSuspendedByAccount(false);

            return mapToResponse(controlPlaneUserRepository.save(user));
        });
    }

    public ControlPlaneUserDetailsResponse updateControlPlaneUserSuspended(Long userId, boolean suspended) {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            assertOwnerOnly("UPDATE_STATUS");
            assertNotSelfTarget(userId, "UPDATE_STATUS");

            ControlPlaneUser user = loadNotDeletedUserOr404(userId, controlPlaneAccount.getId());
            assertReservedBuiltInReadonly(user, "UPDATE_STATUS");

            user.setSuspendedByAdmin(suspended);
            return mapToResponse(controlPlaneUserRepository.save(user));
        });
    }

    // =========================
    // ME
    // =========================

    public ControlPlaneMeResponse getMe() {
        return publicUnitOfWork.readOnly(() -> {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (auth == null || !auth.isAuthenticated()) {
                throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
            }

            Object principal = auth.getPrincipal();
            if (!(principal instanceof AuthenticatedUserContext ctx)) {
                throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
            }

            return new ControlPlaneMeResponse(
                    ctx.getUserId(),
                    ctx.getAccountId(),
                    ctx.getName(),
                    ctx.getEmail(),
                    ctx.getRoleName(),
                    ctx.isSuspendedByAccount(),
                    ctx.isSuspendedByAdmin(),
                    ctx.isDeleted(),
                    ctx.isEnabled()
            );
        });
    }

    // =========================
    // PASSWORDS (permitido para reservados)
    // =========================

    public void changeMyPassword(ControlPlaneChangeMyPasswordRequest req) {
        publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            if (req == null) throw new ApiException("INVALID_REQUEST", "Request inválido", 400);
            if (req.newPassword() == null || req.newPassword().isBlank()) {
                throw new ApiException("INVALID_PASSWORD", "Nova senha é obrigatória", 400);
            }
            if (!req.newPassword().equals(req.confirmPassword())) {
                throw new ApiException("PASSWORD_MISMATCH", "Senha e confirmação não conferem", 400);
            }

            Long meId = securityUtils.getCurrentUserId();
            if (meId == null) throw new ApiException("UNAUTHORIZED", "Usuário não autenticado", 401);

            ControlPlaneUser me = controlPlaneUserRepository
                    .findNotDeletedByIdAndAccountId(meId, controlPlaneAccount.getId())
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            if (me.isDeleted()) throw new ApiException("USER_DELETED", "Usuário removido", 409);
            if (me.isSuspendedByAccount() || me.isSuspendedByAdmin()) {
                throw new ApiException("ACCESS_DENIED", "Usuário não autorizado", 403);
            }

            if (!passwordEncoder.matches(req.currentPassword(), me.getPassword())) {
                throw new ApiException("INVALID_CURRENT_PASSWORD", "Senha atual inválida", 400);
            }

            if (passwordEncoder.matches(req.newPassword(), me.getPassword())) {
                throw new ApiException("PASSWORD_REUSE", "Nova senha não pode ser igual à senha atual", 400);
            }

            me.setPassword(passwordEncoder.encode(req.newPassword()));
            me.setMustChangePassword(false);
            me.setPasswordChangedAt(appClock.now());

            me.clearSecurityLockState();
            me.clearPasswordResetToken();


            controlPlaneUserRepository.save(me);
        });
    }

    public void resetControlPlaneUserPassword(Long targetUserId, ControlPlaneUserPasswordResetRequest req) {
        publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            if (req == null) throw new ApiException("INVALID_REQUEST", "Request inválido", 400);
            if (req.newPassword() == null || req.newPassword().isBlank()) {
                throw new ApiException("INVALID_PASSWORD", "Nova senha é obrigatória", 400);
            }
            if (!req.newPassword().equals(req.confirmPassword())) {
                throw new ApiException("PASSWORD_MISMATCH", "Senha e confirmação não conferem", 400);
            }

            assertOwnerOnly("RESET_PASSWORD");
            assertNotSelfTarget(targetUserId, "RESET_PASSWORD");

            ControlPlaneUser superAdmin = controlPlaneUserRepository
                    .findNotDeletedBuiltInOwner(
                            controlPlaneAccount.getId(),
                            ControlPlaneUserOrigin.BUILT_IN,
                            ControlPlaneRole.CONTROLPLANE_OWNER
                    )
                    .orElseThrow(() -> new ApiException(
                            "BUILTIN_OWNER_NOT_FOUND",
                            "Usuário BUILT_IN (CONTROLPLANE_OWNER) não encontrado. Rode a seed.",
                            500
                    ));

            if (superAdmin.getId().equals(targetUserId)) {
                throw new ApiException("SUPERADMIN_CANNOT_RESET_SELF", "Superadmin não pode resetar a própria senha", 409);
            }

            ControlPlaneUser target = controlPlaneUserRepository
                    .findNotDeletedByIdAndAccountId(targetUserId, controlPlaneAccount.getId())
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            // Não permite resetar senha de OWNER (inclusive superadmin)
            if (target.getRole() == ControlPlaneRole.CONTROLPLANE_OWNER) {
                throw new ApiException("OWNER_PASSWORD_RESET_BLOCKED",
                        "Não é permitido resetar senha de CONTROLPLANE_OWNER", 409);
            }

            target.setPassword(passwordEncoder.encode(req.newPassword()));
            target.setMustChangePassword(true);
            target.setPasswordChangedAt(appClock.now());

            target.clearSecurityLockState();
            target.clearPasswordResetToken();

            controlPlaneUserRepository.save(target);
        });
    }

    // =========================
    // HELPERS
    // =========================

    private void assertRestoreNoNotDeletedCollision(Account account, ControlPlaneUser deletedUser) {
        if (deletedUser.getEmail() != null && !deletedUser.getEmail().isBlank()) {
            boolean existsOther = controlPlaneUserRepository.existsOtherNotDeletedByEmailIgnoreCase(
                    account.getId(),
                    deletedUser.getEmail(),
                    deletedUser.getId()
            );
            if (existsOther) {
                throw new ApiException("EMAIL_ALREADY_EXISTS",
                        "Não é possível restaurar: email já está em uso", 409);
            }
        }
    }

    private LinkedHashSet<ControlPlanePermission> normalizeControlPlanePermissionsStrict(Collection<String> raw) {
        if (raw == null || raw.isEmpty()) return new LinkedHashSet<>();

        LinkedHashSet<String> normalized = PermissionScopeValidator.normalizeControlPlaneStrict(raw);

        LinkedHashSet<ControlPlanePermission> out = new LinkedHashSet<>();
        for (String s : normalized) {
            if (s == null || s.isBlank()) continue;
            try {
                out.add(ControlPlanePermission.valueOf(s.trim().toUpperCase(Locale.ROOT)));
            } catch (IllegalArgumentException e) {
                throw new ApiException("INVALID_PERMISSION", "Permissão inválida: " + s, 400);
            }
        }
        return out;
    }

    // =========================
    // ENABLED (not deleted + not suspended)
    // =========================

    public List<ControlPlaneUserDetailsResponse> listEnabledControlPlaneUsers() {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            List<ControlPlaneUser> users =
                    controlPlaneUserRepository.findEnabledByAccountId(controlPlaneAccount.getId());

            return users.stream().map(this::mapToResponse).toList();
        });
    }

    public ControlPlaneUserDetailsResponse getEnabledControlPlaneUser(Long userId) {
        return publicUnitOfWork.tx(() -> {
            Account controlPlaneAccount = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository
                    .findEnabledByIdAndAccountId(userId, controlPlaneAccount.getId())
                    .orElseThrow(() -> new ApiException(
                            "USER_NOT_ENABLED",
                            "Usuário não encontrado ou não habilitado",
                            404
                    ));

            return mapToResponse(user);
        });
    }

    private ControlPlaneUserDetailsResponse mapToResponse(ControlPlaneUser user) {
        return new ControlPlaneUserDetailsResponse(
                user.getId(),
                user.getAccount().getId(),
                user.getName(),
                user.getEmail(),
                user.getRole().name(),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.isDeleted(),
                user.isEnabled(),
                user.getCreatedAt()
        );
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/account/Account.java
============================================================
package brito.com.multitenancy001.controlplane.domain.account;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.domain.DomainException;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "accounts")
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Account implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_type", nullable = false, length = 20)
    @Builder.Default
    private AccountType type = AccountType.TENANT;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_origin", nullable = false, length = 20)
    @Builder.Default
    private AccountOrigin origin = AccountOrigin.ADMIN;

    @Column(name = "display_name", nullable = false, length = 150)
    private String displayName;

    @Column(name = "legal_name", length = 200)
    private String legalName;

    @Enumerated(EnumType.STRING)
    @Column(name = "legal_entity_type", nullable = false, length = 20)
    @Builder.Default
    private LegalEntityType legalEntityType = LegalEntityType.COMPANY;

    @Column(name = "schema_name", nullable = false, unique = true, length = 100)
    private String schemaName;

    @Column(name = "slug", nullable = false, unique = true, length = 80)
    private String slug;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    @Builder.Default
    private AccountStatus status = AccountStatus.FREE_TRIAL;

    // ===== AUDIT (tempo)
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // ===== AUDIT (ator)
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    // ===== BUSINESS DATES
    @Column(name = "trial_end_date")
    private LocalDateTime trialEndDate;

    @Column(name = "payment_due_date")
    private LocalDateTime paymentDueDate;

    @Column(name = "next_billing_date")
    private LocalDateTime nextBillingDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "subscription_plan", nullable = false, length = 50)
    @Builder.Default
    private SubscriptionPlan subscriptionPlan = SubscriptionPlan.FREE;

    @Column(name = "login_email", nullable = false, length = 150)
    private String loginEmail;

    @Column(name = "billing_email", length = 150)
    private String billingEmail;

    @Enumerated(EnumType.STRING)
    @Column(name = "tax_id_type", length = 20)
    private TaxIdType taxIdType;

    @Column(name = "tax_id_number", length = 40)
    private String taxIdNumber;

    @Column(name = "tax_country_code", length = 2, nullable = false)
    @Builder.Default
    private String taxCountryCode = "BR";

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "address", length = 500)
    private String address;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "state", length = 50)
    private String state;

    @Column(name = "country", length = 60, nullable = false)
    @Builder.Default
    private String country = "Brasil";

    @Column(name = "timezone", length = 60, nullable = false)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", length = 20, nullable = false)
    @Builder.Default
    private String locale = "pt_BR";

    @Column(name = "currency", length = 3, nullable = false)
    @Builder.Default
    private String currency = "BRL";

    @OneToMany(mappedBy = "account", fetch = FetchType.LAZY, cascade = { CascadeType.PERSIST, CascadeType.MERGE })
    @Builder.Default
    @ToString.Exclude
    private List<ControlPlaneUser> controlPlaneUsers = new ArrayList<>();

    @Column(name = "settings_json", columnDefinition = "TEXT")
    private String settingsJson;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    // ===== SOFT DELETE
    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Override
    public boolean isDeleted() {
        return deleted || deletedAt != null;
    }

    @PrePersist
    protected void onCreate() {

        if (origin == null) origin = AccountOrigin.ADMIN;

        if (country == null || country.isBlank()) country = "Brasil";
        if (timezone == null || timezone.isBlank()) timezone = "America/Sao_Paulo";
        if (locale == null || locale.isBlank()) locale = "pt_BR";
        if (currency == null || currency.isBlank()) currency = "BRL";
        if (taxCountryCode == null || taxCountryCode.isBlank()) taxCountryCode = "BR";

        if (displayName == null || displayName.isBlank()) {
            throw new DomainException("displayName is required");
        }

        if (slug == null || slug.isBlank()) {
            slug = displayName.toLowerCase()
                    .replaceAll("[^a-z0-9]+", "-")
                    .replaceAll("(^-|-$)", "");
        }

        if (schemaName == null || schemaName.isBlank()) {
            schemaName = "tenant_" + slug.replace("-", "_") + "_"
                    + UUID.randomUUID().toString().substring(0, 8);
        }

        if (loginEmail != null) loginEmail = loginEmail.trim().toLowerCase();
        if (billingEmail != null && !billingEmail.isBlank()) billingEmail = billingEmail.trim().toLowerCase();
        if (billingEmail != null && billingEmail.isBlank()) billingEmail = null;

        if (taxIdNumber != null) {
            taxIdNumber = taxIdNumber.replaceAll("\\D+", "");
            if (taxIdNumber.isBlank()) taxIdNumber = null;
        }

        if ((taxIdType == null) != (taxIdNumber == null)) {
            throw new DomainException("taxIdType and taxIdNumber must be provided together");
        }

        if (isBuiltInAccount()) {
            applyBuiltInDefaults();
        }
    }

    public boolean isTenantAccount() { return type == AccountType.TENANT; }
    public boolean isPlatformAccount() { return type == AccountType.PLATFORM; }
    public boolean isBuiltInAccount() { return origin == AccountOrigin.BUILT_IN; }

    public boolean isTrialActive(LocalDateTime now) {
        return status == AccountStatus.FREE_TRIAL
                && trialEndDate != null
                && now != null
                && trialEndDate.isAfter(now);
    }

    public boolean isOperational(LocalDateTime now) {
        if (isDeleted()) return false;
        if (isBuiltInAccount()) return true;
        return status == AccountStatus.ACTIVE
                || (status == AccountStatus.FREE_TRIAL && isTrialActive(now));
    }

    public boolean isPaymentOverdue(LocalDateTime now) {
        return paymentDueDate != null && now != null && paymentDueDate.isBefore(now);
    }

    public long getDaysRemainingInTrial(LocalDateTime now) {
        if (now == null) return 0;
        if (!isTrialActive(now)) return 0;
        return ChronoUnit.DAYS.between(now.toLocalDate(), trialEndDate.toLocalDate());
    }

    public void softDelete(LocalDateTime now) {
        if (deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        if (isBuiltInAccount()) {
            throw new DomainException("BUILT_IN account cannot be deleted");
        }

        deleted = true;
        deletedAt = now;
        status = AccountStatus.CANCELLED;
    }

    public void restore() {
        if (!deleted) return;

        deleted = false;
        deletedAt = null;
        status = AccountStatus.ACTIVE;

        if (isBuiltInAccount()) {
            applyBuiltInDefaults();
        }
    }

    public void setSubscriptionPlan(SubscriptionPlan plan) {
        if (plan == null) throw new DomainException("subscriptionPlan is required");
        if (isBuiltInAccount() && plan != SubscriptionPlan.BUILT_IN_PLAN) {
            throw new DomainException("BUILT_IN account must use BUILT_IN_PLAN");
        }
        subscriptionPlan = plan;
    }

    public void setStatus(AccountStatus newStatus) {
        if (newStatus == null) throw new DomainException("status is required");
        if (isBuiltInAccount() && newStatus != AccountStatus.ACTIVE) {
            throw new DomainException("BUILT_IN account must be ACTIVE");
        }
        status = newStatus;
    }

    public void setTrialEndDate(LocalDateTime newTrialEndDate) {
        if (isBuiltInAccount() && newTrialEndDate != null) {
            throw new DomainException("BUILT_IN account must not have trialEndDate");
        }
        trialEndDate = newTrialEndDate;
    }

    public void setPaymentDueDate(LocalDateTime newPaymentDueDate) {
        if (isBuiltInAccount() && newPaymentDueDate != null) {
            throw new DomainException("BUILT_IN account must not have paymentDueDate");
        }
        paymentDueDate = newPaymentDueDate;
    }

    public void setType(AccountType newType) {
        if (newType == null) throw new DomainException("accountType is required");
        type = newType;

        if (origin == AccountOrigin.BUILT_IN && type != AccountType.PLATFORM) {
            throw new DomainException("BUILT_IN account must be PLATFORM");
        }
    }

    public void setOrigin(AccountOrigin newOrigin) {
        if (newOrigin == null) throw new DomainException("accountOrigin is required");
        origin = newOrigin;

        if (origin == AccountOrigin.BUILT_IN) {
            type = AccountType.PLATFORM;
            applyBuiltInDefaults();
        }
    }

    private void applyBuiltInDefaults() {
        subscriptionPlan = SubscriptionPlan.BUILT_IN_PLAN;
        status = AccountStatus.ACTIVE;
        trialEndDate = null;
        paymentDueDate = null;
        nextBillingDate = null;
        deleted = false;
        deletedAt = null;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/account/AccountEntitlements.java
============================================================
package brito.com.multitenancy001.controlplane.domain.account;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "account_entitlements")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AccountEntitlements {

    @Id
    @Column(name = "account_id")
    private Long accountId;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id")
    private Account account;

    @Column(name = "max_users", nullable = false)
    private Integer maxUsers;

    @Column(name = "max_products", nullable = false)
    private Integer maxProducts;

    @Column(name = "max_storage_mb", nullable = false)
    private Integer maxStorageMb;
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/account/AccountOrigin.java
============================================================
package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountOrigin {
    BUILT_IN,   // seed / migration
    ADMIN,      // criado via painel por superadmin
    API         // futuro (integração, signup automático, etc)
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/account/AccountStatus.java
============================================================
package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountStatus {
    FREE_TRIAL("Trial Gratuito"),
    ACTIVE("Ativa"),
    SUSPENDED("Suspensa"),
    CANCELLED("Cancelada"),
    EXPIRED("Expirada");

    private final String description;

    AccountStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    /** Regra de negócio: permite operar (independente de datas finas do trial). */
    public boolean isOperational() {
        return this == FREE_TRIAL || this == ACTIVE;
    }

    public boolean isTrial() {
        return this == FREE_TRIAL;
    }

    public boolean isSuspended() {
        return this == SUSPENDED;
    }

    public boolean isCancelled() {
        return this == CANCELLED || this == EXPIRED;
    }

 
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/account/AccountType.java
============================================================
package brito.com.multitenancy001.controlplane.domain.account;

public enum AccountType {
    TENANT,
    PLATFORM
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/account/LegalEntityType.java
============================================================
package brito.com.multitenancy001.controlplane.domain.account;

public enum LegalEntityType {
    INDIVIDUAL,   // pessoa física
    COMPANY       // pessoa jurídica
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/account/SubscriptionPlan.java
============================================================
package brito.com.multitenancy001.controlplane.domain.account;

public enum SubscriptionPlan {
    FREE,
    PRO,
    ENTERPRISE,

    /**
     * Plano interno do sistema (Control Plane).
     * BUILTIN != cliente, não tem trial, não tem billing, não tem entitlements.
     */
    BUILT_IN_PLAN
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/account/TaxIdType.java
============================================================
package brito.com.multitenancy001.controlplane.domain.account;

import lombok.Getter;

@Getter
public enum TaxIdType {
    CPF,
    CNPJ;

   
    }

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/billing/Payment.java
============================================================
package brito.com.multitenancy001.controlplane.domain.billing;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "payments", indexes = {
        @Index(name = "idx_payment_account", columnList = "account_id"),
        @Index(name = "idx_payment_status", columnList = "status"),
        @Index(name = "idx_payment_date", columnList = "payment_date")
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment implements Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    @Column(name = "payment_date", nullable = false)
    private LocalDateTime paymentDate;

    @Column(name = "valid_until")
    private LocalDateTime validUntil;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private PaymentStatus status = PaymentStatus.PENDING;

    @Column(name = "transaction_id", unique = true, length = 100)
    private String transactionId;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", nullable = false, length = 50)
    private PaymentMethod paymentMethod;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_gateway", nullable = false, length = 50)
    private PaymentGateway paymentGateway;

    @Column(name = "currency", length = 3, nullable = false)
    @Builder.Default
    private String currency = "BRL";

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    @Column(name = "invoice_url", columnDefinition = "TEXT")
    private String invoiceUrl;

    @Column(name = "receipt_url", columnDefinition = "TEXT")
    private String receiptUrl;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // ===== AUDIT (ator)
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Column(name = "refunded_at")
    private LocalDateTime refundedAt;

    @Column(name = "refund_amount", precision = 10, scale = 2)
    private BigDecimal refundAmount;

    @Column(name = "refund_reason", length = 500)
    private String refundReason;

    @PrePersist
    protected void onCreate() {
        if (this.transactionId == null) {
            this.transactionId = "PAY_" + UUID.randomUUID().toString()
                    .replace("-", "")
                    .substring(0, 16)
                    .toUpperCase();
        }

        if (this.paymentDate == null) {
            throw new IllegalStateException("paymentDate deve ser definido pela aplicação (Clock/AppClock).");
        }

        if (this.status == PaymentStatus.COMPLETED && this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    private LocalDateTime calculateDefaultValidUntil(LocalDateTime baseDate) {
        return baseDate.plusDays(30);
    }

    public void markAsCompleted(LocalDateTime now) {
        this.status = PaymentStatus.COMPLETED;
        if (this.paymentDate == null) this.paymentDate = now;
        if (this.validUntil == null) this.validUntil = calculateDefaultValidUntil(this.paymentDate);
    }

    public void markAsFailed(String reason) {
        this.status = PaymentStatus.FAILED;
        if (this.metadataJson == null) {
            this.metadataJson = "{\"failure_reason\":\"" + reason + "\"}";
        }
    }
    
    public boolean canBeRefunded(LocalDateTime now) {
        if (this.status != PaymentStatus.COMPLETED) return false;
        if (this.refundedAt != null) return false;
        if (this.paymentDate == null) return false;

        // Exemplo original: até 90 dias após paymentDate (regra determinística)
        // (equivalente a: paymentDate.isAfter(now.minusDays(90)))
        return this.paymentDate.isAfter(now.minusDays(90));
    }
    
    public void refundPartially(LocalDateTime now, BigDecimal amount, String reason) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0 || amount.compareTo(this.amount) > 0) {
            throw new IllegalArgumentException("Valor de reembolso inválido");
        }
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento não pode ser reembolsado");
        }

        this.refundAmount = amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }

    public void refundFully(LocalDateTime now, String reason) {
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento não pode ser reembolsado");
        }

        this.refundAmount = this.amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/user/ControlPlaneBuiltInUsers.java
============================================================
package brito.com.multitenancy001.controlplane.domain.user;

import java.util.Locale;
import java.util.Set;

public final class ControlPlaneBuiltInUsers {
    private ControlPlaneBuiltInUsers() {}

    public static final String SUPERADMIN_EMAIL = "superadmin@platform.local";
    public static final String BILLING_EMAIL    = "billing@platform.local";
    public static final String SUPPORT_EMAIL    = "support@platform.local";
    public static final String OPERATOR_EMAIL   = "operator@platform.local";

    public static final Set<String> RESERVED_EMAILS = Set.of(
            SUPERADMIN_EMAIL,
            BILLING_EMAIL,
            SUPPORT_EMAIL,
            OPERATOR_EMAIL
    );

    public static boolean isReservedEmail(String email) {
        if (email == null) return false;
        return RESERVED_EMAILS.contains(email.trim().toLowerCase(Locale.ROOT));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/user/ControlPlaneUser.java
============================================================
package brito.com.multitenancy001.controlplane.domain.user;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(name = "controlplane_users")
@EntityListeners(AuditEntityListener.class)
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"account", "password"})
public class ControlPlaneUser implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Setter(AccessLevel.NONE)
    @Enumerated(EnumType.STRING)
    @Column(name = "user_origin", nullable = false, length = 20)
    @Builder.Default
    private ControlPlaneUserOrigin origin = ControlPlaneUserOrigin.ADMIN;

    public boolean isBuiltInUser() { return this.origin == ControlPlaneUserOrigin.BUILT_IN; }

    @Setter(AccessLevel.NONE)
    @Column(nullable = false, length = 100)
    private String name;

    @Setter(AccessLevel.NONE)
    @Column(name = "password", nullable = false, length = 255)
    private String password;

    @Setter(AccessLevel.NONE)
    @Column(name = "email", nullable = false, length = 150)
    private String email;

    @Setter(AccessLevel.NONE)
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 50)
    private ControlPlaneRole role;

    @Setter(AccessLevel.NONE)
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Setter(AccessLevel.NONE)
    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Setter(AccessLevel.NONE)
    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts", nullable = false)
    @Builder.Default
    private int failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Setter(AccessLevel.NONE)
    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    @Column(name = "timezone", nullable = false, length = 60)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", nullable = false, length = 20)
    @Builder.Default
    private String locale = "pt_BR";

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Setter(AccessLevel.NONE)
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Setter(AccessLevel.NONE)
    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    // ===== AUDIT (ator)
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() { return audit; }

    @Override
    public boolean isDeleted() { return deleted; }

    @Setter(AccessLevel.NONE)
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
            name = "controlplane_user_permissions",
            schema = Schemas.CONTROL_PLANE,
            joinColumns = @JoinColumn(name = "user_id")
    )
    @Enumerated(EnumType.STRING)
    @Column(name = "permission", nullable = false, length = 120)
    @Builder.Default
    private Set<ControlPlanePermission> permissions = new LinkedHashSet<>();

    // =========================================================
    // RESERVED USERS (4 administrativos)
    // =========================================================

    public boolean isReservedBuiltInAdmin() {
        var base = (_originalEmail != null) ? _originalEmail : this.email;
        return ControlPlaneBuiltInUsers.isReservedEmail(base);
    }

    private void assertMutable(String action) {
        if (isReservedBuiltInAdmin()) {
            throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: " + action);
        }
    }

    // setters controlados (bloqueados quando reservado)

    public void setOrigin(ControlPlaneUserOrigin origin) {
        assertMutable("SET_ORIGIN");
        this.origin = origin;
    }

    public void setName(String name) {
        assertMutable("SET_NAME");
        this.name = name;
    }

    public void setEmail(String email) {
        assertMutable("SET_EMAIL");
        this.email = email;
    }

    public void setRole(ControlPlaneRole role) {
        assertMutable("SET_ROLE");
        this.role = role;
    }

    public void setAccount(Account account) {
        assertMutable("SET_ACCOUNT");
        this.account = account;
    }

    public void setSuspendedByAccount(boolean suspendedByAccount) {
        assertMutable("SET_SUSPENDED_BY_ACCOUNT");
        this.suspendedByAccount = suspendedByAccount;
    }

    public void setSuspendedByAdmin(boolean suspendedByAdmin) {
        assertMutable("SET_SUSPENDED_BY_ADMIN");
        this.suspendedByAdmin = suspendedByAdmin;
    }

    public void setMustChangePassword(boolean mustChangePassword) {
        // ✅ permitido até para reservados (só senha pode mudar; esse flag faz parte da gestão de senha)
        this.mustChangePassword = mustChangePassword;
    }

    public void setPermissions(Set<ControlPlanePermission> permissions) {
        assertMutable("SET_PERMISSIONS");
        this.permissions = (permissions == null) ? new LinkedHashSet<>() : new LinkedHashSet<>(permissions);
    }

    // ✅ setters “de senha” são permitidos para reservados
    public void setPassword(String password) {
        this.password = password;
    }

    public void setPasswordChangedAt(LocalDateTime passwordChangedAt) {
        this.passwordChangedAt = passwordChangedAt;
    }

    // =========================================================
    // Normalizações (JPA: apenas 1 callback por tipo)
    // =========================================================

    @PrePersist
    private void prePersist() {
        normalizeInternal();
        normalizePermissionsInternal();
    }

    @PreUpdate
    private void preUpdate() {
        normalizeInternal();
        normalizePermissionsInternal();
        preventReservedMutationBySnapshotInternal();
    }

    private void normalizeInternal() {
        if (email != null) email = email.trim().toLowerCase();
    }

    private void normalizePermissionsInternal() {
        if (permissions == null) {
            permissions = new LinkedHashSet<>();
            return;
        }
        var normalized = PermissionScopeValidator.normalizeControlPlanePermissions(permissions);
        permissions.clear();
        permissions.addAll(normalized);
    }

    // =========================================================
    // Snapshot + validação em @PreUpdate (rede de segurança)
    // =========================================================

    private void preventReservedMutationBySnapshotInternal() {
        // decide se é reservado usando snapshot ou fallback
        var base = (_originalEmail != null) ? _originalEmail : this.email;
        if (!ControlPlaneBuiltInUsers.isReservedEmail(base)) return;

        // 🔒 se não existe snapshot ainda, não valida por snapshot
        if (_originalEmail == null) return;

        // para reservado: email/nome/origin/role/suspensões/deleted NÃO podem mudar
        if (!safeEq(base, this.email)) throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: EMAIL");
        if (!safeEq(_originalName, this.name)) throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: NAME");
        if (_originalRole != this.role) throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: ROLE");
        if (_originalOrigin != this.origin) throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: ORIGIN");
        if (_originalSuspendedByAccount != this.suspendedByAccount) throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: SUSPENDED_BY_ACCOUNT");
        if (_originalSuspendedByAdmin != this.suspendedByAdmin) throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: SUSPENDED_BY_ADMIN");
        if (_originalDeleted != this.deleted) throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: DELETED");

        // permissions (bloqueia até mutação interna do Set)
        var original = (_originalPermissions == null) ? new LinkedHashSet<ControlPlanePermission>() : _originalPermissions;
        var current = (this.permissions == null) ? new LinkedHashSet<ControlPlanePermission>() : this.permissions;

        if (!original.equals(current)) {
            throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY: PERMISSIONS");
        }
    }

    // =========================================================
    // Snapshot (captura estado original)
    // =========================================================

    @Transient private String _originalEmail;
    @Transient private String _originalName;
    @Transient private ControlPlaneRole _originalRole;
    @Transient private ControlPlaneUserOrigin _originalOrigin;
    @Transient private boolean _originalSuspendedByAccount;
    @Transient private boolean _originalSuspendedByAdmin;
    @Transient private boolean _originalDeleted;
    @Transient private Set<ControlPlanePermission> _originalPermissions;

    @PostLoad
    @PostPersist
    @PostUpdate
    private void captureOriginalState() {
        this._originalEmail = this.email;
        this._originalName = this.name;
        this._originalRole = this.role;
        this._originalOrigin = this.origin;
        this._originalSuspendedByAccount = this.suspendedByAccount;
        this._originalSuspendedByAdmin = this.suspendedByAdmin;
        this._originalDeleted = this.deleted;

        this._originalPermissions = (this.permissions == null)
                ? new LinkedHashSet<>()
                : new LinkedHashSet<>(this.permissions);
    }

    private static boolean safeEq(Object a, Object b) {
        return a == null ? b == null : a.equals(b);
    }

    // =========================================================
    // Semânticas de estado / domínio
    // =========================================================

    public boolean isAccountNonLocked(LocalDateTime now) {
        return lockedUntil == null || !lockedUntil.isAfter(now);
    }

    public boolean isEnabledForLogin() {
        return isEnabled();
    }

    public boolean isEnabledForLogin(LocalDateTime now) {
        return isEnabledForLogin() && isAccountNonLocked(now);
    }

    public void softDelete(LocalDateTime now) {
        // ✅ trava também os reservados (mesmo que alguém mude origin)
        if (isReservedBuiltInAdmin()) throw new IllegalStateException("RESERVED_BUILTIN_USER_READONLY");
        if (isBuiltInUser()) throw new IllegalStateException("SYSTEM_USER_READONLY");
        if (deleted) return;

        deleted = true;
        deletedAt = now;
    }

    public void restore() {
        // restore é uma “ação administrativa”; o service já bloqueia reserved.
        // aqui não bloqueio para não travar cenários de recuperação de dados manual.
        this.deleted = false;
        this.deletedAt = null;
        this.suspendedByAccount = false;
        this.suspendedByAdmin = false;
    }

    /**
     * enabled = usuário operacionalmente apto:
     * - não deletado
     * - não suspenso pela conta
     * - não suspenso pelo admin
     */
    public boolean isEnabled() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    public boolean isNotDeleted() {
        return !deleted;
    }

    public boolean isSuspended() {
        return suspendedByAccount || suspendedByAdmin;
    }

    // =========================================================
    // Security helpers (login / lock / reset) - permitido inclusive para reservados
    // =========================================================

    /**
     * Zera contadores e desbloqueia o usuário.
     * Permitido inclusive para usuários administrativos reservados.
     */
    public void clearSecurityLockState() {
        this.failedLoginAttempts = 0;
        this.lockedUntil = null;
    }

    /**
     * Limpa token de reset de senha.
     * Permitido inclusive para usuários administrativos reservados.
     */
    public void clearPasswordResetToken() {
        this.passwordResetToken = null;
        this.passwordResetExpires = null;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/domain/user/ControlPlaneUserOrigin.java
============================================================
package brito.com.multitenancy001.controlplane.domain.user;

public enum ControlPlaneUserOrigin {
    BUILT_IN,
    ADMIN,
    API
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/persistence/account/AccountEntitlementsRepository.java
============================================================
package brito.com.multitenancy001.controlplane.persistence.account;

import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AccountEntitlementsRepository extends JpaRepository<AccountEntitlements, Long> {
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/persistence/account/AccountRepository.java
============================================================
package brito.com.multitenancy001.controlplane.persistence.account;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountStatus;
import brito.com.multitenancy001.controlplane.domain.account.AccountType;
import brito.com.multitenancy001.controlplane.domain.account.TaxIdType;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {

    // =========================================================
    // EXISTS / UNIQUE (padrão: NOT DELETED)
    // =========================================================

    boolean existsByTaxCountryCodeAndTaxIdTypeAndTaxIdNumberAndDeletedFalse(
            String taxCountryCode, TaxIdType taxIdType, String taxIdNumber
    );

    boolean existsByTypeAndDeletedFalse(AccountType type);

    boolean existsByLoginEmailAndDeletedFalse(String loginEmail);

    boolean existsByTaxIdTypeAndTaxIdNumberAndDeletedFalse(TaxIdType taxIdType, String taxIdNumber);

    // =========================================================
    // DEFAULT DE DOMÍNIO: NOT DELETED (deleted=false)
    // =========================================================

    /** Lista todas as contas não deletadas. */
    List<Account> findAllByDeletedFalse();

    /** Busca por slug (não deletado). */
    Optional<Account> findBySlugAndDeletedFalse(String slug);

    /** Busca por slug ignoreCase (não deletado). */
    Optional<Account> findBySlugAndDeletedFalseIgnoreCase(String slug);
    
    // =========================================================
    // PROJECTIONS (para evitar expor entidade fora do CP)
    // =========================================================

 // ✅ faltava este método (usado pelo AccountResolver)
    Optional<AccountResolverProjection> findProjectionByIdAndDeletedFalse(Long id);

    Optional<AccountResolverProjection> findProjectionBySlugAndDeletedFalseIgnoreCase(String slug);


    /** Busca por id (não deletado). Default para leitura normal. */
    Optional<Account> findByIdAndDeletedFalse(Long id);

    /** Contas por lista de status (não deletado). */
    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.status IN :statuses")
    List<Account> findByStatuses(@Param("statuses") List<AccountStatus> statuses);

    // =========================================================
    // DEFAULT DE SEGURANÇA: ENABLED (operacional)
    // enabled = NOT DELETED + status operacional
    // =========================================================

    /**
     * Conta "enabled/operacional": não deletada e status operacional.
     * Use em fluxos que precisam garantir conta em operação (ex.: login, ações sensíveis).
     */
    @Query("""
            SELECT a
              FROM Account a
             WHERE a.id = :id
               AND a.deleted = false
               AND a.status IN ('ACTIVE', 'FREE_TRIAL')
           """)
    Optional<Account> findEnabledById(@Param("id") Long id);

    // =========================================================
    // BYPASS CONSCIENTE: ANY (inclui deleted)
    // =========================================================

    /**
     * ⚠️ BYPASS: pode incluir soft-deleted.
     * Use apenas para auditoria/suporte/restore.
     */
    Optional<Account> findAnyById(Long id);

    // =========================================================
    // QUERIES OPERACIONAIS (NOT DELETED)
    // =========================================================

    @Query("SELECT COUNT(a) FROM Account a WHERE a.deleted = false AND a.status = :status")
    long countByStatusAndDeletedFalse(@Param("status") AccountStatus status);

    @Query("SELECT COUNT(a) FROM Account a WHERE a.deleted = false AND a.status IN :statuses")
    long countByStatusesAndDeletedFalse(@Param("statuses") List<AccountStatus> statuses);

    default long countOperationalAccounts() {
        return countByStatusesAndDeletedFalse(List.of(AccountStatus.ACTIVE, AccountStatus.FREE_TRIAL));
    }

    Page<Account> findByDeletedFalseOrderByCreatedAtDesc(Pageable pageable);

    Page<Account> findByStatusAndDeletedFalse(AccountStatus status, Pageable pageable);

    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.createdAt BETWEEN :start AND :end")
    Page<Account> findAccountsCreatedBetween(@Param("start") LocalDateTime start,
                                             @Param("end") LocalDateTime end,
                                             Pageable pageable);

    // busca em displayName e legalName
    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND (
            LOWER(a.displayName) LIKE LOWER(CONCAT('%', :term, '%'))
            OR (a.legalName IS NOT NULL AND LOWER(a.legalName) LIKE LOWER(CONCAT('%', :term, '%')))
          )
    """)
    Page<Account> searchByDisplayName(@Param("term") String term, Pageable pageable);

    // =========================================================
    // QUERIES "ANTIGAS" (potencialmente unsafe) -> manter por compatibilidade
    // =========================================================

    /** Contas por status, NOT DELETED. Preferir esta. */
    List<Account> findByStatusAndDeletedFalse(AccountStatus status);

    /** Contas com vencimento antes de X, NOT DELETED. Preferir esta. */
    List<Account> findByPaymentDueDateBeforeAndDeletedFalse(LocalDateTime date);

    /** Trials expirados, NOT DELETED. Preferir esta. */
    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.trialEndDate <= :date AND a.status = :status")
    List<Account> findExpiredTrialsNotDeleted(@Param("date") LocalDateTime date, @Param("status") AccountStatus status);

    /** Contas em atraso, NOT DELETED. Preferir esta. */
    @Query("SELECT a FROM Account a WHERE a.deleted = false AND a.status = :status AND a.paymentDueDate < :today")
    List<Account> findOverdueAccountsNotDeleted(@Param("status") AccountStatus status, @Param("today") LocalDateTime today);

    

  

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/persistence/account/AccountResolverProjection.java
============================================================
package brito.com.multitenancy001.controlplane.persistence.account;

import java.time.LocalDateTime;

public interface AccountResolverProjection {
    Long getId();
    String getSchemaName();

    // ✅ necessários para seleção no frontend
    String getSlug();
    String getDisplayName();

    String getStatus();
    LocalDateTime getTrialEndDate();
    String getOrigin();
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/persistence/billing/ControlPlanePaymentRepository.java
============================================================
package brito.com.multitenancy001.controlplane.persistence.billing;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.domain.billing.Payment;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlanePaymentRepository extends JpaRepository<Payment, Long> {

    // =========================================================
    // ANY (bypass consciente / scoped)
    // Payment normalmente não tem soft-delete; "Any" aqui significa
    // "scoped por account e sem filtros adicionais".
    // =========================================================

    /**
     * Busca payment por id + account (scoped).
     * "Any" aqui não é sobre deleted; é sobre não aplicar filtros extras (status/data).
     */
    Optional<Payment> findScopedByIdAndAccountId(Long id, Long accountId);

    

    boolean existsByIdAndAccountId(Long id, Long accountId);

    // =========================================================
    // Queries normais
    // =========================================================

    List<Payment> findByAccountId(Long accountId);

    List<Payment> findByAccountIdAndStatus(Long accountId, PaymentStatus status);

    Page<Payment> findByAccountId(Long accountId, Pageable pageable);

    Optional<Payment> findByTransactionId(String transactionId);

    List<Payment> findByStatus(PaymentStatus status);

    List<Payment> findByStatusAndCreatedAtBefore(PaymentStatus status, LocalDateTime date);

    List<Payment> findByValidUntilBeforeAndStatus(LocalDateTime date, PaymentStatus status);

    @Query("SELECT p FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' ORDER BY p.paymentDate DESC")
    List<Payment> findCompletedPaymentsByAccount(@Param("accountId") Long accountId);

  
    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalPaidInPeriod(@Param("accountId") Long accountId,
                                   @Param("startDate") LocalDateTime startDate,
                                   @Param("endDate") LocalDateTime endDate);

    @Query("SELECT COUNT(p) FROM Payment p WHERE p.account.id = :accountId AND p.status = 'COMPLETED'")
    Long countCompletedPayments(@Param("accountId") Long accountId);

    @Query("SELECT p FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate")
    List<Payment> findPaymentsInPeriod(@Param("startDate") LocalDateTime startDate,
                                       @Param("endDate") LocalDateTime endDate);

    @Query("SELECT p.account.id, SUM(p.amount) FROM Payment p WHERE p.status = 'COMPLETED' AND p.paymentDate BETWEEN :startDate AND :endDate GROUP BY p.account.id")
    List<Object[]> getRevenueByAccount(@Param("startDate") LocalDateTime startDate,
                                       @Param("endDate") LocalDateTime endDate);

    boolean existsByTransactionId(String transactionId);
    
 // Lista pagamentos de uma conta (mais recentes primeiro)
    List<Payment> findByAccountIdOrderByCreatedAtDesc(Long accountId);

    // Busca pagamento por id + accountId (protege contra acesso cruzado)
    Optional<Payment> findByIdAndAccountId(Long id, Long accountId);

    @Query("""
    	    select (count(p) > 0)
    	    from Payment p
    	    where p.account.id = :accountId
    	      and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
    	      and p.validUntil is not null
    	      and p.validUntil >= :now
    	""")
    	boolean existsActivePayment(@Param("accountId") Long accountId, @Param("now") LocalDateTime now);

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/persistence/user/ControlPlaneUserRepository.java
============================================================
package brito.com.multitenancy001.controlplane.persistence.user;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUserOrigin;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlaneUserRepository extends JpaRepository<ControlPlaneUser, Long> {

   

	  // ✅ alias para compat com services existentes
    long countByAccountIdAndDeletedFalse(Long accountId);

	
	// ✅ identidade: email
    Optional<ControlPlaneUser> findByEmailAndDeletedFalse(String email);

    Optional<ControlPlaneUser> findByEmailAndAccount_IdAndDeletedFalse(String email, Long accountId);

    // =========================================================
    // NOT DELETED (deleted=false) ✅ default do domínio
    // =========================================================

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.account.id = :accountId AND u.deleted = false")
    List<ControlPlaneUser> findNotDeletedByAccountId(@Param("accountId") Long accountId);

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.id = :id AND u.account.id = :accountId AND u.deleted = false")
    Optional<ControlPlaneUser> findNotDeletedByIdAndAccountId(@Param("id") Long id,
                                                              @Param("accountId") Long accountId);

    /**
     * 
     * Agora: usuário BUILT_IN + role CONTROLPLANE_OWNER.
     */
    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.origin = :origin
               AND u.role = :role
           """)
    Optional<ControlPlaneUser> findNotDeletedBuiltInOwner(@Param("accountId") Long accountId,
                                                         @Param("origin") ControlPlaneUserOrigin origin,
                                                         @Param("role") ControlPlaneRole role);

    long countByAccount_IdAndDeletedFalse(Long accountId);

    // =========================================================
    // ENABLED = NOT DELETED + NOT suspended ✅ default segurança
    // =========================================================

    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.suspendedByAccount = false
               AND u.suspendedByAdmin = false
           """)
    List<ControlPlaneUser> findEnabledByAccountId(@Param("accountId") Long accountId);

    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.id = :id
               AND u.account.id = :accountId
               AND u.deleted = false
               AND u.suspendedByAccount = false
               AND u.suspendedByAdmin = false
           """)
    Optional<ControlPlaneUser> findEnabledByIdAndAccountId(@Param("id") Long id,
                                                           @Param("accountId") Long accountId);

    // =========================================================
    // ANY = BYPASS consciente (inclui deleted) ⚠️
    // =========================================================

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.id = :id AND u.account.id = :accountId")
    Optional<ControlPlaneUser> findAnyByIdAndAccountId(@Param("id") Long id,
                                                       @Param("accountId") Long accountId);

    // =========================================================
    // UNICIDADE NOT DELETED (deleted=false) e case-insensitive
    // =========================================================

    @Query("""
            SELECT (COUNT(u) > 0)
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND lower(u.email) = lower(:email)
           """)
    boolean existsNotDeletedByEmailIgnoreCase(@Param("accountId") Long accountId,
                                              @Param("email") String email);

    @Query("""
            SELECT (COUNT(u) > 0)
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND lower(u.email) = lower(:email)
               AND u.id <> :userId
           """)
    boolean existsOtherNotDeletedByEmailIgnoreCase(@Param("accountId") Long accountId,
                                                   @Param("email") String email,
                                                   @Param("userId") Long userId);

    @Query("""
        select u
        from ControlPlaneUser u
        where u.id = :id
          and u.deleted = false
          and u.suspendedByAdmin = false
          and u.suspendedByAccount = false
    """)
    Optional<ControlPlaneUser> findEnabledById(@Param("id") Long id);
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/security/ControlPlanePermission.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.PermissionCode;

public enum ControlPlanePermission implements PermissionCode {

    CP_TENANT_READ,
    CP_TENANT_SUSPEND,
    CP_TENANT_RESUME,
    CP_TENANT_DELETE,

    CP_BILLING_READ,
    CP_BILLING_WRITE,

    CP_USER_READ,
    CP_USER_WRITE,
    CP_USER_DELETE,

    CP_USER_PASSWORD_RESET;

    @Override
    public String asAuthority() {
        return name();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRole.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum ControlPlaneRole implements RoleAuthority {

    CONTROLPLANE_OWNER,
    CONTROLPLANE_BILLING_MANAGER,
    CONTROLPLANE_SUPPORT,
    CONTROLPLANE_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isOwner() {
        return this == CONTROLPLANE_OWNER;
    }

    public boolean isBillingManager() {
        return this == CONTROLPLANE_BILLING_MANAGER;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRolePermissions.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Set;

public final class ControlPlaneRolePermissions {

    private ControlPlaneRolePermissions() {}

    private static final EnumMap<ControlPlaneRole, Set<ControlPlanePermission>> MAP = new EnumMap<>(ControlPlaneRole.class);

    static {
        MAP.put(ControlPlaneRole.CONTROLPLANE_OWNER, EnumSet.allOf(ControlPlanePermission.class));

        MAP.put(ControlPlaneRole.CONTROLPLANE_BILLING_MANAGER, EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_BILLING_READ,
                ControlPlanePermission.CP_BILLING_WRITE
        ));



        MAP.put(ControlPlaneRole.CONTROLPLANE_SUPPORT, EnumSet.of(
            ControlPlanePermission.CP_TENANT_READ,
            ControlPlanePermission.CP_TENANT_SUSPEND,
            ControlPlanePermission.CP_TENANT_RESUME,
            ControlPlanePermission.CP_TENANT_DELETE,
            ControlPlanePermission.CP_USER_READ,
            ControlPlanePermission.CP_USER_WRITE,
            ControlPlanePermission.CP_USER_DELETE,          // <-- add
            ControlPlanePermission.CP_USER_PASSWORD_RESET
        ));


        MAP.put(ControlPlaneRole.CONTROLPLANE_OPERATOR, EnumSet.of(
                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_USER_READ
        ));
    }

    public static Set<ControlPlanePermission> permissionsFor(ControlPlaneRole role) {
        if (role == null) return Set.of();
        return Collections.unmodifiableSet(MAP.getOrDefault(role, Set.of()));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/config/time/TimeConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.config.time;

import java.time.Clock;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class TimeConfig {

    @Bean
    public Clock systemClock() {
        return Clock.systemDefaultZone();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import brito.com.multitenancy001.shared.db.Schemas;

@Configuration
public class PublicFlywayConfig {

    @Bean
    public Flyway flywayPublic(DataSource dataSource) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas(Schemas.CONTROL_PLANE)
                .locations("classpath:db/migration/accounts")
                .baselineOnMigrate(true)
                .load();

      
        return flyway;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayRunner.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import org.flywaydb.core.Flyway;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Component
@RequiredArgsConstructor
@Slf4j
public class PublicFlywayRunner implements ApplicationRunner {

	private final Flyway flywayPublic;

	@Override
	public void run(ApplicationArguments args) {

		log.info("🚀 Executando Flyway ACCOUNT (schema public)");
		flywayPublic.migrate();
	}
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicSchemaVerifier.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.db.Schemas;

@Slf4j
@Component
@RequiredArgsConstructor
public class PublicSchemaVerifier {
    
    private final JdbcTemplate jdbcTemplate;
    
    @EventListener(ApplicationReadyEvent.class)
    public void verifyTables() {
        log.info("🔍 Verificando tabelas criadas pelo Flyway...");
        
        try {
            // Apenas VERIFICA, não cria
        	Integer accountsCount = jdbcTemplate.queryForObject(
        		    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = ? AND table_name = 'accounts'",
        		    Integer.class,
        		    Schemas.CONTROL_PLANE
        		);

        		Integer usersCount = jdbcTemplate.queryForObject(
        		    "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = ? AND table_name = 'controlplane_users'",
        		    Integer.class,
        		    Schemas.CONTROL_PLANE
        		);    

            
            log.info("✅ Verificação OK! Tabelas encontradas: accounts={}, controlplane_users={}", accountsCount, usersCount);

        } catch (Exception e) {
            log.error("⚠️ Aviso na verificação: {}", e.getMessage());
        }
    }
}
============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/flyway/tenantschema/TenantSchemaFlywayMigrationService.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.tenantschema;

import lombok.RequiredArgsConstructor;
import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;

@Service
@RequiredArgsConstructor
public class TenantSchemaFlywayMigrationService {

    private final DataSource dataSource;

    public void migrateTenantSchema(String schemaName) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas(schemaName)
                .defaultSchema(schemaName) // 🔥 ESSENCIAL
                .createSchemas(false)
                .locations("classpath:db/migration/tenants")
                .baselineOnMigrate(true)
                .load();

        flyway.migrate();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/CurrentTenantSchemaResolver.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.extern.slf4j.Slf4j;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.db.Schemas;

@Slf4j
@Component
public class CurrentTenantSchemaResolver
        implements CurrentTenantIdentifierResolver<String> {

	private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;
    private static final ThreadLocal<String> TENANT_THREAD_LOCAL = new ThreadLocal<>();

    /**
     * Bind do tenant na thread atual.
     * - Se vier vazio/nulo: remove o tenant (fica "sem tenant", e o resolver decide fallback).
     * - Se vier preenchido: seta no ThreadLocal.
     */
    public static void bindTenantToCurrentThread(String tenantId) {
        String previous = TENANT_THREAD_LOCAL.get();

        String normalized = (tenantId != null ? tenantId.trim() : null);

        if (StringUtils.hasText(normalized)) {
            TENANT_THREAD_LOCAL.set(normalized);
            if (!normalized.equals(previous)) {
                log.info("🔄 Tenant bindado à thread: {} -> {}", previous, normalized);
            } else {
                log.debug("🔄 Tenant já estava bindado: {}", normalized);
            }
        } else {
            TENANT_THREAD_LOCAL.remove();
            if (previous != null) {
                log.info("🧹 Tenant removido da thread (anterior: {})", previous);
            } else {
                log.debug("🧹 Tenant já estava vazio (nada para remover)");
            }
        }
    }

    /**
     * Retorna o tenant REALMENTE bindado.
     * ✅ Importante: aqui retornamos null quando não há tenant,
     * pra não mascarar estado e facilitar debug.
     */
    public static String resolveBoundTenantOrNull() {
        String t = TENANT_THREAD_LOCAL.get();
        return StringUtils.hasText(t) ? t : null;
    }

    /**
     * Mantém compatibilidade com seu código atual (ex.: logs do provider).
     * Use isso somente quando você quer um fallback explícito para public.
     */
    public static String resolveBoundTenantOrDefault() {
        String t = resolveBoundTenantOrNull();
        return (t != null ? t : DEFAULT_SCHEMA);
    }

    public static void unbindTenantFromCurrentThread() {
        String previous = TENANT_THREAD_LOCAL.get();
        TENANT_THREAD_LOCAL.remove();
        if (previous != null) {
            log.info("🧹 Tenant desbindado da thread (anterior: {})", previous);
        } else {
            log.debug("🧹 Tenant desbindado (já estava vazio)");
        }
    }

    /**
     * O Hibernate sempre precisa de um tenant válido.
     * ✅ Aqui sim a gente aplica fallback para DEFAULT_SCHEMA.
     */
    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenant = resolveBoundTenantOrNull();
        String resolved = (tenant != null ? tenant : DEFAULT_SCHEMA);

        if (log.isDebugEnabled()) {
            log.debug("🏷️ Hibernate resolveu tenant={} (bound={}, default={})",
                    resolved, tenant, DEFAULT_SCHEMA);
        }
        return resolved;
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return false;
    }

    @Override
    public boolean isRoot(String tenantIdentifier) {
        return DEFAULT_SCHEMA.equals(tenantIdentifier);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TenantSchemaConnectionProvider.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.context.TenantContext;

import javax.sql.DataSource;
import java.sql.*;

@Slf4j
@Component
@RequiredArgsConstructor
public class TenantSchemaConnectionProvider
        extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String> {

    private static final long serialVersionUID = 1L;
    private static final String DEFAULT_SCHEMA = TenantContext.PUBLIC_SCHEMA;


    private final DataSource dataSource;

    @Override
    protected DataSource selectAnyDataSource() {
        return dataSource;
    }

    @Override
    protected DataSource selectDataSource(String tenantIdentifier) {
        return dataSource;
    }

    @Override
    public Connection getConnection(String tenantIdentifier) throws SQLException {

    	long threadId = Thread.currentThread().threadId();
    	String threadTenant = TenantContext.getOrDefaultPublic();

        
        
        
        String effectiveTenant = StringUtils.hasText(tenantIdentifier)
                ? tenantIdentifier
                : DEFAULT_SCHEMA;

        if (!StringUtils.hasText(tenantIdentifier)) {
            log.warn("⚠️ [MT] tenantIdentifier vazio → usando DEFAULT ({}) | threadTenant={}",
                    DEFAULT_SCHEMA, threadTenant);
        }

        validateSchemaName(effectiveTenant);

        Connection connection = dataSource.getConnection();

        try (Statement stmt = connection.createStatement()) {

            if (!DEFAULT_SCHEMA.equals(effectiveTenant)) {
                ensureSchemaExists(connection, effectiveTenant);

                String quotedTenant = quoteIdentifier(effectiveTenant);

                String setSearchPath = "SET search_path TO " + quotedTenant + ", public";
                log.info("🎯 [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL={}",
                        threadId, tenantIdentifier, threadTenant, setSearchPath);

                stmt.execute(setSearchPath);

            } else {
                log.info("🏠 [MT] getConnection | thread={} | tenantParam={} | tenantThread={} | SQL=SET search_path TO public;",
                        threadId, tenantIdentifier, threadTenant);

                stmt.execute("SET search_path TO public;");
            }

            return connection;

        } catch (SQLException e) {
            log.error("❌ [MT] Erro configurando conexão | effectiveTenant={}", effectiveTenant, e);
            try { connection.close(); } catch (SQLException ignore) {}
            throw e;
        }
    }

    @Override
    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
        if (connection == null || connection.isClosed()) return;

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("SET search_path TO public;");
        } finally {
            connection.close();
        }
    }

    private void ensureSchemaExists(Connection connection, String schemaName) throws SQLException {
        String quotedSchema = quoteIdentifier(schemaName);

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE SCHEMA IF NOT EXISTS " + quotedSchema);
        }

        try (PreparedStatement ps = connection.prepareStatement(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = ?")) {
            ps.setString(1, schemaName);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    throw new SQLException("Schema " + schemaName + " não encontrado após CREATE");
                }
            }
        }
    }

    private void validateSchemaName(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new IllegalArgumentException("schemaName vazio");
        }
        if (!schemaName.matches("[A-Za-z_][A-Za-z0-9_]*")) {
            throw new IllegalArgumentException("schemaName inválido: " + schemaName);
        }
    }

    private String quoteIdentifier(String identifier) {
        return "\"" + identifier + "\"";
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TenantSchemaHibernateConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import org.hibernate.cfg.AvailableSettings;
import org.hibernate.cfg.MultiTenancySettings;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.hibernate5.SpringBeanContainer;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class TenantSchemaHibernateConfig {

    private final DataSource dataSource;
    private final TenantSchemaConnectionProvider tenantSchemaConnectionProvider;
    private final CurrentTenantSchemaResolver currentTenantSchemaResolver;

    private final ConfigurableListableBeanFactory configurableListableBeanFactory;

    @Bean(name = "tenantEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        // Entidades do TENANT
        emf.setPackagesToScan("brito.com.multitenancy001.tenant.domain");

        emf.setPersistenceUnitName("TENANT_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);
        props.put("hibernate.dialect", "org.hibernate.dialect.PostgreSQLDialect");


        // ✅ Multi-tenancy por schema (strategy)
        // (Não use AvailableSettings.MULTI_TENANT — não existe no Hibernate 6)
        props.put("hibernate.multiTenancy", "SCHEMA");

        // ✅ Provider/Resolver (use constantes do Hibernate)
        props.put(MultiTenancySettings.MULTI_TENANT_CONNECTION_PROVIDER, tenantSchemaConnectionProvider);
        props.put(MultiTenancySettings.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantSchemaResolver);

        // ✅ Hibernate resolve beans do Spring (EntityListeners @Component etc.)
        props.put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(configurableListableBeanFactory));

        emf.setJpaPropertyMap(props);
        return emf;
    }

    @Bean(name = "tenantTransactionManager")
    public PlatformTransactionManager tenantTransactionManager(
            @Qualifier("tenantEntityManagerFactory") jakarta.persistence.EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/multitenancy/hibernate/TransactionManagementConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.hibernate;

import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
public class TransactionManagementConfig {
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/multitenancy/observability/TenantContextMonitor.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.observability;

import brito.com.multitenancy001.shared.context.TenantContext;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

@Aspect
@Component
@Slf4j
public class TenantContextMonitor {

    @Around("@within(org.springframework.stereotype.Service)")
    public Object monitorServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();

        String boundTenant = TenantContext.getOrNull();               // null ou tenant real
        String effectiveTenant = TenantContext.getOrDefaultPublic();  // tenant ou public/controlplane

        log.debug("🏁 INÍCIO {} - Tenant(bound={}, effective={})", methodName, boundTenant, effectiveTenant);

        try {
            Object result = joinPoint.proceed();

            String boundAfter = TenantContext.getOrNull();
            String effectiveAfter = TenantContext.getOrDefaultPublic();

            log.debug("✅ FIM {} - Tenant(bound={}, effective={})", methodName, boundAfter, effectiveAfter);
            return result;

        } catch (Throwable e) {

            // ✅ Login inválido = fluxo normal (não é erro do sistema)
            if (isInvalidLogin(e)) {
                log.info("🔐 AUTH inválida {} - Tenant(bound={}, effective={}) - {}",
                        methodName, boundTenant, effectiveTenant, safeMsg(e));
                throw e;
            }

            // ❌ Erro real
            log.error("❌ ERRO {} - Tenant(bound={}, effective={}) - Erro: {}",
                    methodName, boundTenant, effectiveTenant, safeMsg(e), e);
            throw e;
        }
    }

    private boolean isInvalidLogin(Throwable ex) {
        if (ex == null) return false;

        // Spring Security (senha errada / user inexistente após map)
        if (ex instanceof BadCredentialsException) return true;

        // user inexistente no UserDetailsService
        if (ex instanceof UsernameNotFoundException unf) {
            return "INVALID_USER".equalsIgnoreCase(unf.getMessage());
        }

        // encadeado (muito comum virem wrapped)
        Throwable cause = ex.getCause();
        if (cause != null && cause != ex) return isInvalidLogin(cause);

        return false;
    }

    private String safeMsg(Throwable ex) {
        String msg = ex.getMessage();
        return (msg != null && !msg.isBlank()) ? msg : ex.getClass().getSimpleName();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/openapi/OpenApiConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.openapi;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;

import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    public static final String SECURITY_SCHEME_NAME = "bearerAuth";

    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("Multitenancy001 API")
                .description("ControlPlane / Tenant APIs")
                .version("v1"))
            .addSecurityItem(new SecurityRequirement().addList(SECURITY_SCHEME_NAME))
            .components(new Components()
                .addSecuritySchemes(SECURITY_SCHEME_NAME,
                    new SecurityScheme()
                        .type(SecurityScheme.Type.HTTP)
                        .scheme("bearer")
                        .bearerFormat("JWT")
                )
            );
    }




@Bean
public GroupedOpenApi adminApi() {
    return GroupedOpenApi.builder()
        .group("admin")
        .pathsToMatch("/api/admin/**")
        .build();
}

@Bean
public GroupedOpenApi controlPlaneApi() {
    return GroupedOpenApi.builder()
        .group("controlplane")
        .pathsToMatch("/api/controlplane/**")
        .build();
}

@Bean
public GroupedOpenApi tenantApi() {
    return GroupedOpenApi.builder()
        .group("tenant")
        .pathsToMatch("/api/tenant/**", "/api/me/**")
        .build();
}

@Bean
public GroupedOpenApi publicApi() {
    return GroupedOpenApi.builder()
        .group("public")
        .pathsToMatch("/api/signup", "/api/accounts/auth/**")
        .build();
}

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/persistence/PublicPersistenceConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Persistência do schema PUBLIC (ControlPlane).
 * Usa o EntityManagerFactory default do Spring Boot (bean: "entityManagerFactory")
 * e cria um alias semântico: "publicEntityManagerFactory".
 */
@Configuration
@EnableJpaRepositories(
        basePackages = "brito.com.multitenancy001.controlplane.persistence",
        entityManagerFactoryRef = "publicEntityManagerFactory",
        transactionManagerRef = "publicTransactionManager"
)
public class PublicPersistenceConfig {

    @Bean(name = "publicEntityManagerFactory")
    @Primary
    public EntityManagerFactory publicEntityManagerFactory(
            @Qualifier("entityManagerFactory") EntityManagerFactory emf
    ) {
        return emf;
    }

    @Bean(name = "publicTransactionManager")
    @Primary
    public PlatformTransactionManager publicTransactionManager(
            @Qualifier("publicEntityManagerFactory") EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/persistence/PublicSchemaHibernateConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence;

import brito.com.multitenancy001.shared.db.Schemas;
import lombok.RequiredArgsConstructor;
import org.hibernate.cfg.AvailableSettings;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.hibernate5.SpringBeanContainer;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class PublicSchemaHibernateConfig {

    private final DataSource dataSource;
    private final ConfigurableListableBeanFactory configurableListableBeanFactory;

    @Bean(name = "entityManagerFactory")
    @Primary
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        // Entidades do PUBLIC (ControlPlane)
        emf.setPackagesToScan("brito.com.multitenancy001.controlplane.domain");

        emf.setPersistenceUnitName("PUBLIC_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.hbm2ddl.auto", "none");
        props.put("hibernate.show_sql", true);
        props.put("hibernate.format_sql", true);

        // Default schema do PUBLIC (control plane)
        props.put("hibernate.default_schema", Schemas.CONTROL_PLANE);

        // ✅ Hibernate resolve beans gerenciados pelo Spring (EntityListeners @Component etc.)
        props.put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(configurableListableBeanFactory));

        emf.setJpaPropertyMap(props);
        return emf;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/persistence/TenantPersistenceConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@Configuration
@EnableJpaRepositories(
        basePackages = "brito.com.multitenancy001.tenant.persistence",
        entityManagerFactoryRef = "tenantEntityManagerFactory",
        transactionManagerRef = "tenantTransactionManager"
)
public class TenantPersistenceConfig {
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/publicschema/AccountEntitlementsGuard.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicUnitOfWork;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsGuard {

    private final AccountRepository accountRepository;
    private final AccountEntitlementsService accountEntitlementsService;
    private final PublicUnitOfWork publicUnitOfWork;

    public void assertCanCreateUser(Long accountId, long currentUsers) {
        if (accountId == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);
        }

        publicUnitOfWork.readOnly(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            accountEntitlementsService.assertCanCreateUser(account, currentUsers);
        });
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/publicschema/AccountEntitlementsService.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema;

import brito.com.multitenancy001.controlplane.domain.account.Account;
import brito.com.multitenancy001.controlplane.domain.account.AccountEntitlements;
import brito.com.multitenancy001.controlplane.persistence.account.AccountEntitlementsRepository;
import brito.com.multitenancy001.shared.api.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsService {

    private final AccountEntitlementsRepository accountEntitlementsRepository;

    /**
     * Resolve entitlements efetivos da conta:
     * - PLATFORM => ilimitado
     * - TENANT => lê de account_entitlements
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public AccountEntitlementsSnapshot resolveEffective(Account account) {
        if (account == null) {
            throw new ApiException("ACCOUNT_REQUIRED", "Conta é obrigatória", 400);
        }

        if (account.isBuiltInAccount()) {
            return AccountEntitlementsSnapshot.ofUnlimited();
        }

        AccountEntitlements ent = accountEntitlementsRepository.findById(account.getId())
                .orElseThrow(() -> new ApiException(
                        "ENTITLEMENTS_NOT_FOUND",
                        "Entitlements não encontrados para a conta " + account.getId(),
                        500
                ));

        Integer maxUsers = safePositive(ent.getMaxUsers(), "maxUsers");
        Integer maxProducts = safePositive(ent.getMaxProducts(), "maxProducts");
        Integer maxStorageMb = safePositive(ent.getMaxStorageMb(), "maxStorageMb");

        return AccountEntitlementsSnapshot.ofLimited(maxUsers, maxProducts, maxStorageMb);
    }

    /**
     * Valida quota para criação de usuário.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public boolean canCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        return currentUsers < eff.maxUsers();
    }

    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);

        if (currentUsers >= eff.maxUsers()) {
            throw new ApiException(
                    "QUOTA_MAX_USERS_REACHED",
                    "Limite de usuários atingido para este plano",
                    403
            );
        }
    }

    /**
     * Valida quota para criação de produtos.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanCreateProduct(Account account, long currentProducts) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);

        if (currentProducts >= eff.maxProducts()) {
            throw new ApiException(
                    "QUOTA_MAX_PRODUCTS_REACHED",
                    "Limite de produtos atingido para este plano",
                    403
            );
        }
    }

    /**
     * Valida quota de armazenamento.
     */
    @Transactional(readOnly = true, transactionManager = "publicTransactionManager")
    public void assertCanConsumeStorage(Account account, long currentStorageMb, long deltaMb) {
        if (deltaMb < 0) {
            throw new ApiException("INVALID_STORAGE_DELTA", "deltaMb não pode ser negativo", 400);
        }

        AccountEntitlementsSnapshot eff = resolveEffective(account);
        long after = currentStorageMb + deltaMb;

        if (after > eff.maxStorageMb()) {
            throw new ApiException(
                    "QUOTA_MAX_STORAGE_REACHED",
                    "Limite de armazenamento atingido para este plano",
                    403
            );
        }
    }

    // =========================
    // Helpers
    // =========================

    private Integer safePositive(Integer value, String field) {
        if (value == null || value <= 0) {
            throw new ApiException(
                    "INVALID_ENTITLEMENT",
                    "Entitlement inválido: " + field,
                    500
            );
        }
        return value;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/publicschema/AccountEntitlementsSnapshot.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema;

public record AccountEntitlementsSnapshot(
        int maxUsers,
        int maxProducts,
        int maxStorageMb,
        boolean unlimited
) {

    public static AccountEntitlementsSnapshot ofUnlimited() {
        return new AccountEntitlementsSnapshot(
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                true
        );
    }

    public static AccountEntitlementsSnapshot ofLimited(int maxUsers, int maxProducts, int maxStorageMb) {
        return new AccountEntitlementsSnapshot(maxUsers, maxProducts, maxStorageMb, false);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/publicschema/AccountResolver.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema;

import java.time.LocalDateTime;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.persistence.account.AccountRepository;
import brito.com.multitenancy001.controlplane.persistence.account.AccountResolverProjection;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountResolver {

    private final AccountRepository accountRepository;
    private final AppClock appClock;
    private final PublicExecutor publicExecutor;

    public AccountSnapshot resolveActiveAccountBySlug(String slug) {
        return publicExecutor.run(() -> {
            LocalDateTime now = appClock.now();

            AccountResolverProjection p = accountRepository.findProjectionBySlugAndDeletedFalseIgnoreCase(slug)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            if (!isOperational(p, now)) {
                throw new ApiException("ACCOUNT_INACTIVE", "Conta inativa", 403);
            }

            return new AccountSnapshot(p.getId(), p.getSchemaName(), p.getSlug(), p.getDisplayName());
        });
    }

    public AccountSnapshot resolveActiveAccountById(Long accountId) {
        if (accountId == null) throw new ApiException("INVALID_ACCOUNT", "accountId inválido", 400);
        return resolveActiveAccountByIdInternal(accountId);
    }

    private AccountSnapshot resolveActiveAccountByIdInternal(Long accountId) {
        return publicExecutor.run(() -> {
            LocalDateTime now = appClock.now();

            AccountResolverProjection p = accountRepository.findProjectionByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException("ACCOUNT_NOT_FOUND", "Conta não encontrada", 404));

            if (!isOperational(p, now)) {
                throw new ApiException("ACCOUNT_INACTIVE", "Conta inativa", 403);
            }

            return new AccountSnapshot(p.getId(), p.getSchemaName(), p.getSlug(), p.getDisplayName());
        });
    }

    private boolean isOperational(AccountResolverProjection p, LocalDateTime now) {
        if (p == null) return false;

        if ("BUILT_IN".equalsIgnoreCase(p.getOrigin())) return true;

        String status = p.getStatus();
        if ("ACTIVE".equalsIgnoreCase(status)) return true;

        if ("FREE_TRIAL".equalsIgnoreCase(status)) {
            return p.getTrialEndDate() != null && now != null && p.getTrialEndDate().isAfter(now);
        }

        return false;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/publicschema/AccountSnapshot.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema;

public record AccountSnapshot(
        Long id,
        String schemaName,
        String slug,
        String displayName
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/publicschema/LoginIdentityResolver.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema;

import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
@RequiredArgsConstructor
public class LoginIdentityResolver {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    /** ✅ nome esperado pelo TenantAuthService */
    public List<LoginIdentityRow> findTenantAccountsByEmail(String email) {
        return findTenantsByEmail(email);
    }

    /** ✅ implementação real */
    public List<LoginIdentityRow> findTenantsByEmail(String email) {
        if (email == null || email.isBlank()) return List.of();

        String normalized = email.trim().toLowerCase();

        String sql = """
            select li.account_id,
                   a.display_name,
                   a.slug
              from public.login_identities li
              join public.accounts a on a.id = li.account_id
             where lower(li.email) = lower(:email)
               and a.deleted = false
        """;

        var params = new MapSqlParameterSource("email", normalized);

        return jdbcTemplate.query(sql, params, (rs, rowNum) -> new LoginIdentityRow(
                rs.getLong("account_id"),
                rs.getString("display_name"),
                rs.getString("slug")
        ));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/publicschema/LoginIdentityRow.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema;





public record LoginIdentityRow(
        Long accountId,
        String displayName,
        String slug
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/AuthenticatedUserContext.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.shared.security.AuthenticatedPrincipal;
import brito.com.multitenancy001.shared.security.RoleAuthority;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;

/**
 * Principal autenticado usado pelo Spring Security.
 *
 * Observação importante:
 * - O método do contrato UserDetails se chama getUsername().
 * - No nosso domínio, login é por email.
 * - Por isso, aqui guardamos o principal como principalEmail e
 *   implementamos getUsername() retornando esse email.
 */
public class AuthenticatedUserContext implements UserDetails, AuthenticatedPrincipal {

    private static final long serialVersionUID = 1L;

    private final Long userId;

    /** Email usado como principal (UserDetails#getUsername). */
    private final String principalEmail;

    private final String name;
    private final String email;

    private final String password;
    private final boolean mustChangePassword;

    private final boolean enabled;
    private final boolean accountNonLocked;

    private final Long accountId;
    private final String schemaName;

    private final boolean suspendedByAccount;
    private final boolean suspendedByAdmin;
    private final boolean deleted;

    private final RoleAuthority roleAuthority;

    private final Collection<? extends GrantedAuthority> authorities;

    private AuthenticatedUserContext(
            Long userId,
            String principalEmail,
            String name,
            String email,
            String password,
            boolean mustChangePassword,
            boolean enabled,
            boolean accountNonLocked,
            Long accountId,
            String schemaName,
            boolean suspendedByAccount,
            boolean suspendedByAdmin,
            boolean deleted,
            RoleAuthority roleAuthority,
            Collection<? extends GrantedAuthority> authorities
    ) {
        this.userId = userId;
        this.principalEmail = principalEmail;
        this.name = name;
        this.email = email;
        this.password = password;
        this.mustChangePassword = mustChangePassword;
        this.enabled = enabled;
        this.accountNonLocked = accountNonLocked;
        this.accountId = accountId;
        this.schemaName = schemaName;
        this.suspendedByAccount = suspendedByAccount;
        this.suspendedByAdmin = suspendedByAdmin;
        this.deleted = deleted;
        this.roleAuthority = roleAuthority;
        this.authorities = authorities;
    }

    @Override
    public Long getUserId() {
        return userId;
    }

    public String getName() {
        return name;
    }

    /**
     * Email principal usado para autenticação (mesmo valor de getUsername()).
     * Exposto por clareza.
     */
    public String getPrincipalEmail() {
        return principalEmail;
    }

    /**
     * Contrato do AuthenticatedPrincipal.
     */
    @Override
    public String getEmail() {
        return email;
    }

    public boolean isMustChangePassword() {
        return mustChangePassword;
    }

    public Long getAccountId() {
        return accountId;
    }

    public String getSchemaName() {
        return schemaName;
    }

    public boolean isSuspendedByAccount() {
        return suspendedByAccount;
    }

    public boolean isSuspendedByAdmin() {
        return suspendedByAdmin;
    }

    public boolean isDeleted() {
        return deleted;
    }

    public RoleAuthority getRoleAuthorityEnum() {
        return roleAuthority;
    }

    public String getRoleAuthority() {
        return roleAuthority == null ? null : roleAuthority.asAuthority();
    }

    public String getRoleName() {
        return roleAuthority == null ? null : roleAuthority.toString();
    }

    /** Compat com código antigo que chamava getRole() */
    public String getRole() {
        return getRoleName();
    }

    public static AuthenticatedUserContext fromTenantUser(
            TenantUser user,
            String tenantSchema,
            LocalDateTime now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        String email = user.getEmail();

        if (!user.isEnabledForLogin(now)) {
            throw new BadCredentialsException("USER_DISABLED");
        }

        return new AuthenticatedUserContext(
                user.getId(),
                email,
                user.getName(),
                email,
                user.getPassword(),
                user.isMustChangePassword(),
                user.isEnabled(),
                user.isAccountNonLocked(now),
                user.getAccountId(),
                tenantSchema,
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.isDeleted(),
                user.getRole(),
                authorities
        );
    }

    public static AuthenticatedUserContext fromControlPlaneUser(
            ControlPlaneUser user,
            String tenantSchema,
            LocalDateTime now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        String email = user.getEmail();

        if (!user.isEnabledForLogin(now)) {
            throw new BadCredentialsException("USER_DISABLED");
        }

        return new AuthenticatedUserContext(
                user.getId(),
                email,
                user.getName(),
                email,
                user.getPassword(),
                user.isMustChangePassword(),
                user.isEnabled(),
                user.isAccountNonLocked(now),
                user.getAccount().getId(),
                tenantSchema,
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.isDeleted(),
                user.getRole(),
                authorities
        );
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    /**
     * Contrato do Spring Security. No nosso sistema, isso é SEMPRE o email.
     */
    @Override
    public String getUsername() {
        return principalEmail;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/SecurityConstants.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

/**
 * Constantes de segurança (infra).
 * Mantém strings de domínios e rotas em um só lugar.
 */
public final class SecurityConstants {

    private SecurityConstants() {}

    public static final class AuthDomains {
        private AuthDomains() {}
        public static final String TENANT = "TENANT";
        public static final String CONTROLPLANE = "CONTROLPLANE";
    }

    public static final class ApiPaths {
        private ApiPaths() {}

        public static final String ADMIN_PREFIX = "/api/admin/";
        public static final String CONTROLPLANE_PREFIX = "/api/controlplane/";
        public static final String TENANT_PREFIX = "/api/tenant/";

        // ✅ TENANT "me" fora do prefixo /api/tenant
        public static final String ME = "/api/me";
        public static final String ME_PREFIX = "/api/me/";
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/SecurityUtils.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.api.error.ApiException;

@Component
@RequiredArgsConstructor
public class SecurityUtils {
    
    public Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getUserId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
    public Long getCurrentAccountId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getAccountId();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
    public String getCurrentSchema() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getSchemaName();
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }
    
  
    
    public String getCurrentRoleAuthority() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getRoleAuthority(); // ex: "ROLE_CONTROLPLANE_OWNER"
        }
        throw new ApiException("UNAUTHENTICATED", "Usuário não autenticado", 401);
    }

    /**
     * Lê a role do CONTROLPLANE a partir do roleAuthority armazenado no principal.
     * Ex.: "ROLE_CONTROLPLANE_OWNER" -> ControlPlaneRole.CONTROLPLANE_OWNER
     */
    public ControlPlaneRole getCurrentControlPlaneRole() {
        String roleAuthority = getCurrentRoleAuthority();
        if (roleAuthority == null || !roleAuthority.startsWith("ROLE_")) {
            throw new ApiException("FORBIDDEN", "Role inválida no contexto de autenticação", 403);
        }
        String roleName = roleAuthority.substring("ROLE_".length());
        try {
            return ControlPlaneRole.valueOf(roleName);
        } catch (IllegalArgumentException e) {
            throw new ApiException("FORBIDDEN", "Role não reconhecida: " + roleName, 403);
        }
    }
    
    public String getCurrentEmail() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext) {
            AuthenticatedUserContext userDetails = (AuthenticatedUserContext) authentication.getPrincipal();
            return userDetails.getEmail();
        }
        return authentication != null ? authentication.getName() : null;
    }

    
    
}
============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/authorities/AuthoritiesFactory.java
============================================================
package brito.com.multitenancy001.infrastructure.security.authorities;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRolePermissions;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;

public final class AuthoritiesFactory {

    private AuthoritiesFactory() {}

    public static Set<GrantedAuthority> forControlPlane(ControlPlaneUser user) {
        Set<String> merged = new LinkedHashSet<>();

        // defaults da role (enum -> string)
        for (ControlPlanePermission p : ControlPlaneRolePermissions.permissionsFor(user.getRole())) {
            merged.add(p.name());
        }

        // permissions explícitas do banco (enum -> string)
        if (user.getPermissions() != null) {
            for (ControlPlanePermission p : user.getPermissions()) {
                if (p == null) continue;
                merged.add(p.name());
            }
        }

        // normaliza e bloqueia escopo errado (TEN_ dentro do CP, etc.)
        merged = PermissionScopeValidator.normalizeControlPlaneStrict(merged);

        Set<GrantedAuthority> authorities = new LinkedHashSet<>();
        for (String perm : merged) {
            if (perm == null || perm.isBlank()) continue;
            authorities.add(new SimpleGrantedAuthority(perm.trim().toUpperCase(Locale.ROOT)));
        }
        return authorities;
    }

    public static Set<GrantedAuthority> forTenant(TenantUser user) {
        Set<String> merged = new LinkedHashSet<>();

        // defaults por role
        if (user.getRole() != null) {
            for (TenantPermission p : TenantRolePermissions.permissionsFor(user.getRole())) {
                merged.add(p.name());
            }
        }

        // permissions explícitas do banco (enum -> string)
        if (user.getPermissions() != null) {
            for (TenantPermission p : user.getPermissions()) {
                if (p == null) continue;
                merged.add(p.name());
            }
        }

        // normaliza SEMPRE e bloqueia CP_ dentro do tenant
        merged = PermissionScopeValidator.normalizeTenantStrict(merged);

        Set<GrantedAuthority> authorities = new LinkedHashSet<>();
        for (String perm : merged) {
            if (perm == null || perm.isBlank()) continue;
            authorities.add(new SimpleGrantedAuthority(perm.trim().toUpperCase(Locale.ROOT)));
        }
        return authorities;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/config/SecurityConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.infrastructure.security.filter.JwtAuthenticationFilter;
import brito.com.multitenancy001.infrastructure.security.filter.MustChangePasswordFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public MustChangePasswordFilter mustChangePasswordFilter() {
        return new MustChangePasswordFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
            		
            		
            		// =========================
            		// 🔓 SWAGGER / OPENAPI
            		// =========================
            		.requestMatchers(
            		    "/v3/api-docs/**",
            		    "/swagger-ui.html",
            		    "/swagger-ui/**"
            		).permitAll()

                // =========================
                // 🔓 PUBLIC
                // =========================
                .requestMatchers("/actuator/health").permitAll()

                // =========================
                // 🔓 AUTH CONTROLPLANE (admin)
                // =========================
                .requestMatchers(
                    "/api/admin/auth/login",
                    "/api/admin/auth/refresh"
                ).permitAll()

                // ✅ troca de senha do próprio usuário (precisa estar autenticado)
                .requestMatchers("/api/admin/me/password").authenticated()

                // =========================
                // 🔓 AUTH TENANT
                // =========================
                .requestMatchers(
                    "/api/tenant/auth/login",
                    "/api/tenant/auth/refresh"
                ).permitAll()

                // =========================
                // 🔓 PASSWORD RESET TENANT
                // =========================
                .requestMatchers(
                    "/api/tenant/password/forgot",
                    "/api/tenant/password/reset"
                ).permitAll()

                // =========================
                // 🔓 SIGNUP / CHECKUSER
                // =========================
                .requestMatchers(
                    "/api/accounts/auth/checkuser",
                    "/api/signup"
                ).permitAll()

                // =========================
                // ✅ ME (TENANT) fora do prefixo /api/tenant
                // =========================
                // libera GET/PUT /api/me e qualquer subrota (se no futuro você criar /api/me/password, etc.)
                .requestMatchers("/api/me/**").authenticated()

                // =========================
                // ✅ BOUNDARIES OFICIAIS
                // =========================
                .requestMatchers("/api/admin/**").authenticated()
                .requestMatchers("/api/controlplane/**").authenticated()
                .requestMatchers("/api/tenant/**").authenticated()

                // =========================
                // ❌ Qualquer rota fora disso é erro de arquitetura
                // =========================
                .anyRequest().denyAll()
            );

        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        // ✅ MustChangePassword precisa rodar DEPOIS do JWT filter
        http.addFilterAfter(mustChangePasswordFilter(), JwtAuthenticationFilter.class);

        return http.build();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/filter/JwtAuthenticationFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.SecurityConstants;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final MultiContextUserDetailsService multiContextUserDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest httpServletRequest,
            @NonNull HttpServletResponse httpServletResponse,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        final String authHeader = httpServletRequest.getHeader("Authorization");

        // "Bearer ..." é esquema HTTP, não é domínio do token
        if (!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(httpServletRequest, httpServletResponse);
            return;
        }

        final String jwt = authHeader.substring(7);

        if (!jwtTokenProvider.validateToken(jwt)) {
            filterChain.doFilter(httpServletRequest, httpServletResponse);
            return;
        }

        // ✅ authDomain = TENANT/CONTROLPLANE/...
        final String authDomain = jwtTokenProvider.getAuthDomain(jwt);
        final String emailRaw = jwtTokenProvider.getEmailFromToken(jwt);
        final String email = (emailRaw == null) ? null : emailRaw.trim().toLowerCase();

        // ✅ TRAVA FORTE (403): token tem que bater com a rota
        // Ex.: rota tenant com token controlplane => 403
        if (requiresControlPlane(httpServletRequest) && SecurityConstants.AuthDomains.TENANT.equals(authDomain)) {
            httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
        if (requiresTenant(httpServletRequest) && SecurityConstants.AuthDomains.CONTROLPLANE.equals(authDomain)) {
            httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return;
        }

        // Se chegou aqui, o domínio "pode" bater com a área.
        // Se a rota pede ControlPlane, só aceita CONTROLPLANE.
        if (requiresControlPlane(httpServletRequest) && !SecurityConstants.AuthDomains.CONTROLPLANE.equals(authDomain)) {
            filterChain.doFilter(httpServletRequest, httpServletResponse);
            return;
        }

        // Se a rota pede Tenant, só aceita TENANT.
        if (requiresTenant(httpServletRequest) && !SecurityConstants.AuthDomains.TENANT.equals(authDomain)) {
            filterChain.doFilter(httpServletRequest, httpServletResponse);
            return;
        }

        // só aceitamos TENANT / CONTROLPLANE aqui
        if (!SecurityConstants.AuthDomains.TENANT.equals(authDomain)
                && !SecurityConstants.AuthDomains.CONTROLPLANE.equals(authDomain)) {
            filterChain.doFilter(httpServletRequest, httpServletResponse);
            return;
        }

        if (!StringUtils.hasText(email)) {
            filterChain.doFilter(httpServletRequest, httpServletResponse);
            return;
        }

        if (SecurityContextHolder.getContext().getAuthentication() != null) {
            filterChain.doFilter(httpServletRequest, httpServletResponse);
            return;
        }

        if (SecurityConstants.AuthDomains.TENANT.equals(authDomain)) {
            final String tenantSchema = jwtTokenProvider.getTenantSchemaFromToken(jwt);

            if (!StringUtils.hasText(tenantSchema) || Schemas.CONTROL_PLANE.equalsIgnoreCase(tenantSchema)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            if (!tenantSchema.matches("^[a-zA-Z0-9_]+$")) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
            if (accountId == null) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            // ✅ escopo seguro: sempre limpa no final
            try (TenantContext.Scope ignored = TenantContext.scope(tenantSchema)) {

                UserDetails userDetails = multiContextUserDetailsService.loadTenantUserByEmail(email, accountId);

                UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities()
                        );

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(httpServletRequest));
                SecurityContextHolder.getContext().setAuthentication(authToken);

                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

        } else { // CONTROLPLANE
            String context = jwtTokenProvider.getContextFromToken(jwt);
            if (StringUtils.hasText(context) && !Schemas.CONTROL_PLANE.equalsIgnoreCase(context)) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
            if (accountId == null) {
                filterChain.doFilter(httpServletRequest, httpServletResponse);
                return;
            }

            UserDetails userDetails = multiContextUserDetailsService.loadControlPlaneUserByEmail(email, accountId);

            UsernamePasswordAuthenticationToken authToken =
                    new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities()
                    );

            authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(httpServletRequest));
            SecurityContextHolder.getContext().setAuthentication(authToken);

            filterChain.doFilter(httpServletRequest, httpServletResponse);
        }
    }

    private boolean requiresControlPlane(HttpServletRequest httpServletRequest) {
        String path = httpServletRequest.getRequestURI();
        return path.startsWith(SecurityConstants.ApiPaths.ADMIN_PREFIX)
                || path.startsWith(SecurityConstants.ApiPaths.CONTROLPLANE_PREFIX);
    }

    private boolean requiresTenant(HttpServletRequest httpServletRequest) {
        String path = httpServletRequest.getRequestURI();

        // ✅ /api/me é tenant (GET/PUT)
        boolean isMe = SecurityConstants.ApiPaths.ME.equals(path)
                || path.startsWith(SecurityConstants.ApiPaths.ME_PREFIX);

        return path.startsWith(SecurityConstants.ApiPaths.TENANT_PREFIX) || isMe;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/filter/MustChangePasswordFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Map;

public class MustChangePasswordFilter extends OncePerRequestFilter {

    private static final String CHANGE_PASSWORD_PATH = "/api/admin/me/password";
    private static final String ME_PATH              = "/api/admin/me";

    private static final String LOGIN_PATH   = "/api/admin/auth/login";
    private static final String REFRESH_PATH = "/api/admin/auth/refresh";

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        String method = request.getMethod();
        String path = request.getRequestURI();

        // ✅ libera preflight (CORS)
        if ("OPTIONS".equalsIgnoreCase(method)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera login/refresh
        if (path.startsWith(LOGIN_PATH) || path.startsWith(REFRESH_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera troca de senha
        if (path.startsWith(CHANGE_PASSWORD_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication == null || !(authentication.getPrincipal() instanceof AuthenticatedUserContext ctx)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera /me (pra UI conseguir saber que precisa trocar senha)
        if (path.startsWith(ME_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        if (ctx.isMustChangePassword()) {
            response.setStatus(428);
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);

            Map<String, Object> body = Map.of(
                    "error", "MUST_CHANGE_PASSWORD",
                    "message", "Você precisa alterar a senha antes de continuar.",
                    "status", 428,
                    "details", Map.of(
                            "userId", ctx.getUserId(),
                            "email", ctx.getEmail(),
                            "accountId", ctx.getAccountId()
                    )
            );

            response.getWriter().write(objectMapper.writeValueAsString(body));
            return;
        }

        filterChain.doFilter(request, response);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/jwt/JwtTokenProvider.java
============================================================
package brito.com.multitenancy001.infrastructure.security.jwt;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.time.AppClock;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtTokenProvider {

    public static final String CLAIM_AUTHORITIES = "authorities";
    public static final String CLAIM_AUTH_DOMAIN = "authDomain";
    public static final String CLAIM_CONTEXT = "context";
    public static final String CLAIM_ACCOUNT_ID = "accountId";
    public static final String CLAIM_USER_ID = "userId";

    public static final String CLAIM_ROLE_NAME = "roleName";
    public static final String CLAIM_ROLE_AUTHORITY = "roleAuthority";

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private long jwtExpirationInMs;

    @Value("${app.jwt.refresh.expiration}")
    private long refreshExpirationInMs;

    private final AppClock appClock;
    private SecretKey key;

    public JwtTokenProvider(AppClock appClock) {
        this.appClock = appClock;
    }

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            throw new IllegalArgumentException("JWT secret must be at least 256 bits (32 chars)");
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    private Date issuedAt() { return Date.from(appClock.instant()); }

    private Date expiresAtInMs(long ttlMillis) {
        Instant exp = appClock.instant().plusMillis(ttlMillis);
        return Date.from(exp);
    }

    public String generateControlPlaneToken(Authentication authentication, Long accountId, String context) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getEmail())
                .claim(CLAIM_AUTHORITIES, user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim(CLAIM_AUTH_DOMAIN, "CONTROLPLANE")
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, user.getUserId())
                .claim(CLAIM_ROLE_NAME, user.getRoleName())
                .claim(CLAIM_ROLE_AUTHORITY, user.getRoleAuthority())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public String generateTenantToken(Authentication authentication, Long accountId, String context) {
        AuthenticatedUserContext user = (AuthenticatedUserContext) authentication.getPrincipal();

        return Jwts.builder()
                .subject(user.getEmail())
                .claim(CLAIM_AUTHORITIES, user.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.joining(",")))
                .claim(CLAIM_AUTH_DOMAIN, "TENANT")
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, user.getUserId())
                .claim(CLAIM_ROLE_NAME, user.getRoleName())
                .claim(CLAIM_ROLE_AUTHORITY, user.getRoleAuthority())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public String generateRefreshToken(String email, String context) {
        return Jwts.builder()
                .subject(email)
                .claim(CLAIM_AUTH_DOMAIN, "REFRESH")
                .claim(CLAIM_CONTEXT, context)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(refreshExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public String generatePasswordResetToken(String email, String context, Long accountId) {
        long oneHourMs = 3_600_000L;

        return Jwts.builder()
                .subject(email)
                .claim(CLAIM_AUTH_DOMAIN, "PASSWORD_RESET")
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(oneHourMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    public String getEmailFromToken(String token) {
        return getAllClaimsFromToken(token).getSubject();
    }

    public String getContextFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String context = claims.get(CLAIM_CONTEXT, String.class);
        if (context == null) context = claims.get("tenantSchema", String.class);

        String authDomain = getAuthDomain(token);

        if ("TENANT".equals(authDomain) && Schemas.CONTROL_PLANE.equalsIgnoreCase(context)) {
            throw new JwtException("Invalid context for TENANT token: public");
        }

        return context;
    }

    public String getTenantSchemaFromToken(String token) {
        return getContextFromToken(token);
    }

    public Long getAccountIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ACCOUNT_ID, Long.class);
    }

    public Long getUserIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_USER_ID, Long.class);
    }

    public String getAuthDomain(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authDomain = claims.get(CLAIM_AUTH_DOMAIN, String.class);
        if (!StringUtils.hasText(authDomain)) {
            authDomain = claims.get("type", String.class); // compat tokens antigos
        }

        return authDomain;
    }

    public String getRoleNameFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ROLE_NAME, String.class);
    }

    public String getRoleAuthorityFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ROLE_AUTHORITY, String.class);
    }

    public List<String> getAuthoritiesFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authorities = claims.get(CLAIM_AUTHORITIES, String.class);
        if (!StringUtils.hasText(authorities)) {
            authorities = claims.get("roles", String.class); // compat tokens antigos
        }

        return splitCsv(authorities);
    }

    private List<String> splitCsv(String csv) {
        if (!StringUtils.hasText(csv)) return List.of();

        return Arrays.stream(csv.split(","))
                .map(String::trim)
                .filter(StringUtils::hasText)
                .distinct()
                .toList();
    }

    public boolean isTokenExpired(String token) {
        try {
            Claims claims = getAllClaimsFromToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(Date.from(appClock.instant()));
        } catch (Exception e) {
            return true;
        }
    }

    public boolean validateToken(String token) {
        try {
            getAllClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public boolean isControlPlaneToken(String token) {
        return "CONTROLPLANE".equals(getAuthDomain(token));
    }

    public boolean isTenantToken(String token) {
        return "TENANT".equals(getAuthDomain(token));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/security/userdetails/MultiContextUserDetailsService.java
============================================================
package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.domain.user.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.persistence.user.ControlPlaneUserRepository;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.authorities.AuthoritiesFactory;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
public class MultiContextUserDetailsService implements UserDetailsService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final TenantUserRepository tenantUserRepository;
    private final AppClock appClock;

    private LocalDateTime now() { return appClock.now(); }

    private static String normalizeEmail(String raw) {
        return raw == null ? null : raw.trim().toLowerCase();
    }

    // ✅ COLOQUE AQUI (dentro da classe)
    private static void assertEmail(String email) {
        if (email == null || email.isBlank()) {
            throw new UsernameNotFoundException("INVALID_USER");
        }
    }

    /**
     * Spring Security exige essa assinatura, mas aqui tratamos o parâmetro como EMAIL.
     */
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        String schemaName = TenantContext.getOrNull();

        // CONTROL PLANE continua normal (email é único globalmente)
        if (schemaName == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(schemaName)) {
            return loadControlPlaneUserByEmail(email);
        }

        // 🔒 TENANT: nunca autentica sem accountId
        throw new UsernameNotFoundException("TENANT_LOGIN_REQUIRES_ACCOUNT");
    }

    public UserDetails loadControlPlaneUserByEmail(String email, Long accountId) {
        LocalDateTime now = now();

        if (accountId == null) {
            throw new ApiException(
                    "ACCOUNT_REQUIRED",
                    "accountId é obrigatório para autenticar usuário da controlplane",
                    400
            );
        }

        String loginEmail = normalizeEmail(email);
        assertEmail(loginEmail);

        ControlPlaneUser user = controlPlaneUserRepository
                .findByEmailAndAccount_IdAndDeletedFalse(loginEmail, accountId)
                .orElseThrow(() -> new UsernameNotFoundException("INVALID_USER"));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return AuthenticatedUserContext.fromControlPlaneUser(user, Schemas.CONTROL_PLANE, now, authorities);
    }

    public UserDetails loadControlPlaneUserByEmail(String email) {
        LocalDateTime now = now();

        String loginEmail = normalizeEmail(email);
        assertEmail(loginEmail);

        ControlPlaneUser user = controlPlaneUserRepository.findByEmailAndDeletedFalse(loginEmail)
                .orElseThrow(() -> new UsernameNotFoundException("INVALID_USER"));

        var authorities = AuthoritiesFactory.forControlPlane(user);
        return AuthenticatedUserContext.fromControlPlaneUser(user, Schemas.CONTROL_PLANE, now, authorities);
    }

    public UserDetails loadTenantUserByEmail(String email, Long accountId) {
        String schemaName = TenantContext.getOrNull();
        if (schemaName == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(schemaName)) {
            throw new ApiException(
                    "TENANT_CONTEXT_REQUIRED",
                    "TenantContext não está bindado para autenticar usuário tenant",
                    401
            );
        }

        if (accountId == null) {
            throw new ApiException(
                    "ACCOUNT_REQUIRED",
                    "accountId é obrigatório para autenticar usuário tenant",
                    400
            );
        }

        LocalDateTime now = now();

        String loginEmail = normalizeEmail(email);
        assertEmail(loginEmail);

        TenantUser user = tenantUserRepository
                .findByEmailAndAccountIdAndDeletedFalse(loginEmail, accountId)
                .orElseThrow(() -> new UsernameNotFoundException("INVALID_USER"));

        var authorities = AuthoritiesFactory.forTenant(user);
        return AuthenticatedUserContext.fromTenantUser(user, schemaName, now, authorities);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/tenant/TenantExecutor.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;

@Component
public class TenantExecutor {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public TenantExecutor(TenantSchemaProvisioningService tenantSchemaProvisioningService) {
        this.tenantSchemaProvisioningService = tenantSchemaProvisioningService;
    }

    public <T> T run(String schemaName, Supplier<T> fn) {
        String theSchema = (schemaName == null ? null : schemaName.trim());

        if (theSchema == null || theSchema.isBlank() || Schemas.CONTROL_PLANE.equalsIgnoreCase(theSchema)) {
            throw new ApiException("TENANT_INVALID", "Tenant inválido", 404);
        }

        // ✅ padronizado: nada de bind/clear manual
        try (TenantContext.Scope ignored = TenantContext.scope(theSchema)) {
            return fn.get();
        }
    }

    public void run(String schemaName, Runnable fn) {
        run(schemaName, () -> {
            fn.run();
            return null;
        });
    }

    /** Retorna defaultValue se schemaName/tabela não existir (bom p/ side-effects). */
    public <T> T runIfReady(String schemaName, String requiredTable, Supplier<T> fn, T defaultValue) {
        String s = (schemaName == null ? null : schemaName.trim());

        if (s == null || s.isBlank() || Schemas.CONTROL_PLANE.equalsIgnoreCase(s)) return defaultValue;
        if (!tenantSchemaProvisioningService.schemaExists(s)) return defaultValue;
        if (requiredTable != null && !tenantSchemaProvisioningService.tableExists(s, requiredTable)) return defaultValue;

        return run(s, fn);
    }

    /**
     * Overload conveniente: defaultValue = null
     * (útil quando o caller aceita null como "não aplicou side-effect").
     */
    public <T> T runIfReady(String schemaName, String requiredTable, Supplier<T> fn) {
        return runIfReady(schemaName, requiredTable, fn, null);
    }

    /**
     * Overload para Runnable (quando o caller não precisa retornar nada).
     */
    public void runIfReady(String schemaName, String requiredTable, Runnable fn) {
        runIfReady(schemaName, requiredTable, () -> {
            fn.run();
            return null;
        }, null);
    }

    /** Lança ApiException se schemaName/tabela não existir (bom p/ endpoints admin). */
    public void assertReadyOrThrow(String schemaName, String requiredTable) {
        String s = (schemaName == null ? null : schemaName.trim());

        if (s == null || s.isBlank() || Schemas.CONTROL_PLANE.equalsIgnoreCase(s)) {
            throw new ApiException("TENANT_INVALID", "Tenant inválido", 404);
        }
        if (!tenantSchemaProvisioningService.schemaExists(s)) {
            throw new ApiException("TENANT_SCHEMA_NOT_FOUND", "SchemaName do tenant não existe", 404);
        }
        if (requiredTable != null && !tenantSchemaProvisioningService.tableExists(s, requiredTable)) {
            throw new ApiException("TENANT_TABLE_NOT_FOUND", "Tabela " + requiredTable + " não existe no tenant", 404);
        }
    }

    public <T> T runOrThrow(String schemaName, String requiredTable, Supplier<T> fn) {
        assertReadyOrThrow(schemaName, requiredTable);
        return run(schemaName, fn);
    }

    // overload conveniente
    public <T> T runOrThrow(String schemaName, Supplier<T> fn) {
        return runOrThrow(schemaName, null, fn);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/tenant/TenantRequiredTables.java
============================================================
// arquivo: .../infrastructure/tenant/TenantRequiredTables.java
package brito.com.multitenancy001.infrastructure.tenant;

public final class TenantRequiredTables {
    private TenantRequiredTables() {}
    public static final String TENANT_USERS = "tenant_users";
    public static final String PRODUCTS = "products";
    // ...
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningFacade.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import org.springframework.stereotype.Service;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningFacade {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    public void ensureSchemaExistsAndMigrate(String schemaName) {
        tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(schemaName);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningService.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import brito.com.multitenancy001.infrastructure.flyway.tenantschema.TenantSchemaFlywayMigrationService;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.db.Schemas;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.regex.Pattern;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Slf4j
@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningService {

    private final JdbcTemplate jdbcTemplate;
    private final TenantSchemaFlywayMigrationService tenantSchemaFlywayMigrationService;
    private static final Pattern SCHEMA_PATTERN = Pattern.compile("^[a-zA-Z0-9_]+$");
    
   

    

    private void validateSchemaNameOrThrow(String schemaName) {
        if (!StringUtils.hasText(schemaName)) {
            throw new ApiException("INVALID_SCHEMA", "SchemaName inválido", 400);
        }

        String trimmed = schemaName.trim();

        if (Schemas.CONTROL_PLANE.equalsIgnoreCase(trimmed)) {
            throw new ApiException("INVALID_SCHEMA",
                    "SchemaName '" + Schemas.CONTROL_PLANE + "' não é permitido",
                    400);
        }


        if (!SCHEMA_PATTERN.matcher(trimmed).matches()) {
            throw new ApiException(
                    "INVALID_SCHEMA",
                    "SchemaName inválido: use apenas letras, números e _ (underscore)",
                    400
            );
        }
    }

    

    public boolean schemaExists(String schemaName) {
        if (!StringUtils.hasText(schemaName)) return false;

        String normalized = schemaName.trim();

        if (Schemas.CONTROL_PLANE.equalsIgnoreCase(normalized)) return false;

        String sql = "SELECT EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = ?)";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, normalized);
        return Boolean.TRUE.equals(exists);
    }

   

    public boolean tableExists(String schemaName, String tableName) {
        if (!StringUtils.hasText(schemaName) || !StringUtils.hasText(tableName)) return false;

        String sql =
                "SELECT EXISTS(" +
                "  SELECT 1 FROM information_schema.tables " +
                "  WHERE table_schema = ? AND table_name = ?" +
                ")";
        Boolean exists = jdbcTemplate.queryForObject(sql, Boolean.class, schemaName, tableName);
        return Boolean.TRUE.equals(exists);
    }

    public void ensureSchemaExistsAndMigrate(String schemaName) {
        validateSchemaNameOrThrow(schemaName);

        String normalized = schemaName.trim().toLowerCase();


        if (!schemaExists(normalized)) {
            log.info("📦 Criando schemaName {}", normalized);
            jdbcTemplate.execute("CREATE SCHEMA IF NOT EXISTS \"" + normalized + "\"");
        }

        log.info("🧬 Rodando migrations do tenant: {}", normalized);
        tenantSchemaFlywayMigrationService.migrateTenantSchema(normalized);
    }

    /**
     * Deve ser chamado com TenantContext já bindado no schema do tenant
     */
  
}
============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/tenant/TenantUnitOfWork.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.executor.TxExecutor;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class TenantUnitOfWork {

    private final TenantExecutor tenantExecutor;
    private final TxExecutor txExecutor;

    public <T> T tx(String schemaName, Supplier<T> fn) {
        return tenantExecutor.run(schemaName, () -> txExecutor.tenantTx(fn));
    }
    public void tx(String schemaName, Runnable fn) {
        tenantExecutor.run(schemaName, () -> txExecutor.tenantTx(fn));
    }

    public <T> T readOnly(String schemaName, Supplier<T> fn) {
        return tenantExecutor.run(schemaName, () -> txExecutor.tenantReadOnlyTx(fn));
    }

    public <T> T requiresNew(String schemaName, Supplier<T> fn) {
        return tenantExecutor.run(schemaName, () -> txExecutor.tenantRequiresNew(fn));
    }

    public <T> T requiresNewReadOnly(String schemaName, Supplier<T> fn) {
        return tenantExecutor.run(schemaName, () -> txExecutor.tenantRequiresNewReadOnly(fn));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/infrastructure/tenant/TenantUserProvisioningFacade.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.TxExecutor;
import brito.com.multitenancy001.shared.security.TenantRoleName;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import brito.com.multitenancy001.tenant.security.TenantRole;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantUserProvisioningFacade {

    private static final String REQUIRED_TABLE = "tenant_users";
    private static final String OWNER_NAME_FALLBACK = "Owner";

    private final TenantExecutor tenantExecutor;
    private final TxExecutor txExecutor;

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;

    private final AppClock appClock;

    public List<UserSummaryData> listUserSummaries(String schemaName, Long accountId, boolean onlyOperational) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantReadOnlyTx(() -> {

                    var users = onlyOperational
                            ? tenantUserRepository.findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId)
                            : tenantUserRepository.findByAccountId(accountId);

                    return users.stream()
                            .map(u -> new UserSummaryData(
                                    u.getId(),
                                    u.getAccountId(),
                                    u.getName(),
                                    u.getEmail(),
                                    u.getRole() == null ? null : TenantRoleName.valueOf(u.getRole().name()),
                                    u.isSuspendedByAccount(),
                                    u.isSuspendedByAdmin(),
                                    u.isDeleted()
                            ))
                            .toList();
                })
        );
    }

    /**
     * Cria o usuário dono (TENANT_OWNER) no schema do Tenant.
     *
     * Retorna um snapshot (UserSummaryData) para evitar vazamento do domínio Tenant
     * para o contexto ControlPlane.
     *
     * Login é por EMAIL 
     */
    public UserSummaryData createTenantOwner(
            String schemaName,
            Long accountId,
            String ownerDisplayName,
            String email,
            String rawPassword
    ) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantTx(() -> {

                    if (accountId == null) {
                        throw new ApiException("ACCOUNT_REQUIRED", "AccountId obrigatório", 400);
                    }
                    if (!StringUtils.hasText(email)) {
                        throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
                    }
                    if (!StringUtils.hasText(rawPassword)) {
                        throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);
                    }

                    String emailNorm = email.trim().toLowerCase();

                    boolean emailExists = tenantUserRepository.existsByEmailAndAccountId(emailNorm, accountId);
                    if (emailExists) {
                        throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já cadastrado nesta conta", 409);
                    }

                    String name = StringUtils.hasText(ownerDisplayName)
                            ? ownerDisplayName.trim()
                            : OWNER_NAME_FALLBACK;

                    TenantUser tenantUser = new TenantUser();
                    tenantUser.setAccountId(accountId);
                    tenantUser.setName(name);
                    tenantUser.setEmail(emailNorm);
                    tenantUser.setPassword(passwordEncoder.encode(rawPassword));
                    tenantUser.setRole(TenantRole.TENANT_OWNER);
                    tenantUser.setSuspendedByAccount(false);
                    tenantUser.setSuspendedByAdmin(false);
                    tenantUser.setTimezone("America/Sao_Paulo");
                    tenantUser.setLocale("pt_BR");

                    TenantUser saved = tenantUserRepository.save(tenantUser);

                    return new UserSummaryData(
                            saved.getId(),
                            saved.getAccountId(),
                            saved.getName(),
                            saved.getEmail(),
                            saved.getRole() == null ? null : TenantRoleName.valueOf(saved.getRole().name()),
                            saved.isSuspendedByAccount(),
                            saved.isSuspendedByAdmin(),
                            saved.isDeleted()
                    );
                })
        );
    }

    public int suspendAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName,
                REQUIRED_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.suspendAllByAccount(accountId)),
                0
        );
    }

    public int unsuspendAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName,
                REQUIRED_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.unsuspendAllByAccount(accountId)),
                0
        );
    }

    /**
     * Soft delete em massa de usuários no schema tenant.
     * Usado pelo ControlPlane ao excluir/cancelar conta.
     */
    public int softDeleteAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName,
                REQUIRED_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.softDeleteAllByAccount(accountId, appClock.now())),
                0
        );
    }

    /**
     * Restore em massa de usuários no schema tenant.
     * Usado pelo ControlPlane ao restaurar conta.
     */
    public int restoreAllUsersByAccount(String schemaName, Long accountId) {
        return tenantExecutor.runIfReady(
                schemaName,
                REQUIRED_TABLE,
                () -> txExecutor.tenantRequiresNew(() -> tenantUserRepository.restoreAllByAccount(accountId)),
                0
        );
    }

    /**
     * Suspende/reativa um usuário por ADMIN (ação administrativa do ControlPlane).
     * identidade é EMAIL, mas aqui o alvo é por userId.
     */
    public void setSuspendedByAdmin(String schemaName, Long accountId, Long userId, boolean suspended) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        tenantExecutor.run(schemaName, () ->
                txExecutor.tenantTx(() -> {
                    int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
                    if (updated == 0) {
                        throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado ou removido", 404);
                    }
                    return null;
                })
        );
    }

    public void setPasswordResetToken(String schemaName, Long accountId, Long userId, String token, LocalDateTime expiresAt) {
        tenantExecutor.runIfReady(schemaName, REQUIRED_TABLE, () ->
                txExecutor.tenantTx(() -> {
                    TenantUser user = tenantUserRepository.findEnabledByIdAndAccountId(userId, accountId)
                            .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

                    user.setPasswordResetToken(token);
                    user.setPasswordResetExpires(expiresAt);
                    tenantUserRepository.save(user);
                    return null;
                })
        );
    }

    public TenantUser findByPasswordResetToken(String schemaName, Long accountId, String token) {
        tenantExecutor.assertReadyOrThrow(schemaName, REQUIRED_TABLE);

        return tenantExecutor.run(schemaName, () ->
                txExecutor.tenantReadOnlyTx(() ->
                        tenantUserRepository.findByPasswordResetTokenAndAccountId(token, accountId)
                                .orElseThrow(() -> new ApiException("TOKEN_INVALID", "Token inválido", 400))
                )
        );
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/account/UserLimitPolicy.java
============================================================
package brito.com.multitenancy001.shared.account;

public enum UserLimitPolicy {
    SEATS_IN_USE,        // deleted=false
    SEATS_ENABLED,
    ACTIVE_USERS_ONLY    // deleted=false AND suspendedByAccount=false AND suspendedByAdmin=false
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/api/dto/auth/JwtResponse.java
============================================================
package brito.com.multitenancy001.shared.api.dto.auth;

public record JwtResponse(
        String accessToken,
        String refreshToken,

        /**
         * HTTP Authorization scheme (ex: "Bearer").
         * NÃO confundir com o "authDomain" do JWT (TENANT/CONTROLPLANE/etc).
         */
        String tokenType,

        Long userId,

        /**
         * ✅ Identidade canônica de login (única).
         */
        String email,

        /**
         * ✅ Role "name" (ex: CONTROLPLANE_OWNER, TENANT_ADMIN)
         */
        String role,

        Long accountId,

        /**
         * ✅ Para tenant: schema do tenant. Para controlplane: Schemas.CONTROL_PLANE.
         */
        String tenantSchema
) {
    public JwtResponse {
        if (tokenType == null || tokenType.isBlank()) tokenType = "Bearer";
    }

    /** ✅ Construtor curto (sem tokenType). */
    public JwtResponse(
            String accessToken,
            String refreshToken,
            Long userId,
            String email,
            String role,
            Long accountId,
            String tenantSchema
    ) {
        this(accessToken, refreshToken, "Bearer", userId, email, role, accountId, tenantSchema);
    }

    public static JwtResponse forEmailLogin(
            String accessToken,
            String refreshToken,
            Long userId,
            String email,
            String role,
            Long accountId,
            String tenantSchema
    ) {
        return new JwtResponse(accessToken, refreshToken, "Bearer", userId, email, role, accountId, tenantSchema);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/api/dto/billing/AdminPaymentRequest.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record AdminPaymentRequest(
        @NotNull Long accountId,

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotNull PaymentMethod paymentMethod,
        @NotNull PaymentGateway paymentGateway,

        String description
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentRequest.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record PaymentRequest(
        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotNull PaymentMethod paymentMethod,
        @NotNull PaymentGateway paymentGateway,

        String description
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentResponse.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.LocalDateTime;

public record PaymentResponse(
        Long id,
        Long accountId,
        BigDecimal amount,
        LocalDateTime paymentDate,
        LocalDateTime validUntil,
        PaymentStatus status,
        String transactionId,
        PaymentMethod paymentMethod,
        PaymentGateway paymentGateway,
        String description,
        LocalDateTime createdAt,
        LocalDateTime updatedAt
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/api/error/ApiEnumErrorResponse.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;

import java.time.LocalDateTime;
import java.util.List;

@Builder
public record ApiEnumErrorResponse(
        LocalDateTime timestamp,
        String error,
        String message,

        // opcional: erros de enum/constraint
        String field,
        String invalidValue,
        List<String> allowedValues,

        // ✅ qualquer payload extra (ex.: lista de tenants para seleção)
        Object details
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/api/error/ApiErrorResponse.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;

import java.time.LocalDateTime;
import java.util.List;

@Builder
public record ApiErrorResponse(
        LocalDateTime timestamp,
        String error,
        String message,
        List<String> details
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/api/error/ApiException.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import lombok.Getter;

import java.util.List;

@Getter
public class ApiException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    private final String error;
    private final int status;

    // ✅ extras padronizados (opcionais)
    private final String field;
    private final String invalidValue;
    private final List<String> allowedValues;
    private final Object details;

    public ApiException(String error, String message, int status) {
        this(error, message, status, null, null, null, null);
    }

    public ApiException(String error, String message, int status, Object details) {
        this(error, message, status, null, null, null, details);
    }

    public ApiException(
            String error,
            String message,
            int status,
            String field,
            String invalidValue,
            List<String> allowedValues,
            Object details
    ) {
        super(message);
        this.error = error;
        this.status = status;
        this.field = field;
        this.invalidValue = invalidValue;
        this.allowedValues = allowedValues;
        this.details = details;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/api/error/GlobalExceptionHandler.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import brito.com.multitenancy001.shared.domain.DomainException;
import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RestControllerAdvice
@RequiredArgsConstructor
@Slf4j
public class GlobalExceptionHandler {

    private final AppClock appClock;

    private LocalDateTime now() {
        return appClock.now();
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleNotReadable(HttpMessageNotReadableException ex) {

        Throwable cause = ex.getCause();

        if (cause instanceof InvalidFormatException ife) {
            Class<?> targetType = ife.getTargetType();

            if (targetType != null && targetType.isEnum()) {
                String fieldName = ife.getPath().isEmpty() ? "status" : ife.getPath().get(0).getFieldName();
                String invalidValue = ife.getValue() != null ? ife.getValue().toString() : "null";

                List<String> allowedValues = Arrays.stream(targetType.getEnumConstants())
                        .map(Object::toString)
                        .toList();

                return ResponseEntity.badRequest().body(
                        ApiEnumErrorResponse.builder()
                                .timestamp(now())
                                .error("INVALID_ENUM")
                                .message("Valor inválido para o campo " + fieldName)
                                .field(fieldName)
                                .invalidValue(invalidValue)
                                .allowedValues(allowedValues)
                                .build()
                );
            }
        }

        return ResponseEntity.badRequest().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INVALID_REQUEST_BODY")
                        .message("Corpo da requisição inválido")
                        .build()
        );
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {

        String errorMessage = ex.getMostSpecificCause() != null ? ex.getMostSpecificCause().getMessage() : ex.getMessage();
        if (!StringUtils.hasText(errorMessage)) errorMessage = "";

        log.debug("DataIntegrityViolationException: {}", errorMessage);

        if (errorMessage.contains("tax_id_number")) {
            String cnpj = extractValue(errorMessage, "tax_id_number");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_NUMBER")
                            .message("Já existe uma conta com o Number: " + cnpj)
                            .field("taxIdNumber")
                            .invalidValue(cnpj)
                            .build()
            );
        }

        if (errorMessage.contains("LoginEmail")) {
            String email = extractValue(errorMessage, "LoginEmail");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_EMAIL")
                            .message("Já existe uma conta com o email " + email)
                            .field("loginEmail")
                            .invalidValue(email)
                            .build()
            );
        }

        if (errorMessage.contains("slug")) {
            String slug = extractValue(errorMessage, "slug");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_SLUG")
                            .message("Já existe uma conta com o slug " + slug)
                            .field("slug")
                            .invalidValue(slug)
                            .build()
            );
        }

        if (errorMessage.contains("schema_name")) {
            String schema = extractValue(errorMessage, "schema_name");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(now())
                            .error("DUPLICATE_SCHEMA")
                            .message("Erro interno: schema " + schema + " já existe")
                            .build()
            );
        }

        return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("DUPLICATE_ENTRY")
                        .message("Registro duplicado. Verifique os dados informados.")
                        .build()
        );
    }

    private String extractValue(String message, String fieldName) {
        try {
            Pattern pattern = Pattern.compile("\\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher = pattern.matcher(message);
            if (matcher.find()) return matcher.group(1);

            Pattern pattern2 = Pattern.compile("Key \\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher2 = pattern2.matcher(message);
            if (matcher2.find()) return matcher2.group(1);

        } catch (Exception e) {
            log.debug("Erro ao extrair valor do erro de constraint: {}", e.getMessage());
        }

        return "não identificado";
    }

    @ExceptionHandler(ApiException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleApi(ApiException ex) {
        return ResponseEntity.status(ex.getStatus()).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error(ex.getError())
                        .message(ex.getMessage())
                        .field(ex.getField())
                        .invalidValue(ex.getInvalidValue())
                        .allowedValues(ex.getAllowedValues())
                        .details(ex.getDetails())
                        .build()
        );
    }


    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .toList();

        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(now())
                .error("VALIDATION_ERROR")
                .message("Erro de validação")
                .details(errors)
                .build();

        return ResponseEntity.badRequest().body(errorResponse);
    }

    /**
     * ✅ Login inválido (não vazar se o usuário existe).
     */
    @ExceptionHandler({
            BadCredentialsException.class,
            InternalAuthenticationServiceException.class,
            AuthenticationException.class
    })
    public ResponseEntity<ApiEnumErrorResponse> handleAuthentication(AuthenticationException ex) {

        log.warn("Authentication failed: {}", ex.getMessage());

        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INVALID_USER")
                        .message("usuario ou senha invalidos")
                        .build()
        );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiEnumErrorResponse> handleGeneric(Exception ex) {
        log.error("Unhandled exception: {}", ex.getMessage(), ex);

        return ResponseEntity.internalServerError().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(now())
                        .error("INTERNAL_SERVER_ERROR")
                        .message("Erro interno inesperado. Contate o suporte.")
                        .build()
        );
    }

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ApiErrorResponse> handleDomainException(DomainException ex) {
        ApiErrorResponse body = ApiErrorResponse.builder()
                .timestamp(now())
                .error("DOMAIN_RULE_VIOLATION")
                .message(ex.getMessage())
                .build();

        return ResponseEntity.badRequest().body(body);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/billing/PaymentQueryFacade.java
============================================================
package brito.com.multitenancy001.shared.billing;

import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Facade de leitura de pagamentos (origem: Control Plane / schema público).
 *
 * Objetivo: permitir que o contexto TENANT consulte pagamentos
 * sem depender diretamente de classes do pacote controlplane.*.
 *
 * Implementação padrão: ControlPlanePaymentQueryService.
 */
public interface PaymentQueryFacade {

    List<PaymentResponse> findByStatus(PaymentStatus status);

    BigDecimal getTotalPaidInPeriod(Long accountId, LocalDateTime startDate, LocalDateTime endDate);

    long countCompletedPayments(Long accountId);

    List<PaymentResponse> listByAccount(Long accountId);

    PaymentResponse getByAccount(Long accountId, Long paymentId);

    boolean hasActivePayment(Long accountId);
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/context/TenantContext.java
============================================================
package brito.com.multitenancy001.shared.context;

import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.infrastructure.multitenancy.hibernate.CurrentTenantSchemaResolver;
import brito.com.multitenancy001.shared.db.Schemas;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TenantContext {

    public static final String PUBLIC_SCHEMA = Schemas.CONTROL_PLANE;

    /**
     * ✅ Retorna o tenant REALMENTE bindado (ou null).
     * Não mascara com Schemas.CONTROL_PLANE.
     */
    public static String getOrNull() {
        return CurrentTenantSchemaResolver.resolveBoundTenantOrNull();
    }

    /**
     * ✅ Quando você quer um fallback explícito para public.
     * (Útil pra logs/diagnóstico; no runtime o "public" é representado por null.)
     */
    public static String getOrDefaultPublic() {
        String t = getOrNull();
        return (t != null ? t : PUBLIC_SCHEMA);
    }

    public static boolean isPublic() {
        String t = getOrNull();
        return t == null || PUBLIC_SCHEMA.equalsIgnoreCase(t);
    }

    public static void bind(String tenantId) {
        if (TransactionSynchronizationManager.isActualTransactionActive()) {
            throw new IllegalStateException("🔥 TenantContext.bind chamado DENTRO de transação! tenant=" + tenantId);
        }

        String normalized = (tenantId != null ? tenantId.trim() : null);

        // "public" = null (sem tenant)
        if (!StringUtils.hasText(normalized)) {
            CurrentTenantSchemaResolver.bindTenantToCurrentThread(null);
            log.info("🔄 Tenant bindado para PUBLIC (null) | thread={}", Thread.currentThread().threadId());
            return;
        }

        CurrentTenantSchemaResolver.bindTenantToCurrentThread(normalized);
        log.info("🔄 Tenant bindado | thread={} | tenant={}", Thread.currentThread().threadId(), normalized);
    }

    /**
     * Remove qualquer tenant (equivalente a PUBLIC).
     * Prefira usar publicScope()/scope() com try-with-resources.
     */
    public static void clear() {
        CurrentTenantSchemaResolver.unbindTenantFromCurrentThread();
        log.info("🧹 Tenant desbindado | thread={}", Thread.currentThread().threadId());
    }

    // ✅ escopo seguro (restaura o tenant anterior ao sair)
    public static Scope scope(String tenantId) {
        String previous = getOrNull();
        bind(tenantId);
        return new Scope(previous);
    }

    // ✅ escopo PUBLIC explícito (restaura o tenant anterior ao sair)
    public static Scope publicScope() {
        String previous = getOrNull();
        bind(null); // explícito: public = sem tenant
        return new Scope(previous);
    }

    public static final class Scope implements AutoCloseable {
        private final String previous;
        private boolean closed = false;

        private Scope(String previous) {
            this.previous = previous;
        }

        @Override
        public void close() {
            if (!closed) {
                // restaura exatamente o que estava antes (tenant ou public)
                TenantContext.bind(previous);
                closed = true;
            }
        }
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/contracts/AccountRef.java
============================================================
package brito.com.multitenancy001.shared.contracts;

public record AccountRef(
        Long id,
        String schemaName,
        String timezone,
        String locale
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/contracts/AccountSnapshot.java
============================================================
package brito.com.multitenancy001.shared.contracts;

public record AccountSnapshot(Long id, String schemaName, String slug) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/contracts/UserSummaryData.java
============================================================
package brito.com.multitenancy001.shared.contracts;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Snapshot compartilhado (contrato) para representar um usuário do Tenant
 * sem expor a entidade do Tenant (bounded context).
 */
public record UserSummaryData(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRoleName role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/db/Schemas.java
============================================================
package brito.com.multitenancy001.shared.db;

public final class Schemas {

    /**
     * Schema do Control Plane (tabelas globais).
     * Hoje é Schemas.CONTROL_PLANE (Postgres default).
     */
    public static final String CONTROL_PLANE = "public";

    private Schemas() {}
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/domain/DomainException.java
============================================================
package brito.com.multitenancy001.shared.domain;

public class DomainException extends RuntimeException {
    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public DomainException(String message) {
        super(message);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/domain/audit/AuditActor.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public record AuditActor(Long userId, String email) {
    public static AuditActor system() {
        return new AuditActor(null, "system@local");
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/domain/audit/AuditInfo.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@Embeddable
@NoArgsConstructor
public class AuditInfo {

    /**
     * IMPORTANTE:
     * As migrations do projeto usam VARCHAR(120) para:
     * created_by_email, updated_by_email, deleted_by_email.
     *
     * Então o código precisa respeitar 120 para evitar erro de persistência.
     */
    private static final int AUDIT_EMAIL_MAX_LEN = 120;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @Column(name = "deleted_by")
    private Long deletedBy;

    @Column(name = "created_by_email", length = AUDIT_EMAIL_MAX_LEN)
    private String createdByEmail;

    @Column(name = "updated_by_email", length = AUDIT_EMAIL_MAX_LEN)
    private String updatedByEmail;

    @Column(name = "deleted_by_email", length = AUDIT_EMAIL_MAX_LEN)
    private String deletedByEmail;

    public void onCreate(AuditActor actor) {
        if (actor == null) return;

        if (this.createdBy == null) this.createdBy = actor.userId();
        if (this.createdByEmail == null) this.createdByEmail = safeEmail(actor.email());

        this.updatedBy = actor.userId();
        this.updatedByEmail = safeEmail(actor.email());
    }

    public void onUpdate(AuditActor actor) {
        if (actor == null) return;

        this.updatedBy = actor.userId();
        this.updatedByEmail = safeEmail(actor.email());
    }

    public void onDelete(AuditActor actor) {
        if (actor == null) return;

        this.deletedBy = actor.userId();
        this.deletedByEmail = safeEmail(actor.email());
    }

    private static String safeEmail(String email) {
        if (email == null) return null;

        String v = email.trim().toLowerCase();
        if (v.isBlank()) return null;

        if (v.length() <= AUDIT_EMAIL_MAX_LEN) return v;
        return v.substring(0, AUDIT_EMAIL_MAX_LEN);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/domain/audit/Auditable.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public interface Auditable {
    AuditInfo getAudit();
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/domain/audit/SoftDeletable.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public interface SoftDeletable {
    boolean isDeleted();
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/domain/billing/PaymentGateway.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentGateway {
    MERCADOPAGO, STRIPE, PAGSEGURO, MANUAL
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/domain/billing/PaymentMethod.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentMethod {
    PIX, BOLETO, CREDIT_CARD, DEBIT_CARD, TRANSFER, CASH
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/domain/billing/PaymentStatus.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentStatus {
    PENDING("Pendente"),
    COMPLETED("Concluído"),
    FAILED("Falhou"),
    REFUNDED("Reembolsado"),
    CANCELLED("Cancelado"),
    EXPIRED("Expirado");

    private final String description;

    PaymentStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    public boolean isSuccessful() {
        return this == COMPLETED;
    }

    public boolean isFinal() {
        return this != PENDING;
    }

    public static PaymentStatus fromString(String status) {
        if (status == null) return PENDING;
        try {
            return PaymentStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            return PENDING;
        }
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/executor/PublicExecutor.java
============================================================
package brito.com.multitenancy001.shared.executor;

import java.util.function.Supplier;
import org.springframework.stereotype.Component;
import brito.com.multitenancy001.shared.context.TenantContext;

@Component
public class PublicExecutor {

    public <T> T run(Supplier<T> supplier) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            return supplier.get();
        }
    }

    public void run(Runnable runnable) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            runnable.run();
        }
    }

    // aliases semânticos (opcional, mas ajuda muito leitura)
    public <T> T inPublic(Supplier<T> supplier) { return run(supplier); }
    public void inPublic(Runnable runnable) { run(runnable); }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/executor/PublicUnitOfWork.java
============================================================
package brito.com.multitenancy001.shared.executor;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class PublicUnitOfWork {

    private final PublicExecutor publicExecutor;
    private final TxExecutor txExecutor;

    // REQUIRED
    public <T> T tx(Supplier<T> fn) {
        return publicExecutor.run(() -> txExecutor.publicTx(fn));
    }

    public void tx(Runnable fn) {
        publicExecutor.run(() -> txExecutor.publicTx(fn));
    }

    // REQUIRES_NEW
    public <T> T requiresNew(Supplier<T> fn) {
        return publicExecutor.run(() -> txExecutor.publicRequiresNew(fn));
    }

    public void requiresNew(Runnable fn) {
        publicExecutor.run(() -> txExecutor.publicRequiresNew(fn));
    }

    // READ ONLY
    public <T> T readOnly(Supplier<T> fn) {
        return publicExecutor.run(() -> txExecutor.publicReadOnlyTx(fn));
    }

    public void readOnly(Runnable fn) {
        publicExecutor.run(() -> txExecutor.publicReadOnlyTx(fn));
    }

    // REQUIRES_NEW READ ONLY
    public <T> T requiresNewReadOnly(Supplier<T> fn) {
        return publicExecutor.run(() -> txExecutor.publicRequiresNewReadOnly(fn));
    }

    public void requiresNewReadOnly(Runnable fn) {
        publicExecutor.run(() -> txExecutor.publicRequiresNewReadOnly(fn));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/executor/TxExecutor.java
============================================================
package brito.com.multitenancy001.shared.executor;

import java.util.function.Supplier;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

@Component
public class TxExecutor {

    private final TransactionTemplate transactionTemplatePublicTx;
    private final TransactionTemplate transactionTemplatePublicRequiresNew;

    private final TransactionTemplate transactionTemplatePublicReadOnlyTx;
    private final TransactionTemplate transactionTemplatePublicRequiresNewReadOnly;

    private final TransactionTemplate transactionTemplateTenantTx;
    private final TransactionTemplate transactionTemplateTenantRequiresNew;

    private final TransactionTemplate transactionTemplateTenantReadOnlyTx;
    private final TransactionTemplate transactionTemplateTenantRequiresNewReadOnly;

    public TxExecutor(
            @Qualifier("publicTransactionManager") PlatformTransactionManager publicTm,
            @Qualifier("tenantTransactionManager") PlatformTransactionManager tenantTm
    ) {
        // PUBLIC - REQUIRED
        this.transactionTemplatePublicTx = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // PUBLIC - REQUIRES_NEW
        this.transactionTemplatePublicRequiresNew = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // PUBLIC - REQUIRED READONLY
        this.transactionTemplatePublicReadOnlyTx = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.transactionTemplatePublicReadOnlyTx.setReadOnly(true);

        // PUBLIC - REQUIRES_NEW READONLY
        this.transactionTemplatePublicRequiresNewReadOnly = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.transactionTemplatePublicRequiresNewReadOnly.setReadOnly(true);

        // TENANT - REQUIRED
        this.transactionTemplateTenantTx = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // TENANT - REQUIRES_NEW
        this.transactionTemplateTenantRequiresNew = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // TENANT - REQUIRED READONLY
        this.transactionTemplateTenantReadOnlyTx = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.transactionTemplateTenantReadOnlyTx.setReadOnly(true);

        // TENANT - REQUIRES_NEW READONLY
        this.transactionTemplateTenantRequiresNewReadOnly = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.transactionTemplateTenantRequiresNewReadOnly.setReadOnly(true);
    }

    // ---------- PUBLIC ----------
    public <T> T publicTx(Supplier<T> fn) {
        return transactionTemplatePublicTx.execute(status -> fn.get());
    }
    public void publicTx(Runnable fn) {
        transactionTemplatePublicTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNew(Supplier<T> fn) {
        return transactionTemplatePublicRequiresNew.execute(status -> fn.get());
    }
    public void publicRequiresNew(Runnable fn) {
        transactionTemplatePublicRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicReadOnlyTx(Supplier<T> fn) {
        return transactionTemplatePublicReadOnlyTx.execute(status -> fn.get());
    }
    public void publicReadOnlyTx(Runnable fn) {
        transactionTemplatePublicReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T publicRequiresNewReadOnly(Supplier<T> fn) {
        return transactionTemplatePublicRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void publicRequiresNewReadOnly(Runnable fn) {
        transactionTemplatePublicRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }

    // ---------- TENANT ----------
    public <T> T tenantTx(Supplier<T> fn) {
        return transactionTemplateTenantTx.execute(status -> fn.get());
    }
    public void tenantTx(Runnable fn) {
        transactionTemplateTenantTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNew(Supplier<T> fn) {
        return transactionTemplateTenantRequiresNew.execute(status -> fn.get());
    }
    public void tenantRequiresNew(Runnable fn) {
        transactionTemplateTenantRequiresNew.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantReadOnlyTx(Supplier<T> fn) {
        return transactionTemplateTenantReadOnlyTx.execute(status -> fn.get());
    }
    public void tenantReadOnlyTx(Runnable fn) {
        transactionTemplateTenantReadOnlyTx.executeWithoutResult(status -> fn.run());
    }

    public <T> T tenantRequiresNewReadOnly(Supplier<T> fn) {
        return transactionTemplateTenantRequiresNewReadOnly.execute(status -> fn.get());
    }
    public void tenantRequiresNewReadOnly(Runnable fn) {
        transactionTemplateTenantRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/persistence/audit/AuditActorProvider.java
============================================================
package brito.com.multitenancy001.shared.persistence.audit;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;
import brito.com.multitenancy001.shared.security.AuthenticatedPrincipal;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

@Component
public class AuditActorProvider {

    @PostConstruct
    void register() {
        AuditActorProviders.setProvider(this);
    }

    @PreDestroy
    void unregister() {
        AuditActorProviders.clear();
    }

    public AuditActor current() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        if (auth == null || !(auth.getPrincipal() instanceof AuthenticatedPrincipal p)) {
            return AuditActor.system();
        }

        return new AuditActor(p.getUserId(), p.getEmail());
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/persistence/audit/AuditActorProviders.java
============================================================
package brito.com.multitenancy001.shared.persistence.audit;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;

/**
 * Holder estático para permitir que EntityListeners (instanciados pelo JPA)
 * acessem o AuditActorProvider (bean Spring) sem injeção direta.
 *
 * Motivo:
 * - EntityListeners NÃO são gerenciados pelo Spring por padrão.
 * - Injeção @Autowired em listener costuma falhar silenciosamente.
 */
public final class AuditActorProviders {

    private static volatile AuditActorProvider provider;

    private AuditActorProviders() {}

    static void setProvider(AuditActorProvider provider) {
        AuditActorProviders.provider = provider;
    }

    static void clear() {
        AuditActorProviders.provider = null;
    }

    public static AuditActor currentOrSystem() {
        AuditActorProvider p = provider;
        if (p == null) return AuditActor.system();
        return p.current();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/persistence/audit/AuditEntityListener.java
============================================================
package brito.com.multitenancy001.shared.persistence.audit;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;

/**
 * Listener de auditoria (JPA/Hibernate).
 *
 * Importante:
 * - Este listener é instanciado pelo JPA, NÃO pelo Spring.
 * - Por isso, NÃO use @Component/@Autowired aqui.
 * - A ponte com Spring é feita via AuditActorProviders (holder estático).
 */
public class AuditEntityListener {

    @PrePersist
    public void prePersist(Object entity) {
        if (!(entity instanceof Auditable auditable)) return;

        AuditActor actor = AuditActorProviders.currentOrSystem();
        auditable.getAudit().onCreate(actor);

        if (entity instanceof SoftDeletable softDeletable
                && softDeletable.isDeleted()
                && auditable.getAudit().getDeletedBy() == null) {
            auditable.getAudit().onDelete(actor);
        }
    }

    @PreUpdate
    public void preUpdate(Object entity) {
        if (!(entity instanceof Auditable auditable)) return;

        AuditActor actor = AuditActorProviders.currentOrSystem();
        auditable.getAudit().onUpdate(actor);

        if (entity instanceof SoftDeletable softDeletable
                && softDeletable.isDeleted()
                && auditable.getAudit().getDeletedBy() == null) {
            auditable.getAudit().onDelete(actor);
        }
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/persistence/audit/AuditWiringVerifier.java
============================================================
package brito.com.multitenancy001.shared.persistence.audit;

import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Component;

/**
 * Verifica no startup se o AuditActorProvider foi corretamente
 * registrado no AuditActorProviders (holder estático).
 *
 * Evita cenário silencioso onde:
 * - EntityListener funciona
 * - Mas sempre retorna AuditActor.system()
 * - Porque o provider Spring não foi injetado no holder.
 */
@Component
public class AuditWiringVerifier {

    @PostConstruct
    public void verifyAuditWiring() {
        try {
            AuditActorProviders.currentOrSystem();
        } catch (Exception e) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditActorProvider não está registrado no AuditActorProviders. " +
                "A auditoria irá registrar tudo como SYSTEM. Verifique o bean AuditActorProvider e o método @PostConstruct.",
                e
            );
        }
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/security/AuthenticatedPrincipal.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Contrato mínimo para Principal autenticado.
 *
 * Evita acoplamento do shared/persistence com classes de infraestrutura.
 */
public interface AuthenticatedPrincipal {
    Long getUserId();
    String getEmail();
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/security/PermissionAuthority.java
============================================================
package brito.com.multitenancy001.shared.security;

public interface PermissionAuthority {
    String asAuthority(); // ex: "CP_USER_READ" ou "TEN_USER_READ"
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/security/PermissionCode.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Contrato "shared" para permissões.
 *
 * - O shared pode depender deste contrato.
 * - ControlPlane e Tenant podem implementar este contrato nos seus enums.
 * - O shared NÃO deve importar classes/enums dos bounded contexts.
 *
 * Observação:
 * - Mantemos compatibilidade com o seu modelo atual (PermissionAuthority),
 *   já que o resto do projeto usa "asAuthority()" para gerar GrantedAuthority/JWT claims.
 */
public interface PermissionCode extends PermissionAuthority {
    // marker + compatibilidade (herda asAuthority())
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/security/PermissionScopeValidator.java
============================================================
package brito.com.multitenancy001.shared.security;

import brito.com.multitenancy001.shared.domain.DomainException;

import java.util.Collection;
import java.util.LinkedHashSet;

public final class PermissionScopeValidator {

    private PermissionScopeValidator() {}

    // =========================================================
    // STRICT (recomendado): exige prefixo correto SEMPRE
    // =========================================================

    public static LinkedHashSet<String> normalizeTenantStrict(Collection<String> perms) {
        LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("CP_")) {
                throw new DomainException("Permission de Control Plane não é permitida no Tenant: " + x);
            }
            if (!x.startsWith("TEN_")) {
                throw new DomainException("Permission inválida (esperado prefixo TEN_): " + x);
            }
            out.add(x);
        }
        return out;
    }

    public static LinkedHashSet<String> normalizeControlPlaneStrict(Collection<String> perms) {
        LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("TEN_")) {
                throw new DomainException("Permission de Tenant não é permitida no Control Plane: " + x);
            }
            if (!x.startsWith("CP_")) {
                throw new DomainException("Permission inválida (esperado prefixo CP_): " + x);
            }
            out.add(x);
        }
        return out;
    }

    // =========================================================
    // LENIENT (legado): auto-prefixa se faltar prefixo
    // =========================================================

    public static LinkedHashSet<String> normalizeTenantLenient(Collection<String> perms) {
        LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("CP_")) {
                throw new DomainException("Permission de Control Plane não é permitida no Tenant: " + x);
            }

            if (!x.startsWith("TEN_")) x = "TEN_" + x;
            out.add(x);
        }
        return out;
    }

    public static LinkedHashSet<String> normalizeControlPlaneLenient(Collection<String> perms) {
        LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("TEN_")) {
                throw new DomainException("Permission de Tenant não é permitida no Control Plane: " + x);
            }

            if (!x.startsWith("CP_")) x = "CP_" + x;
            out.add(x);
        }
        return out;
    }

    // =========================================================
    // TIPADO (genérico) - NÃO depende de enums concretos
    // =========================================================

    /**
     * Normaliza/valida permissões do Tenant em formato tipado (enum).
     *
     * Regra:
     * - não aceita CP_*
     * - exige prefixo TEN_*
     *
     * Importante:
     * - T é inferido pelo compilador (ex.: TenantPermission).
     * - O shared não precisa conhecer o enum concreto.
     */
    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> normalizeTenantPermissions(Collection<T> perms) {
        LinkedHashSet<T> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (T p : perms) {
            if (p == null) continue;

            String code = p.asAuthority(); // tipado + compat com sua infra de authorities
            if (code == null) continue;

            String x = code.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("CP_")) {
                throw new DomainException("Permission de Control Plane não é permitida no Tenant: " + x);
            }
            if (!x.startsWith("TEN_")) {
                throw new DomainException("Permission inválida (esperado prefixo TEN_): " + x);
            }

            out.add(p);
        }

        return out;
    }

    /**
     * Normaliza/valida permissões do ControlPlane em formato tipado (enum).
     *
     * Regra:
     * - não aceita TEN_*
     * - exige prefixo CP_*
     */
    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> normalizeControlPlanePermissions(Collection<T> perms) {
        LinkedHashSet<T> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (T p : perms) {
            if (p == null) continue;

            String code = p.asAuthority();
            if (code == null) continue;

            String x = code.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("TEN_")) {
                throw new DomainException("Permission de Tenant não é permitida no Control Plane: " + x);
            }
            if (!x.startsWith("CP_")) {
                throw new DomainException("Permission inválida (esperado prefixo CP_): " + x);
            }

            out.add(p);
        }

        return out;
    }

    // =========================================================
    // Aliases SEMÂNTICOS (para ficar claro no service layer)
    // =========================================================

    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> validateTenantPermissionsStrict(Collection<T> perms) {
        return normalizeTenantPermissions(perms);
    }

    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> validateControlPlanePermissionsStrict(Collection<T> perms) {
        return normalizeControlPlanePermissions(perms);
    }

    // =========================================================
    // Guards (assert) - úteis para service layer
    // =========================================================

    public static void assertNoTenantPermissionLeak(Collection<String> perms) {
        if (perms == null) return;

        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("TEN_")) {
                throw new DomainException("Permission de Tenant não é permitida no Control Plane: " + x);
            }
        }
    }

    public static void assertNoControlPlanePermissionLeak(Collection<String> perms) {
        if (perms == null) return;

        for (String p : perms) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("CP_")) {
                throw new DomainException("Permission de Control Plane não é permitida no Tenant: " + x);
            }
        }
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/security/RoleAuthority.java
============================================================
package brito.com.multitenancy001.shared.security;

import java.io.Serializable;

public interface RoleAuthority extends Serializable {
    String asAuthority();
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/security/TenantRoleName.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Role do contexto Tenant exposta como "contrato" compartilhado.
 *
 * Motivo: permitir tipagem no ControlPlane (DTOs, contratos, integrações)
 * sem depender de tenant.security.TenantRole (bounded context Tenant).
 *
 * Regra: este enum não deve conter comportamento de segurança, apenas nomes.
 */
public enum TenantRoleName {

	TENANT_OWNER,
    TENANT_ADMIN,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    public static TenantRoleName fromString(String value) {
        if (value == null || value.isBlank()) return null;
        return TenantRoleName.valueOf(value.trim().toUpperCase());
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/time/AppClock.java
============================================================
package brito.com.multitenancy001.shared.time;

import java.time.Clock;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;

public interface AppClock {

    Clock clock();

    default Instant instant() {
        return Instant.now(clock());
    }

    default LocalDateTime now() {
        return LocalDateTime.now(clock());
    }

    default ZoneId zone() {
        return clock().getZone();
    }

    default long epochMillis() {
        return instant().toEpochMilli();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/time/SystemAppClock.java
============================================================
package brito.com.multitenancy001.shared.time;

import java.time.Clock;
import org.springframework.stereotype.Component;

@Component
public class SystemAppClock implements AppClock {

    private final Clock clock;

    public SystemAppClock(Clock clock) {
        this.clock = clock;
    }

    @Override
    public Clock clock() {
        return clock;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/shared/validation/ValidationPatterns.java
============================================================
package brito.com.multitenancy001.shared.validation;

/**
 * Padrões de validação reutilizáveis em todo o sistema
 */
public final class ValidationPatterns {

    // ⚠️ APENAS PARA TESTE/DEV - NUNCA EM PRODUÇÃO!
    // Password: mínimo 3 caracteres, letras/números
    public static final String PASSWORD_PATTERN = "^[a-zA-Z0-9]{3,}$";

    // Email
    public static final String EMAIL_PATTERN = "^[A-Za-z0-9+_.-]+@(.+)$";

    // Nome
    public static final String NAME_PATTERN = "^[a-zA-ZÀ-ÿ\\s'-]{2,100}$";

    // Telefone
    public static final String PHONE_PATTERN = "^(\\(?\\d{2}\\)?)?\\s?\\d{4,5}-?\\d{4}$";

    public static final String CNPJ_PATTERN = "^\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}$";
    public static final String CPF_PATTERN  = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$";
    public static final String CEP_PATTERN  = "^\\d{5}-\\d{3}$";

    public static final String URL_PATTERN = "^(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?$";

    public static final String TIMEZONE_PATTERN = "^[A-Za-z_]+/[A-Za-z_]+$";
    public static final String LOCALE_PATTERN   = "^[a-z]{2}_[A-Z]{2}$";
    public static final String CURRENCY_PATTERN = "^[A-Z]{3}$";
    public static final String COLOR_PATTERN    = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
    public static final String IP_PATTERN       = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
    public static final String UUID_PATTERN     = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";

    public static final String PERMISSION_PATTERN = "^[A-Z_]+$";

    private ValidationPatterns() {
        throw new UnsupportedOperationException("Classe utilitária - não instanciável");
    }

    public static boolean isValid(String value, String pattern) {
        return value != null && value.matches(pattern);
    }

    public static void validatePassword(String password) {
        if (password == null || !password.matches(PASSWORD_PATTERN)) {
            throw new IllegalArgumentException("Senha inválida");
        }
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/auth/TenantAuthController.java
============================================================
package brito.com.multitenancy001.tenant.api.auth;

import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.application.auth.TenantAuthService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantAuthController {

    private final TenantAuthService tenantAuthService;

    // Autentica usuário tenant e retorna JWT (access/refresh) para o contexto do tenant.
    @PostMapping("/login")
    public ResponseEntity<JwtResponse> loginTenant(@Valid @RequestBody TenantLoginRequest tenantLoginRequest) {
        JwtResponse jwtResponse = tenantAuthService.loginTenant(tenantLoginRequest);
        return ResponseEntity.ok(jwtResponse);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/auth/TenantPasswordController.java
============================================================
package brito.com.multitenancy001.tenant.api.auth;

import brito.com.multitenancy001.tenant.api.dto.auth.ForgotPasswordRequest;
import brito.com.multitenancy001.tenant.api.dto.auth.ResetPasswordRequest;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/password")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantPasswordController {

    private final TenantUserService tenantUserService;

    // Gera token de reset de senha para usuário tenant (por slug + email).
    @PostMapping("/forgot")
    public ResponseEntity<String> forgotPassword(@Valid @RequestBody ForgotPasswordRequest forgotPasswordRequest) {
        tenantUserService.generatePasswordResetToken(forgotPasswordRequest.slug(), forgotPasswordRequest.email());
        return ResponseEntity.ok("Token gerado");
    }

    // Redefine a senha do usuário tenant validando o token de reset.
    @PostMapping("/reset")
    public ResponseEntity<String> resetPassword(@Valid @RequestBody ResetPasswordRequest resetPasswordRequest) {
        tenantUserService.resetPasswordWithToken(resetPasswordRequest.token(), resetPasswordRequest.newPassword());
        return ResponseEntity.ok("Senha redefinida com sucesso");
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/billing/TenantPaymentController.java
============================================================
package brito.com.multitenancy001.tenant.api.billing;


import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.tenant.application.billing.TenantBillingService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/billing/payments")
@RequiredArgsConstructor
public class TenantPaymentController {

    private final TenantBillingService tenantBillingService;

    @GetMapping("/account/{accountId}")
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<List<PaymentResponse>> listPayments(@PathVariable Long accountId) {
        return ResponseEntity.ok(tenantBillingService.listPaymentsForAccount(accountId));
    }

    @GetMapping("/account/{accountId}/{paymentId}")
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<PaymentResponse> getPayment(@PathVariable Long accountId, @PathVariable Long paymentId) {
        return ResponseEntity.ok(tenantBillingService.getPaymentForAccount(accountId, paymentId));
    }

    @GetMapping("/account/{accountId}/has-active")
    @PreAuthorize("hasAuthority('TEN_BILLING_READ')")
    public ResponseEntity<Boolean> hasActive(@PathVariable Long accountId) {
        return ResponseEntity.ok(tenantBillingService.hasActivePayment(accountId));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/categories/TenantCategoryController.java
============================================================
package brito.com.multitenancy001.tenant.api.categories;

import brito.com.multitenancy001.tenant.application.category.TenantCategoryService;
import brito.com.multitenancy001.tenant.domain.category.Category;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/categories")
@RequiredArgsConstructor
public class TenantCategoryController {

    private final TenantCategoryService tenantCategoryService;

    // Lista categorias (não-deletadas) do tenant.
    @GetMapping
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Category>> listAll() {
        return ResponseEntity.ok(tenantCategoryService.findAll());
    }

    // Lista categorias ativas (não-deletadas) do tenant.
    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Category>> listActive() {
        return ResponseEntity.ok(tenantCategoryService.findActive());
    }

    // Busca categoria por id (escopo: tenant).
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<Category> getById(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.findById(id));
    }

    // Pesquisa categorias por nome (escopo: tenant).
    @GetMapping("/search")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Category>> search(@RequestParam("name") String name) {
        return ResponseEntity.ok(tenantCategoryService.searchByName(name));
    }

    // Lista categorias com flags administrativas (incluir deletadas/inativas).
    @GetMapping("/admin")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Category>> listAdmin(
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        return ResponseEntity.ok(tenantCategoryService.findWithFlags(includeDeleted, includeInactive));
    }

    // Cria categoria no tenant.
    @PostMapping
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Category> create(@Valid @RequestBody Category category) {
        Category saved = tenantCategoryService.create(category);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    // Atualiza categoria do tenant (substituição completa).
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Category> update(@PathVariable Long id, @RequestBody Category category) {
        return ResponseEntity.ok(tenantCategoryService.update(id, category));
    }

    // Alterna status ativo/inativo da categoria.
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Category> toggleActive(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.toggleActive(id));
    }

    // Soft-delete de categoria no tenant.
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Void> softDelete(@PathVariable Long id) {
        tenantCategoryService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    // Restaura categoria previamente deletada (soft-delete).
    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Category> restore(@PathVariable Long id) {
        return ResponseEntity.ok(tenantCategoryService.restore(id));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/categories/TenantSubcategoryController.java
============================================================
package brito.com.multitenancy001.tenant.api.categories;

import brito.com.multitenancy001.tenant.application.category.TenantSubcategoryService;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/subcategories")
@RequiredArgsConstructor
public class TenantSubcategoryController {

    private final TenantSubcategoryService tenantSubcategoryService;

    // Lista subcategorias (não-deletadas) do tenant.
    @GetMapping
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listAll() {
        return ResponseEntity.ok(tenantSubcategoryService.findAll());
    }

    // Lista subcategorias ativas (não-deletadas) do tenant.
    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listActive() {
        return ResponseEntity.ok(tenantSubcategoryService.findActive());
    }

    // Busca subcategoria por id (escopo: tenant).
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<Subcategory> getById(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.findById(id));
    }

    // Lista subcategorias por categoria (default: apenas ativas e não-deletadas).
    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listByCategory(@PathVariable Long categoryId) {
        return ResponseEntity.ok(tenantSubcategoryService.findByCategoryId(categoryId));
    }

    // Lista subcategorias por categoria com flags administrativas (incluir deletadas/inativas).
    @GetMapping("/category/{categoryId}/admin")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listByCategoryAdmin(
            @PathVariable Long categoryId,
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        return ResponseEntity.ok(
                tenantSubcategoryService.findByCategoryIdAdmin(categoryId, includeDeleted, includeInactive)
        );
    }

    // Cria subcategoria dentro de uma categoria.
    @PostMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Subcategory> create(
            @PathVariable Long categoryId,
            @Valid @RequestBody Subcategory subcategory
    ) {
        Subcategory saved = tenantSubcategoryService.create(categoryId, subcategory);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    // Atualiza subcategoria do tenant (substituição completa).
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Subcategory> update(@PathVariable Long id, @RequestBody Subcategory subcategory) {
        return ResponseEntity.ok(tenantSubcategoryService.update(id, subcategory));
    }

    // Alterna status ativo/inativo da subcategoria.
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Subcategory> toggleActive(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.toggleActive(id));
    }

    // Soft-delete de subcategoria no tenant.
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Void> softDelete(@PathVariable Long id) {
        tenantSubcategoryService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    // Restaura subcategoria previamente deletada (soft-delete).
    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_WRITE')")
    public ResponseEntity<Subcategory> restore(@PathVariable Long id) {
        return ResponseEntity.ok(tenantSubcategoryService.restore(id));
    }
    
    // Lista subcategorias por categoria (NOT DELETED, inclui inativas).
    @GetMapping("/category/{categoryId}/not-deleted")
    @PreAuthorize("hasAuthority('TEN_CATEGORY_READ')")
    public ResponseEntity<List<Subcategory>> listByCategoryNotDeleted(@PathVariable Long categoryId) {
        return ResponseEntity.ok(tenantSubcategoryService.findByCategoryIdNotDeleted(categoryId));
    }

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/auth/ForgotPasswordRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ForgotPasswordRequest(
        @NotBlank String slug,
        @NotBlank @Email String email
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/auth/ResetPasswordRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record ResetPasswordRequest(
        @NotBlank String token,
        @NotBlank
        @Pattern(
          regexp = ValidationPatterns.PASSWORD_PATTERN,
          message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais"
        )
        String newPassword
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/auth/TenantLoginRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

public record TenantLoginRequest(
        @NotBlank String email,
        @NotBlank String password,
        Long accountId // opcional: só vem quando o front já escolheu o tenant
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/auth/TenantSelectionOption.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.auth;

public record TenantSelectionOption(
        Long accountId,
        String displayName,
        String slug
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/me/TenantMeResponse.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.me;

public record TenantMeResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        String role,
        String phone,
        String avatarUrl,
        String timezone,
        String locale,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/me/TenantMeUpdateRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.me;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record TenantMeUpdateRequest(

        @NotBlank(message = "name é obrigatório")
        @Size(min = 2, max = 100, message = "name deve ter entre 2 e 100 caracteres")
        String name,

        @Size(max = 20, message = "phone deve ter no máximo 20 caracteres")
        String phone,

        @Size(max = 20, message = "locale deve ter no máximo 20 caracteres")
        String locale,

        @Size(max = 60, message = "timezone deve ter no máximo 60 caracteres")
        String timezone
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/me/UpdateMyProfileRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.me;

import jakarta.validation.constraints.Size;

public record UpdateMyProfileRequest(
        @Size(min = 2, max = 100, message = "name deve ter entre 2 e 100 caracteres")
        String name,

        @Size(max = 20, message = "phone deve ter no máximo 20 caracteres")
        String phone,

        @Size(max = 20, message = "locale deve ter no máximo 20 caracteres")
        String locale,

        @Size(max = 60, message = "timezone deve ter no máximo 60 caracteres")
        String timezone
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/products/ProductResponse.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.products;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

public record ProductResponse(
        UUID id,
        @NotBlank String name,
        String description,
        String sku,
        @NotNull @PositiveOrZero BigDecimal price,
        @PositiveOrZero Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        BigDecimal profitMargin,

        Long categoryId,
        String categoryName,
        Long subcategoryId,
        String subcategoryName,

        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,

        UUID supplierId,
        String supplierName,

        LocalDateTime createdAt,
        LocalDateTime updatedAt
) {
    public ProductResponse {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }

  
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/products/ProductUpsertRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.products;

import java.math.BigDecimal;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

// Record para criação/atualização expandido (com Category/Subcategory por ID)
public record ProductUpsertRequest(
     @NotBlank String name,
     String description,
     String sku,
     @NotNull @PositiveOrZero BigDecimal price,
     @PositiveOrZero Integer stockQuantity,
     Integer minStock,
     Integer maxStock,
     BigDecimal costPrice,

     @NotNull Long categoryId,     // ✅ obrigatório
     Long subcategoryId,           // ✅ opcional

     String brand,
     BigDecimal weightKg,
     String dimensions,
     String barcode,
     Boolean active,
     UUID supplierId
) {
    public ProductUpsertRequest {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/products/SupplierProductCountResponse.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.products;

import java.util.UUID;

public record SupplierProductCountResponse(UUID supplierId, long count) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/users/TenantUserCreateRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.users;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.domain.user.TenantUserOrigin;
import brito.com.multitenancy001.tenant.security.TenantRole;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.LinkedHashSet;

/**
 * Request para criação de usuário no Tenant.
 *
 * Login é por EMAIL
 *
 * Observações:
 * - locale/timezone são opcionais (defaults são aplicados no service).
 * - mustChangePassword é opcional (default false).
 * - permissions aqui são strings TEN_* (extras), se você quiser tipar isso com enum,
 *   podemos evoluir depois (mas hoje mantém compatibilidade).
 */
@Builder
public record TenantUserCreateRequest(

        @NotBlank(message = "Nome é obrigatório")
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @NotBlank(message = "Email é obrigatório")
        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email não pode exceder 150 caracteres")
        String email,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
                regexp = ValidationPatterns.PASSWORD_PATTERN,
                message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais"
        )
        String password,

        @NotNull(message = "Role é obrigatória")
        TenantRole role,

        LinkedHashSet<
                @Pattern(
                        regexp = "^TEN_[A-Z0-9_]+$",
                        message = "Permission must follow TEN_* pattern (e.g. TEN_USER_CREATE)"
                )
                String> permissions,

        @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, message = "Telefone inválido")
        @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
        String phone,

        @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
        String avatarUrl,

        @Size(max = 10, message = "Locale não pode exceder 10 caracteres")
        String locale,

        @Size(max = 50, message = "Timezone não pode exceder 50 caracteres")
        String timezone,

        Boolean mustChangePassword,

        TenantUserOrigin origin

) {
    public TenantUserCreateRequest {
        if (name != null) name = name.trim();
        if (email != null) email = email.trim();
        if (phone != null) phone = phone.trim();
        if (avatarUrl != null) avatarUrl = avatarUrl.trim();
        if (locale != null) locale = locale.trim();
        if (timezone != null) timezone = timezone.trim();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/users/TenantUserDetailsResponse.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.users;

public record TenantUserDetailsResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        String role,
        String phone,
        String avatarUrl,
        String timezone,
        String locale,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/users/TenantUserPermissionsUpdateRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.users;

import brito.com.multitenancy001.tenant.security.TenantPermission;
import jakarta.validation.constraints.NotNull;

import java.util.Set;

/**
 * Request para atualizar permissões adicionais de um usuário no Tenant.
 *
 * - Role permanece sendo a base (TenantRolePermissions).
 * - Este request define permissões extras (whitelist) para somar à base.
 *
 * Obs: Permissões são TIPADAS (TenantPermission).
 */
public record TenantUserPermissionsUpdateRequest(
        @NotNull(message = "permissions é obrigatório")
        Set<TenantPermission> permissions
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/users/TenantUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.users;

public record TenantUserSummaryResponse(
        Long id,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/users/TenantUserUpdateRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.users;

import brito.com.multitenancy001.tenant.security.TenantRole;

/**
 * Request para atualização parcial de usuário no Tenant.
 * Tudo é opcional (PATCH semantics).
 *
 * Login é por EMAIL 
 */
public record TenantUserUpdateRequest(
        String name,
        String email,
        TenantRole role,
        Boolean suspendedByAccount,
        Boolean suspendedByAdmin,
        String locale,
        String timezone
) {}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/dto/users/admin/TenantUserAdminSuspendRequest.java
============================================================
package brito.com.multitenancy001.tenant.api.dto.users.admin;

public record TenantUserAdminSuspendRequest(boolean suspended) {}
============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/mapper/ProductApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.domain.product.Product;

@Component
public class ProductApiMapper {

    public ProductResponse toResponse(Product product) {
        return new ProductResponse(
            product.getId(),
            product.getName(),
            product.getDescription(),
            product.getSku(),
            product.getPrice(),
            product.getStockQuantity(),
            product.getMinStock(),
            product.getMaxStock(),
            product.getCostPrice(),
            product.getProfitMargin(),

            product.getCategory() != null ? product.getCategory().getId() : null,
            product.getCategory() != null ? product.getCategory().getName() : null,
            product.getSubcategory() != null ? product.getSubcategory().getId() : null,
            product.getSubcategory() != null ? product.getSubcategory().getName() : null,

            product.getBrand(),
            product.getWeightKg(),
            product.getDimensions(),
            product.getBarcode(),
            product.getActive(),

            product.getSupplier() != null ? product.getSupplier().getId() : null,
            product.getSupplier() != null ? product.getSupplier().getName() : null,

            product.getCreatedAt(),
            product.getUpdatedAt()
        );
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/mapper/TenantUserApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.api.dto.me.TenantMeResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;

@Component
public class TenantUserApiMapper {

    public TenantUserSummaryResponse toSummary(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantUserSummaryResponse(
                tenantUser.getId(),
    
                tenantUser.getEmail(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                enabled
        );
    }

    public TenantUserDetailsResponse toDetails(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantUserDetailsResponse(
                tenantUser.getId(),
                tenantUser.getAccountId(),
                tenantUser.getName(),
  
                tenantUser.getEmail(),
                tenantUser.getRole() != null ? tenantUser.getRole().name() : null,
                tenantUser.getPhone(),
                tenantUser.getAvatarUrl(),
                tenantUser.getTimezone(),
                tenantUser.getLocale(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                tenantUser.isDeleted(),
                enabled
        );
    }
    
    
    public TenantMeResponse toMe(TenantUser tenantUser) {
        // Você já tem isEnabled() no entity, então usa ele
        return new TenantMeResponse(
                tenantUser.getId(),
                tenantUser.getAccountId(),
                tenantUser.getName(),
        
                tenantUser.getEmail(),
                tenantUser.getRole() != null ? tenantUser.getRole().name() : null,
                tenantUser.getPhone(),
                tenantUser.getAvatarUrl(),
                tenantUser.getTimezone(),
                tenantUser.getLocale(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                tenantUser.isDeleted(),
                tenantUser.isEnabled()
        );
    }

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/me/TenantMeController.java
============================================================
package brito.com.multitenancy001.tenant.api.me;

import brito.com.multitenancy001.tenant.api.dto.me.TenantMeResponse;
import brito.com.multitenancy001.tenant.api.dto.me.UpdateMyProfileRequest;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/tenant/me")
public class TenantMeController {

    private final TenantUserService tenantUserService;

    // ✅ Perfil do usuário logado
    @GetMapping
    public ResponseEntity<TenantMeResponse> me() {
        return ResponseEntity.ok(tenantUserService.getMyProfile());
    }

    // ✅ Atualiza perfil do usuário logado (SAFE whitelist)
    @PutMapping
    public ResponseEntity<TenantMeResponse> update(@Valid @RequestBody UpdateMyProfileRequest req) {
        return ResponseEntity.ok(tenantUserService.updateMyProfile(req));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/products/TenantProductController.java
============================================================
package brito.com.multitenancy001.tenant.api.products;

import brito.com.multitenancy001.tenant.api.dto.products.ProductResponse;
import brito.com.multitenancy001.tenant.api.dto.products.ProductUpsertRequest;
import brito.com.multitenancy001.tenant.api.dto.products.SupplierProductCountResponse;
import brito.com.multitenancy001.tenant.api.mapper.ProductApiMapper;
import brito.com.multitenancy001.tenant.application.product.TenantProductService;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.product.Product;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/tenant/products")
@RequiredArgsConstructor
public class TenantProductController {

    private final ProductApiMapper productApiMapper;
    private final TenantProductService tenantProductService;

    // Busca produto por id (escopo: tenant).
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<ProductResponse> getById(@PathVariable UUID id) {
        Product product = tenantProductService.findById(id);
        return ResponseEntity.ok(productApiMapper.toResponse(product));
    }

    // Lista produtos por categoria (default: somente não-deletados/ativos conforme service).
    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByCategory(@PathVariable Long categoryId) {
        List<Product> products = tenantProductService.findByCategoryId(categoryId);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por categoria com flags administrativas (incluir deletados/inativos).
    @GetMapping("/category/{categoryId}/admin")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByCategoryAdmin(
            @PathVariable Long categoryId,
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        List<Product> products = tenantProductService.findByCategoryId(categoryId, includeDeleted, includeInactive);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por categoria e subcategoria opcional.
    @GetMapping("/category/{categoryId}/optional")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByCategoryOptionalSubcategory(
            @PathVariable Long categoryId,
            @RequestParam(value = "subcategoryId", required = false) Long subcategoryId
    ) {
        List<Product> products = tenantProductService.findByCategoryAndOptionalSubcategory(categoryId, subcategoryId);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por subcategoria.
    @GetMapping("/subcategory/{subcategoryId}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsBySubcategory(@PathVariable Long subcategoryId) {
        List<Product> products = tenantProductService.findBySubcategoryId(subcategoryId);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por marca.
    @GetMapping("/brand/{brand}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByBrand(@PathVariable String brand) {
        List<Product> products = tenantProductService.findByBrand(brand);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos ativos.
    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getActiveProducts() {
        List<Product> products = tenantProductService.findActiveProducts();
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Pesquisa produtos por nome.
    @GetMapping("/name")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByName(@RequestParam("name") String name) {
        List<Product> products = tenantProductService.findByName(name);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Pesquisa produtos por nome com paginação.
    @GetMapping("/name/paged")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<Page<ProductResponse>> getProductsByNamePaged(
            @RequestParam("name") String name,
            Pageable pageable
    ) {
        Page<Product> page = tenantProductService.findByNamePaged(name, pageable);
        return ResponseEntity.ok(page.map(productApiMapper::toResponse));
    }

    // Lista produtos por faixa de preço.
    @GetMapping("/price-between")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsByPriceBetween(
            @RequestParam("minPrice") BigDecimal minPrice,
            @RequestParam("maxPrice") BigDecimal maxPrice
    ) {
        List<Product> products = tenantProductService.findByPriceBetween(minPrice, maxPrice);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Lista produtos por fornecedor.
    @GetMapping("/supplier/{supplierId}")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> getProductsBySupplier(@PathVariable UUID supplierId) {
        List<Product> products = tenantProductService.findBySupplierId(supplierId);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Filtra produtos por múltiplos critérios (nome/preço/estoque).
    @GetMapping("/filter")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> filterProducts(
            @RequestParam("name") String name,
            @RequestParam("minPrice") BigDecimal minPrice,
            @RequestParam("maxPrice") BigDecimal maxPrice,
            @RequestParam("minStock") Integer minStock,
            @RequestParam("maxStock") Integer maxStock
    ) {
        List<Product> products =
                tenantProductService.findByNameAndPriceAndStock(name, minPrice, maxPrice, minStock, maxStock);
        return ResponseEntity.ok(products.stream().map(productApiMapper::toResponse).toList());
    }

    // Retorna contagem de produtos agrupada por fornecedor.
    @GetMapping("/stats/count-by-supplier")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<SupplierProductCountResponse>> countBySupplier() {
        return ResponseEntity.ok(tenantProductService.countProductsBySupplier());
    }

    // Retorna o valor total do inventário (estoque * custo) do tenant.
    @GetMapping("/inventory-value")
    @PreAuthorize("hasAuthority('TEN_INVENTORY_READ')")
    public ResponseEntity<BigDecimal> getTotalInventoryValue() {
        BigDecimal value = tenantProductService.calculateTotalInventoryValue();
        return ResponseEntity.ok(value != null ? value : BigDecimal.ZERO);
    }

    // Retorna a contagem de produtos com estoque baixo.
    @GetMapping("/low-stock/count")
    @PreAuthorize("hasAuthority('TEN_INVENTORY_READ')")
    public ResponseEntity<Long> countLowStockProducts(@RequestParam(defaultValue = "10") Integer threshold) {
        Long count = tenantProductService.countLowStockProducts(threshold);
        return ResponseEntity.ok(count != null ? count : 0L);
    }

    // Alterna status ativo/inativo do produto.
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> toggleActive(@PathVariable UUID id) {
        Product updated = tenantProductService.toggleActive(id);
        return ResponseEntity.ok(productApiMapper.toResponse(updated));
    }

    // Atualiza o custo do produto (costPrice).
    @PatchMapping("/{id}/cost-price")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> updateCostPrice(
            @PathVariable UUID id,
            @RequestParam BigDecimal costPrice
    ) {
        Product updatedProduct = tenantProductService.updateCostPrice(id, costPrice);
        return ResponseEntity.ok(productApiMapper.toResponse(updatedProduct));
    }

    // Cria produto detalhado a partir de um request DTO (upsert).
    @PostMapping("/detailed")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_WRITE')")
    public ResponseEntity<ProductResponse> createDetailedProduct(@Valid @RequestBody ProductUpsertRequest req) {

        Product product = new Product();
        product.setName(req.name());
        product.setDescription(req.description());
        product.setSku(req.sku());
        product.setPrice(req.price());
        product.setStockQuantity(req.stockQuantity());
        product.setMinStock(req.minStock());
        product.setMaxStock(req.maxStock());
        product.setCostPrice(req.costPrice());
        product.setBrand(req.brand());
        product.setWeightKg(req.weightKg());
        product.setDimensions(req.dimensions());
        product.setBarcode(req.barcode());
        product.setActive(req.active());

        Category category = new Category();
        category.setId(req.categoryId());
        product.setCategory(category);

        if (req.subcategoryId() != null) {
            Subcategory sub = new Subcategory();
            sub.setId(req.subcategoryId());
            product.setSubcategory(sub);
        }

        if (req.supplierId() != null) {
            Supplier supplier = new Supplier();
            supplier.setId(req.supplierId());
            product.setSupplier(supplier);
        }

        Product savedProduct = tenantProductService.create(product);
        return ResponseEntity.status(HttpStatus.CREATED).body(productApiMapper.toResponse(savedProduct));
    }
    
    // "Any" (pode incluir deleted/inactive) - útil para telas/admin/relatórios internos
    @GetMapping("/category/{categoryId}/any")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> listAnyByCategory(@PathVariable Long categoryId) {
        return ResponseEntity.ok(
                tenantProductService.findAnyByCategoryId(categoryId)
                        .stream()
                        .map(productApiMapper::toResponse)
                        .toList()
        );
    }

    @GetMapping("/subcategory/{subcategoryId}/any")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> listAnyBySubcategory(@PathVariable Long subcategoryId) {
        return ResponseEntity.ok(
                tenantProductService.findAnyBySubcategoryId(subcategoryId)
                        .stream()
                        .map(productApiMapper::toResponse)
                        .toList()
        );
    }

    @GetMapping("/brand/{brand}/any")
    @PreAuthorize("hasAuthority('TEN_PRODUCT_READ')")
    public ResponseEntity<List<ProductResponse>> listAnyByBrand(@PathVariable String brand) {
        return ResponseEntity.ok(
                tenantProductService.findAnyByBrandIgnoreCase(brand)
                        .stream()
                        .map(productApiMapper::toResponse)
                        .toList()
        );
    }

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/suppliers/TenantSupplierController.java
============================================================
package brito.com.multitenancy001.tenant.api.suppliers;

import brito.com.multitenancy001.tenant.application.supplier.TenantSupplierService;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/tenant/suppliers")
@RequiredArgsConstructor
public class TenantSupplierController {

    private final TenantSupplierService tenantSupplierService;

    // Lista fornecedores (não-deletados) do tenant.
    @GetMapping
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> listAll() {
        return ResponseEntity.ok(tenantSupplierService.findAll());
    }

    // Lista fornecedores ativos (não-deletados) do tenant.
    @GetMapping("/active")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> listActive() {
        return ResponseEntity.ok(tenantSupplierService.findActive());
    }

    // Busca fornecedor por id (escopo: tenant).
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<Supplier> getById(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.findById(id));
    }

    // Busca fornecedor por documento (CPF/CNPJ) no tenant.
    @GetMapping("/document/{document}")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<Supplier> getByDocument(@PathVariable String document) {
        return ResponseEntity.ok(tenantSupplierService.findByDocument(document));
    }

    // Pesquisa fornecedores por nome.
    @GetMapping("/search")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> searchByName(@RequestParam("name") String name) {
        return ResponseEntity.ok(tenantSupplierService.searchByName(name));
    }

    // Lista fornecedores por email.
    @GetMapping("/email")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> getByEmail(@RequestParam("email") String email) {
        return ResponseEntity.ok(tenantSupplierService.findByEmail(email));
    }

    // Cria fornecedor no tenant.
    @PostMapping
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Supplier> create(@Valid @RequestBody Supplier supplier) {
        Supplier saved = tenantSupplierService.create(supplier);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    // Atualiza fornecedor do tenant (substituição completa).
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Supplier> update(@PathVariable UUID id, @RequestBody Supplier supplier) {
        Supplier updated = tenantSupplierService.update(id, supplier);
        return ResponseEntity.ok(updated);
    }

    // Alterna status ativo/inativo do fornecedor.
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Supplier> toggleActive(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.toggleActive(id));
    }

    // Soft-delete de fornecedor no tenant.
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Void> softDelete(@PathVariable UUID id) {
        tenantSupplierService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    // Restaura fornecedor previamente deletado (soft-delete).
    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_WRITE')")
    public ResponseEntity<Supplier> restore(@PathVariable UUID id) {
        return ResponseEntity.ok(tenantSupplierService.restore(id));
    }
    
    // "Any" (pode incluir deleted/inactive) - útil para admin/auditoria
    @GetMapping("/email/any")
    @PreAuthorize("hasAuthority('TEN_SUPPLIER_READ')")
    public ResponseEntity<List<Supplier>> findAnyByEmail(@RequestParam String email) {
        return ResponseEntity.ok(tenantSupplierService.findAnyByEmail(email));
    }

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/users/TenantUserController.java
============================================================
package brito.com.multitenancy001.tenant.api.users;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.application.user.TenantUserService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/users")
@RequiredArgsConstructor
public class TenantUserController {

    private final TenantUserService tenantUserService;

    // Lista usuários do tenant.
    @GetMapping
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<List<TenantUserSummaryResponse>> listTenantUsers() {
        return ResponseEntity.ok(tenantUserService.listTenantUsers());
    }

    // Lista usuários ativos do tenant.
    @GetMapping("/enabled")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<List<TenantUserSummaryResponse>> listEnabledTenantUsers() {
        return ResponseEntity.ok(tenantUserService.listEnabledTenantUsers());
    }

    // Busca detalhes de um usuário do tenant por id.
    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<TenantUserDetailsResponse> getTenantUser(@PathVariable Long userId) {
        return ResponseEntity.ok(tenantUserService.getTenantUser(userId));
    }

    // Cria usuário no tenant.
    @PostMapping
    @PreAuthorize("hasAuthority('TEN_USER_CREATE')")
    public ResponseEntity<TenantUserDetailsResponse> createTenantUser(
            @Valid @RequestBody TenantUserCreateRequest tenantUserCreateRequest
    ) {
        TenantUserDetailsResponse response = tenantUserService.createTenantUser(tenantUserCreateRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    // Transfere a propriedade/admin (owner) do tenant para o usuário informado.
    @PatchMapping("/{userId}/transfer-admin")
    @PreAuthorize("hasAuthority('TEN_ROLE_TRANSFER')")
    public ResponseEntity<Void> transferTenantOwner(@PathVariable Long userId) {
        tenantUserService.transferTenantOwner(userId);
        return ResponseEntity.noContent().build();
    }

    // Atualiza status de suspensão do usuário 
    @PatchMapping("/{userId}/status")
    @PreAuthorize("hasAuthority('TEN_USER_UPDATE')")
    public ResponseEntity<TenantUserSummaryResponse> updateTenantUserStatus(
            @PathVariable Long userId,
            @RequestParam(required = false) Boolean suspendedByAccount,
            @RequestParam(required = false) Boolean suspendedByAdmin
    ) {
        if (suspendedByAccount == null && suspendedByAdmin == null) {
            throw new ApiException("INVALID_STATUS", "Informe 'suspended' ou 'enabled' ", 400);
        }

        boolean finalSuspended = (suspendedByAccount != null) ? suspendedByAccount : !suspendedByAdmin;

        TenantUserSummaryResponse response =
                tenantUserService.setTenantUserSuspendedByAdmin(userId, finalSuspended);

        return ResponseEntity.ok(response);
    }

    // Reseta a senha do usuário do tenant para um novo valor.
    @PatchMapping("/{userId}/password")
    @PreAuthorize("hasAuthority('TEN_USER_UPDATE')")
    public ResponseEntity<TenantUserSummaryResponse> resetTenantUserPassword(
            @PathVariable Long userId,
            @RequestParam
            @Pattern(
                    regexp = ValidationPatterns.PASSWORD_PATTERN,
                    message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas e números"
            )
            String newPassword
    ) {
        TenantUserSummaryResponse response = tenantUserService.resetTenantUserPassword(userId, newPassword);
        return ResponseEntity.ok(response);
    }

    // Soft-delete de usuário do tenant.
    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_DELETE')")
    public ResponseEntity<Void> deleteTenantUser(@PathVariable Long userId) {
        tenantUserService.softDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    // Hard-delete de usuário do tenant.
    @DeleteMapping("/{userId}/hard")
    @PreAuthorize("hasAuthority('TEN_USER_DELETE')")
    public ResponseEntity<Void> hardDeleteTenantUser(@PathVariable Long userId) {
        tenantUserService.hardDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    // Restaura usuário previamente deletado (soft-delete).
    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority('TEN_USER_RESTORE')")
    public ResponseEntity<TenantUserSummaryResponse> restoreTenantUser(@PathVariable Long userId) {
        TenantUserSummaryResponse response = tenantUserService.restoreTenantUser(userId);
        return ResponseEntity.ok(response);
    }
    
    // Busca detalhes de um usuário habilitado (enabled).
    @GetMapping("/enabled/{userId}")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<TenantUserDetailsResponse> getEnabledTenantUser(@PathVariable Long userId) {
        return ResponseEntity.ok(tenantUserService.getEnabledTenantUser(userId));
    }

    // Conta usuários habilitados (enabled) do tenant.
    @GetMapping("/enabled/count")
    @PreAuthorize("hasAuthority('TEN_USER_READ')")
    public ResponseEntity<Long> countEnabledTenantUsers() {
        return ResponseEntity.ok(tenantUserService.countEnabledTenantUsers());
    }
 
    
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/api/users/admin/TenantUserAdminController.java
============================================================
package brito.com.multitenancy001.tenant.api.users.admin;

import brito.com.multitenancy001.tenant.api.dto.users.admin.TenantUserAdminSuspendRequest;
import brito.com.multitenancy001.tenant.application.user.admin.TenantUserAdminService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tenant/admin/users")
@RequiredArgsConstructor
public class TenantUserAdminController {

    private final TenantUserAdminService tenantUserAdminService;

    // Suspende ou reativa usuário do tenant por ação administrativa.
    @PatchMapping("/{userId}/suspend")
    @PreAuthorize("hasAuthority('TEN_USER_SUSPEND')")
    public ResponseEntity<Void> suspendUser(
            @PathVariable Long userId,
            @RequestBody TenantUserAdminSuspendRequest tenantUserAdminSuspendRequest
    ) {
        tenantUserAdminService.setUserSuspendedByAdmin(userId, tenantUserAdminSuspendRequest.suspended());
        return ResponseEntity.noContent().build();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/auth/TenantAuthService.java
============================================================
package brito.com.multitenancy001.tenant.application.auth;

import brito.com.multitenancy001.infrastructure.publicschema.AccountResolver;
import brito.com.multitenancy001.infrastructure.publicschema.AccountSnapshot;
import brito.com.multitenancy001.infrastructure.publicschema.LoginIdentityResolver;
import brito.com.multitenancy001.infrastructure.publicschema.LoginIdentityRow;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.PublicExecutor;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantLoginRequest;
import brito.com.multitenancy001.tenant.api.dto.auth.TenantSelectionOption;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantAuthService {

    private static final String INVALID_USER_MSG = "usuario ou senha invalidos";

    private final org.springframework.security.authentication.AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;

    private final AccountResolver accountResolver;
    private final LoginIdentityResolver loginIdentityResolver;

    private final TenantUserRepository tenantUserRepository;
    private final PublicExecutor publicExecutor;
    private final TenantExecutor tenantExecutor;

    public JwtResponse loginTenant(TenantLoginRequest req) {

        if (req == null) throw new ApiException("INVALID_REQUEST", "Requisição inválida", 400);
        if (!StringUtils.hasText(req.email())) throw new ApiException("INVALID_LOGIN", "email é obrigatório", 400);
        if (!StringUtils.hasText(req.password())) throw new ApiException("INVALID_LOGIN", "password é obrigatório", 400);

        final String email = req.email().trim().toLowerCase();
        final String password = req.password();

        // 1) PUBLIC — descobre quais contas (tenants) têm esse email cadastrado
        List<LoginIdentityRow> candidates = publicExecutor.run(() ->
                loginIdentityResolver.findTenantAccountsByEmail(email)
        );

        if (candidates == null || candidates.isEmpty()) {
            throw new BadCredentialsException(INVALID_USER_MSG);
        }

        // 2) Se veio accountId, tenta só nele (2º passo do front)
        if (req.accountId() != null) {
            Long chosen = req.accountId();

            boolean exists = candidates.stream().anyMatch(r -> r.accountId().equals(chosen));
            if (!exists) {
                // evita vazar info / evita brute force de accountId
                throw new BadCredentialsException(INVALID_USER_MSG);
            }

            AccountSnapshot account = publicExecutor.run(() ->
                    accountResolver.resolveActiveAccountById(chosen)
            );

            return attemptLoginOnAccount(account, email, password);
        }

        // 3) Se NÃO veio accountId: tenta autenticar em cada tenant
        //    - se só 1 bater -> JWT direto
        //    - se várias baterem -> pede seleção
        //    - se nenhuma bater -> invalid
        List<SuccessfulTenantLogin> successes = new ArrayList<>();

        for (LoginIdentityRow row : candidates) {
            AccountSnapshot account;
            try {
                account = publicExecutor.run(() ->
                        accountResolver.resolveActiveAccountById(row.accountId())
                );
            } catch (ApiException e) {
                // conta inativa/cancelada/etc -> ignora
                continue;
            }

            try {
                JwtResponse jwt = attemptLoginOnAccount(account, email, password);
                successes.add(new SuccessfulTenantLogin(account, jwt));
            } catch (BadCredentialsException ex) {
                // senha não bate nesse tenant -> ignora
            } catch (ApiException ex) {
                // usuário inativo nesse tenant -> ignora (ou decide se quer bloquear)
            }
        }

        if (successes.isEmpty()) {
            throw new BadCredentialsException(INVALID_USER_MSG);
        }

        if (successes.size() == 1) {
            return successes.get(0).jwt();
        }

        // várias contas com senha válida -> pede escolha
        List<TenantSelectionOption> options = successes.stream()
                .map(s -> new TenantSelectionOption(
                        s.account().id(),
                        s.account().displayName(),
                        s.account().slug()
                ))
                .toList();

        throw new ApiException(
                "TENANT_SELECTION_REQUIRED",
                "Selecione a empresa",
                409,
                options
        );
    }

    private JwtResponse attemptLoginOnAccount(AccountSnapshot account, String email, String password) {

        return tenantExecutor.run(account.schemaName(), () -> {

            Authentication authentication = authenticateOrInvalidUser(email, password);

            TenantUser user = tenantUserRepository
                    .findByEmailAndDeletedFalse(email)
                    .orElseThrow(() -> new BadCredentialsException(INVALID_USER_MSG));

            if (user.isSuspendedByAccount() || user.isSuspendedByAdmin() || user.isDeleted()) {
                throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
            }

            String accessToken = jwtTokenProvider.generateTenantToken(
                    authentication,
                    account.id(),
                    account.schemaName()
            );

            String refreshToken = jwtTokenProvider.generateRefreshToken(
                    user.getEmail(),
                    account.schemaName()
            );

            return new JwtResponse(
                    accessToken,
                    refreshToken,
                    user.getId(),
        
                    user.getEmail(),
                    user.getRole().name(),
                    account.id(),
                    account.schemaName()
            );
        });
    }

    private Authentication authenticateOrInvalidUser(String email, String password) {
        try {
            return authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(email, password)
            );

        } catch (BadCredentialsException e) {
            throw new BadCredentialsException(INVALID_USER_MSG);

        } catch (UsernameNotFoundException e) {
            throw new BadCredentialsException(INVALID_USER_MSG);

        } catch (InternalAuthenticationServiceException e) {
            Throwable cause = e.getCause();
            if (cause instanceof UsernameNotFoundException) {
                throw new BadCredentialsException(INVALID_USER_MSG);
            }
            throw e;
        }
    }

    private record SuccessfulTenantLogin(AccountSnapshot account, JwtResponse jwt) {}
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/billing/TenantBillingService.java
============================================================
package brito.com.multitenancy001.tenant.application.billing;

import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.billing.PaymentQueryFacade;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantBillingService {

    private final PaymentQueryFacade paymentQueryFacade;

    @Transactional(readOnly = true)
    public List<PaymentResponse> listPaymentsForAccount(Long accountId) {
        return paymentQueryFacade.listByAccount(accountId);
    }

    @Transactional(readOnly = true)
    public PaymentResponse getPaymentForAccount(Long accountId, Long paymentId) {
        return paymentQueryFacade.getByAccount(accountId, paymentId);
    }

    @Transactional(readOnly = true)
    public boolean hasActivePayment(Long accountId) {
        return paymentQueryFacade.hasActivePayment(accountId);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/category/TenantCategoryService.java
============================================================
package brito.com.multitenancy001.tenant.application.category;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.persistence.category.TenantCategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantCategoryService {

    private final TenantCategoryRepository tenantCategoryRepository;
    private final AppClock appClock;

    // =========================================================
    // READ
    // =========================================================

    @Transactional(readOnly = true)
    public Category findById(Long id) {
        if (id == null) throw new ApiException("CATEGORY_ID_REQUIRED", "id é obrigatório", 400);

        Category c = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (c.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Categoria deletada não pode ser consultada", 404);
        }

        return c;
    }

    @Transactional(readOnly = true)
    public List<Category> findAll() {
        return tenantCategoryRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Category> findActive() {
        return tenantCategoryRepository.findNotDeletedActive();
    }

    @Transactional(readOnly = true)
    public List<Category> searchByName(String name) {
        if (!StringUtils.hasText(name)) {
            throw new ApiException("CATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }
        return tenantCategoryRepository.findNotDeletedByNameContainingIgnoreCase(name.trim());
    }

    @Transactional(readOnly = true)
    public List<Category> findWithFlags(boolean includeDeleted, boolean includeInactive) {
        return tenantCategoryRepository.findWithFlags(includeDeleted, includeInactive);
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Category create(Category category) {
        if (category == null) throw new ApiException("CATEGORY_REQUIRED", "payload é obrigatório", 400);
        if (!StringUtils.hasText(category.getName())) {
            throw new ApiException("CATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }

        String name = category.getName().trim();

        // uk_categories_name (global) -> valida para evitar 500
        tenantCategoryRepository.findNotDeletedByNameIgnoreCase(name)
                .ifPresent(existing -> {
                    throw new ApiException("CATEGORY_NAME_ALREADY_EXISTS", "Categoria já existe: " + name, 409);
                });

        category.setName(name);
        category.setDeleted(false);
        category.setActive(true);

        return tenantCategoryRepository.save(category);
    }

    @Transactional
    public Category update(Long id, Category req) {
        if (id == null) throw new ApiException("CATEGORY_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("CATEGORY_REQUIRED", "payload é obrigatório", 400);

        Category existing = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido alterar categoria deletada", 409);
        }

        if (StringUtils.hasText(req.getName())) {
            String newName = req.getName().trim();

            // valida unicidade
            tenantCategoryRepository.findNotDeletedByNameIgnoreCase(newName)
                    .ifPresent(other -> {
                        if (!other.getId().equals(id)) {
                            throw new ApiException("CATEGORY_NAME_ALREADY_EXISTS", "Categoria já existe: " + newName, 409);
                        }
                    });

            existing.setName(newName);
        }

        // active é boolean primitivo -> melhor controlar via endpoint específico (toggle)
        return tenantCategoryRepository.save(existing);
    }

    @Transactional
    public Category toggleActive(Long id) {
        Category category = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        if (category.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido alterar categoria deletada", 409);
        }

        category.setActive(!category.isActive());
        return tenantCategoryRepository.save(category);
    }

    @Transactional
    public void softDelete(Long id) {
        Category category = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        category.softDelete(appClock.now());
        tenantCategoryRepository.save(category);
    }

    @Transactional
    public Category restore(Long id) {
        Category category = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + id, 404));

        category.restore();
        return tenantCategoryRepository.save(category);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/category/TenantSubcategoryService.java
============================================================
package brito.com.multitenancy001.tenant.application.category;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.persistence.category.TenantCategoryRepository;
import brito.com.multitenancy001.tenant.persistence.category.TenantSubcategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantSubcategoryService {

    private final TenantSubcategoryRepository tenantSubcategoryRepository;
    private final TenantCategoryRepository tenantCategoryRepository;
    private final AppClock appClock;

    // =========================================================
    // READ
    // =========================================================

    @Transactional(readOnly = true)
    public Subcategory findById(Long id) {
        if (id == null) throw new ApiException("SUBCATEGORY_ID_REQUIRED", "id é obrigatório", 400);

        Subcategory s = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (s.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Subcategoria deletada não pode ser consultada", 404);
        }

        return s;
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findAll() {
        return tenantSubcategoryRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findActive() {
        return tenantSubcategoryRepository.findActiveNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findByCategoryId(Long categoryId) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findActiveNotDeletedByCategoryId(categoryId);
    }

    @Transactional(readOnly = true)
    public List<Subcategory> findByCategoryIdAdmin(Long categoryId, boolean includeDeleted, boolean includeInactive) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findByCategoryWithFlags(categoryId, includeDeleted, includeInactive);
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Subcategory create(Long categoryId, Subcategory req) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        if (req == null) throw new ApiException("SUBCATEGORY_REQUIRED", "payload é obrigatório", 400);
        if (!StringUtils.hasText(req.getName())) {
            throw new ApiException("SUBCATEGORY_NAME_REQUIRED", "name é obrigatório", 400);
        }

        Category category = tenantCategoryRepository.findById(categoryId)
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada: " + categoryId, 404));

        if (category.isDeleted()) {
            throw new ApiException("CATEGORY_DELETED", "Não é permitido criar subcategoria em categoria deletada", 409);
        }

        String name = req.getName().trim();

        // uk_subcategories_name_category (category_id, name)
        tenantSubcategoryRepository.findNotDeletedByCategoryIdAndNameIgnoreCase(categoryId, name)
                .ifPresent(existing -> {
                    throw new ApiException("SUBCATEGORY_ALREADY_EXISTS",
                            "Subcategoria já existe na categoria " + categoryId + ": " + name, 409);
                });

        Subcategory sub = new Subcategory();
        sub.setCategory(category);
        sub.setName(name);
        sub.setDeleted(false);
        sub.setActive(true);

        return tenantSubcategoryRepository.save(sub);
    }

    @Transactional
    public Subcategory update(Long id, Subcategory req) {
        if (id == null) throw new ApiException("SUBCATEGORY_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("SUBCATEGORY_REQUIRED", "payload é obrigatório", 400);

        Subcategory existing = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Não é permitido alterar subcategoria deletada", 409);
        }

        if (StringUtils.hasText(req.getName())) {
            String newName = req.getName().trim();
            Long categoryId = existing.getCategory().getId();

            tenantSubcategoryRepository.findNotDeletedByCategoryIdAndNameIgnoreCase(categoryId, newName)
                    .ifPresent(other -> {
                        if (!other.getId().equals(id)) {
                            throw new ApiException("SUBCATEGORY_ALREADY_EXISTS",
                                    "Subcategoria já existe na categoria " + categoryId + ": " + newName, 409);
                        }
                    });

            existing.setName(newName);
        }

        return tenantSubcategoryRepository.save(existing);
    }

    @Transactional
    public Subcategory toggleActive(Long id) {
        Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        if (sub.isDeleted()) {
            throw new ApiException("SUBCATEGORY_DELETED", "Não é permitido alterar subcategoria deletada", 409);
        }

        sub.setActive(!sub.isActive());
        return tenantSubcategoryRepository.save(sub);
    }

    @Transactional
    public void softDelete(Long id) {
        Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        sub.softDelete(appClock.now());
        tenantSubcategoryRepository.save(sub);
    }

    @Transactional
    public Subcategory restore(Long id) {
        Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada: " + id, 404));

        sub.restore();
        return tenantSubcategoryRepository.save(sub);
    }
    
    @Transactional(readOnly = true)
    public List<Subcategory> findByCategoryIdNotDeleted(Long categoryId) {
        if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findNotDeletedByCategoryId(categoryId);
    }

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/product/TenantProductService.java
============================================================
// ===============================
// ProductService.java
// (corrigido: resolveCategoryAndSubcategory sem duplicação,
//  update limpando subcategory quando vier null,
//  usando findByIdWithCategory pra validar)
// ===============================
package brito.com.multitenancy001.tenant.application.product;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.api.dto.products.SupplierProductCountResponse;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.product.Product;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import brito.com.multitenancy001.tenant.persistence.category.TenantCategoryRepository;
import brito.com.multitenancy001.tenant.persistence.category.TenantSubcategoryRepository;
import brito.com.multitenancy001.tenant.persistence.product.TenantProductRepository;
import brito.com.multitenancy001.tenant.persistence.supplier.TenantSupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProductService {

    private final TenantProductRepository tenantProductRepository;
    private final TenantSupplierRepository tenantSupplierRepository;
    private final TenantCategoryRepository tenantCategoryRepository;
    private final TenantSubcategoryRepository tenantSubcategoryRepository;
    private final AppClock appClock;

    @Transactional(readOnly = true)
    public Page<Product> findAll(Pageable pageable) {
        return tenantProductRepository.findAll(pageable);
    }

    @Transactional(readOnly = true)
    public Product findById(UUID id) {
        return tenantProductRepository.findById(id)
            .orElseThrow(() -> new ApiException("PRODUCT_NOT_FOUND",
                "Produto não encontrado com ID: " + id, 404));
    }

    @Transactional
    public Product create(Product product) {
        validateProduct(product);

        resolveCategoryAndSubcategory(product);
        resolveSupplier(product);
        validateSubcategoryBelongsToCategory(product);

        return tenantProductRepository.save(product);
    }

    @Transactional
    public Product update(UUID id, Product productDetails) {
        Product existingProduct = findById(id);

        if (StringUtils.hasText(productDetails.getName())) {
            existingProduct.setName(productDetails.getName());
        }

        if (productDetails.getDescription() != null) {
            existingProduct.setDescription(productDetails.getDescription());
        }

        if (StringUtils.hasText(productDetails.getSku())) {
            Optional<Product> productWithSku = tenantProductRepository.findBySku(productDetails.getSku());
            if (productWithSku.isPresent() && !productWithSku.get().getId().equals(id)) {
                throw new ApiException("SKU_ALREADY_EXISTS",
                    "SKU já cadastrado: " + productDetails.getSku(), 409);
            }
            existingProduct.setSku(productDetails.getSku());
        }

        if (productDetails.getPrice() != null) {
            validatePrice(productDetails.getPrice());
            existingProduct.setPrice(productDetails.getPrice());
        }

        if (productDetails.getStockQuantity() != null) {
            existingProduct.setStockQuantity(productDetails.getStockQuantity());
        }

        // ✅ category
        if (productDetails.getCategory() != null && productDetails.getCategory().getId() != null) {
            Category category = tenantCategoryRepository.findById(productDetails.getCategory().getId())
                .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada", 404));
            existingProduct.setCategory(category);
        }

     // ✅ subcategory: só mexe se veio no payload
        if (productDetails.getSubcategory() != null) {
            if (productDetails.getSubcategory().getId() != null) {
                Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(productDetails.getSubcategory().getId())
                        .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada", 404));
                existingProduct.setSubcategory(sub);
            } else {
                // veio "subcategory": {} (ou sem id) => limpa
                existingProduct.setSubcategory(null);
            }
        }



        // ✅ supplier
        if (productDetails.getSupplier() != null && productDetails.getSupplier().getId() != null) {
            Supplier supplier = tenantSupplierRepository.findById(productDetails.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND", "Fornecedor não encontrado", 404));
            existingProduct.setSupplier(supplier);
        }

        validateSubcategoryBelongsToCategory(existingProduct);

        return tenantProductRepository.save(existingProduct);
    }

    private void resolveSupplier(Product product) {
        if (product.getSupplier() != null && product.getSupplier().getId() != null) {
            UUID supplierId = product.getSupplier().getId();
            Supplier supplier = tenantSupplierRepository.findById(product.getSupplier().getId())
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                    "Fornecedor não encontrado com ID: " + supplierId, 404));
            product.setSupplier(supplier);
        }
    }


    private void resolveCategoryAndSubcategory(Product product) {
        // ✅ category obrigatória
        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria é obrigatória", 400);
        }

        Category category = tenantCategoryRepository.findById(product.getCategory().getId())
            .orElseThrow(() -> new ApiException("CATEGORY_NOT_FOUND", "Categoria não encontrada", 404));
        product.setCategory(category);

        // ✅ subcategory opcional
        if (product.getSubcategory() != null && product.getSubcategory().getId() != null) {
            Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(product.getSubcategory().getId())
                .orElseThrow(() -> new ApiException("SUBCATEGORY_NOT_FOUND", "Subcategoria não encontrada", 404));
            product.setSubcategory(sub);
        } else {
            product.setSubcategory(null);
        }
    }

    private void validateSubcategoryBelongsToCategory(Product product) {
        if (product.getSubcategory() == null) return;

        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException("CATEGORY_REQUIRED", "Categoria é obrigatória", 400);
        }

        if (product.getSubcategory().getCategory() == null
            || product.getSubcategory().getCategory().getId() == null) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria sem categoria associada (cadastro inconsistente)", 409);
        }

        Long subCatCategoryId = product.getSubcategory().getCategory().getId();
        Long productCategoryId = product.getCategory().getId();

        if (!subCatCategoryId.equals(productCategoryId)) {
            throw new ApiException("INVALID_SUBCATEGORY",
                "Subcategoria não pertence à categoria informada", 409);
        }
    }

    // ======= outros métodos =======

    @Transactional(readOnly = true)
    public List<Product> searchProducts(String name, BigDecimal minPrice,
                                        BigDecimal maxPrice, Integer minStock, Integer maxStock) {
        return tenantProductRepository.searchProducts(name, minPrice, maxPrice, minStock, maxStock);
    }


    @Transactional(readOnly = true)
    public List<Product> findLowStock(Integer threshold) {
        return tenantProductRepository.findByStockQuantityLessThan(threshold);
    }

    @Transactional
    public Product updateStock(UUID id, Integer quantityChange) {
        Product product = findById(id);
        if (quantityChange > 0) product.addToStock(quantityChange);
        else if (quantityChange < 0) product.removeFromStock(Math.abs(quantityChange));
        return tenantProductRepository.save(product);
    }

    @Transactional
    public Product updatePrice(UUID id, BigDecimal newPrice) {
        validatePrice(newPrice);
        Product product = findById(id);
        product.updatePrice(newPrice);
        return tenantProductRepository.save(product);
    }

    @Transactional
    public void delete(UUID id) {
        Product product = findById(id);
        product.softDelete(appClock.now());
        tenantProductRepository.save(product);
    }

    private void validateProduct(Product product) {
        if (!StringUtils.hasText(product.getName())) {
            throw new ApiException("PRODUCT_NAME_REQUIRED", "Nome do produto é obrigatório", 400);
        }
        if (product.getPrice() == null) {
            throw new ApiException("PRODUCT_PRICE_REQUIRED", "Preço do produto é obrigatório", 400);
        }
        validatePrice(product.getPrice());

        if (product.getStockQuantity() == null) product.setStockQuantity(0);
        if (product.getStockQuantity() < 0) {
            throw new ApiException("INVALID_STOCK", "Quantidade em estoque não pode ser negativa", 400);
        }
    }

    private void validatePrice(BigDecimal price) {
        if (price == null) throw new ApiException("INVALID_PRICE", "Preço não pode ser nulo", 400);
        if (price.compareTo(BigDecimal.ZERO) < 0) throw new ApiException("INVALID_PRICE", "Preço não pode ser negativo", 400);
        if (price.compareTo(BigDecimal.valueOf(1_000_000)) > 0) {
            throw new ApiException("PRICE_TOO_HIGH", "Preço muito alto. Valor máximo permitido: 1.000.000", 400);
        }
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryId(Long categoryId) {
        if (categoryId == null) {
            throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByCategoryId(categoryId);
    }


    @Transactional(readOnly = true)
    public List<Product> findByBrand(String brand) {
        if (!StringUtils.hasText(brand)) {
            throw new ApiException("INVALID_BRAND", "brand é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByBrandIgnoreCase(brand.trim());
    }



    @Transactional(readOnly = true)
    public List<Product> findActiveProducts() {
        return tenantProductRepository.findByActiveTrueAndDeletedFalse();
    }


    @Transactional
    public Product updateCostPrice(UUID id, BigDecimal costPrice) {
        Product product = findById(id);
        product.updateCostPrice(costPrice);
        return tenantProductRepository.save(product);
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateTotalInventoryValue() {
        return tenantProductRepository.calculateTotalInventoryValue();
    }

    @Transactional(readOnly = true)
    public Long countLowStockProducts(Integer threshold) {
        return tenantProductRepository.countLowStock(threshold);
    }
    
 // =========================================================
 // ✅ QUERIES PARA "DAR USO" AOS MÉTODOS DO ProductRepository
 // =========================================================

    @Transactional(readOnly = true)
    public List<Product> findBySubcategoryId(Long subcategoryId) {
        if (subcategoryId == null) {
            throw new ApiException("SUBCATEGORY_REQUIRED", "subcategoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedBySubcategoryId(subcategoryId);
    }

    @Transactional(readOnly = true)
    public List<Product> findByCategoryAndOptionalSubcategory(Long categoryId, Long subcategoryId) {
        if (categoryId == null) {
            throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
        }
        return tenantProductRepository.findActiveNotDeletedByCategoryAndOptionalSubcategory(categoryId, subcategoryId);
    }


 @Transactional(readOnly = true)
 public List<Product> findByName(String name) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     return tenantProductRepository.findByNameContainingIgnoreCase(name.trim());
 }

 @Transactional(readOnly = true)
 public Page<Product> findByNamePaged(String name, Pageable pageable) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     return tenantProductRepository.findByNameContainingIgnoreCase(name.trim(), pageable);
 }

 @Transactional(readOnly = true)
 public List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice) {
     if (minPrice == null || maxPrice == null) {
         throw new ApiException("INVALID_PRICE_RANGE", "minPrice e maxPrice são obrigatórios", 400);
     }
     if (maxPrice.compareTo(minPrice) < 0) {
         throw new ApiException("INVALID_PRICE_RANGE", "maxPrice deve ser >= minPrice", 400);
     }
     return tenantProductRepository.findByPriceBetween(minPrice, maxPrice);
 }

 @Transactional(readOnly = true)
 public List<Product> findBySupplierId(UUID supplierId) {
     if (supplierId == null) {
         throw new ApiException("SUPPLIER_REQUIRED", "supplierId é obrigatório", 400);
     }
     return tenantProductRepository.findBySupplier_Id(supplierId);
 }

 @Transactional(readOnly = true)
 public List<Product> findByNameAndPriceAndStock(
         String name,
         BigDecimal minPrice,
         BigDecimal maxPrice,
         Integer minStock,
         Integer maxStock
 ) {
     if (!StringUtils.hasText(name)) {
         throw new ApiException("INVALID_NAME", "name é obrigatório", 400);
     }
     if (minPrice == null || maxPrice == null) {
         throw new ApiException("INVALID_PRICE_RANGE", "minPrice e maxPrice são obrigatórios", 400);
     }
     if (maxPrice.compareTo(minPrice) < 0) {
         throw new ApiException("INVALID_PRICE_RANGE", "maxPrice deve ser >= minPrice", 400);
     }
     if (minStock == null || maxStock == null) {
         throw new ApiException("INVALID_STOCK_RANGE", "minStock e maxStock são obrigatórios", 400);
     }
     if (maxStock < minStock) {
         throw new ApiException("INVALID_STOCK_RANGE", "maxStock deve ser >= minStock", 400);
     }

     return tenantProductRepository.findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(
             name.trim(), minPrice, maxPrice, minStock, maxStock
     );
 }

 /**
  * Usa o @Query:
  * SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id
  */
 @Transactional(readOnly = true)
 public List<SupplierProductCountResponse> countProductsBySupplier() {
     List<Object[]> rows = tenantProductRepository.countProductsBySupplier();

     return rows.stream()
             .map(row -> new SupplierProductCountResponse(
                     (UUID) row[0],
                     ((Number) row[1]).longValue()
             ))
             .toList();
 }

 
 @Transactional
 public Product toggleActive(UUID id) {
     Product product = findById(id);

     if (Boolean.TRUE.equals(product.getDeleted())) {
         throw new ApiException("PRODUCT_DELETED", "Não é permitido alterar produto deletado", 409);
     }

     boolean next = !Boolean.TRUE.equals(product.getActive());
     product.setActive(next);

     return tenantProductRepository.save(product);
 }
 
 @Transactional(readOnly = true)
 public List<Product> findByCategoryId(Long categoryId, boolean includeDeleted, boolean includeInactive) {
     if (categoryId == null) {
         throw new ApiException("CATEGORY_REQUIRED", "categoryId é obrigatório", 400);
     }
     return tenantProductRepository.findByCategoryWithFlags(categoryId, includeDeleted, includeInactive);
 }

 @Transactional(readOnly = true)
 public List<Product> findAnyByCategoryId(Long categoryId) {
     if (categoryId == null) throw new ApiException("CATEGORY_ID_REQUIRED", "categoryId é obrigatório", 400);
     return tenantProductRepository.findByCategory_Id(categoryId);
 }

 @Transactional(readOnly = true)
 public List<Product> findAnyBySubcategoryId(Long subcategoryId) {
     if (subcategoryId == null) throw new ApiException("SUBCATEGORY_ID_REQUIRED", "subcategoryId é obrigatório", 400);
     return tenantProductRepository.findBySubcategory_Id(subcategoryId);
 }

 @Transactional(readOnly = true)
 public List<Product> findAnyByBrandIgnoreCase(String brand) {
     if (!StringUtils.hasText(brand)) throw new ApiException("BRAND_REQUIRED", "brand é obrigatório", 400);
     return tenantProductRepository.findAnyByBrandIgnoreCase(brand);
 }

 
    
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/supplier/TenantSupplierService.java
============================================================
package brito.com.multitenancy001.tenant.application.supplier;

import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import brito.com.multitenancy001.tenant.persistence.supplier.TenantSupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantSupplierService {

    private final TenantSupplierRepository tenantSupplierRepository;
    private final AppClock appClock;

    // =========================================================
    // READ (por padrão: NÃO retorna deletados)
    // =========================================================

    @Transactional(readOnly = true)
    public Supplier findById(UUID id) {
        if (id == null) throw new ApiException("SUPPLIER_ID_REQUIRED", "id é obrigatório", 400);

        Supplier s = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (s.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Fornecedor deletado não pode ser consultado", 404);
        }

        return s;
    }

    @Transactional(readOnly = true)
    public List<Supplier> findAll() {
        return tenantSupplierRepository.findNotDeleted();
    }

    @Transactional(readOnly = true)
    public List<Supplier> findActive() {
        return tenantSupplierRepository.findActiveNotDeleted();
    }

    @Transactional(readOnly = true)
    public Supplier findByDocument(String document) {
        if (!StringUtils.hasText(document)) {
            throw new ApiException("SUPPLIER_DOCUMENT_REQUIRED", "document é obrigatório", 400);
        }

        String doc = document.trim();

        return tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(doc)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com document: " + doc, 404));
    }

    @Transactional(readOnly = true)
    public List<Supplier> searchByName(String name) {
        if (!StringUtils.hasText(name)) {
            throw new ApiException("SUPPLIER_NAME_REQUIRED", "name é obrigatório", 400);
        }
        return tenantSupplierRepository.findNotDeletedByNameContainingIgnoreCase(name.trim());
    }

    @Transactional(readOnly = true)
    public List<Supplier> findByEmail(String email) {
        if (!StringUtils.hasText(email)) {
            throw new ApiException("SUPPLIER_EMAIL_REQUIRED", "email é obrigatório", 400);
        }
        return tenantSupplierRepository.findNotDeletedByEmail(email.trim());
    }

    // =========================================================
    // WRITE
    // =========================================================

    @Transactional
    public Supplier create(Supplier supplier) {
        validateForCreate(supplier);

        // Regra do seu DB: document único quando NOT NULL e deleted=false.
        // Então: se vier document, garantimos unicidade entre não-deletados.
        if (StringUtils.hasText(supplier.getDocument())) {
            String doc = supplier.getDocument().trim();
            Optional<Supplier> existing = tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(doc);
            if (existing.isPresent()) {
                throw new ApiException("SUPPLIER_DOCUMENT_ALREADY_EXISTS",
                        "Já existe fornecedor com document: " + doc, 409);
            }
            supplier.setDocument(doc);
        } else {
            supplier.setDocument(null);
        }

        // defaults
        // (em Supplier você usa boolean primitivo, então já vem false/true; aqui só garantimos coerência)
        supplier.setDeleted(false);
        supplier.setActive(true);

        return tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public Supplier update(UUID id, Supplier req) {
        if (id == null) throw new ApiException("SUPPLIER_ID_REQUIRED", "id é obrigatório", 400);
        if (req == null) throw new ApiException("SUPPLIER_REQUIRED", "payload é obrigatório", 400);

        Supplier existing = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Não é permitido alterar fornecedor deletado", 409);
        }

        // name
        if (StringUtils.hasText(req.getName())) {
            existing.setName(req.getName().trim());
        }

        // contactPerson
        if (req.getContactPerson() != null) {
            existing.setContactPerson(StringUtils.hasText(req.getContactPerson()) ? req.getContactPerson().trim() : null);
        }

        // email
        if (req.getEmail() != null) {
            existing.setEmail(StringUtils.hasText(req.getEmail()) ? req.getEmail().trim() : null);
        }

        // phone
        if (req.getPhone() != null) {
            existing.setPhone(StringUtils.hasText(req.getPhone()) ? req.getPhone().trim() : null);
        }

        // address
        if (req.getAddress() != null) {
            existing.setAddress(StringUtils.hasText(req.getAddress()) ? req.getAddress().trim() : null);
        }

        // document + documentType
        if (req.getDocument() != null) {
            String newDoc = req.getDocument();
            if (StringUtils.hasText(newDoc)) {
                newDoc = newDoc.trim();

                Optional<Supplier> other = tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(newDoc);
                if (other.isPresent() && !other.get().getId().equals(id)) {
                    throw new ApiException("SUPPLIER_DOCUMENT_ALREADY_EXISTS",
                            "Já existe fornecedor com document: " + newDoc, 409);
                }

                existing.setDocument(newDoc);
            } else {
                existing.setDocument(null);
            }
        }

        if (req.getDocumentType() != null) {
            existing.setDocumentType(StringUtils.hasText(req.getDocumentType()) ? req.getDocumentType().trim() : null);
        }

        // website
        if (req.getWebsite() != null) {
            existing.setWebsite(StringUtils.hasText(req.getWebsite()) ? req.getWebsite().trim() : null);
        }

        // paymentTerms
        if (req.getPaymentTerms() != null) {
            existing.setPaymentTerms(StringUtils.hasText(req.getPaymentTerms()) ? req.getPaymentTerms().trim() : null);
        }

        // leadTimeDays
        if (req.getLeadTimeDays() != null) {
            if (req.getLeadTimeDays() < 0) {
                throw new ApiException("INVALID_LEAD_TIME", "leadTimeDays não pode ser negativo", 400);
            }
            existing.setLeadTimeDays(req.getLeadTimeDays());
        }

        // rating
        if (req.getRating() != null) {
            validateRating(req.getRating());
            existing.setRating(req.getRating());
        }

        // notes
        if (req.getNotes() != null) {
            existing.setNotes(StringUtils.hasText(req.getNotes()) ? req.getNotes().trim() : null);
        }

        // active (permitimos atualizar, mas não pode ativar se estiver deletado - já barramos acima)
        // Aqui: só atualiza se o payload tiver sido enviado em algum formato.
        // Como é boolean primitivo, não dá pra saber se "veio" ou não. Então mantemos SEM alterar.
        // Se você quiser controlar ativo via endpoint específico, faça um PATCH /{id}/toggle-active (igual product).

        return tenantSupplierRepository.save(existing);
    }

    @Transactional
    public Supplier toggleActive(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        if (supplier.isDeleted()) {
            throw new ApiException("SUPPLIER_DELETED", "Não é permitido alterar fornecedor deletado", 409);
        }

        supplier.setActive(!supplier.isActive());
        return tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public void softDelete(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        supplier.softDelete(appClock.now());
        tenantSupplierRepository.save(supplier);
    }

    @Transactional
    public Supplier restore(UUID id) {
        Supplier supplier = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException("SUPPLIER_NOT_FOUND",
                        "Fornecedor não encontrado com ID: " + id, 404));

        supplier.restore();
        return tenantSupplierRepository.save(supplier);
    }

    // =========================================================
    // Validation
    // =========================================================

    private void validateForCreate(Supplier supplier) {
        if (supplier == null) throw new ApiException("SUPPLIER_REQUIRED", "Fornecedor é obrigatório", 400);

        if (!StringUtils.hasText(supplier.getName())) {
            throw new ApiException("SUPPLIER_NAME_REQUIRED", "name é obrigatório", 400);
        }

        supplier.setName(supplier.getName().trim());

        if (supplier.getEmail() != null) {
            supplier.setEmail(StringUtils.hasText(supplier.getEmail()) ? supplier.getEmail().trim() : null);
        }
        if (supplier.getContactPerson() != null) {
            supplier.setContactPerson(StringUtils.hasText(supplier.getContactPerson()) ? supplier.getContactPerson().trim() : null);
        }
        if (supplier.getPhone() != null) {
            supplier.setPhone(StringUtils.hasText(supplier.getPhone()) ? supplier.getPhone().trim() : null);
        }
        if (supplier.getAddress() != null) {
            supplier.setAddress(StringUtils.hasText(supplier.getAddress()) ? supplier.getAddress().trim() : null);
        }
        if (supplier.getDocumentType() != null) {
            supplier.setDocumentType(StringUtils.hasText(supplier.getDocumentType()) ? supplier.getDocumentType().trim() : null);
        }
        if (supplier.getWebsite() != null) {
            supplier.setWebsite(StringUtils.hasText(supplier.getWebsite()) ? supplier.getWebsite().trim() : null);
        }
        if (supplier.getPaymentTerms() != null) {
            supplier.setPaymentTerms(StringUtils.hasText(supplier.getPaymentTerms()) ? supplier.getPaymentTerms().trim() : null);
        }
        if (supplier.getNotes() != null) {
            supplier.setNotes(StringUtils.hasText(supplier.getNotes()) ? supplier.getNotes().trim() : null);
        }

        if (supplier.getLeadTimeDays() != null && supplier.getLeadTimeDays() < 0) {
            throw new ApiException("INVALID_LEAD_TIME", "leadTimeDays não pode ser negativo", 400);
        }

        if (supplier.getRating() != null) {
            validateRating(supplier.getRating());
        }
    }

    private void validateRating(BigDecimal rating) {
        // rating NUMERIC(3,2) -> vai até 9.99
        if (rating.compareTo(BigDecimal.ZERO) < 0) {
            throw new ApiException("INVALID_RATING", "rating não pode ser negativo", 400);
        }
        if (rating.compareTo(new BigDecimal("9.99")) > 0) {
            throw new ApiException("INVALID_RATING", "rating máximo é 9.99", 400);
        }
    }
    
    @Transactional(readOnly = true)
    public List<Supplier> findAnyByEmail(String email) {
        if (!StringUtils.hasText(email)) {
            throw new ApiException("SUPPLIER_EMAIL_REQUIRED", "email é obrigatório", 400);
        }
        return tenantSupplierRepository.findAnyByEmail(email);
    }

    
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/user/TenantUserService.java
============================================================
package brito.com.multitenancy001.tenant.application.user;

import brito.com.multitenancy001.infrastructure.publicschema.AccountEntitlementsGuard;
import brito.com.multitenancy001.infrastructure.publicschema.AccountResolver;
import brito.com.multitenancy001.infrastructure.publicschema.AccountSnapshot;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.account.UserLimitPolicy;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.api.dto.me.TenantMeResponse;
import brito.com.multitenancy001.tenant.api.dto.me.UpdateMyProfileRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.api.dto.users.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.domain.user.TenantUserOrigin;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.LinkedHashSet;
import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantUserService {

    private final TenantUserApiMapper tenantUserApiMapper;

    private final TenantUserTxService tenantUserTxService;
    private final AccountResolver accountResolver;
    private final JwtTokenProvider jwtTokenProvider;
    private final SecurityUtils securityUtils;
    private final AppClock appClock;
    private final AccountEntitlementsGuard accountEntitlementsGuard;

    private final TenantExecutor tenantExecutor;

    // =========================================================
    // CONTROLLER METHODS
    // =========================================================

    public void transferTenantOwner(Long toUserId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long fromUserId = securityUtils.getCurrentUserId();

        tenantExecutor.run(schema, () ->
                tenantUserTxService.transferTenantOwnerRole(accountId, fromUserId, toUserId)
        );
    }

    public TenantMeResponse getMyProfile() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long userId = securityUtils.getCurrentUserId();

        return tenantExecutor.run(schema, () -> {
            TenantUser user = tenantUserTxService.getUser(userId, accountId);
            return tenantUserApiMapper.toMe(user);
        });
    }

    public TenantUserDetailsResponse createTenantUser(TenantUserCreateRequest req) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        if (req == null) throw new ApiException("INVALID_REQUEST", "Request inválido", 400);

        String name = (req.name() == null) ? null : req.name().trim();
        String email = (req.email() == null) ? null : req.email().trim().toLowerCase();

        final LinkedHashSet<String> perms =
                (req.permissions() == null || req.permissions().isEmpty())
                        ? null
                        : new LinkedHashSet<>(req.permissions());

        TenantUserOrigin origin = (req.origin() != null) ? req.origin() : TenantUserOrigin.ADMIN;

        if (origin == TenantUserOrigin.BUILT_IN) {
            throw new ApiException("INVALID_ORIGIN", "Origin BUILT_IN não pode ser criado via API", 400);
        }

        long currentUsers = tenantExecutor.run(schema, () ->
                tenantUserTxService.countUsersForLimit(accountId, UserLimitPolicy.SEATS_IN_USE)
        );

        accountEntitlementsGuard.assertCanCreateUser(accountId, currentUsers);

        return tenantExecutor.run(schema, () -> {
            TenantUser created = tenantUserTxService.createTenantUser(
                    accountId,
                    name,
                    email,
                    req.password(),
                    req.role(),
                    req.phone(),
                    req.avatarUrl(),
                    perms,
                    origin
            );

            return tenantUserApiMapper.toDetails(created);
        });
    }

    public List<TenantUserSummaryResponse> listTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () ->
                tenantUserTxService.listUsers(accountId)
                        .stream()
                        .map(tenantUserApiMapper::toSummary)
                        .toList()
        );
    }

    public List<TenantUserSummaryResponse> listEnabledTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () ->
                tenantUserTxService.listEnabledUsers(accountId)
                        .stream()
                        .map(tenantUserApiMapper::toSummary)
                        .toList()
        );
    }

    public TenantUserDetailsResponse getTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            TenantUser user = tenantUserTxService.getUser(userId, accountId);
            return tenantUserApiMapper.toDetails(user);
        });
    }

    public TenantUserSummaryResponse setTenantUserSuspendedByAdmin(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            tenantUserTxService.setSuspendedByAdmin(accountId, userId, suspended);
            TenantUser updated = tenantUserTxService.getUser(userId, accountId);
            return tenantUserApiMapper.toSummary(updated);
        });
    }
    
    
    public TenantUserSummaryResponse setTenantUserSuspendedByAccount(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            tenantUserTxService.setSuspendedByAccount(accountId, userId, suspended);
            TenantUser updated = tenantUserTxService.getUser(userId, accountId);
            return tenantUserApiMapper.toSummary(updated);
        });
    }


    public void softDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        tenantExecutor.run(schema, () -> tenantUserTxService.softDelete(userId, accountId));
    }

    public TenantUserSummaryResponse restoreTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            TenantUser restored = tenantUserTxService.restore(userId, accountId);
            return tenantUserApiMapper.toSummary(restored);
        });
    }

    public TenantUserSummaryResponse resetTenantUserPassword(Long userId, String newPassword) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            TenantUser updated = tenantUserTxService.resetPassword(userId, accountId, newPassword);
            return tenantUserApiMapper.toSummary(updated);
        });
    }

    public void hardDeleteTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        tenantExecutor.run(schema, () -> tenantUserTxService.hardDelete(userId, accountId));
    }

    // =========================================================
    // PASSWORD RESET (PUBLIC -> TENANT)
    // =========================================================

   public String generatePasswordResetToken(String slug, String email) {
    if (!StringUtils.hasText(slug)) throw new ApiException("INVALID_SLUG", "Slug é obrigatório", 400);
    if (!StringUtils.hasText(email)) throw new ApiException("INVALID_LOGIN", "Email é obrigatório", 400);

    AccountSnapshot account = accountResolver.resolveActiveAccountBySlug(slug);

    return tenantExecutor.run(account.schemaName(), () -> {
        TenantUser user = tenantUserTxService.getUserByEmail(email, account.id());

        if (user.isDeleted() || user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
            throw new ApiException("USER_INACTIVE", "Usuário inativo", 403);
        }

        String token = jwtTokenProvider.generatePasswordResetToken(
                user.getEmail(),
                account.schemaName(),
                account.id()
        );

        user.setPasswordResetToken(token);
        user.setPasswordResetExpires(appClock.now().plusHours(1));
        tenantUserTxService.save(user);

        return token;
    });
}


   public void resetPasswordWithToken(String token, String newPassword) {
    if (!StringUtils.hasText(token)) throw new ApiException("INVALID_TOKEN", "Token inválido", 400);
    if (!StringUtils.hasText(newPassword)) throw new ApiException("INVALID_PASSWORD", "Nova senha é obrigatória", 400);

    String schema = jwtTokenProvider.getTenantSchemaFromToken(token);
    Long accountId = jwtTokenProvider.getAccountIdFromToken(token);

    String email = jwtTokenProvider.getEmailFromToken(token);

    tenantExecutor.run(schema, () ->
            tenantUserTxService.resetPasswordWithToken(accountId, email, token, newPassword)
    );
}


    // =========================================================
    // MY PROFILE
    // =========================================================

    public TenantMeResponse updateMyProfile(UpdateMyProfileRequest req) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();
        Long userId = securityUtils.getCurrentUserId();

        return tenantExecutor.run(schema, () -> {
            TenantUser updated = tenantUserTxService.updateProfile(
                    userId,
                    accountId,
                    req.name(),
                    req.phone(),
                    req.locale(),
                    req.timezone(),
                    appClock.now()
            );
            return tenantUserApiMapper.toMe(updated);
        });
    }

    public TenantUserDetailsResponse getEnabledTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> {
            TenantUser user = tenantUserTxService.getEnabledUser(userId, accountId);
            return tenantUserApiMapper.toDetails(user);
        });
    }

    public long countEnabledTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        return tenantExecutor.run(schema, () -> tenantUserTxService.countEnabledUsersByAccount(accountId));
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/user/TenantUserTxService.java
============================================================
package brito.com.multitenancy001.tenant.application.user;

import brito.com.multitenancy001.shared.account.UserLimitPolicy;
import brito.com.multitenancy001.shared.api.error.ApiException;
import brito.com.multitenancy001.shared.executor.TxExecutor;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import brito.com.multitenancy001.tenant.domain.user.TenantUserOrigin;
import brito.com.multitenancy001.tenant.persistence.user.TenantUserRepository;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
public class TenantUserTxService {

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;
    private final TxExecutor txExecutor;

    // =========================================================
    // LIMITS / COUNTS
    // =========================================================

    public long countUsersForLimit(Long accountId, UserLimitPolicy policy) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);

        return txExecutor.tenantReadOnlyTx(() -> {
            if (policy == null) return tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);

            return switch (policy) {
                // “seats in use” normalmente ignora suspensões, mas ignora deletados
                case SEATS_IN_USE -> tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);

                // “enabled” = não deletado + não suspenso por admin/conta
                case SEATS_ENABLED -> tenantUserRepository.countEnabledUsersByAccount(accountId);

                default -> tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);
            };
        });
    }

    public long countEnabledUsersByAccount(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        return txExecutor.tenantReadOnlyTx(() -> tenantUserRepository.countEnabledUsersByAccount(accountId));
    }

    // =========================================================
    // CREATE
    // =========================================================

    public TenantUser createTenantUser(
            Long accountId,
            String name,
            String email,
            String rawPassword,
            TenantRole role,
            String phone,
            String avatarUrl,
            LinkedHashSet<String> permissionNames,
            TenantUserOrigin origin
    ) {
        return txExecutor.tenantTx(() -> {

            if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
            if (!StringUtils.hasText(name)) throw new ApiException("INVALID_NAME", "Nome é obrigatório", 400);
            if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);
            if (!StringUtils.hasText(rawPassword)) throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);
            if (role == null) throw new ApiException("INVALID_ROLE", "Role é obrigatória", 400);

            String normEmail = email.trim().toLowerCase();

            if (!normEmail.matches(ValidationPatterns.EMAIL_PATTERN)) {
                throw new ApiException("INVALID_EMAIL", "Email inválido", 400);
            }
            if (!rawPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
                throw new ApiException("WEAK_PASSWORD", "Senha fraca", 400);
            }

            boolean exists = tenantUserRepository.existsByEmailAndAccountId(normEmail, accountId);
            if (exists) {
                throw new ApiException("EMAIL_ALREADY_EXISTS", "Email já cadastrado nesta conta", 409);
            }

            TenantUser user = new TenantUser();
            user.setAccountId(accountId);
            user.setName(name.trim());
            user.setEmail(normEmail);
            user.setPassword(passwordEncoder.encode(rawPassword));
            user.setRole(role);

            user.setOrigin(origin == null ? TenantUserOrigin.ADMIN : origin);

            user.setPhone(StringUtils.hasText(phone) ? phone.trim() : null);
            user.setAvatarUrl(StringUtils.hasText(avatarUrl) ? avatarUrl.trim() : null);

            user.setSuspendedByAccount(false);
            user.setSuspendedByAdmin(false);

            // Permissões: base da role + extras desejadas
            Set<TenantPermission> base = new LinkedHashSet<>(TenantRolePermissions.permissionsFor(role));
            Set<TenantPermission> desired = new LinkedHashSet<>();

            if (permissionNames != null && !permissionNames.isEmpty()) {
                for (String p : permissionNames) {
                    if (!StringUtils.hasText(p)) continue;
                    try {
                        desired.add(TenantPermission.valueOf(p.trim()));
                    } catch (IllegalArgumentException ex) {
                        throw new ApiException("INVALID_PERMISSION", "Permissão inválida: " + p, 400);
                    }
                }
            }

            desired = PermissionScopeValidator.validateTenantPermissionsStrict(desired);

            Set<TenantPermission> finalPerms = new LinkedHashSet<>(base);
            finalPerms.addAll(desired);

            user.setPermissions(finalPerms);

            // defaults
            if (!StringUtils.hasText(user.getLocale())) user.setLocale("pt_BR");
            if (!StringUtils.hasText(user.getTimezone())) user.setTimezone("America/Sao_Paulo");

            return tenantUserRepository.save(user);
        });
    }

    // =========================================================
    // READ / LIST
    // =========================================================

    public TenantUser getUser(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        return txExecutor.tenantReadOnlyTx(() ->
                tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                        .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404))
        );
    }

    public TenantUser getEnabledUser(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        return txExecutor.tenantReadOnlyTx(() ->
                tenantUserRepository.findEnabledByIdAndAccountId(userId, accountId)
                        .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário habilitado não encontrado", 404))
        );
    }

    public TenantUser getUserByEmail(String email, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (!StringUtils.hasText(email)) throw new ApiException("INVALID_EMAIL", "Email é obrigatório", 400);

        String normEmail = email.trim().toLowerCase();

        return txExecutor.tenantReadOnlyTx(() ->
                tenantUserRepository.findByEmailAndAccountIdAndDeletedFalse(normEmail, accountId)
                        .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404))
        );
    }

    public List<TenantUser> listUsers(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);

        return txExecutor.tenantReadOnlyTx(() ->
                tenantUserRepository.findByAccountIdAndDeletedFalse(accountId)
        );
    }

    public List<TenantUser> listEnabledUsers(Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);

        return txExecutor.tenantReadOnlyTx(() ->
                tenantUserRepository.findEnabledUsersByAccount(accountId)
        );
    }

    // =========================================================
    // UPDATE: STATUS / PROFILE / PASSWORD
    // =========================================================

    public void setSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        txExecutor.tenantTx(() -> {
            int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
            if (updated == 0) throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404);
        });
    }

    public void setSuspendedByAccount(Long accountId, Long userId, boolean suspended) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        txExecutor.tenantTx(() -> {
            int updated = tenantUserRepository.setSuspendedByAccount(accountId, userId, suspended);
            if (updated == 0) throw new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404);
        });
    }

    public TenantUser updateProfile(
            Long userId,
            Long accountId,
            String name,
            String phone,
            String locale,
            String timezone,
            LocalDateTime now
    ) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        return txExecutor.tenantTx(() -> {
            TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            if (StringUtils.hasText(name)) user.setName(name.trim());
            if (StringUtils.hasText(phone)) user.setPhone(phone.trim());
            if (StringUtils.hasText(locale)) user.setLocale(locale.trim());
            if (StringUtils.hasText(timezone)) user.setTimezone(timezone.trim());

            // now é usado só se você quiser setar algo manualmente.
            // updated_at já é UpdateTimestamp.
            return tenantUserRepository.save(user);
        });
    }

    public TenantUser resetPassword(Long userId, Long accountId, String newPassword) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);

        if (!newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("WEAK_PASSWORD", "Senha fraca", 400);
        }

        return txExecutor.tenantTx(() -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            LocalDateTime now = appClock.now();

            user.setPassword(passwordEncoder.encode(newPassword));
            user.setMustChangePassword(false);
            user.setPasswordChangedAt(now);
            user.setPasswordResetToken(null);
            user.setPasswordResetExpires(null);

            return tenantUserRepository.save(user);
        });
    }

    public void resetPasswordWithToken(Long accountId, String email, String token, String newPassword) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (!StringUtils.hasText(token)) throw new ApiException("TOKEN_REQUIRED", "token é obrigatório", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException("INVALID_PASSWORD", "Senha é obrigatória", 400);

        if (!newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException("WEAK_PASSWORD", "Senha fraca", 400);
        }

        txExecutor.tenantTx(() -> {
            TenantUser user = tenantUserRepository.findByPasswordResetTokenAndAccountId(token, accountId)
                    .orElseThrow(() -> new ApiException("TOKEN_INVALID", "Token inválido", 400));

            LocalDateTime now = appClock.now();

            if (user.getPasswordResetExpires() == null || user.getPasswordResetExpires().isBefore(now)) {
                throw new ApiException("TOKEN_EXPIRED", "Token expirado", 400);
            }

            // Compat/segurança: se veio email no token, confere
            if (StringUtils.hasText(email) && user.getEmail() != null) {
                String tokenLogin = email.trim().toLowerCase();
                if (!user.getEmail().trim().equalsIgnoreCase(tokenLogin)) {
                    throw new ApiException("TOKEN_INVALID", "Token inválido", 400);
                }
            }

            user.setPassword(passwordEncoder.encode(newPassword));
            user.setMustChangePassword(false);
            user.setPasswordChangedAt(now);

            user.setPasswordResetToken(null);
            user.setPasswordResetExpires(null);

            tenantUserRepository.save(user);
        });
    }

    // =========================================================
    // DELETE / RESTORE
    // =========================================================

    public void softDelete(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        txExecutor.tenantTx(() -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            if (user.isDeleted()) return;

            LocalDateTime now = appClock.now();
            user.softDelete(now, System.currentTimeMillis());
            tenantUserRepository.save(user);
        });
    }

    public TenantUser restore(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        return txExecutor.tenantTx(() -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            user.restore();
            return tenantUserRepository.save(user);
        });
    }

    public void hardDelete(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException("USER_REQUIRED", "userId é obrigatório", 400);

        txExecutor.tenantTx(() -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário não encontrado", 404));

            tenantUserRepository.delete(user);
        });
    }

    public TenantUser save(TenantUser user) {
        if (user == null) throw new ApiException("INVALID_REQUEST", "Usuário inválido", 400);
        return txExecutor.tenantTx(() -> tenantUserRepository.save(user));
    }

    // =========================================================
    // ROLE TRANSFER (OWNER)
    // =========================================================

    public void transferTenantOwnerRole(Long accountId, Long fromUserId, Long toUserId) {
        if (accountId == null) throw new ApiException("ACCOUNT_REQUIRED", "accountId é obrigatório", 400);
        if (fromUserId == null) throw new ApiException("FROM_USER_REQUIRED", "fromUserId é obrigatório", 400);
        if (toUserId == null) throw new ApiException("TO_USER_REQUIRED", "toUserId é obrigatório", 400);
        if (fromUserId.equals(toUserId)) {
            throw new ApiException("INVALID_TRANSFER", "Não é possível transferir para si mesmo", 400);
        }

        txExecutor.tenantTx(() -> {
            TenantUser from = tenantUserRepository.findEnabledByIdAndAccountId(fromUserId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário origem não encontrado/habilitado", 404));

            if (from.getRole() == null || !from.getRole().isTenantOwner()) {
                throw new ApiException("FORBIDDEN", "Apenas o TENANT_OWNER pode transferir", 403);
            }

            TenantUser to = tenantUserRepository.findEnabledByIdAndAccountId(toUserId, accountId)
                    .orElseThrow(() -> new ApiException("USER_NOT_FOUND", "Usuário destino não encontrado/habilitado", 404));

            // troca roles
            from.setRole(TenantRole.TENANT_ADMIN);
            to.setRole(TenantRole.TENANT_OWNER);

            // zera permissões custom e volta base do papel (evita “herdar” extras indevidos)
            from.setPermissions(new LinkedHashSet<>(TenantRolePermissions.permissionsFor(from.getRole())));
            to.setPermissions(new LinkedHashSet<>(TenantRolePermissions.permissionsFor(to.getRole())));

            tenantUserRepository.save(from);
            tenantUserRepository.save(to);
        });
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/application/user/admin/TenantUserAdminService.java
============================================================
package brito.com.multitenancy001.tenant.application.user.admin;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.tenant.application.user.TenantUserTxService;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantUserAdminService {

    private final TenantUserTxService tenantUserTxService;
    private final SecurityUtils securityUtils;
    private final TenantExecutor tenantExecutor;

    public void setUserSuspendedByAdmin(Long userId, boolean suspended) {
        Long accountId = securityUtils.getCurrentAccountId();
        String schema = securityUtils.getCurrentSchema();

        tenantExecutor.run(schema, () -> {
            tenantUserTxService.setSuspendedByAdmin(accountId, userId, suspended);
            return null;
        });
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/category/Category.java
============================================================
package brito.com.multitenancy001.tenant.domain.category;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "categories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_categories_name",
                columnNames = "name"
        )
)
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
public class Category implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Embedded
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/category/Subcategory.java
============================================================
package brito.com.multitenancy001.tenant.domain.category;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(
        name = "subcategories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_subcategories_name_category",
                columnNames = {"category_id", "name"}
        )
)
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
public class Subcategory implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_subcategories_category")
    )
    private Category category;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Embedded
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() { return audit; }

    @Override
    public boolean isDeleted() { return deleted; }

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/product/Product.java
============================================================
package brito.com.multitenancy001.tenant.domain.product;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;
import brito.com.multitenancy001.tenant.domain.category.Category;
import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "products")
@EntityListeners(AuditEntityListener.class)

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"supplier", "category", "subcategory"})
public class Product implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(length = 100, nullable = false)
    private String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    @Builder.Default
    private Integer stockQuantity = 0;

    @Column(name = "min_stock")
    private Integer minStock;

    @Column(name = "max_stock")
    private Integer maxStock;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    @Column(name = "profit_margin", precision = 5, scale = 2)
    private BigDecimal profitMargin;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_products_category")
    )
    private Category category;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
            name = "subcategory_id",
            foreignKey = @ForeignKey(name = "fk_products_subcategory")
    )
    private Subcategory subcategory;

    @Column(name = "brand", length = 100)
    private String brand;

    @Column(name = "weight_kg", precision = 8, scale = 3)
    private BigDecimal weightKg;

    @Column(name = "dimensions", length = 50)
    private String dimensions;

    @Column(name = "barcode", length = 50)
    private String barcode;

    @Column(name = "active", nullable = false)
    @Builder.Default
    private Boolean active = true;

    @Column(name = "images_json", columnDefinition = "TEXT")
    private String imagesJson;

    @Column(name = "attributes_json", columnDefinition = "TEXT")
    private String attributesJson;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", foreignKey = @ForeignKey(name = "fk_product_supplier"))
    private Supplier supplier;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private Boolean deleted = false;

    @PrePersist
    protected void onCreate() {
        if (this.stockQuantity == null) this.stockQuantity = 0;
        if (this.active == null) this.active = true;
        if (this.deleted == null) this.deleted = false;
        calculateProfitMargin();
    }

    @PreUpdate
    protected void onUpdate() {
        calculateProfitMargin();
    }
    
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return Boolean.TRUE.equals(deleted);
    }


    private void calculateProfitMargin() {
        if (this.costPrice != null && this.costPrice.compareTo(BigDecimal.ZERO) > 0 && this.price != null) {
            BigDecimal profit = this.price.subtract(this.costPrice);

            // % = (profit / cost) * 100
            BigDecimal percent = profit
                    .divide(this.costPrice, 6, RoundingMode.HALF_UP)
                    .multiply(BigDecimal.valueOf(100));

            // ✅ alinha com NUMERIC(5,2)
            this.profitMargin = percent.setScale(2, RoundingMode.HALF_UP);
        } else {
            this.profitMargin = null;
        }
    }

    // =====================
    // Regras de domínio
    // =====================

    public void softDelete(LocalDateTime now) {
        if (Boolean.TRUE.equals(this.deleted)) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!Boolean.TRUE.equals(this.deleted)) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }

    public void updatePrice(BigDecimal newPrice) {
        if (newPrice == null || newPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Preço inválido");
        }
        this.price = newPrice;
        calculateProfitMargin();
    }

    public void updateCostPrice(BigDecimal newCostPrice) {
        this.costPrice = newCostPrice;
        calculateProfitMargin();
    }

    public void addToStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;
        this.stockQuantity += quantity;
    }

    public void removeFromStock(Integer quantity) {
        if (quantity == null || quantity <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }
        if (this.stockQuantity == null) this.stockQuantity = 0;

        if (this.stockQuantity < quantity) {
            throw new IllegalStateException("Estoque insuficiente. Disponível: " + this.stockQuantity);
        }
        this.stockQuantity -= quantity;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/sale/Sale.java
============================================================
package brito.com.multitenancy001.tenant.domain.sale;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "sales", indexes = {
        @Index(name = "idx_sales_sale_date", columnList = "sale_date"),
        @Index(name = "idx_sales_status", columnList = "status")
})
@EntityListeners(AuditEntityListener.class)

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "items")
public class Sale implements Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    @Column(name = "sale_date", nullable = false)
    private LocalDateTime saleDate;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "customer_name", length = 200)
    private String customerName;

    @Column(name = "customer_document", length = 20)
    private String customerDocument;

    @Column(name = "customer_email", length = 150)
    private String customerEmail;

    @Column(name = "customer_phone", length = 20)
    private String customerPhone;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private SaleStatus status;

    @OneToMany(
            mappedBy = "sale",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            orphanRemoval = true,
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<SaleItem> items = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

 


    public void addItem(SaleItem item) {
        if (item == null) return;
        item.setSale(this);
        this.items.add(item);
        recalcTotal();
    }

    public void removeItem(SaleItem item) {
        if (item == null) return;
        this.items.remove(item);
        item.setSale(null);
        recalcTotal();
    }

    public void recalcTotal() {
        BigDecimal sum = BigDecimal.ZERO;
        for (SaleItem it : items) {
            if (it.getTotalPrice() != null) {
                sum = sum.add(it.getTotalPrice());
            }
        }
        this.totalAmount = sum;
    }

    public void cancel() {
        this.status = SaleStatus.CANCELLED;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/sale/SaleItem.java
============================================================
package brito.com.multitenancy001.tenant.domain.sale;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.util.UUID;

@Entity
@Table(name = "sale_items", indexes = {
        @Index(name = "idx_sale_items_sale_id", columnList = "sale_id"),
        @Index(name = "idx_sale_items_product_id", columnList = "product_id")
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "sale")
public class SaleItem implements Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "sale_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_sale_items_sale")
    )
    private Sale sale;

    // Sem FK para products. Referência fraca (histórico)
    @Column(name = "product_id")
    private UUID productId;

    // Snapshot obrigatório do produto no momento da venda
    @Column(name = "product_name", nullable = false, length = 255)
    private String productName;

    @Column(name = "quantity", nullable = false, precision = 12, scale = 3)
    private BigDecimal quantity;

    @Column(name = "unit_price", nullable = false, precision = 12, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_price", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalPrice;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    public void recalcTotal() {
        if (quantity == null || unitPrice == null) {
            this.totalPrice = BigDecimal.ZERO;
            return;
        }
        this.totalPrice = unitPrice.multiply(quantity);
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/sale/SaleStatus.java
============================================================
package brito.com.multitenancy001.tenant.domain.sale;


public enum SaleStatus {
    DRAFT,
    CONFIRMED,
    PAID,
    CANCELLED
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/supplier/Supplier.java
============================================================
package brito.com.multitenancy001.tenant.domain.supplier;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;
import brito.com.multitenancy001.tenant.domain.product.Product;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "suppliers", indexes = {
        @Index(name = "idx_supplier_name", columnList = "name"),
        @Index(name = "idx_supplier_email", columnList = "email")
        // NÃO declare unique index de document aqui (é parcial no DB)
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"products"})
public class Supplier implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", updatable = false, nullable = false)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(name = "contact_person", length = 100)
    private String contactPerson;

    @Column(length = 150)
    private String email;

    @Column(length = 20)
    private String phone;

    @Column(columnDefinition = "TEXT")
    private String address;

    @Column(length = 20)
    private String document;

    @Column(name = "document_type", length = 10)
    private String documentType;

    @Column(name = "website", length = 200)
    private String website;

    @Column(name = "payment_terms", length = 100)
    private String paymentTerms;

    @Column(name = "lead_time_days")
    private Integer leadTimeDays;

    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating;

    @Builder.Default
    @Column(name = "active", nullable = false)
    private boolean active = true;

    @Builder.Default
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @OneToMany(
            mappedBy = "supplier",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<Product> products = new ArrayList<>();

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return Boolean.TRUE.equals(deleted);
    }


    // =====================
    // Regras de domínio
    // =====================

    public void softDelete(LocalDateTime now) {
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.deletedAt = now;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.deletedAt = null;
        this.active = true;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/user/TenantUser.java
============================================================
package brito.com.multitenancy001.tenant.domain.user;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.persistence.audit.AuditEntityListener;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import jakarta.persistence.*;
import jakarta.validation.constraints.Pattern;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.DynamicUpdate;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.LinkedHashSet;
import java.util.Set;

@DynamicUpdate
@Entity
@Table(
    name = "tenant_users",
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_tenant_users_email_account", columnNames = {"email", "account_id"})
    }
)
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "password")
public class TenantUser implements Auditable, SoftDeletable {

    private static final int EMAIL_MAX_LEN = 150;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "user_origin", nullable = false, length = 20)
    @Builder.Default
    private TenantUserOrigin origin = TenantUserOrigin.ADMIN;

    public boolean isBuiltInUser() {
        return this.origin == TenantUserOrigin.BUILT_IN;
    }

    @Column(name = "password_reset_token", length = 255)
    private String passwordResetToken;

    @Column(name = "password_reset_expires")
    private LocalDateTime passwordResetExpires;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = EMAIL_MAX_LEN)
    @Pattern(regexp = ValidationPatterns.EMAIL_PATTERN, message = "Email inválido.")
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private TenantRole role;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
            name = "tenant_user_permissions",
            joinColumns = @JoinColumn(name = "tenant_user_id")
    )
    @Enumerated(EnumType.STRING)
    @Column(name = "permission", nullable = false, length = 120)
    @Builder.Default
    private Set<TenantPermission> permissions = new LinkedHashSet<>();

    @Column(name = "last_login")
    private LocalDateTime lastLogin;

    @Column(name = "failed_login_attempts", nullable = false)
    @Builder.Default
    private int failedLoginAttempts = 0;

    @Column(name = "locked_until")
    private LocalDateTime lockedUntil;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private boolean mustChangePassword = false;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    @Column(name = "timezone", nullable = false, length = 60)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(name = "locale", nullable = false, length = 20)
    @Builder.Default
    private String locale = "pt_BR";

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @PrePersist
    @PreUpdate
    protected void onSave() {
        if (origin == null) origin = TenantUserOrigin.ADMIN;
        if (role == null) throw new IllegalStateException("Role is required");

        if (permissions == null) {
            permissions = new LinkedHashSet<>();
        }

        if (email != null) email = email.toLowerCase().trim();

        if (permissions.isEmpty()) {
            permissions.addAll(TenantRolePermissions.permissionsFor(role));
        }

        var normalized = PermissionScopeValidator.normalizeTenantPermissions(permissions);

        if (!permissions.equals(normalized)) {
            permissions.clear();
            permissions.addAll(normalized);
        }
    }

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() { return audit; }

    @Override
    public boolean isDeleted() { return deleted; }

    public boolean isAccountNonLocked(LocalDateTime now) {
        return lockedUntil == null || !lockedUntil.isAfter(now);
    }

    public boolean isEnabledForLogin() {
        return isEnabled();
    }

    public boolean isEnabledForLogin(LocalDateTime now) {
        return isEnabledForLogin() && isAccountNonLocked(now);
    }

    public void softDelete(LocalDateTime now, long suffixEpochMillis) {
        if (deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        deleted = true;
        deletedAt = now;

        suspendedByAccount = true;
        suspendedByAdmin = true;

        // liberar unique(email, account_id)
        String ts = String.valueOf(suffixEpochMillis);
        String newEmail = "deleted_" + (email == null ? "user" : email) + "_" + ts;
        if (newEmail.length() > EMAIL_MAX_LEN) newEmail = newEmail.substring(0, EMAIL_MAX_LEN);
        email = newEmail;
    }

    public void restore() {
        if (!deleted) return;

        deleted = false;
        deletedAt = null;
        suspendedByAdmin = false;
        // não altera suspendedByAccount aqui
    }

    public boolean isEnabled() {
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    public boolean isNotDeleted() {
        return !deleted;
    }

    public boolean isSuspended() {
        return suspendedByAccount || suspendedByAdmin;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/domain/user/TenantUserOrigin.java
============================================================
package brito.com.multitenancy001.tenant.domain.user;

public enum TenantUserOrigin {
    BUILT_IN,
    ADMIN,
    API
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/persistence/category/TenantCategoryRepository.java
============================================================
package brito.com.multitenancy001.tenant.persistence.category;

import brito.com.multitenancy001.tenant.domain.category.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantCategoryRepository extends JpaRepository<Category, Long> {

    // =========
    // Normal (default): NÃO retorna deletados
    // =========

    @Query("select c from Category c where c.deleted = false order by c.name asc")
    List<Category> findNotDeleted();

    @Query("select c from Category c where c.deleted = false and c.active = true order by c.name asc")
    List<Category> findNotDeletedActive();

    @Query("select c from Category c where c.deleted = false and lower(c.name) = lower(:name)")
    Optional<Category> findNotDeletedByNameIgnoreCase(@Param("name") String name);

    @Query("select c from Category c where c.deleted = false and lower(c.name) like lower(concat('%', :name, '%')) order by c.name asc")
    List<Category> findNotDeletedByNameContainingIgnoreCase(@Param("name") String name);

    // =========
    // Admin: flags (includeDeleted / includeInactive)
    // =========

    @Query("""
           select c from Category c
           where (:includeDeleted = true or c.deleted = false)
             and (:includeInactive = true or c.active = true)
           order by c.name asc
           """)
    List<Category> findWithFlags(@Param("includeDeleted") boolean includeDeleted,
                                 @Param("includeInactive") boolean includeInactive);
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/persistence/category/TenantSubcategoryRepository.java
============================================================
package brito.com.multitenancy001.tenant.persistence.category;

import brito.com.multitenancy001.tenant.domain.category.Subcategory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantSubcategoryRepository extends JpaRepository<Subcategory, Long> {

    @Query("select s from Subcategory s join fetch s.category where s.id = :id")
    Optional<Subcategory> findByIdWithCategory(@Param("id") Long id);

    // =========
    // Default: NÃO retorna deletados
    // =========

    @Query("""
           select s from Subcategory s
           where s.deleted = false
           order by s.name asc
           """)
    List<Subcategory> findNotDeleted();

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.active = true
           order by s.name asc
           """)
    List<Subcategory> findActiveNotDeleted();

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.category.id = :categoryId
           order by s.name asc
           """)
    List<Subcategory> findNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.active = true and s.category.id = :categoryId
           order by s.name asc
           """)
    List<Subcategory> findActiveNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
           select s from Subcategory s
           where s.deleted = false
             and s.category.id = :categoryId
             and lower(s.name) = lower(:name)
           """)
    Optional<Subcategory> findNotDeletedByCategoryIdAndNameIgnoreCase(@Param("categoryId") Long categoryId,
                                                                      @Param("name") String name);

    // =========
    // Admin: flags (includeDeleted / includeInactive)
    // =========

    @Query("""
           select s from Subcategory s
           where s.category.id = :categoryId
             and (:includeDeleted = true or s.deleted = false)
             and (:includeInactive = true or s.active = true)
           order by s.name asc
           """)
    List<Subcategory> findByCategoryWithFlags(@Param("categoryId") Long categoryId,
                                              @Param("includeDeleted") boolean includeDeleted,
                                              @Param("includeInactive") boolean includeInactive);
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/persistence/product/TenantProductRepository.java
============================================================
package brito.com.multitenancy001.tenant.persistence.product;

import brito.com.multitenancy001.tenant.domain.product.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface TenantProductRepository extends JpaRepository<Product, UUID> {

    // =========================================================
    // ✅ "CATÁLOGO": SOMENTE ATIVOS E NÃO DELETADOS
    // =========================================================

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND LOWER(p.brand) = LOWER(:brand)
        """)
    List<Product> findActiveNotDeletedByBrandIgnoreCase(@Param("brand") String brand);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.category.id = :categoryId
        """)
    List<Product> findActiveNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.subcategory.id = :subcategoryId
        """)
    List<Product> findActiveNotDeletedBySubcategoryId(@Param("subcategoryId") Long subcategoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.deleted = false
          AND p.active = true
          AND p.category.id = :categoryId
          AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
        """)
    List<Product> findActiveNotDeletedByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
                                                                      @Param("subcategoryId") Long subcategoryId);

    // ✅ seu endpoint /active
    List<Product> findByActiveTrueAndDeletedFalse();

    // =========================================================
    // EXISTENTES (mantidos)
    // =========================================================

   
    List<Product> findByCategory_Id(Long categoryId);

    List<Product> findBySubcategory_Id(Long subcategoryId);

    @Query("""
        SELECT p FROM Product p
        WHERE p.category.id = :categoryId
          AND (:subcategoryId IS NULL OR p.subcategory.id = :subcategoryId)
        """)
    List<Product> findByCategoryAndOptionalSubcategory(@Param("categoryId") Long categoryId,
                                                      @Param("subcategoryId") Long subcategoryId);

    List<Product> findByNameContainingIgnoreCase(String name);

    Optional<Product> findBySku(String sku);

    List<Product> findByStockQuantityLessThan(Integer quantity);

    List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

    List<Product> findBySupplier_Id(UUID supplierId);

    Page<Product> findByNameContainingIgnoreCase(String name, Pageable pageable);

    @Query("""
        SELECT p FROM Product p WHERE
            (:name IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :name, '%'))) AND
            (:minPrice IS NULL OR p.price >= :minPrice) AND
            (:maxPrice IS NULL OR p.price <= :maxPrice) AND
            (:minStock IS NULL OR p.stockQuantity >= :minStock) AND
            (:maxStock IS NULL OR p.stockQuantity <= :maxStock)
        """)
    List<Product> searchProducts(@Param("name") String name,
                                 @Param("minPrice") BigDecimal minPrice,
                                 @Param("maxPrice") BigDecimal maxPrice,
                                 @Param("minStock") Integer minStock,
                                 @Param("maxStock") Integer maxStock);

    List<Product> findByNameContainingIgnoreCaseAndPriceBetweenAndStockQuantityBetween(
            String name,
            BigDecimal minPrice,
            BigDecimal maxPrice,
            Integer minStock,
            Integer maxStock
    );

    @Query("SELECT COUNT(p) FROM Product p WHERE p.stockQuantity <= :threshold")
    Long countLowStock(@Param("threshold") Integer threshold);

    @Query("SELECT SUM(p.stockQuantity * p.price) FROM Product p")
    BigDecimal calculateTotalInventoryValue();

    @Query("SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id")
    List<Object[]> countProductsBySupplier();
    
    @Query("""
    	    SELECT p FROM Product p
    	    WHERE (:includeDeleted = true OR p.deleted = false)
    	      AND (:includeInactive = true OR p.active = true)
    	      AND p.category.id = :categoryId
    	    """)
    	List<Product> findByCategoryWithFlags(@Param("categoryId") Long categoryId,
    	                                     @Param("includeDeleted") boolean includeDeleted,
    	                                     @Param("includeInactive") boolean includeInactive);
   
    
    // =========================================================
    // ANY (admin/relatórios internos) ⚠️ pode incluir deleted/inactive
    // =========================================================

    /**
     * ⚠️ Pode incluir deleted/inactive.
     * Use apenas para telas/admin/relatórios internos.
     * Para catálogo público use findActiveNotDeleted*.
     */
    List<Product> findAnyByBrandIgnoreCase(String brand);


    
    

}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/persistence/supplier/TenantSupplierRepository.java
============================================================
package brito.com.multitenancy001.tenant.persistence.supplier;

import brito.com.multitenancy001.tenant.domain.supplier.Supplier;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface TenantSupplierRepository extends JpaRepository<Supplier, UUID> {

	// =========================
	// FINDs "crus" (podem incluir deletados) - mantenho, mas no service vamos usar
	// os "ativos/notDeleted"
	// =========================
	

	 @Query("SELECT s FROM Supplier s WHERE s.deleted = false ORDER BY s.name ASC")
	    List<Supplier> findNotDeleted();

	    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND LOWER(s.name) LIKE LOWER(CONCAT('%', :name, '%')) ORDER BY s.name ASC")
	    List<Supplier> findNotDeletedByNameContainingIgnoreCase(@Param("name") String name);

	    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND s.email = :email ORDER BY s.name ASC")
	    List<Supplier> findNotDeletedByEmail(@Param("email") String email);
	
	List<Supplier> findByNameContainingIgnoreCase(String name);

	// =========================
	// RECOMENDADO: queries usadas pelos endpoints (não-deletados)
	// =========================

	
	@Query("""
			SELECT s FROM Supplier s
			WHERE s.deleted = false
			  AND s.document IS NOT NULL
			  AND TRIM(s.document) <> ''
			  AND LOWER(TRIM(s.document)) = LOWER(TRIM(:document))
			""")
	Optional<Supplier> findNotDeletedByDocumentIgnoreCase(@Param("document") String document);

	@Query("SELECT s FROM Supplier s WHERE s.deleted = false AND s.active = true ORDER BY s.name ASC")
	List<Supplier> findActiveNotDeleted();
	
 
    
    // =========================================================
    // ANY (admin/relatórios internos) ⚠️ pode incluir deleted/inactive
    // =========================================================

    /**
     * ⚠️ Pode incluir deleted/inactive.
     * Prefira findNotDeletedByEmail / findActiveNotDeleted quando for regra normal.
     */
    List<Supplier> findAnyByEmail(String email);

   



}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/persistence/user/TenantUserRepository.java
============================================================
package brito.com.multitenancy001.tenant.persistence.user;

import brito.com.multitenancy001.tenant.domain.user.TenantUser;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface TenantUserRepository extends JpaRepository<TenantUser, Long> {

    // =========================================================
    // LOGIN / IDENTIDADE (email)
    // =========================================================

    Optional<TenantUser> findByEmailAndDeletedFalse(String email);



    Optional<TenantUser> findByEmailAndAccountIdAndDeletedFalse(String email, Long accountId);

    boolean existsByEmailAndAccountId(String email, Long accountId);



    // =========================================================
    // PASSWORD RESET
    // =========================================================

    Optional<TenantUser> findByPasswordResetTokenAndAccountId(String passwordResetToken, Long accountId);

    // =========================================================
    // LISTS
    // =========================================================

    List<TenantUser> findByAccountId(Long accountId);

    List<TenantUser> findByAccountIdAndDeletedFalse(Long accountId);

    /**
     * Enabled = NOT deleted + NOT suspendedByAccount + NOT suspendedByAdmin
     */
    List<TenantUser> findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(Long accountId);

    /**
     * Alias legível (evita nome gigante espalhado no projeto).
     */
    default List<TenantUser> findEnabledUsersByAccount(Long accountId) {
        return findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId);
    }

    // =========================================================
    // COUNTS / LIMITS
    // =========================================================

    long countByAccountIdAndDeletedFalse(Long accountId);

    long countByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(Long accountId);

    default long countEnabledUsersByAccount(Long accountId) {
        return countByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId);
    }

    // =========================================================
    // SCOPED ID (READ)
    // =========================================================

    /**
     * DEFAULT (NotDeleted): leitura normal do domínio.
     */
    Optional<TenantUser> findByIdAndAccountIdAndDeletedFalse(Long id, Long accountId);

    /**
     * DEFAULT (Enabled): login/uso ativo.
     */
    @Query("""
        select u from TenantUser u
        where u.id = :id
          and u.accountId = :accountId
          and u.deleted = false
          and u.suspendedByAccount = false
          and u.suspendedByAdmin = false
    """)
    Optional<TenantUser> findEnabledByIdAndAccountId(
            @Param("id") Long id,
            @Param("accountId") Long accountId
    );

    /**
     * ⚠️ Inclui soft-deleted. Use apenas para auditoria/suporte/restore.
     */
    @Query("""
        select u from TenantUser u
        where u.id = :id
          and u.accountId = :accountId
    """)
    Optional<TenantUser> findIncludingDeletedByIdAndAccountId(
            @Param("id") Long id,
            @Param("accountId") Long accountId
    );

    /**
     * Alias (mesma coisa do findIncludingDeletedByIdAndAccountId).
     * Mantido se houver código chamando "findAny...".
     */
    default Optional<TenantUser> findAnyByIdAndAccountId(Long id, Long accountId) {
        return findIncludingDeletedByIdAndAccountId(id, accountId);
    }

    // =========================================================
    // UPDATE: SUSPENSÕES
    // =========================================================

    /**
     * Suspende/Reativa por ADMIN (1 usuário) - não mexe em suspendedByAccount.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAdmin = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAdmin(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

    /**
     * Suspende/Reativa por CONTA (1 usuário) - não mexe em suspendedByAdmin.
     * ✅ Este método é necessário porque o TenantUserTxService chama ele.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAccount(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

    /**
     * Suspende TODOS por CONTA (bulk) - não mexe em suspendedByAdmin.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = true
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int suspendAllByAccount(@Param("accountId") Long accountId);

    /**
     * Reativa TODOS por CONTA (bulk) - não mexe em suspendedByAdmin.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = false
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int unsuspendAllByAccount(@Param("accountId") Long accountId);

    // =========================================================
    // UPDATE: SOFT DELETE / RESTORE (bulk)
    // =========================================================

    /**
     * Soft-delete em massa por conta.
     * ✅ Necessário porque o TenantUserProvisioningFacade chama este método.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.deleted = true,
               u.deletedAt = :deletedAt
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int softDeleteAllByAccount(
            @Param("accountId") Long accountId,
            @Param("deletedAt") LocalDateTime deletedAt
    );

    /**
     * Restore em massa por conta.
     * ✅ Necessário porque o TenantUserProvisioningFacade chama este método.
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Transactional
    @Query("""
        update TenantUser u
           set u.deleted = false,
               u.deletedAt = null
         where u.accountId = :accountId
           and u.deleted = true
    """)
    int restoreAllByAccount(@Param("accountId") Long accountId);
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/security/TenantPermission.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.PermissionCode;

/**
 * Padrão: TODA permissão de tenant deve iniciar com TEN_
 */
public enum TenantPermission implements PermissionCode {

    TEN_USER_READ,
    TEN_USER_CREATE,
    TEN_USER_UPDATE,
    TEN_USER_SUSPEND,
    TEN_USER_RESTORE,
    TEN_USER_DELETE,

    TEN_ROLE_TRANSFER,

    TEN_PRODUCT_READ,
    TEN_PRODUCT_WRITE,

    TEN_CATEGORY_READ,
    TEN_CATEGORY_WRITE,

    TEN_SUPPLIER_READ,
    TEN_SUPPLIER_WRITE,

    TEN_SALE_READ,
    TEN_SALE_WRITE,
    TEN_SALE_ISSUES_READ,
    TEN_SALE_ISSUES_WRITE,

    TEN_REPORT_SALES_READ,

    TEN_BILLING_READ,
    TEN_BILLING_WRITE,

    TEN_SETTINGS_READ,
    TEN_SETTINGS_WRITE,

    TEN_INVENTORY_READ,
    TEN_INVENTORY_WRITE;

    @Override
    public String asAuthority() {
        return name();
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/security/TenantRole.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum TenantRole implements RoleAuthority {

    TENANT_OWNER,
    TENANT_ADMIN,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isTenantOwner() {
        return this == TENANT_OWNER;
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/security/TenantRoleMapper.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Mapper local do contexto Tenant.
 * Aqui o Tenant conhece o shared contract, mas o shared não conhece o Tenant.
 */
public final class TenantRoleMapper {

    private TenantRoleMapper() {}

    public static TenantRole toTenantRole(TenantRoleName roleName) {
        if (roleName == null) return null;
        return TenantRole.valueOf(roleName.name());
    }

    public static TenantRoleName toRoleName(TenantRole role) {
        if (role == null) return null;
        return TenantRoleName.valueOf(role.name());
    }
}

============================================================
// FILE: ./main/java/brito/com/multitenancy001/tenant/security/TenantRolePermissions.java
============================================================
package brito.com.multitenancy001.tenant.security;

import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Set;

import static brito.com.multitenancy001.tenant.security.TenantPermission.*;

public final class TenantRolePermissions {

    private static final EnumMap<TenantRole, Set<TenantPermission>> MAP = new EnumMap<>(TenantRole.class);

    static {
        // OWNER = tudo
        MAP.put(TenantRole.TENANT_OWNER, unmodifiable(EnumSet.allOf(TenantPermission.class)));

        // ADMIN = administra tudo do tenant (conforme seu set de TenantPermission)
        MAP.put(TenantRole.TENANT_ADMIN, unmodifiable(EnumSet.of(
                // Users
                TEN_USER_READ,
                TEN_USER_CREATE,
                TEN_USER_UPDATE,
                TEN_USER_SUSPEND,
                TEN_USER_RESTORE,
                TEN_USER_DELETE,

                // Transfer ownership/admin
                TEN_ROLE_TRANSFER,

                // Products + Inventory
                TEN_PRODUCT_READ,
                TEN_PRODUCT_WRITE,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE,

                // Catalog
                TEN_CATEGORY_READ,
                TEN_CATEGORY_WRITE,
                TEN_SUPPLIER_READ,
                TEN_SUPPLIER_WRITE,

                // Sales + Issues + Reports
                TEN_SALE_READ,
                TEN_SALE_WRITE,
                TEN_SALE_ISSUES_READ,
                TEN_SALE_ISSUES_WRITE,   // ✅ FIX: seu enum tem WRITE; admin normalmente deve ter
                TEN_REPORT_SALES_READ,

                // Billing + Settings
                TEN_BILLING_READ,
                TEN_BILLING_WRITE,
                TEN_SETTINGS_READ,
                TEN_SETTINGS_WRITE
        )));

        MAP.put(TenantRole.TENANT_PRODUCT_MANAGER, unmodifiable(EnumSet.of(
                TEN_PRODUCT_READ,
                TEN_PRODUCT_WRITE,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE
        )));

        MAP.put(TenantRole.TENANT_SALES_MANAGER, unmodifiable(EnumSet.of(
                TEN_SALE_READ,
                TEN_SALE_WRITE,
                TEN_SALE_ISSUES_READ,
                TEN_SALE_ISSUES_WRITE,   // ✅ coerente com SALES_MANAGER também (remova se não quiser)
                TEN_REPORT_SALES_READ
        )));

        MAP.put(TenantRole.TENANT_BILLING_MANAGER, unmodifiable(EnumSet.of(
                TEN_BILLING_READ,
                TEN_BILLING_WRITE
        )));

        MAP.put(TenantRole.TENANT_READ_ONLY, unmodifiable(EnumSet.of(
                TEN_PRODUCT_READ,
                TEN_INVENTORY_READ,
                TEN_USER_READ
        )));

        // OPERATOR operacional (não administra usuários/config/billing)
        MAP.put(TenantRole.TENANT_OPERATOR, unmodifiable(EnumSet.of(
                TEN_PRODUCT_READ,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE,
                TEN_SALE_READ
        )));
    }

    private TenantRolePermissions() {}

    /**
     * Mantém o mesmo nome do seu método atual.
     * Retorna Set imutável (consistente com CP).
     */
    public static Set<TenantPermission> permissionsFor(TenantRole role) {
        if (role == null) return Set.of();
        return MAP.getOrDefault(role, Set.of());
    }

    private static Set<TenantPermission> unmodifiable(EnumSet<TenantPermission> set) {
        return Collections.unmodifiableSet(set);
    }
}

============================================================
// FILE: ./main/resources/db/migration/accounts/V1__create_extension.sql
============================================================
-- V1__create_extension.sql
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
============================================================
// FILE: ./main/resources/db/migration/accounts/V2__create_table_accounts.sql
============================================================
-- V2__create_table_accounts.sql

SET search_path TO public;

CREATE TABLE IF NOT EXISTS accounts (
    id BIGSERIAL PRIMARY KEY,

    account_type   VARCHAR(20) NOT NULL DEFAULT 'TENANT',
    account_origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    -- Core identity (neutro)
    display_name VARCHAR(150) NOT NULL,
    legal_name   VARCHAR(200),
    legal_entity_type VARCHAR(20) NOT NULL DEFAULT 'COMPANY', -- INDIVIDUAL | COMPANY

    schema_name VARCHAR(100) NOT NULL,
    slug        VARCHAR(80)  NOT NULL,

    status            VARCHAR(50) NOT NULL DEFAULT 'FREE_TRIAL',
    subscription_plan VARCHAR(50) NOT NULL DEFAULT 'FREE',

    -- Emails (neutro)
    login_email   VARCHAR(150) NOT NULL,
    billing_email VARCHAR(150),

    -- Documento fiscal/identificador legal (neutro)
    tax_id_type      VARCHAR(20),
    tax_id_number    VARCHAR(40),
    tax_country_code VARCHAR(2)  NOT NULL DEFAULT 'BR',

    -- Contato / Endereço (neutro)
    phone   VARCHAR(20),
    address VARCHAR(500),
    city    VARCHAR(100),
    state   VARCHAR(50),
    country VARCHAR(60) NOT NULL DEFAULT 'Brasil',

    -- Preferências
    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale   VARCHAR(20) NOT NULL DEFAULT 'pt_BR',
    currency VARCHAR(3) NOT NULL DEFAULT 'BRL',

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,
    
    -- AUDITORIA (quem criou/alterou/deletou)
    created_by BIGINT,
    updated_by BIGINT,
    deleted_by BIGINT,

    created_by_email VARCHAR(120),
    updated_by_email VARCHAR(120),
    deleted_by_email VARCHAR(120),

    trial_end_date   TIMESTAMP,
    payment_due_date TIMESTAMP,
    next_billing_date TIMESTAMP,

    settings_json TEXT,
    metadata_json TEXT,

    deleted   BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP
);

-- =========================
-- CHECK constraints (enums)
-- =========================
ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_account_type
    CHECK (account_type IN ('TENANT', 'PLATFORM'));

ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_account_origin
    CHECK (account_origin IN ('BUILT_IN', 'ADMIN', 'API'));

ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_subscription_plan
    CHECK (subscription_plan IN ('FREE', 'PRO', 'ENTERPRISE', 'BUILT_IN_PLAN'));

ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_legal_entity_type
    CHECK (legal_entity_type IN ('INDIVIDUAL', 'COMPANY'));

ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_tax_id_type
    CHECK (tax_id_type IS NULL OR tax_id_type IN ('CPF', 'CNPJ'));

ALTER TABLE accounts
    ADD CONSTRAINT chk_accounts_tax_id_pair
    CHECK (
        (tax_id_type IS NULL AND tax_id_number IS NULL)
        OR
        (tax_id_type IS NOT NULL AND tax_id_number IS NOT NULL)
    );

-- =========================
-- Índices / Uniques
-- =========================

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_single_platform
ON accounts (account_type)
WHERE account_type = 'PLATFORM';

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_tax_id_active
ON accounts (tax_country_code, tax_id_type, tax_id_number)
WHERE deleted = false AND tax_id_type IS NOT NULL AND tax_id_number IS NOT NULL;

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_login_email_active
ON accounts (login_email)
WHERE deleted = false;

CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_schema_name
ON accounts (schema_name);

CREATE UNIQUE INDEX IF NOT EXISTS uk_accounts_slug
ON accounts (slug);

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_billing_email_active
ON accounts (billing_email)
WHERE deleted = false AND billing_email IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_accounts_display_name
ON accounts (display_name);

============================================================
// FILE: ./main/resources/db/migration/accounts/V3__create_table_account_entitlements.sql
============================================================
-- V3__create_table_account_entitlements.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS account_entitlements (
  account_id BIGINT PRIMARY KEY REFERENCES accounts(id) ON DELETE CASCADE,
  max_users INT NOT NULL,
  max_products INT NOT NULL,
  max_storage_mb INT NOT NULL
);

-- (opcional) coerência básica
ALTER TABLE account_entitlements
    ADD CONSTRAINT chk_entitlements_positive
    CHECK (max_users > 0 AND max_products > 0 AND max_storage_mb > 0);

============================================================
// FILE: ./main/resources/db/migration/accounts/V4__create_table_controlplane_users.sql
============================================================
-- V4__create_table_controlplane_users.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_users (
    id BIGSERIAL PRIMARY KEY,

    name VARCHAR(100) NOT NULL,

    -- ✅ email é a identidade de login
    email VARCHAR(150) NOT NULL,
    password VARCHAR(255) NOT NULL,

    role VARCHAR(50) NOT NULL,

    account_id BIGINT NOT NULL,

    user_origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,

    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(20) NOT NULL DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP,

    created_by BIGINT,
    updated_by BIGINT,
    deleted_by BIGINT,

    created_by_email VARCHAR(120),
    updated_by_email VARCHAR(120),
    deleted_by_email VARCHAR(120),

    deleted BOOLEAN NOT NULL DEFAULT false,

    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    CONSTRAINT fk_controlplane_users_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE,

    CONSTRAINT chk_cp_user_origin
        CHECK (user_origin IN ('BUILT_IN', 'ADMIN', 'API'))
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_cp_users_email_active
ON controlplane_users (account_id, email)
WHERE deleted = false;

============================================================
// FILE: ./main/resources/db/migration/accounts/V5__insert_controlplane_account.sql
============================================================
-- V5__insert_controlplane_account.sql
SET search_path TO public;

INSERT INTO accounts (
    account_type,
    account_origin,
    display_name,
    legal_name,
    legal_entity_type,
    schema_name,
    slug,
    status,
    subscription_plan,
    tax_id_type,
    tax_id_number,
    tax_country_code,
    login_email,
    billing_email,
    country,
    timezone,
    locale,
    currency,
    deleted
)
SELECT
    'PLATFORM',
    'BUILT_IN',
    'Control Plane',
    NULL,
    'COMPANY',
    'public',
    'controlplane',
    'ACTIVE',
    'BUILT_IN_PLAN',
    'CNPJ',
    '00000000000000',
    'BR',
    'admin@controlplane.com',
    NULL,
    'Brasil',
    'America/Sao_Paulo',
    'pt_BR',
    'BRL',
    false
WHERE NOT EXISTS (
    SELECT 1 FROM accounts WHERE slug = 'controlplane'
);

============================================================
// FILE: ./main/resources/db/migration/accounts/V6__insert_controlplane_users.sql
============================================================
-- V6__insert_controlplane_users.sql
SET search_path TO public;

WITH cp_account AS (
    SELECT id
    FROM accounts
    WHERE slug = 'controlplane'
    LIMIT 1
)
INSERT INTO controlplane_users (
    name,
    email,
    password,
    role,
    account_id,
    user_origin,
    suspended_by_account,
    suspended_by_admin,
    must_change_password
)
SELECT
    u.name,
    u.email,
    u.password,
    u.role,
    a.id,
    'BUILT_IN',
    false,
    false,
    u.must_change_password
FROM cp_account a
JOIN (
    VALUES
      ('ControlPlane Super Admin', 'superadmin@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OWNER', false),

      ('ControlPlane Billing Manager', 'billing@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_BILLING_MANAGER', true),

      ('ControlPlane Support', 'support@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_SUPPORT', true),

      ('ControlPlane Operator', 'operator@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OPERATOR', true)

) AS u(name, email, password, role, must_change_password)
ON TRUE
WHERE NOT EXISTS (
    SELECT 1
    FROM controlplane_users existing
    WHERE existing.account_id = a.id
      AND existing.deleted = false
      AND LOWER(existing.email) = LOWER(u.email)
);

============================================================
// FILE: ./main/resources/db/migration/accounts/V7__create_table_controlplane_user_permissions.sql
============================================================
-- V7__create_table_controlplane_user_permissions.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_user_permissions (
    user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (user_id, permission),

    CONSTRAINT fk_cp_user_permissions_user
        FOREIGN KEY (user_id)
        REFERENCES controlplane_users(id)
        ON DELETE CASCADE
);

============================================================
// FILE: ./main/resources/db/migration/accounts/V8__create_table_payments.sql
============================================================
-- V8__create_table_payments.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS payments (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,

    payment_date TIMESTAMP NOT NULL,
    valid_until TIMESTAMP,

    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',

    transaction_id VARCHAR(100) UNIQUE,
    payment_method VARCHAR(50) NOT NULL,
    payment_gateway VARCHAR(50) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'BRL',

    description VARCHAR(500),
    metadata_json TEXT,

    invoice_url TEXT,
    receipt_url TEXT,

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,
    
    -- AUDITORIA
    created_by BIGINT,
    updated_by BIGINT,
    deleted_by BIGINT,

    created_by_email VARCHAR(120),
    updated_by_email VARCHAR(120),
    deleted_by_email VARCHAR(120),

    refunded_at TIMESTAMP,
    refund_amount NUMERIC(10,2),
    refund_reason VARCHAR(500),

    CONSTRAINT fk_payments_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_payment_account ON payments(account_id);
CREATE INDEX IF NOT EXISTS idx_payment_status ON payments(status);
CREATE INDEX IF NOT EXISTS idx_payment_date ON payments(payment_date);

============================================================
// FILE: ./main/resources/db/migration/accounts/V9__crete_table_login_identities.sql
============================================================
-- V9__crete_table_login_identities.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS login_identities (
    id BIGSERIAL PRIMARY KEY,

    email VARCHAR(150) NOT NULL,

    user_type VARCHAR(20) NOT NULL, -- 'TENANT' | 'CONTROLPLANE'
    account_id BIGINT,              -- para TENANT: obrigatório / para CONTROLPLANE: pode ser NULL

    created_at TIMESTAMP NOT NULL DEFAULT now(),

    CONSTRAINT chk_login_identities_user_type
        CHECK (user_type IN ('TENANT', 'CONTROLPLANE')),

    CONSTRAINT fk_login_identities_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- ✅ CONTROLPLANE: email único global (user_type='CONTROLPLANE')
CREATE UNIQUE INDEX IF NOT EXISTS ux_login_identity_cp_email
ON login_identities (email)
WHERE user_type = 'CONTROLPLANE';

-- ✅ TENANT: email pode repetir em vários tenants, mas não pode repetir no MESMO tenant
CREATE UNIQUE INDEX IF NOT EXISTS ux_login_identity_tenant_email_account
ON login_identities (email, account_id)
WHERE user_type = 'TENANT';

-- lookup por email (lista de tenants)
CREATE INDEX IF NOT EXISTS idx_login_identities_email_tenant
ON login_identities (email)
WHERE user_type = 'TENANT';

============================================================
// FILE: ./main/resources/db/migration/tenants/V1__create_table_tenant_users.sql
============================================================
-- V1__create_table_tenant_users.sql

CREATE TABLE IF NOT EXISTS tenant_users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    user_origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    account_id BIGINT NOT NULL,

    name VARCHAR(100) NOT NULL,

    -- ✅ email é a identidade de login
    email VARCHAR(150) NOT NULL,
    password VARCHAR(255) NOT NULL,

    role VARCHAR(50) NOT NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin  BOOLEAN NOT NULL DEFAULT FALSE,

    last_login TIMESTAMP,
    failed_login_attempts INTEGER NOT NULL DEFAULT 0,
    locked_until TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP,

    phone VARCHAR(20),
    avatar_url VARCHAR(500),

    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale VARCHAR(20) NOT NULL DEFAULT 'pt_BR',

    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    deleted_by BIGINT,

    created_by_email VARCHAR(120),
    updated_by_email VARCHAR(120),
    deleted_by_email VARCHAR(120),

    deleted BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMP,

    CONSTRAINT chk_tenant_user_origin CHECK (user_origin IN ('BUILT_IN', 'ADMIN', 'API')),

    CONSTRAINT uk_tenant_users_email_account UNIQUE (email, account_id)
);

CREATE INDEX IF NOT EXISTS idx_tenant_users_account_id ON tenant_users(account_id);
CREATE INDEX IF NOT EXISTS idx_tenant_users_deleted ON tenant_users(deleted) WHERE deleted = false;

============================================================
// FILE: ./main/resources/db/migration/tenants/V2__create_table_tenant_users_permissions.sql
============================================================

-- V2__create_table_tenant_users_permissions.sql
CREATE TABLE IF NOT EXISTS tenant_user_permissions (
    tenant_user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (tenant_user_id, permission),

    CONSTRAINT fk_tenant_user_permissions_user
        FOREIGN KEY (tenant_user_id)
        REFERENCES tenant_users(id)
        ON DELETE CASCADE
);
============================================================
// FILE: ./main/resources/db/migration/tenants/V3__create_table_categories.sql
============================================================
-- V3__create_table_categories.sql
CREATE TABLE IF NOT EXISTS categories (
  id BIGSERIAL PRIMARY KEY,

  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,
  
  -- AUDITORIA
  created_by BIGINT,
  updated_by BIGINT,
  deleted_by BIGINT,

  created_by_email VARCHAR(120),
  updated_by_email VARCHAR(120),
  deleted_by_email VARCHAR(120),

  CONSTRAINT uk_categories_name UNIQUE (name)
);

CREATE INDEX IF NOT EXISTS idx_categories_active  ON categories(active);
CREATE INDEX IF NOT EXISTS idx_categories_deleted ON categories(deleted) WHERE deleted = false;

============================================================
// FILE: ./main/resources/db/migration/tenants/V4__create_table_subcategories.sql
============================================================
-- V4__create_table_subcategories.sql

CREATE TABLE IF NOT EXISTS subcategories (
  id BIGSERIAL PRIMARY KEY,

  category_id BIGINT NOT NULL,
  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,
  
  -- AUDITORIA
  created_by BIGINT,
  updated_by BIGINT,
  deleted_by BIGINT,

  created_by_email VARCHAR(120),
  updated_by_email VARCHAR(120),
  deleted_by_email VARCHAR(120),

  CONSTRAINT fk_subcategories_category
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE,

  CONSTRAINT uk_subcategories_name_category UNIQUE (category_id, name)
);

CREATE INDEX IF NOT EXISTS idx_subcategories_active      ON subcategories(active);
CREATE INDEX IF NOT EXISTS idx_subcategories_deleted     ON subcategories(deleted) WHERE deleted = false;

============================================================
// FILE: ./main/resources/db/migration/tenants/V5__create_table_suppliers.sql
============================================================
-- V5__create_table_suppliers.sql

CREATE TABLE IF NOT EXISTS suppliers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  contact_person VARCHAR(100),

  email VARCHAR(150),
  phone VARCHAR(20),
  address TEXT,

  document VARCHAR(20),
  document_type VARCHAR(10),

  website VARCHAR(200),
  payment_terms VARCHAR(100),

  lead_time_days INTEGER,
  rating NUMERIC(3,2),

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,

  notes TEXT,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,
  
  -- AUDITORIA
  created_by BIGINT,
  updated_by BIGINT,
  deleted_by BIGINT,

  created_by_email VARCHAR(120),
  updated_by_email VARCHAR(120),
  deleted_by_email VARCHAR(120)
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_suppliers_document_active
ON suppliers(document)
WHERE document IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_supplier_name    ON suppliers(name);
CREATE INDEX IF NOT EXISTS idx_supplier_email   ON suppliers(email);
CREATE INDEX IF NOT EXISTS idx_supplier_active  ON suppliers(active);
CREATE INDEX IF NOT EXISTS idx_supplier_deleted ON suppliers(deleted) WHERE deleted = false;

============================================================
// FILE: ./main/resources/db/migration/tenants/V6__create_table_products.sql
============================================================
-- V6__create_table_products.sql
CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  description TEXT,

  sku VARCHAR(100) NOT NULL,
  price NUMERIC(10,2) NOT NULL,

  stock_quantity INT NOT NULL DEFAULT 0,
  min_stock INT,
  max_stock INT,

  cost_price NUMERIC(10,2),
  profit_margin NUMERIC(5,2),

  category_id BIGINT NOT NULL,
  subcategory_id BIGINT NULL,

  brand VARCHAR(100),
  weight_kg NUMERIC(8,3),
  dimensions VARCHAR(50),
  barcode VARCHAR(50),

  active BOOLEAN NOT NULL DEFAULT true,

  images_json TEXT,
  attributes_json TEXT,

  supplier_id UUID NULL,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  deleted BOOLEAN NOT NULL DEFAULT false,
  deleted_at TIMESTAMP,
  
  -- AUDITORIA
  created_by BIGINT,
  updated_by BIGINT,
  deleted_by BIGINT,

  created_by_email VARCHAR(120),
  updated_by_email VARCHAR(120),
  deleted_by_email VARCHAR(120),

  CONSTRAINT fk_products_category
    FOREIGN KEY (category_id) REFERENCES categories(id),

  CONSTRAINT fk_products_subcategory
    FOREIGN KEY (subcategory_id) REFERENCES subcategories(id),

  CONSTRAINT fk_product_supplier
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id),

  CONSTRAINT ck_products_sku_not_blank
    CHECK (length(trim(sku)) > 0)
);

CREATE UNIQUE INDEX ux_products_sku_not_deleted
ON products (sku)
WHERE deleted = false;

CREATE INDEX idx_products_name_lower
ON products (LOWER(name));

CREATE INDEX idx_products_brand_lower
ON products (LOWER(brand));

CREATE INDEX idx_products_active_deleted
ON products (active, deleted);

CREATE INDEX idx_products_supplier_id
ON products (supplier_id);

CREATE INDEX idx_products_category_id
ON products (category_id);

CREATE INDEX idx_products_subcategory_id
ON products (subcategory_id);

CREATE INDEX idx_products_created_at
ON products (created_at);

============================================================
// FILE: ./main/resources/db/migration/tenants/V7__create_table_sales.sql
============================================================
-- V7__create_table_sales.sql



CREATE TABLE IF NOT EXISTS sales (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_date TIMESTAMP NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL,

  customer_name VARCHAR(200),
  customer_document VARCHAR(20),
  customer_email VARCHAR(150),
  customer_phone VARCHAR(20),

  status VARCHAR(20) NOT NULL,

  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP,

  -- AUDITORIA (compatível com AuditInfo)
  created_by BIGINT,
  updated_by BIGINT,
  deleted_by BIGINT,

  created_by_email VARCHAR(120),
  updated_by_email VARCHAR(120),
  deleted_by_email VARCHAR(120)
);

CREATE INDEX IF NOT EXISTS idx_sales_sale_date ON sales(sale_date);
CREATE INDEX IF NOT EXISTS idx_sales_status ON sales(status);

============================================================
// FILE: ./main/resources/db/migration/tenants/V8__create_table_sales_items.sql
============================================================
-- V8__create_table_sales_items.sql


CREATE TABLE IF NOT EXISTS sale_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_id UUID NOT NULL,
  product_id UUID,
  product_name VARCHAR(255) NOT NULL,

  quantity NUMERIC(12,3) NOT NULL,
  unit_price NUMERIC(12,2) NOT NULL,
  total_price NUMERIC(12,2) NOT NULL,

  -- AUDITORIA (compatível com AuditInfo)
  created_by BIGINT,
  updated_by BIGINT,
  deleted_by BIGINT,

  created_by_email VARCHAR(120),
  updated_by_email VARCHAR(120),
  deleted_by_email VARCHAR(120),

  CONSTRAINT fk_sale_items_sale
    FOREIGN KEY (sale_id) REFERENCES sales(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_sale_items_sale_id ON sale_items(sale_id);
CREATE INDEX IF NOT EXISTS idx_sale_items_product_id ON sale_items(product_id);

============================================================
// FILE: ./test/java/brito/com/multitenancy001/Multitenancy001ApplicationTests.java
============================================================
package brito.com.multitenancy001;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Multitenancy001ApplicationTests {

	@Test
	void contextLoads() {
	}

}

