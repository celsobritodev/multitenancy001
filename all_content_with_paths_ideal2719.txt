### PROJECT FILE INDEX
pom.xml
src/main/java/brito/com/multitenancy001/Multitenancy001Application.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountAdminController.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountProvisioningEventController.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountQueryController.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountAdminDetailsResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountCountByStatusesRequest.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountProvisioningEventResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountStatusChangeRequest.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/summary/AccountTenantUserSummaryResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountAdminDetailsApiMapper.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountApiMapper.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountUserApiMapper.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountAppService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountEntitlementsProvisioningService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountFactory.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountStatusService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountTenantUserService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/audit/AccountProvisioningAuditService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/command/AccountStatusChangeCommand.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/command/CreateAccountCommand.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountAdminDetailsProjection.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountStatusChangeResponse.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountStatusChangeResult.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountStatusSideEffect.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/AccountProvisioningEventQueryService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/ControlPlaneAccountQueryService.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/dto/AccountProvisioningEventData.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/Account.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountEntitlements.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountProvisioningEvent.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountStatus.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountType.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/LegalEntityType.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/ProvisioningFailureCode.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/ProvisioningStatus.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/SubscriptionPlan.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/TaxIdType.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountEntitlementsRepository.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountProvisioningEventRepository.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountRepository.java
src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountResolverProjection.java
src/main/java/brito/com/multitenancy001/controlplane/auth/api/admin/ControlPlaneAuthController.java
src/main/java/brito/com/multitenancy001/controlplane/auth/api/dto/ControlPlaneAdminLoginRequest.java
src/main/java/brito/com/multitenancy001/controlplane/auth/api/dto/ControlPlaneRefreshRequest.java
src/main/java/brito/com/multitenancy001/controlplane/auth/app/ControlPlaneAuthService.java
src/main/java/brito/com/multitenancy001/controlplane/auth/app/ControlPlaneLogoutService.java
src/main/java/brito/com/multitenancy001/controlplane/auth/app/ControlPlaneTokenRefreshService.java
src/main/java/brito/com/multitenancy001/controlplane/auth/app/command/ControlPlaneAdminLoginCommand.java
src/main/java/brito/com/multitenancy001/controlplane/billing/api/admin/ControlPlanePaymentController.java
src/main/java/brito/com/multitenancy001/controlplane/billing/api/admin/ControlPlanePaymentQueryController.java
src/main/java/brito/com/multitenancy001/controlplane/billing/app/ControlPlanePaymentService.java
src/main/java/brito/com/multitenancy001/controlplane/billing/app/audit/ControlPlaneBillingSecurityAuditRecorder.java
src/main/java/brito/com/multitenancy001/controlplane/billing/app/query/ControlPlanePaymentQueryService.java
src/main/java/brito/com/multitenancy001/controlplane/billing/domain/Payment.java
src/main/java/brito/com/multitenancy001/controlplane/billing/persistence/ControlPlanePaymentRepository.java
src/main/java/brito/com/multitenancy001/controlplane/scheduling/app/AccountJobScheduleService.java
src/main/java/brito/com/multitenancy001/controlplane/scheduling/domain/AccountJobSchedule.java
src/main/java/brito/com/multitenancy001/controlplane/scheduling/infra/AccountJobScheduler.java
src/main/java/brito/com/multitenancy001/controlplane/scheduling/persistence/AccountJobScheduleRepository.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneEndpointPreAuthorizeVerifier.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlanePermission.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRole.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRolePermissions.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneSecurityFlags.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneSecurityWiringVerifier.java
src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneSystemRoleMapper.java
src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/SignupRequest.java
src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/SignupResponse.java
src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/TenantAdminResponse.java
src/main/java/brito/com/multitenancy001/controlplane/signup/api/publicweb/AccountSignupController.java
src/main/java/brito/com/multitenancy001/controlplane/signup/app/AccountOnboardingService.java
src/main/java/brito/com/multitenancy001/controlplane/signup/app/command/SignupCommand.java
src/main/java/brito/com/multitenancy001/controlplane/signup/app/dto/SignupResult.java
src/main/java/brito/com/multitenancy001/controlplane/signup/app/dto/TenantAdminResult.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/ControlPlaneUserController.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/admin/ControlPlaneMeController.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneAdminUserSummaryResponse.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneChangeMyPasswordRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneMeResponse.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserCreateRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserDetailsResponse.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserPasswordResetRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserPermissionsUpdateRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserSuspendRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserUpdateRequest.java
src/main/java/brito/com/multitenancy001/controlplane/users/api/mapper/ControlPlaneUserApiMapper.java
src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserExplicitPermissionsService.java
src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserService.java
src/main/java/brito/com/multitenancy001/controlplane/users/domain/ControlPlaneBuiltInUsers.java
src/main/java/brito/com/multitenancy001/controlplane/users/domain/ControlPlaneUser.java
src/main/java/brito/com/multitenancy001/controlplane/users/persistence/ControlPlaneUserRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/config/time/TimeConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayRunner.java
src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicSchemaVerifier.java
src/main/java/brito/com/multitenancy001/infrastructure/flyway/tenantschema/TenantSchemaFlywayMigrationService.java
src/main/java/brito/com/multitenancy001/infrastructure/jpa/publicschema/PrimaryTransactionManagerAliasConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/jpa/publicschema/PublicPersistenceConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/jpa/tenantschema/TenantPersistenceConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/observability/TenantContextMonitor.java
src/main/java/brito/com/multitenancy001/infrastructure/openapi/OpenApiConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/TxExecutor.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/PublicSchemaHibernateConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TenantSchemaConnectionProvider.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TenantSchemaHibernateConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TenantSchemaResolver.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TransactionManagementConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TransactionManagersVerifier.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/transaction/PublicTransactionTemplateProvider.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/tx/PublicReadOnlyTx.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/tx/PublicTx.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/tx/TenantReadOnlyTx.java
src/main/java/brito/com/multitenancy001/infrastructure/persistence/tx/TenantTx.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEvent.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEventAuditService.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEventRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/PublicAuditDispatcher.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditEvent.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditEventRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditQueryService.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditService.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/TenantAuthAuditRecorderPublicSchemaJpa.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionEntity.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionJpaRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionStorePublicSchemaJpa.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/RefreshTokenHasherSha256.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallengeEntity.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallengeJpaRepository.java
src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallengeStoreJpa.java
src/main/java/brito/com/multitenancy001/infrastructure/security/AuthenticatedUserContext.java
src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityConstants.java
src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityFailureCode.java
src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityUtils.java
src/main/java/brito/com/multitenancy001/infrastructure/security/authorities/AuthoritiesFactory.java
src/main/java/brito/com/multitenancy001/infrastructure/security/config/RestAccessDeniedHandler.java
src/main/java/brito/com/multitenancy001/infrastructure/security/config/RestAuthenticationEntryPoint.java
src/main/java/brito/com/multitenancy001/infrastructure/security/config/SecurityConfig.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/JwtAuthenticationFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/MustChangePasswordFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/RequestLoggingFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/RequestMetaContextFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/filter/TenantHeaderTenantContextFilter.java
src/main/java/brito/com/multitenancy001/infrastructure/security/jwt/JwtTokenProvider.java
src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/MultiContextUserDetailsService.java
src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/TenantUserPrincipal.java
src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/TenantUserPrincipalFactory.java
src/main/java/brito/com/multitenancy001/infrastructure/startup/DatabaseMissingFailFastListener.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantExecutor.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantRequiredTables.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningService.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningWorker.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaReadinessService.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaUnitOfWork.java
src/main/java/brito/com/multitenancy001/infrastructure/tenant/auth/TenantAuthMechanicsSpringSecurity.java
src/main/java/brito/com/multitenancy001/integration/audit/ControlPlaneAuthAuditIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/audit/ControlPlaneAuthEventAuditIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/audit/ControlPlaneSecurityAuditIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneAuthenticationIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneJwtIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneRefreshIdentity.java
src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneRefreshTokenIntrospectionIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneTokenIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/security/ControlPlaneRequestIdentityService.java
src/main/java/brito/com/multitenancy001/integration/security/ControlPlaneSecurityContextService.java
src/main/java/brito/com/multitenancy001/integration/security/TenantRequestIdentityService.java
src/main/java/brito/com/multitenancy001/integration/tenant/TenantProvisioningIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/tenant/TenantSchemaProvisioningIntegrationService.java
src/main/java/brito/com/multitenancy001/integration/tenant/TenantUsersIntegrationService.java
src/main/java/brito/com/multitenancy001/shared/account/UserLimitPolicy.java
src/main/java/brito/com/multitenancy001/shared/api/compliance/ControllerComplianceExempt.java
src/main/java/brito/com/multitenancy001/shared/api/compliance/ControllerComplianceVerifier.java
src/main/java/brito/com/multitenancy001/shared/api/dto/GenericMessageResponse.java
src/main/java/brito/com/multitenancy001/shared/api/dto/auth/JwtResponse.java
src/main/java/brito/com/multitenancy001/shared/api/dto/auth/LogoutRequest.java
src/main/java/brito/com/multitenancy001/shared/api/dto/billing/AdminPaymentRequest.java
src/main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentRequest.java
src/main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentResponse.java
src/main/java/brito/com/multitenancy001/shared/api/error/ApiEnumErrorResponse.java
src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorCategory.java
src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorCode.java
src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorResponse.java
src/main/java/brito/com/multitenancy001/shared/api/error/GlobalExceptionHandler.java
src/main/java/brito/com/multitenancy001/shared/audit/AuditDetails.java
src/main/java/brito/com/multitenancy001/shared/auth/app/AuthRefreshSessionService.java
src/main/java/brito/com/multitenancy001/shared/auth/app/boundary/AuthRefreshSessionData.java
src/main/java/brito/com/multitenancy001/shared/auth/app/boundary/AuthRefreshSessionStore.java
src/main/java/brito/com/multitenancy001/shared/auth/app/boundary/RefreshTokenHasher.java
src/main/java/brito/com/multitenancy001/shared/auth/app/dto/JwtResult.java
src/main/java/brito/com/multitenancy001/shared/auth/domain/AuthSessionDomain.java
src/main/java/brito/com/multitenancy001/shared/billing/PaymentQueryService.java
src/main/java/brito/com/multitenancy001/shared/context/RequestMeta.java
src/main/java/brito/com/multitenancy001/shared/context/RequestMetaContext.java
src/main/java/brito/com/multitenancy001/shared/context/TenantContext.java
src/main/java/brito/com/multitenancy001/shared/contracts/AccountRef.java
src/main/java/brito/com/multitenancy001/shared/contracts/AccountSnapshot.java
src/main/java/brito/com/multitenancy001/shared/contracts/TenantUserOperations.java
src/main/java/brito/com/multitenancy001/shared/contracts/UserSummaryData.java
src/main/java/brito/com/multitenancy001/shared/db/Schemas.java
src/main/java/brito/com/multitenancy001/shared/domain/DomainException.java
src/main/java/brito/com/multitenancy001/shared/domain/EmailNormalizer.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditActor.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditInfo.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditOutcome.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/Auditable.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/AuthDomain.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/AuthDomainConverter.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/AuthEventType.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/SecurityAuditActionType.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/SoftDeletable.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditActorProvider.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditActorProviders.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditClockProvider.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditClockProviders.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditEntityListener.java
src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditWiringVerifier.java
src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentGateway.java
src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentMethod.java
src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentStatus.java
src/main/java/brito/com/multitenancy001/shared/domain/common/EntityOrigin.java
src/main/java/brito/com/multitenancy001/shared/executor/PublicSchemaExecutor.java
src/main/java/brito/com/multitenancy001/shared/executor/PublicSchemaUnitOfWork.java
src/main/java/brito/com/multitenancy001/shared/json/JsonDetailsMapper.java
src/main/java/brito/com/multitenancy001/shared/kernel/error/ApiException.java
src/main/java/brito/com/multitenancy001/shared/net/IpAddressMapper.java
src/main/java/brito/com/multitenancy001/shared/persistence/PgColumnTypes.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsGuard.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsService.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsSnapshot.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountResolver.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountSnapshot.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityProvisioningService.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityResolver.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityRow.java
src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentitySubjectType.java
src/main/java/brito/com/multitenancy001/shared/security/AuthenticatedPrincipal.java
src/main/java/brito/com/multitenancy001/shared/security/PermissionAuthority.java
src/main/java/brito/com/multitenancy001/shared/security/PermissionCode.java
src/main/java/brito/com/multitenancy001/shared/security/PermissionScopeValidator.java
src/main/java/brito/com/multitenancy001/shared/security/PreAuthorizePermissionReferenceParser.java
src/main/java/brito/com/multitenancy001/shared/security/RoleAuthority.java
src/main/java/brito/com/multitenancy001/shared/security/SystemRoleName.java
src/main/java/brito/com/multitenancy001/shared/security/TenantRoleName.java
src/main/java/brito/com/multitenancy001/shared/security/TenantSystemRoleMapper.java
src/main/java/brito/com/multitenancy001/shared/time/AppClock.java
src/main/java/brito/com/multitenancy001/shared/time/SystemAppClock.java
src/main/java/brito/com/multitenancy001/shared/validation/ValidationPatterns.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantAuthController.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantPasswordController.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/ForgotPasswordRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/ResetPasswordRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantLoginConfirmRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantLoginInitRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantRefreshRequest.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantSelectionOption.java
src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantSelectionRequiredResponse.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginCandidateAccountService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginChallengeService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginConfirmService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginInitService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLogoutService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantPasswordResetService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantTokenRefreshService.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/audit/TenantAuthAuditRecorder.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/boundary/TenantAuthMechanics.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/boundary/TenantLoginChallengeStore.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/boundary/TenantRefreshIdentity.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/command/TenantLoginConfirmCommand.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/command/TenantLoginInitCommand.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/TenantLoginCandidateAccount.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/TenantLoginResult.java
src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/TenantSelectionOptionData.java
src/main/java/brito/com/multitenancy001/tenant/auth/domain/TenantLoginChallenge.java
src/main/java/brito/com/multitenancy001/tenant/billing/api/TenantPaymentController.java
src/main/java/brito/com/multitenancy001/tenant/billing/app/TenantPaymentService.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/TenantCategoryController.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/TenantSubcategoryController.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/CategoryCreateRequest.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/CategoryResponse.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/CategoryUpdateRequest.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/SubcategoryCreateRequest.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/SubcategoryResponse.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/SubcategoryUpdateRequest.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/mapper/CategoryApiMapper.java
src/main/java/brito/com/multitenancy001/tenant/categories/api/mapper/SubcategoryApiMapper.java
src/main/java/brito/com/multitenancy001/tenant/categories/app/TenantCategoryService.java
src/main/java/brito/com/multitenancy001/tenant/categories/app/TenantSubcategoryService.java
src/main/java/brito/com/multitenancy001/tenant/categories/app/command/CreateCategoryCommand.java
src/main/java/brito/com/multitenancy001/tenant/categories/app/command/CreateSubcategoryCommand.java
src/main/java/brito/com/multitenancy001/tenant/categories/app/command/UpdateCategoryCommand.java
src/main/java/brito/com/multitenancy001/tenant/categories/app/command/UpdateSubcategoryCommand.java
src/main/java/brito/com/multitenancy001/tenant/categories/domain/Category.java
src/main/java/brito/com/multitenancy001/tenant/categories/domain/Subcategory.java
src/main/java/brito/com/multitenancy001/tenant/categories/persistence/TenantCategoryRepository.java
src/main/java/brito/com/multitenancy001/tenant/categories/persistence/TenantSubcategoryRepository.java
src/main/java/brito/com/multitenancy001/tenant/debug/api/TenantDebugController.java
src/main/java/brito/com/multitenancy001/tenant/debug/api/dto/TenantSchemaDebugResponse.java
src/main/java/brito/com/multitenancy001/tenant/debug/app/TenantDebugQueryService.java
src/main/java/brito/com/multitenancy001/tenant/me/api/TenantMeController.java
src/main/java/brito/com/multitenancy001/tenant/me/api/dto/TenantChangeMyPasswordRequest.java
src/main/java/brito/com/multitenancy001/tenant/me/api/dto/TenantMeResponse.java
src/main/java/brito/com/multitenancy001/tenant/me/api/dto/UpdateMyProfileRequest.java
src/main/java/brito/com/multitenancy001/tenant/me/api/mapper/TenantMeApiMapper.java
src/main/java/brito/com/multitenancy001/tenant/me/app/TenantMeService.java
src/main/java/brito/com/multitenancy001/tenant/payments/app/audit/TenantBillingSecurityAuditRecorder.java
src/main/java/brito/com/multitenancy001/tenant/products/api/TenantProductController.java
src/main/java/brito/com/multitenancy001/tenant/products/api/dto/ProductResponse.java
src/main/java/brito/com/multitenancy001/tenant/products/api/dto/ProductUpsertRequest.java
src/main/java/brito/com/multitenancy001/tenant/products/api/dto/SupplierProductCountResponse.java
src/main/java/brito/com/multitenancy001/tenant/products/api/mapper/ProductApiMapper.java
src/main/java/brito/com/multitenancy001/tenant/products/app/TenantProductService.java
src/main/java/brito/com/multitenancy001/tenant/products/app/command/CreateProductCommand.java
src/main/java/brito/com/multitenancy001/tenant/products/app/command/UpdateProductCommand.java
src/main/java/brito/com/multitenancy001/tenant/products/app/dto/SupplierProductCountData.java
src/main/java/brito/com/multitenancy001/tenant/products/domain/Product.java
src/main/java/brito/com/multitenancy001/tenant/products/persistence/TenantProductRepository.java
src/main/java/brito/com/multitenancy001/tenant/provisioning/app/TenantUserProvisioningService.java
src/main/java/brito/com/multitenancy001/tenant/provisioning/infra/TenantFlywayMigrator.java
src/main/java/brito/com/multitenancy001/tenant/sales/domain/Sale.java
src/main/java/brito/com/multitenancy001/tenant/sales/domain/SaleItem.java
src/main/java/brito/com/multitenancy001/tenant/sales/domain/SaleStatus.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantEndpointPreAuthorizeVerifier.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantPermission.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantRole.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantRoleMapper.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantRolePermissions.java
src/main/java/brito/com/multitenancy001/tenant/security/TenantSecurityWiringVerifier.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/api/TenantSupplierController.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/api/dto/SupplierCreateRequest.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/api/dto/SupplierResponse.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/api/dto/SupplierUpdateRequest.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/api/mapper/SupplierApiMapper.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/app/TenantSupplierService.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/app/command/CreateSupplierCommand.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/app/command/UpdateSupplierCommand.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/domain/Supplier.java
src/main/java/brito/com/multitenancy001/tenant/suppliers/persistence/TenantSupplierRepository.java
src/main/java/brito/com/multitenancy001/tenant/users/api/TenantUserController.java
src/main/java/brito/com/multitenancy001/tenant/users/api/admin/TenantUserAdminController.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantActorRef.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserCreateRequest.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserDetailsResponse.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserListItemResponse.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserSummaryResponse.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUsersListResponse.java
src/main/java/brito/com/multitenancy001/tenant/users/api/dto/admin/TenantUserAdminSuspendRequest.java
src/main/java/brito/com/multitenancy001/tenant/users/api/mapper/TenantUserApiMapper.java
src/main/java/brito/com/multitenancy001/tenant/users/app/TenantUserAdminTxService.java
src/main/java/brito/com/multitenancy001/tenant/users/app/admin/TenantUserAdminService.java
src/main/java/brito/com/multitenancy001/tenant/users/app/audit/TenantUserSecurityAuditRecorder.java
src/main/java/brito/com/multitenancy001/tenant/users/app/command/TenantUserCommandService.java
src/main/java/brito/com/multitenancy001/tenant/users/app/context/TenantUserCurrentContextCommandService.java
src/main/java/brito/com/multitenancy001/tenant/users/app/context/TenantUserCurrentContextQueryService.java
src/main/java/brito/com/multitenancy001/tenant/users/app/query/TenantUserQueryService.java
src/main/java/brito/com/multitenancy001/tenant/users/app/query/TenantUsersListView.java
src/main/java/brito/com/multitenancy001/tenant/users/domain/TenantUser.java
src/main/java/brito/com/multitenancy001/tenant/users/domain/permission/TenantUserPermission.java
src/main/java/brito/com/multitenancy001/tenant/users/persistence/TenantUserRepository.java
src/main/resources/application-dev.properties
src/main/resources/application.properties
src/main/resources/db/migration/accounts/V10__create_table_account_provisioning_events.sql
src/main/resources/db/migration/accounts/V11__create_table_tenant_login_challenges.sql
src/main/resources/db/migration/accounts/V12__seed_account_entitlements_for_existing_accounts.sql
src/main/resources/db/migration/accounts/V13__create_table_auth_events.sql
src/main/resources/db/migration/accounts/V14__create_table_security_audit_events.sql
src/main/resources/db/migration/accounts/V15__create_table_account_job_schedules.sql
src/main/resources/db/migration/accounts/V16__alter_controlplane_users_email_to_citext.sql
src/main/resources/db/migration/accounts/V17__protect_builtin_controlplane_users.sql
src/main/resources/db/migration/accounts/V18__create_table_auth_refresh_sessions.sql
src/main/resources/db/migration/accounts/V19__add_check_auth_refresh_sessions_domain.sql
src/main/resources/db/migration/accounts/V1__create_extension.sql
src/main/resources/db/migration/accounts/V20__create_account_job_schedules.sql
src/main/resources/db/migration/accounts/V2__create_table_accounts.sql
src/main/resources/db/migration/accounts/V3__create_table_account_entitlements.sql
src/main/resources/db/migration/accounts/V4__create_table_controlplane_users.sql
src/main/resources/db/migration/accounts/V5__insert_controlplane_account.sql
src/main/resources/db/migration/accounts/V6__insert_controlplane_users.sql
src/main/resources/db/migration/accounts/V7__create_table_controlplane_user_permissions.sql
src/main/resources/db/migration/accounts/V8__create_table_payments.sql
src/main/resources/db/migration/accounts/V9__create_table_login_identities.sql
src/main/resources/db/migration/tenants/V1__create_table_tenant_users.sql
src/main/resources/db/migration/tenants/V2__create_table_tenant_user_permissions.sql
src/main/resources/db/migration/tenants/V3__create_table_categories.sql
src/main/resources/db/migration/tenants/V4__create_table_subcategories.sql
src/main/resources/db/migration/tenants/V5__create_table_suppliers.sql
src/main/resources/db/migration/tenants/V6__create_table_products.sql
src/main/resources/db/migration/tenants/V7__create_table_sales.sql
src/main/resources/db/migration/tenants/V8__create_table_sales_items.sql
src/test/java/brito/com/multitenancy001/Multitenancy001ApplicationTests.java
src/test/java/brito/com/multitenancy001/tenant/users/app/context/TenantUserRestoreVerifierTest.java

### FILE CONTENTS

============================================================
### FILE: pom.xml
============================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.9</version>
        <relativePath/>
    </parent>
    
    <groupId>brito.com.multitenancy001</groupId>
    <artifactId>multitenancy001</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>multitenancy001</name>
    <description>Prototipo Multi Tenancy</description>
    
    <properties>
        <java.version>21</java.version>
        <flyway.version>11.20.2</flyway.version>
        <!-- REMOVIDO: maven-resources-plugin.version - deixar Spring gerenciar -->
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Swagger / OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.8.15</version>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-database-postgresql</artifactId>
        </dependency>

        <!-- JWT (JJWT) -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- DevTools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- ================================================== -->
        <!-- DEPENDÊNCIAS DE TESTE (ESCOPO test)                -->
        <!-- ================================================== -->
        
        <!-- Spring Boot Test (inclui JUnit 5 Jupiter, Mockito, AssertJ, Hamcrest) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Spring Security Test -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- REMOVIDAS TODAS AS DEPENDÊNCIAS EXPLÍCITAS DE TESTE:
             - mockito-core
             - mockito-junit-jupiter
             - junit-jupiter-api
             - junit-jupiter-engine
             - junit-jupiter-params
             - assertj-core
             - hamcrest
             
             Tudo isso já está incluso no spring-boot-starter-test com versões compatíveis!
        -->
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            
            <!-- Plugin do Maven Surefire - SEM VERSÃO EXPLÍCITA -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <!-- VERSÃO REMOVIDA - Spring Boot gerencia -->
                <configuration>
                    <includes>
                        <include>**/*Test.java</include>
                        <include>**/*Tests.java</include>
                        <include>**/*TestCase.java</include>
                    </includes>
                </configuration>
            </plugin>
            
            <!-- Plugin do Maven Resources - SEM VERSÃO EXPLÍCITA -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <!-- VERSÃO REMOVIDA - Spring Boot gerencia -->
                <configuration>
                    <encoding>UTF-8</encoding>
                    <nonFilteredFileExtensions>
                        <nonFilteredFileExtension>properties</nonFilteredFileExtension>
                        <nonFilteredFileExtension>yml</nonFilteredFileExtension>
                        <nonFilteredFileExtension>yaml</nonFilteredFileExtension>
                    </nonFilteredFileExtensions>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
============================================================
### FILE: src/main/java/brito/com/multitenancy001/Multitenancy001Application.java
============================================================
package brito.com.multitenancy001;

import brito.com.multitenancy001.infrastructure.startup.DatabaseMissingFailFastListener;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
//@EnableCaching
@EnableScheduling
public class Multitenancy001Application {

	public static void main(String[] args) {
		SpringApplication app = new SpringApplication(Multitenancy001Application.class);
		app.addListeners(new DatabaseMissingFailFastListener());
		app.run(args);
	}

}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountAdminController.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.admin;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountResponse;
import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountStatusChangeRequest;
import brito.com.multitenancy001.controlplane.accounts.api.dto.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountAdminDetailsApiMapper;
import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountUserApiMapper;
import brito.com.multitenancy001.controlplane.accounts.app.AccountAppService;
import brito.com.multitenancy001.controlplane.accounts.app.command.AccountStatusChangeCommand;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountAdminDetailsProjection;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountStatusChangeResponse;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountStatusChangeResult;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.signup.api.dto.SignupRequest;
import brito.com.multitenancy001.controlplane.signup.api.dto.SignupResponse;
import brito.com.multitenancy001.controlplane.signup.api.dto.TenantAdminResponse;
import brito.com.multitenancy001.controlplane.signup.app.command.SignupCommand;
import brito.com.multitenancy001.controlplane.signup.app.dto.SignupResult;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.Instant;
import java.util.List;

@RestController
@RequestMapping("/api/controlplane/accounts")
@RequiredArgsConstructor
public class ControlPlaneAccountAdminController {

    private final AccountAppService accountAppService;

    private final AccountApiMapper accountApiMapper;
    private final AccountAdminDetailsApiMapper accountAdminDetailsApiMapper;

    private final AccountUserApiMapper accountUserApiMapper;

    /**
     * Signup via admin (criação de tenant pelo Control Plane).
     */
    @PostMapping("/signup")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_CREATE.asAuthority())")
    public ResponseEntity<SignupResponse> createAccount(@Valid @RequestBody SignupRequest req) {

        SignupResult result = accountAppService.createAccount(new SignupCommand(
                req.displayName(),
                req.loginEmail(),
                req.taxIdType(),
                req.taxIdNumber(),
                req.password(),
                req.confirmPassword()
        ));

        SignupResponse http = new SignupResponse(
                accountApiMapper.toResponse(result.account()),
                new TenantAdminResponse(
                        result.tenantAdmin().id(),
                        result.tenantAdmin().email(),
                        result.tenantAdmin().role()
                )
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(http);
    }

    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<List<AccountResponse>> listAccounts() {
        List<AccountResponse> out = accountAppService.listAccounts()
                .stream().map(accountApiMapper::toResponse).toList();
        return ResponseEntity.ok(out);
    }

    @GetMapping("/{accountId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<AccountResponse> getAccount(@PathVariable Long accountId) {
        Account a = accountAppService.getAccount(accountId);
        return ResponseEntity.ok(accountApiMapper.toResponse(a));
    }

    @GetMapping("/{accountId}/admin-details")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<AccountAdminDetailsResponse> getAdminDetails(@PathVariable Long accountId) {
        AccountAdminDetailsProjection p = accountAppService.getAccountAdminDetails(accountId);
        return ResponseEntity.ok(accountAdminDetailsApiMapper.toResponse(p.account(), p.admin(), p.totalUsers()));
    }

    @PostMapping("/{accountId}/status")
    @PreAuthorize("hasAnyAuthority("
            + "T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_SUSPEND.asAuthority(), "
            + "T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_RESUME.asAuthority()"
            + ")")
    public ResponseEntity<AccountStatusChangeResponse> changeStatus(
            @PathVariable Long accountId,
            @Valid @RequestBody AccountStatusChangeRequest req
    ) {
        AccountStatusChangeResult r = accountAppService.changeAccountStatus(
                accountId,
                new AccountStatusChangeCommand(req.status())
        );

        // ✅ Response “flat” + tipado 
        return ResponseEntity.ok(AccountStatusChangeResponse.from(r));
    }

    @DeleteMapping("/{accountId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_DELETE.asAuthority())")
    public ResponseEntity<Void> softDelete(@PathVariable Long accountId) {
        accountAppService.softDeleteAccount(accountId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{accountId}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_RESUME.asAuthority())")
    public ResponseEntity<Void> restore(@PathVariable Long accountId) {
        accountAppService.restoreAccount(accountId);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/{accountId}/tenant-users")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<List<AccountTenantUserSummaryResponse>> listTenantUsers(
            @PathVariable Long accountId,
            @RequestParam(name = "onlyOperational", defaultValue = "false") boolean onlyOperational
    ) {
        List<AccountTenantUserSummaryResponse> out = accountAppService
                .listTenantUsers(accountId, onlyOperational)
                .stream()
                .map(accountUserApiMapper::toAccountUserSummary)
                .toList();

        return ResponseEntity.ok(out);
    }

    @PostMapping("/{accountId}/tenant-users/{userId}/suspended-by-admin")
    @PreAuthorize("hasAnyAuthority("
            + "T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_SUSPEND.asAuthority(), "
            + "T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_RESUME.asAuthority()"
            + ")")
    public ResponseEntity<Void> setSuspendedByAdmin(
            @PathVariable Long accountId,
            @PathVariable Long userId,
            @RequestParam("value") boolean value
    ) {
        accountAppService.setUserSuspendedByAdmin(accountId, userId, value);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/by-status")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<Page<AccountResponse>> listByStatus(
            @RequestParam AccountStatus status,
            Pageable pageable
    ) {
        return ResponseEntity.ok(
                accountAppService.listAccountsByStatus(status, pageable).map(accountApiMapper::toResponse)
        );
    }

  @GetMapping("/created-between")
@PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
public ResponseEntity<Page<AccountResponse>> listCreatedBetween(
        @RequestParam("start") Instant start,
        @RequestParam("end") Instant end,
        Pageable pageable
) {
    return ResponseEntity.ok(
            accountAppService
                    .listAccountsCreatedBetween(start, end, pageable)
                    .map(accountApiMapper::toResponse)
    );
}


    @GetMapping("/search")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<Page<AccountResponse>> search(
            @RequestParam("term") String term,
            Pageable pageable
    ) {
        return ResponseEntity.ok(
                accountAppService.searchAccountsByDisplayName(term, pageable).map(accountApiMapper::toResponse)
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountProvisioningEventController.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.admin;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountProvisioningEventResponse;
import brito.com.multitenancy001.controlplane.accounts.app.query.AccountProvisioningEventQueryService;
import brito.com.multitenancy001.controlplane.accounts.app.query.dto.AccountProvisioningEventData;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/api/controlplane/accounts/{accountId}/provisioning-events")
@RequiredArgsConstructor
public class ControlPlaneAccountProvisioningEventController {

    private final AccountProvisioningEventQueryService accountProvisioningEventQueryService;

    private static AccountProvisioningEventResponse toHttp(AccountProvisioningEventData d) {
        return new AccountProvisioningEventResponse(
                d.id(),
                d.accountId(),
                d.status(),
                d.failureCode(),
                d.message(),
                d.detailsJson(),
                d.createdAt()
        );
    }

    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<Page<AccountProvisioningEventResponse>> list(@PathVariable Long accountId, Pageable pageable) {
        return ResponseEntity.ok(
                accountProvisioningEventQueryService
                        .listByAccount(accountId, pageable)
                        .map(ControlPlaneAccountProvisioningEventController::toHttp)
        );
    }

    @GetMapping("/latest")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<AccountProvisioningEventResponse> latest(
            @PathVariable Long accountId,
            @RequestParam(name = "status", required = false) ProvisioningStatus status
    ) {
        Optional<AccountProvisioningEventData> d =
                accountProvisioningEventQueryService.getLatestByAccount(accountId, status);

        return d.map(x -> ResponseEntity.ok(toHttp(x)))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/admin/ControlPlaneAccountQueryController.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.admin;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountCountByStatusesRequest;
import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountResponse;
import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.accounts.app.query.ControlPlaneAccountQueryService;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

/**
 * Endpoints de consulta (query) para Accounts no Control Plane.
 *
 * Regras:
 * - Controller não acessa repositórios diretamente (somente services).
 * - Contratos de request/response preferem DTOs (evita payload "solto").
 */
@RestController
@RequestMapping("/api/controlplane/accounts/query")
@RequiredArgsConstructor
public class ControlPlaneAccountQueryController {

    private final ControlPlaneAccountQueryService controlPlaneAccountQueryService;
    private final AccountApiMapper accountApiMapper;

    @GetMapping("/{id}/enabled")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<AccountResponse> getEnabledById(@PathVariable Long id) {
        /* Busca conta habilitada por id (regra de negócio no service). */
        Account a = controlPlaneAccountQueryService.getEnabledById(id);
        return ResponseEntity.ok(accountApiMapper.toResponse(a));
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<AccountResponse> getAnyById(@PathVariable Long id) {
        /* Busca conta por id sem exigir estado enabled (regra de negócio no service). */
        Account a = controlPlaneAccountQueryService.getAnyById(id);
        return ResponseEntity.ok(accountApiMapper.toResponse(a));
    }

    @PostMapping("/count")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<Long> countByStatuses(@Valid @RequestBody AccountCountByStatusesRequest request) {
        /* Conta accounts por statuses (excluindo deletadas), com contrato tipado. */
        return ResponseEntity.ok(
                controlPlaneAccountQueryService.countByStatusesNotDeleted(request.statuses())
        );
    }

    /**
     * Semântica: paymentDueDate é DATA CIVIL (LocalDate <-> DATE).
     * Endpoint aceita yyyy-MM-dd.
     *
     * Ex: /payment-due-before?date=2026-02-10
     */
    @GetMapping("/payment-due-before")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())")
    public ResponseEntity<List<AccountResponse>> findPaymentDueBefore(
            @RequestParam("date")
            @DateTimeFormat(iso = DateTimeFormat.ISO.DATE)
            LocalDate date
    ) {
        /* Lista accounts com paymentDueDate anterior (excluindo deletadas). */
        return ResponseEntity.ok(
                controlPlaneAccountQueryService.findPaymentDueBeforeNotDeleted(date)
                        .stream()
                        .map(accountApiMapper::toResponse)
                        .toList()
        );
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountAdminDetailsResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountType;
import brito.com.multitenancy001.controlplane.accounts.domain.SubscriptionPlan;
import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneAdminUserSummaryResponse;

import java.time.Instant;
import java.time.LocalDate;

public record AccountAdminDetailsResponse(

        // Identificação
        Long id,
        String displayName,
        String slug,
        String tenantSchema,
        AccountStatus status,
        AccountType accountType,
        SubscriptionPlan subscriptionPlan,

        // Dados legais (sempre em conjunto)
        TaxIdType taxIdType,
        String taxIdNumber,

        // Datas
        Instant createdAt,
        Instant trialEndAt,
        LocalDate paymentDueDate,
        Instant deletedAt,

        // Flags calculadas
        boolean inTrial,
        boolean trialExpired,
        long trialDaysRemaining,

        // Admin da conta
        ControlPlaneAdminUserSummaryResponse admin,

        // Indicadores
        long totalControlPlaneUsers,
        boolean operational
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountCountByStatusesRequest.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

import java.util.List;

/**
 * Request tipado para consultas de contagem de contas por status.
 *
 * Motivação:
 * - Evitar @RequestBody List<Enum> "solto" (contrato frágil e difícil de estender).
 * - Permitir evolução futura (ex.: incluir flags, filtros adicionais, paginação etc).
 */
public record AccountCountByStatusesRequest(

        @NotNull
        @NotEmpty
        List<AccountStatus> statuses

) {
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountProvisioningEventResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import java.time.Instant;

import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;

public record AccountProvisioningEventResponse(
        Long id,
        Long accountId,
        ProvisioningStatus status,
        ProvisioningFailureCode failureCode,
        String message,
        String detailsJson,
        Instant createdAt
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import java.time.Instant;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountType;
import brito.com.multitenancy001.controlplane.accounts.domain.SubscriptionPlan;

public record AccountResponse(
        Long id,
        String displayName,
        String slug,
        String tenantSchema,
        AccountStatus status,
        AccountType accountType,
        SubscriptionPlan subscriptionPlan,
        Instant createdAt,
        Instant trialEndAt
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/AccountStatusChangeRequest.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public record AccountStatusChangeRequest(
        @NotNull(message = "status é obrigatório")
        AccountStatus status,

        @Size(max = 255, message = "reason deve ter no máximo 255 caracteres")
        String reason
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/dto/summary/AccountTenantUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.dto.summary;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Resumo de usuário de uma conta (visão ControlPlane).
 *
 * Role é tipada usando TenantRoleName (contrato compartilhado),
 * sem dependência do enum interno do Tenant.
 */
public record AccountTenantUserSummaryResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRoleName role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountAdminDetailsApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.mapper;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountAdminDetailsResponse;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.users.api.mapper.ControlPlaneUserApiMapper;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.time.AppClock;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;

@Component
public class AccountAdminDetailsApiMapper {

    private final AppClock appClock;
    private final ControlPlaneUserApiMapper controlPlaneUserApiMapper;

    public AccountAdminDetailsApiMapper(AppClock appClock, ControlPlaneUserApiMapper controlPlaneUserApiMapper) {
        this.appClock = appClock;
        this.controlPlaneUserApiMapper = controlPlaneUserApiMapper;
    }

    public AccountAdminDetailsResponse toResponse(Account account, ControlPlaneUser admin, long totalUsers) {
        Instant now = appClock.instant();

        LocalDate todayUtc = LocalDate.ofInstant(now, ZoneOffset.UTC);

        Instant trialEndAt = account.getTrialEndAt();
        LocalDate trialEndDateUtc = trialEndAt != null ? LocalDate.ofInstant(trialEndAt, ZoneOffset.UTC) : null;

        boolean inTrial = trialEndAt != null && now.isBefore(trialEndAt);
        boolean trialExpired = trialEndAt != null && now.isAfter(trialEndAt);

        long trialDaysRemaining = 0;
        if (inTrial && trialEndDateUtc != null) {
            trialDaysRemaining = ChronoUnit.DAYS.between(todayUtc, trialEndDateUtc);
            if (trialDaysRemaining < 0) trialDaysRemaining = 0;
        }

        return new AccountAdminDetailsResponse(
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getTenantSchema(),
                account.getStatus(),
                account.getType(),
                account.getSubscriptionPlan(),
                account.getTaxIdType(),
                account.getTaxIdNumber(),
                account.getAudit() != null ? account.getAudit().getCreatedAt() : null,
                account.getTrialEndAt(),
                account.getPaymentDueDate(),
                account.getAudit() != null ? account.getAudit().getDeletedAt() : null,
                inTrial,
                trialExpired,
                trialDaysRemaining,
                admin != null ? controlPlaneUserApiMapper.toAdminSummary(admin) : null,
                totalUsers,
                account.isOperational()
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.mapper;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountResponse;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import org.springframework.stereotype.Component;

@Component
public class AccountApiMapper {

    public AccountResponse toResponse(Account account) {
        return new AccountResponse(
                account.getId(),
                account.getDisplayName(),
                account.getSlug(),
                account.getTenantSchema(),
                account.getStatus(),
                account.getType(),
                account.getSubscriptionPlan(),
                account.getAudit() != null ? account.getAudit().getCreatedAt() : null,
                account.getTrialEndAt()
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/api/mapper/AccountUserApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.controlplane.accounts.api.dto.summary.AccountTenantUserSummaryResponse;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;

@Component
public class AccountUserApiMapper {

    public AccountTenantUserSummaryResponse toAccountUserSummary(UserSummaryData user) {

        boolean enabled =
                !user.deleted()
                && !user.suspendedByAccount()
                && !user.suspendedByAdmin();

        return new AccountTenantUserSummaryResponse(
                user.id(),
                user.accountId(),
                user.name(),
                user.email(),
                user.role(),
                user.suspendedByAccount(),
                user.suspendedByAdmin(),
                enabled
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountAppService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import brito.com.multitenancy001.controlplane.accounts.app.command.AccountStatusChangeCommand;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountAdminDetailsProjection;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountStatusChangeResult;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.signup.app.AccountOnboardingService;
import brito.com.multitenancy001.controlplane.signup.app.command.SignupCommand;
import brito.com.multitenancy001.controlplane.signup.app.dto.SignupResult;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.List;

/**
 * Application Service central do Control Plane para o agregado Account.
 *
 * Responsabilidades:
 * - Orquestrar casos de uso relacionados a contas (signup, consultas administrativas, mudança de status).
 * - Garantir fronteira clara entre Controller e Domínio (DDD layered).
 * - Coordenar múltiplos serviços especializados (onboarding, status, usuários, auditoria).
 *
 * Regras arquiteturais:
 * - Controllers NUNCA acessam repositórios diretamente.
 * - Todas as leituras passam por UnitOfWork readOnly().
 * - Todas as mutações passam por UnitOfWork transacional.
 *
 * Regras de domínio:
 * - Account deletada logicamente não pode ser operada.
 * - Validações semânticas usam ApiErrorCode como fonte única.
 * - O tempo é sempre obtido via AppClock.
 */
@Service
@RequiredArgsConstructor
public class AccountAppService {

    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final AccountRepository accountRepository;
    private final AccountOnboardingService accountOnboardingService;
    private final AccountStatusService accountStatusService;
    private final AccountTenantUserService accountTenantUserService;
    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AppClock appClock;

    // =========================================================
    // 1) ONBOARDING / SIGNUP
    // =========================================================

    public SignupResult createAccount(SignupCommand signupCommand) {
        /* Orquestra fluxo de onboarding e criação de Account (delegado ao onboarding). */
        if (signupCommand == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "signupCommand é obrigatório", 400);
        return accountOnboardingService.createAccount(signupCommand);
    }

    // =========================================================
    // 2) CONSULTAS
    // =========================================================

    public List<Account> listAccounts() {
        /* Lista contas não deletadas. */
        return publicSchemaUnitOfWork.readOnly(accountRepository::findAllByDeletedFalse);
    }

    public Account getAccount(Long accountId) {
        /* Busca conta por id (não deletada). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);

        return publicSchemaUnitOfWork.readOnly(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND))
        );
    }

    public AccountAdminDetailsProjection getAccountAdminDetails(Long accountId) {
        /* Retorna visão admin com total de usuários e primeiro admin (se existir). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);

        return publicSchemaUnitOfWork.readOnly(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND));

            long totalUsers = controlPlaneUserRepository.countByAccount_IdAndDeletedFalse(accountId);
            ControlPlaneUser admin = controlPlaneUserRepository.findFirstAdminByAccountId(accountId).orElse(null);

            return new AccountAdminDetailsProjection(account, admin, totalUsers);
        });
    }

    // =========================================================
    // 3) STATUS / SOFT DELETE / RESTORE
    // =========================================================

    public AccountStatusChangeResult changeAccountStatus(Long accountId, AccountStatusChangeCommand cmd) {
        /* Orquestra mudança de status (delegado ao service específico). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (cmd == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "cmd é obrigatório", 400);

        return accountStatusService.changeAccountStatus(accountId, cmd);
    }

    public void softDeleteAccount(Long accountId) {
        /* Soft delete de account (delegado ao service específico). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        accountStatusService.softDeleteAccount(accountId);
    }
    
    
    
    
    
    

    public void restoreAccount(Long accountId) {
        /* Restaura account deletada (delegado ao service específico). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        accountStatusService.restoreAccount(accountId);
    }

    public List<UserSummaryData> listTenantUsers(Long accountId, boolean onlyOperational) {
        /* Lista usuários do tenant associado à account. */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        return accountTenantUserService.listTenantUsers(accountId, onlyOperational);
    }

    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        /* Suspende/reativa usuário do tenant via ação admin. */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

        accountTenantUserService.setUserSuspendedByAdmin(accountId, userId, suspended);
    }

    // =========================================================
    // 4) CONSULTAS ADMIN (paginação)
    // =========================================================

    private static final int DEFAULT_PAGE_SIZE = 20;
    private static final int MAX_PAGE_SIZE = 100;
    private static final long MAX_CREATED_BETWEEN_DAYS = 90;

    private Pageable normalizePageable(Pageable pageable) {
        /* Normaliza limites de paginação para evitar abuso e manter comportamento consistente. */
        if (pageable == null) return PageRequest.of(0, DEFAULT_PAGE_SIZE);

        int page = Math.max(0, pageable.getPageNumber());
        int size = pageable.getPageSize();

        if (size <= 0) size = DEFAULT_PAGE_SIZE;
        if (size > MAX_PAGE_SIZE) size = MAX_PAGE_SIZE;

        return PageRequest.of(page, size, pageable.getSort());
    }

    private void assertValidCreatedBetweenRange(Instant start, Instant end) {
        /* Valida intervalo (start/end) para consultas por data de criação. */
        if (start == null || end == null) throw new ApiException(ApiErrorCode.INVALID_RANGE, "start/end são obrigatórios", 400);
        if (end.isBefore(start)) throw new ApiException(ApiErrorCode.INVALID_RANGE, "end deve ser >= start", 400);

        Duration d = Duration.between(start, end);
        if (d.toDays() > MAX_CREATED_BETWEEN_DAYS) {
            throw new ApiException(ApiErrorCode.RANGE_TOO_LARGE, "Intervalo máximo é " + MAX_CREATED_BETWEEN_DAYS + " dias", 400);
        }
    }

    public Account findBySlug(String slug) {
        /* Busca conta por slug (case-insensitive) e não deletada. */
        if (slug == null || slug.isBlank()) throw new ApiException(ApiErrorCode.INVALID_SLUG, "slug é obrigatório", 400);

        String normalized = slug.trim();

        return publicSchemaUnitOfWork.readOnly(() ->
                accountRepository.findBySlugAndDeletedFalseIgnoreCase(normalized)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND))
        );
    }

    public Page<Account> listAccountsByStatus(AccountStatus status, Pageable pageable) {
        /* Lista contas por status com paginação normalizada. */
        if (status == null) throw new ApiException(ApiErrorCode.STATUS_REQUIRED, "status é obrigatório", 400);

        Pageable p = normalizePageable(pageable);
        return publicSchemaUnitOfWork.readOnly(() -> accountRepository.findByStatusAndDeletedFalse(status, p));
    }

    public Page<Account> listAccountsCreatedBetween(Instant start, Instant end, Pageable pageable) {
        /* Lista contas criadas em intervalo, com validação e paginação normalizada. */
        assertValidCreatedBetweenRange(start, end);

        Pageable p = normalizePageable(pageable);
        return publicSchemaUnitOfWork.readOnly(() -> accountRepository.findAccountsCreatedBetween(start, end, p));
    }

    public Page<Account> searchAccountsByDisplayName(String term, Pageable pageable) {
        /* Busca por displayName com paginação normalizada. */
        if (term == null || term.isBlank()) throw new ApiException(ApiErrorCode.INVALID_SEARCH, "term é obrigatório", 400);

        String normalized = term.trim();
        Pageable p = normalizePageable(pageable);

        return publicSchemaUnitOfWork.readOnly(() -> accountRepository.searchByDisplayName(normalized, p));
    }

    /**
     * Overdue é DATA CIVIL (paymentDueDate é LocalDate/DATE).
     * Mantemos compatibilidade aceitando Instant e convertendo explicitamente para LocalDate em UTC
     * (sem timezone implícito do servidor).
     */
    public List<Account> listOverdueAccounts(Instant today, AccountStatus status) {
        /* Lista contas overdue com base em data civil UTC (compatibilidade). */
        Instant baseInstant = (today != null ? today : appClock.instant());
        LocalDate baseDateUtc = LocalDate.ofInstant(baseInstant, ZoneOffset.UTC);

        AccountStatus st = (status != null ? status : AccountStatus.ACTIVE);

        return publicSchemaUnitOfWork.readOnly(() ->
                accountRepository.findOverdueAccountsNotDeleted(st, baseDateUtc)
        );
    }

    public long countOperationalAccounts() {
        /* Conta accounts operacionais. */
        return publicSchemaUnitOfWork.readOnly(accountRepository::countOperationalAccounts);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountEntitlementsProvisioningService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountEntitlements;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountEntitlementsRepository;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.Instant;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsProvisioningService {

    private final AccountEntitlementsRepository accountEntitlementsRepository;
    private final AppClock appClock;

    /**
     * Garante entitlements default para TENANT (idempotente / race-safe).
     * - BUILT_IN => não persiste entitlements (ilimitado)
     * - TENANT   => INSERT ... ON CONFLICT DO NOTHING + SELECT
     *
     * IMPORTANTE:
     * Este método deve rodar dentro de uma TX write-capable (via PublicSchemaUnitOfWork.tx()).
     */
    public AccountEntitlements ensureDefaultEntitlementsForTenant(Account account) {
        if (account == null || account.getId() == null) {
            // status e mensagem poderiam ser só "new ApiException(ApiErrorCode.ACCOUNT_REQUIRED)"
            // mas mantive override porque você já fazia isso.
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "Conta é obrigatória", 400);
        }

        if (account.isBuiltInAccount()) {
            // BUILT_IN/PLATFORM => ilimitado / não precisa persistir
            return null;
        }

        // AppClock é a única fonte de tempo
        Instant now = appClock.instant();

        int inserted = accountEntitlementsRepository.insertDefaultIfMissing(
                account.getId(),
                5,
                100,
                100,
                now,
                now
        );

        return accountEntitlementsRepository.findByAccount_Id(account.getId())
                .orElseThrow(() -> new ApiException(
                        ApiErrorCode.ENTITLEMENTS_NOT_FOUND,
                        "Entitlements não encontrados para a conta " + account.getId()
                                + " (inserted=" + inserted + ")",
                        500
                ));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountFactory.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import java.text.Normalizer;
import java.util.Locale;
import java.util.UUID;

import brito.com.multitenancy001.controlplane.accounts.app.command.CreateAccountCommand;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;

public final class AccountFactory {

    private AccountFactory() {}

   // src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountFactory.java
// Atualizar o método newTenantAccount

    public static Account newTenantAccount(CreateAccountCommand cmd) {
        if (cmd == null) throw new IllegalArgumentException("cmd é obrigatório");

        Account account = new Account();

        account.setDisplayName(cmd.displayName());
        account.setLoginEmail(cmd.loginEmail());
        account.setTaxCountryCode(cmd.taxCountryCode());
        account.setTaxIdType(cmd.taxIdType());
        account.setTaxIdNumber(cmd.taxIdNumber());

        String baseSlug = slugify(cmd.displayName());
        account.setSlug(baseSlug + "-" + shortId());

        account.ensureTenantSchema();

        account.setStatus(AccountStatus.PROVISIONING);

        // Valores padrão para campos adicionais
        account.setCountry("Brasil");
        account.setTimezone("America/Sao_Paulo");
        account.setLocale("pt_BR");
        account.setCurrency("BRL");

        return account;
    }

    private static String shortId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 6);
    }

    private static String slugify(String input) {
        if (input == null || input.isBlank()) return "tenant";
        String n = Normalizer.normalize(input, Normalizer.Form.NFD)
                .replaceAll("\\p{InCombiningDiacriticalMarks}+", "");
        String s = n.toLowerCase(Locale.ROOT)
                .replaceAll("[^a-z0-9\\s-]", "")
                .trim()
                .replaceAll("\\s+", "-")
                .replaceAll("-{2,}", "-");
        return s.isBlank() ? "tenant" : s;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountStatusService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import brito.com.multitenancy001.controlplane.accounts.app.command.AccountStatusChangeCommand;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountStatusChangeResult;
import brito.com.multitenancy001.controlplane.accounts.app.dto.AccountStatusSideEffect;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditService;
import brito.com.multitenancy001.integration.security.ControlPlaneRequestIdentityService;
import brito.com.multitenancy001.integration.tenant.TenantUsersIntegrationService;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

/**
 * Application Service (Control Plane): mudança de status e lifecycle da Account.
 *
 * Responsabilidades:
 * - Alterar Account.status no public schema.
 * - Aplicar side-effects no Tenant (suspender/reativar/soft-delete users) via Integration Service.
 * - Registrar auditoria append-only via SecurityAuditService para mudanças sensíveis de estado.
 *
 * Regras:
 * - Controller não acessa repository diretamente.
 * - Fonte de tempo: AppClock.
 * - Auditoria: ATTEMPT/SUCCESS/DENIED/FAILURE, details JSON estruturado, sem segredos.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AccountStatusService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AccountRepository accountRepository;
    private final TenantUsersIntegrationService tenantUsersIntegrationService;
    private final AppClock appClock;

    private final SecurityAuditService securityAuditService;
    private final ControlPlaneRequestIdentityService requestIdentity;
    private final JsonDetailsMapper jsonDetailsMapper;

    public AccountStatusChangeResult changeAccountStatus(Long accountId, AccountStatusChangeCommand cmd) {
        /* Altera status da account e aplica side-effects no tenant + auditoria append-only. */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (cmd == null || cmd.status() == null) throw new ApiException(ApiErrorCode.STATUS_REQUIRED, "status é obrigatório", 400);

        log.info("🔄 Iniciando mudança de status da conta [ID: {}] para [{}]", accountId, cmd.status());

        Instant now = appClock.instant();

        Long actorUserId = nullSafe(() -> requestIdentity.getCurrentUserId());
        String actorEmail = nullSafe(() -> requestIdentity.getCurrentEmail());

        // DETAILS base (estruturado)
        Map<String, Object> details = new LinkedHashMap<>();
        details.put("scope", "controlplane.accounts");
        details.put("event", "account_status_change");
        details.put("accountId", accountId);
        details.put("requestedStatus", cmd.status().name());
        details.put("occurredAt", now.toString());

        if (cmd.origin() != null && !cmd.origin().isBlank()) details.put("origin", cmd.origin().trim());
        if (cmd.reason() != null && !cmd.reason().isBlank()) details.put("reason", cmd.reason().trim());

        if (actorUserId != null) details.put("actorUserId", actorUserId);
        if (actorEmail != null) details.put("actorEmail", actorEmail);

        // Action type existente no seu enum (não quebra histórico)
        SecurityAuditActionType actionType = SecurityAuditActionType.ACCOUNT_STATUS_CHANGED;

        // ATTEMPT
        recordAudit(actionType, AuditOutcome.ATTEMPT, actorEmail, actorUserId, accountId, null, details);

        try {
            AccountStatusChangeResult result = publicSchemaUnitOfWork.tx(() -> {

                Account account = getAccountByIdRaw(accountId);
                AccountStatus previous = account.getStatus();

                log.debug("Status atual da conta: [{}] -> novo status: [{}]", previous, cmd.status());

                AccountStatus newStatus = cmd.status();
                account.setStatus(newStatus);

                // Reativar também restaura soft-delete se necessário
                if (newStatus == AccountStatus.ACTIVE && account.isDeleted()) {
                    account.restore();
                    details.put("restoredSoftDelete", true);
                    log.debug("Conta estava deletada e foi restaurada");
                }

                accountRepository.save(account);

                // ✅ Fronteira explícita: tenantSchema (CP) -> execução Tenant
                String tenantSchema = account.getTenantSchema();
                details.put("tenantSchema", tenantSchema);
                details.put("fromStatus", previous != null ? previous.name() : null);
                details.put("toStatus", newStatus.name());

                int affected = 0;
                boolean applied = false;
                AccountStatusSideEffect action = AccountStatusSideEffect.NONE;

                if (newStatus == AccountStatus.SUSPENDED) {
                    log.info("⏸️ Aplicando suspensão aos usuários do tenant [{}]", tenantSchema);
                    affected = tenantUsersIntegrationService.suspendAllUsersByAccount(tenantSchema, account.getId());
                    applied = true;
                    action = AccountStatusSideEffect.SUSPEND_BY_ACCOUNT;

                } else if (newStatus == AccountStatus.ACTIVE) {
                    log.info("▶️ Reativando usuários do tenant [{}]", tenantSchema);
                    affected = tenantUsersIntegrationService.unsuspendAllUsersByAccount(tenantSchema, account.getId());
                    applied = true;
                    action = AccountStatusSideEffect.UNSUSPEND_BY_ACCOUNT;

                } else if (newStatus == AccountStatus.CANCELLED) {
                    log.info("❌ Cancelando conta e removendo usuários do tenant [{}]", tenantSchema);
                    affected = cancelAccount(account);
                    applied = true;
                    action = AccountStatusSideEffect.CANCEL_ACCOUNT;
                }

                details.put("sideEffectApplied", applied);
                details.put("sideEffectAction", action.name());
                details.put("affectedUsers", affected);

                log.info("✅ Status da conta [{}] alterado com sucesso. Ação: {}, Usuários afetados: {}", 
                        accountId, action, affected);

                return new AccountStatusChangeResult(
                        account.getId(),
                        account.getStatus(),
                        previous,
                        appClock.instant(),
                        tenantSchema,
                        applied,
                        action,
                        affected
                );
            });

            // SUCCESS
            recordAudit(actionType, AuditOutcome.SUCCESS, actorEmail, actorUserId, accountId, null, details);
            return result;

        } catch (ApiException ex) {
            details.put("error", ex.getError());
            details.put("status", ex.getStatus());

            if (ex.getStatus() == 401 || ex.getStatus() == 403) {
                log.warn("🚫 Acesso negado ao alterar status da conta [{}]: {}", accountId, ex.getMessage());
                recordAudit(actionType, AuditOutcome.DENIED, actorEmail, actorUserId, accountId, null, details);
            } else {
                log.error("❌ Erro ao alterar status da conta [{}]: {}", accountId, ex.getMessage());
                recordAudit(actionType, AuditOutcome.FAILURE, actorEmail, actorUserId, accountId, null, details);
            }
            throw ex;

        } catch (Exception ex) {
            log.error("❌ Erro inesperado ao alterar status da conta [{}]", accountId, ex);
            details.put("exception", ex.getClass().getSimpleName());
            recordAudit(actionType, AuditOutcome.FAILURE, actorEmail, actorUserId, accountId, null, details);
            throw ex;
        }
    }

  public void softDeleteAccount(Long accountId) {
    if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);

    log.info("🗑️ Iniciando exclusão da conta [ID: {}]", accountId);

    // PRIMEIRA TRANSAÇÃO: Marca a Account como deletada no Public Schema
    Account account = publicSchemaUnitOfWork.tx(() -> {
        log.debug("Passo 1/2: Marcando conta como deletada no schema public");
        Account acc = getAccountByIdRaw(accountId);

        if (acc.isBuiltInAccount()) {
            log.warn("🚫 Tentativa de excluir conta do sistema [ID: {}]", accountId);
            throw new ApiException(ApiErrorCode.BUILTIN_ACCOUNT_PROTECTED, 
                "Contas do sistema não podem ser excluídas", 403);
        }

        acc.softDelete(appClock.instant());
        Account saved = accountRepository.save(acc);
        log.info("✅ Conta [{} - {}] marcada como deletada", accountId, acc.getDisplayName());
        return saved;
    });

    // SEGUNDA TRANSAÇÃO: Executa em UM NOVO THREAD para garantir isolamento completo
    String tenantSchema = account.getTenantSchema();
    log.info("📦 Passo 2/2: Removendo usuários do tenant [{}]", tenantSchema);

    try {
        // Executa em um novo contexto transacional completamente isolado
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            return publicSchemaUnitOfWork.requiresNew(() -> {
                log.debug("Executando limpeza de usuários em transação isolada");
                return tenantUsersIntegrationService.softDeleteAllUsersByAccount(tenantSchema, account.getId());
            });
        });

        Integer usuariosRemovidos = future.get(30, TimeUnit.SECONDS); // timeout de 30s

        if (usuariosRemovidos != null && usuariosRemovidos > 0) {
            log.info("✅ {} usuário(s) do tenant [{}] foram removidos", usuariosRemovidos, tenantSchema);
        } else {
            log.info("ℹ️ Nenhum usuário encontrado no tenant [{}] para remover", tenantSchema);
        }

        log.info("🎉 Exclusão da conta [{}] concluída com sucesso", accountId);

    } catch (Exception e) {
        log.warn("⚠️ A conta [{}] foi excluída, mas houve um problema ao remover os usuários do tenant [{}].", 
                accountId, tenantSchema);
        log.warn("   Motivo: Não foi possível completar a operação no tenant. A limpeza dos usuários precisará ser feita manualmente.");
        log.debug("Detalhes técnicos:", e);
    }
}

    public void restoreAccount(Long accountId) {
        /* Restaura account (se permitido) + restaura users do tenant (side-effect). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);

        log.info("🔄 Iniciando restauração da conta [ID: {}]", accountId);

        // PRIMEIRA TRANSAÇÃO: Restaura a Account no Public Schema
        Account account = publicSchemaUnitOfWork.tx(() -> {
            log.debug("Passo 1/2: Restaurando conta no schema public");
            Account acc = getAccountByIdRaw(accountId);

            if (acc.isBuiltInAccount() && acc.isDeleted()) {
                log.warn("🚫 Tentativa de restaurar conta do sistema [ID: {}]", accountId);
                throw new ApiException(ApiErrorCode.BUILTIN_ACCOUNT_PROTECTED, 
                    "Contas do sistema não podem ser restauradas", 403);
            }

            acc.restore();
            Account saved = accountRepository.save(acc);
            log.info("✅ Conta [{} - {}] restaurada", accountId, acc.getDisplayName());
            return saved;
        });

        // SEGUNDA TRANSAÇÃO (REQUIRES_NEW): Restaura os usuários do tenant
        String tenantSchema = account.getTenantSchema();
        log.info("📦 Restaurando usuários do tenant [{}]", tenantSchema);

        try {
            publicSchemaUnitOfWork.requiresNew(() -> {
                log.debug("Executando restauração de usuários em transação separada");
                tenantUsersIntegrationService.restoreAllUsersByAccount(tenantSchema, account.getId());
                return null;
            });

            log.info("✅ Usuários do tenant [{}] restaurados com sucesso", tenantSchema);
            log.info("🎉 Restauração da conta [{}] concluída com sucesso", accountId);

        } catch (Exception e) {
            log.warn("⚠️ A conta [{}] foi restaurada, mas houve um problema ao restaurar os usuários do tenant [{}].", 
                    accountId, tenantSchema);
            log.warn("   Motivo: {}", e.getMessage());
            log.debug("Detalhes técnicos:", e);
            // Não relançar a exceção - a operação principal já foi concluída
        }
    }

    private int cancelAccount(Account account) {
        /* Cancela account: soft delete (se necessário) + status CANCELLED + soft delete users. */
        log.info("📝 Cancelando conta [ID: {} - {}]", account.getId(), account.getDisplayName());

        // PRIMEIRA TRANSAÇÃO: Atualiza a Account
        publicSchemaUnitOfWork.requiresNew(() -> {
            if (!account.isDeleted()) {
                account.softDelete(appClock.instant());
            }
            account.setStatus(AccountStatus.CANCELLED);
            accountRepository.save(account);
            log.info("✅ Conta [{}] marcada como CANCELADA", account.getId());
            return null;
        });

        // SEGUNDA TRANSAÇÃO: Deleta os usuários do tenant
        String tenantSchema = account.getTenantSchema();
        try {
            int removidos = publicSchemaUnitOfWork.requiresNew(() -> 
                tenantUsersIntegrationService.softDeleteAllUsersByAccount(tenantSchema, account.getId())
            );
            log.info("✅ {} usuário(s) do tenant removidos durante cancelamento", removidos);
            return removidos;
        } catch (Exception e) {
            log.warn("⚠️ Cancelamento parcial: usuários do tenant não foram removidos. Motivo: {}", e.getMessage());
            log.debug("Detalhes:", e);
            return 0;
        }
    }

    private Account getAccountByIdRaw(Long accountId) {
        /* Busca account por id sem exigir enabled/ready (raw). */
        return accountRepository.findById(accountId)
                .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404));
    }

    private void recordAudit(SecurityAuditActionType actionType,
                             AuditOutcome outcome,
                             String actorEmail,
                             Long actorUserId,
                             Long accountId,
                             String tenantSchema,
                             Map<String, Object> details) {
        /* Persiste evento append-only (public schema) com JSON details estruturado. */
        String detailsJson = (details == null) ? null : jsonDetailsMapper.toJsonNode(details).toString();

        securityAuditService.record(
                actionType,
                outcome,
                actorEmail,
                actorUserId,
                null,
                null,
                accountId,
                tenantSchema,
                detailsJson
        );
    }

    private static <T> T nullSafe(SupplierEx<T> fn) {
        /* Para jobs sem auth: captura exceções de identidade e devolve null. */
        try {
            return fn.get();
        } catch (Exception ex) {
            return null;
        }
    }

    @FunctionalInterface
    private interface SupplierEx<T> {
        T get();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/AccountTenantUserService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.shared.contracts.TenantUserOperations;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Serviço de aplicação responsável por operações administrativas
 * sobre usuários de tenants no contexto do Control Plane.
 *
 * <p>Responsabilidades:</p>
 * <ul>
 *   <li>Suspender ou reativar usuários por decisão administrativa.</li>
 *   <li>Garantir consistência entre Account e seus Tenant Users.</li>
 *   <li>Atuar como fachada para operações em massa em usuários de tenants.</li>
 * </ul>
 *
 * <p>Regras de Negócio:</p>
 * <ul>
 *   <li>Usuários suspensos por admin não podem se autenticar.</li>
 *   <li>Operações respeitam o estado operacional da Account.</li>
 *   <li>O último TENANT_OWNER ativo de uma conta não pode ser suspenso ou deletado.</li>
 * </ul>
 *
 * <p>Arquitetura:</p>
 * <ul>
 *   <li>Este serviço NÃO conhece os detalhes de implementação do Tenant.
 *       Ele depende da abstração {@link TenantUserOperations}, que é implementada
 *       pelo módulo de integração.</li>
 *   <li>Isolamento completo entre os bounded contexts ControlPlane e Tenant.</li>
 * </ul>
 *
 * @see TenantUserOperations
 * @see brito.com.multitenancy001.integration.tenant.TenantProvisioningIntegrationService
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AccountTenantUserService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AccountRepository accountRepository;
    
    // ✅ Agora depende da INTERFACE, não da implementação concreta
    private final TenantUserOperations tenantUserOperations;

    /**
     * Lista os usuários de um tenant, com opção de filtrar apenas os operacionais.
     *
     * @param accountId       O ID da conta (obrigatório).
     * @param onlyOperational Se true, retorna apenas usuários operacionais.
     * @return Lista de resumos dos usuários.
     * @throws ApiException Se a conta não for encontrada.
     */
    public List<UserSummaryData> listTenantUsers(Long accountId, boolean onlyOperational) {
        Account account = publicSchemaUnitOfWork.readOnly(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException(
                                ApiErrorCode.ACCOUNT_NOT_FOUND, 
                                "Conta não encontrada", 
                                404))
        );

        String tenantSchema = account.getTenantSchema();

        return tenantUserOperations.listUserSummaries(tenantSchema, account.getId(), onlyOperational);
    }

    /**
     * Define o status de suspensão por admin de um usuário específico.
     *
     * @param accountId O ID da conta (obrigatório).
     * @param userId    O ID do usuário alvo (obrigatório).
     * @param suspended O novo status de suspensão.
     * @throws ApiException Se a conta não for encontrada ou a operação violar regras.
     */
    public void setUserSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        Account account = publicSchemaUnitOfWork.readOnly(() ->
                accountRepository.findByIdAndDeletedFalse(accountId)
                        .orElseThrow(() -> new ApiException(
                                ApiErrorCode.ACCOUNT_NOT_FOUND, 
                                "Conta não encontrada", 
                                404))
        );

        String tenantSchema = account.getTenantSchema();

        tenantUserOperations.setUserSuspendedByAdmin(tenantSchema, account.getId(), userId, suspended);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/audit/AccountProvisioningAuditService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.audit;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountProvisioningEvent;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountProvisioningEventRepository;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AccountProvisioningAuditService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AccountProvisioningEventRepository accountProvisioningEventRepository;
    private final AppClock appClock;

    public void started(Long accountId, String message, String detailsJson) {
        record(accountId, ProvisioningStatus.STARTED, null, message, detailsJson);
    }

    public void success(Long accountId, String message, String detailsJson) {
        record(accountId, ProvisioningStatus.SUCCESS, null, message, detailsJson);
    }

    public void failed(Long accountId, ProvisioningFailureCode failureCode, String message, String detailsJson) {
        record(accountId, ProvisioningStatus.FAILED, failureCode, message, detailsJson);
    }

    private void record(
            Long accountId,
            ProvisioningStatus status,
            ProvisioningFailureCode failureCode,
            String message,
            String detailsJson
    ) {
        // ✅ write-capable TX no public schema
        publicSchemaUnitOfWork.tx(() -> {
            AccountProvisioningEvent e = new AccountProvisioningEvent(
                    accountId,
                    status,
                    failureCode,
                    message,
                    detailsJson,
                    appClock.instant()
            );
            accountProvisioningEventRepository.save(e);
        });
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/command/AccountStatusChangeCommand.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.command;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;

/**
 * Command para mudança de status da Account (Control Plane).
 *
 * Regras:
 * - status é obrigatório.
 * - reason e origin são opcionais, mas recomendados para auditoria.
 *
 * Origin sugeridos:
 * - "billing_job"
 * - "admin_api"
 * - "system"
 */
public record AccountStatusChangeCommand(
        AccountStatus status,
        String reason,
        String origin
) {
    public AccountStatusChangeCommand(AccountStatus status) {
        /* Construtor de compatibilidade para chamadas antigas. */
        this(status, null, null);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/command/CreateAccountCommand.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.command;

import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;

public record CreateAccountCommand(
        String displayName,
        String loginEmail,
        String taxCountryCode,
        TaxIdType taxIdType,
        String taxIdNumber
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountAdminDetailsProjection.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;

public record AccountAdminDetailsProjection(
        Account account,
        ControlPlaneUser admin,
        long totalUsers
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountStatusChangeResponse.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.dto;

import java.time.Instant;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;

public record AccountStatusChangeResponse(
        Long accountId,
        AccountStatus newStatus,
        AccountStatus previousStatus,
        Instant changedAt,
        String tenantSchema,
        boolean tenantUsersUpdated,
        AccountStatusSideEffect action,
        int affectedUsers
) {
    public static AccountStatusChangeResponse from(AccountStatusChangeResult r) {
        return new AccountStatusChangeResponse(
                r.accountId(),
                r.newStatus(),
                r.previousStatus(),
                r.changedAt(),
                r.tenantSchema(),
                r.tenantUsersUpdated(),
                r.action(),
                r.affectedUsers()
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountStatusChangeResult.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.dto;

import java.time.Instant;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;

public record AccountStatusChangeResult(
        Long accountId,
        AccountStatus newStatus,
        AccountStatus previousStatus,
        Instant changedAt,
        String tenantSchema,
        boolean tenantUsersUpdated,
        AccountStatusSideEffect action,
        int affectedUsers
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/dto/AccountStatusSideEffect.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.dto;

/**
 * Efeito colateral aplicado no Tenant como consequência da mudança de status do Account.
 *
 * - NONE: nenhuma ação no tenant
 * - SUSPEND_BY_ACCOUNT: suspendeu todos os usuários do tenant por conta
 * - UNSUSPEND_BY_ACCOUNT: reativou (removeu suspensão) de todos os usuários do tenant por conta
 * - CANCEL_ACCOUNT: cancelou conta (soft-delete + status CANCELLED) e soft-delete de usuários no tenant
 */
public enum AccountStatusSideEffect {
    NONE,
    SUSPEND_BY_ACCOUNT,
    UNSUSPEND_BY_ACCOUNT,
    CANCEL_ACCOUNT
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/AccountProvisioningEventQueryService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.query;

import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.app.query.dto.AccountProvisioningEventData;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountProvisioningEvent;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountProvisioningEventRepository;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountProvisioningEventQueryService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AccountProvisioningEventRepository accountProvisioningEventRepository;

    public Page<AccountProvisioningEventData> listByAccount(Long accountId, Pageable pageable) {
        return publicSchemaUnitOfWork.readOnly(() ->
                accountProvisioningEventRepository.findByAccountId(accountId, pageable)
                        .map(this::toData)
        );
    }

    public Optional<AccountProvisioningEventData> getLatestByAccount(
            Long accountId,
            ProvisioningStatus requireStatus
    ) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            Optional<AccountProvisioningEvent> event;

            if (requireStatus == null) {
                event = accountProvisioningEventRepository.findTopByAccountIdOrderByCreatedAtDesc(accountId);
            } else {
                event = accountProvisioningEventRepository.findTopByAccountIdAndStatusOrderByCreatedAtDesc(accountId, requireStatus);
            }

            return event.map(this::toData);
        });
    }

    private AccountProvisioningEventData toData(AccountProvisioningEvent e) {
        return new AccountProvisioningEventData(
                e.getId(),
                e.getAccountId(),
                e.getStatus(),
                parseFailureCodeOrNull(e.getFailureCode()),
                e.getMessage(),
                e.getDetailsJson(),
                e.getCreatedAt()
        );
    }

    private ProvisioningFailureCode parseFailureCodeOrNull(String raw) {
        if (raw == null || raw.isBlank()) return null;
        try {
            return ProvisioningFailureCode.valueOf(raw);
        } catch (IllegalArgumentException ex) {
            return null;
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/ControlPlaneAccountQueryService.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.query;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import java.time.LocalDate;
import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlaneAccountQueryService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AccountRepository accountRepository;

    public Account getEnabledById(Long id) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (id == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "id é obrigatório", 400);

            return accountRepository.findEnabledById(id)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_ENABLED, "Conta não encontrada ou não operacional", 404));
        });
    }

    public Account getAnyById(Long id) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (id == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "id é obrigatório", 400);

            return accountRepository.findAnyById(id)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404));
        });
    }

    public long countByStatusesNotDeleted(List<AccountStatus> statuses) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (statuses == null || statuses.isEmpty()) {
                throw new ApiException(ApiErrorCode.ACCOUNT_STATUSES_REQUIRED, "statuses é obrigatório", 400);
            }
            return accountRepository.countByStatusesAndDeletedFalse(statuses);
        });
    }

    public List<Account> findPaymentDueBeforeNotDeleted(LocalDate date) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (date == null) throw new ApiException(ApiErrorCode.DATE_REQUIRED, "date é obrigatório", 400);

            return accountRepository.findByPaymentDueDateBeforeAndDeletedFalse(date);
        });
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/app/query/dto/AccountProvisioningEventData.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.app.query.dto;

import java.time.Instant;

import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;

public record AccountProvisioningEventData(
        Long id,
        Long accountId,
        ProvisioningStatus status,
        ProvisioningFailureCode failureCode,
        String message,
        String detailsJson,
        Instant createdAt
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/Account.java
============================================================
// src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/Account.java
// Versão completa e corrigida

package brito.com.multitenancy001.controlplane.accounts.domain;

import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.domain.DomainException;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import jakarta.persistence.*;
import lombok.*;

/**
 * Agregado raiz que representa uma conta (tenant) no sistema.
 * 
 * <p>Uma conta pode ser de dois tipos:</p>
 * <ul>
 *   <li>{@link AccountType#TENANT} - conta de cliente (tenant)</li>
 *   <li>{@link AccountType#PLATFORM} - conta interna da plataforma (Control Plane)</li>
 * </ul>
 * 
 * <p>As contas de cliente (TENANT) possuem um schema de banco de dados dedicado
 * ({@link #tenantSchema}) onde residem todos os dados específicos do tenant,
 * como usuários, produtos, categorias, etc.</p>
 * 
 * <p>Regras de negócio importantes:</p>
 * <ul>
 *   <li>O status da conta ({@link AccountStatus}) determina se ela está operacional</li>
 *   <li>Contas podem ser suspensas por inadimplência ou ação administrativa</li>
 *   <li>Soft delete ({@link #deleted}) é usado para remoção lógica</li>
 *   <li>Contas BUILT_IN/PLATFORM são protegidas contra exclusão</li>
 * </ul>
 * 
 * @see AccountStatus
 * @see AccountType
 * @see brito.com.multitenancy001.controlplane.accounts.app.AccountAppService
 */
@Entity
@Table(name = "accounts")
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Account implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_type", nullable = false, length = 20)
    @Builder.Default
    private AccountType type = AccountType.TENANT;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_origin", nullable = false, length = 20)
    @Builder.Default
    private EntityOrigin origin = EntityOrigin.ADMIN;

    @Column(name = "display_name", nullable = false, length = 150)
    private String displayName;

    @Column(name = "legal_name", length = 200)
    private String legalName;

    @Enumerated(EnumType.STRING)
    @Column(name = "legal_entity_type", nullable = false, length = 20)
    @Builder.Default
    private LegalEntityType legalEntityType = LegalEntityType.COMPANY;

    /**
     * Schema do banco de dados onde residem os dados do tenant.
     */
    @Column(name = "tenant_schema", nullable = false, unique = true, length = 100)
    private String tenantSchema;

    @Column(name = "slug", nullable = false, unique = true, length = 80)
    private String slug;

    @Column(name = "tax_country_code", nullable = false, length = 2)
    @Builder.Default
    private String taxCountryCode = "BR";

    @Enumerated(EnumType.STRING)
    @Column(name = "tax_id_type", length = 20)
    private TaxIdType taxIdType;

    @Column(name = "tax_id_number", length = 40)
    private String taxIdNumber;

    @Column(name = "login_email", nullable = false, columnDefinition = "citext")
    private String loginEmail;

    @Column(name = "billing_email", columnDefinition = "citext")
    private String billingEmail;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    @Builder.Default
    private AccountStatus status = AccountStatus.PROVISIONING;

    @Enumerated(EnumType.STRING)
    @Column(name = "subscription_plan", nullable = false, length = 50)
    @Builder.Default
    private SubscriptionPlan subscriptionPlan = SubscriptionPlan.FREE;

    @Column(name = "trial_end_at", columnDefinition = "timestamptz")
    private Instant trialEndAt;

    @Column(name = "payment_due_date", columnDefinition = "date")
    private LocalDate paymentDueDate;

    @Column(name = "next_billing_date", columnDefinition = "date")
    private LocalDate nextBillingDate;

    // =========================
    // Informações de contato
    // =========================

    @Column(length = 20)
    private String phone;

    @Column(length = 500)
    private String address;

    @Column(length = 100)
    private String city;

    @Column(length = 50)
    private String state;

    @Column(length = 60)
    @Builder.Default
    private String country = "Brasil";

    @Column(length = 60)
    @Builder.Default
    private String timezone = "America/Sao_Paulo";

    @Column(length = 20)
    @Builder.Default
    private String locale = "pt_BR";

    @Column(length = 3)
    @Builder.Default
    private String currency = "BRL";

    // =========================
    // Configurações adicionais
    // =========================

    @Column(name = "settings_json", columnDefinition = "TEXT")
    private String settingsJson;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    // =========================
    // Soft delete
    // =========================

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    // =========================
    // Relacionamentos
    // =========================

    @OneToMany(mappedBy = "account", fetch = FetchType.LAZY)
    @Builder.Default
    private List<ControlPlaneUser> controlPlaneUsers = new ArrayList<>();

    // =========================
    // Auditable / SoftDeletable
    // =========================

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // =========================
    // Semântica de sistema
    // =========================

    /**
     * Verifica se a conta é uma conta interna do sistema (BUILT_IN/PLATFORM).
     * 
     * @return true se for conta do sistema
     */
    public boolean isBuiltInAccount() {
        return origin == EntityOrigin.BUILT_IN || type == AccountType.PLATFORM;
    }

    // =========================
    // Soft delete / Restore
    // =========================

    /**
     * Aplica soft delete na conta.
     * 
     * @param now instante atual (deve vir do AppClock)
     * @throws DomainException se now for null
     */
    public void softDelete(Instant now) {
        if (now == null) throw new DomainException("now é obrigatório");
        if (this.deleted) return;

        this.deleted = true;
        if (this.audit != null) {
            this.audit.markDeleted(now);
        }
    }

    /**
     * Restaura uma conta previamente deletada.
     */
    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        if (this.audit != null) {
            this.audit.clearDeleted();
        }
    }

    public void setDeletedAt(Instant deletedAt) {
        if (this.audit != null) {
            this.audit.setDeletedAt(deletedAt);
        }
        this.deleted = deletedAt != null;
    }

    // =========================
    // Regras de domínio
    // =========================

    /**
     * Verifica se a conta está operacional (não deletada e status operacional).
     * 
     * @return true se a conta puder ser usada
     */
    public boolean isOperational() {
        return !deleted && status != null && status.isOperational();
    }

    /**
     * Lança exceção se a conta não estiver operacional.
     * 
     * @throws DomainException se a conta não estiver operacional
     */
    public void requireOperational() {
        if (!isOperational()) throw new DomainException("Conta não está operacional");
    }

    /**
     * Define o nome de exibição com validação.
     * 
     * @param value nome de exibição
     * @throws DomainException se value for nulo ou vazio
     */
    public void setDisplayNameSafe(String value) {
        if (value == null || value.isBlank()) throw new DomainException("displayName é obrigatório");
        this.displayName = value.trim();
    }

    /**
     * Define o slug com validação e normalização.
     * 
     * @param value slug desejado
     * @throws DomainException se value for inválido
     */
    public void setSlugSafe(String value) {
        if (value == null || value.isBlank()) throw new DomainException("slug é obrigatório");
        this.slug = normalizeSlug(value);
    }

    /**
     * Garante que a conta tenha um tenantSchema.
     * Se não tiver, gera um a partir do slug.
     */
    public void ensureTenantSchema() {
        if (this.tenantSchema == null || this.tenantSchema.isBlank()) {
            this.tenantSchema = generateTenantSchemaFromSlug(this.slug);
        }
    }

    /**
     * Inicia o período de trial gratuito.
     * 
     * @param now instante atual
     * @param days duração do trial em dias
     * @throws DomainException se parâmetros forem inválidos
     */
    public void startFreeTrial(Instant now, int days) {
        if (now == null) throw new DomainException("now é obrigatório");
        if (days <= 0) throw new DomainException("days inválido");

        this.status = AccountStatus.FREE_TRIAL;
        this.subscriptionPlan = SubscriptionPlan.FREE;
        this.trialEndAt = now.plus(days, ChronoUnit.DAYS);
    }

    /**
     * Ativa um plano pago para a conta.
     * 
     * @param plan plano contratado
     * @param paymentDueDate data de vencimento do pagamento
     * @param nextBillingDate próxima data de cobrança
     * @throws DomainException se parâmetros forem inválidos
     */
    public void activatePaidPlan(SubscriptionPlan plan, LocalDate paymentDueDate, LocalDate nextBillingDate) {
        if (plan == null) throw new DomainException("plan é obrigatório");
        if (plan == SubscriptionPlan.FREE) throw new DomainException("plan inválido");
        if (paymentDueDate == null) throw new DomainException("paymentDueDate é obrigatório");
        if (nextBillingDate == null) throw new DomainException("nextBillingDate é obrigatório");

        this.status = AccountStatus.ACTIVE;
        this.subscriptionPlan = plan;
        this.paymentDueDate = paymentDueDate;
        this.nextBillingDate = nextBillingDate;
    }

    /**
     * Atualiza as informações de contato da conta.
     */
    public void updateContactInfo(String phone, String address, String city, String state, String country) {
        if (phone != null) this.phone = phone.trim();
        if (address != null) this.address = address.trim();
        if (city != null) this.city = city.trim();
        if (state != null) this.state = state.trim();
        if (country != null && !country.isBlank()) this.country = country.trim();
    }

    /**
     * Atualiza as preferências de localização.
     */
    public void updateLocalization(String timezone, String locale, String currency) {
        if (timezone != null && !timezone.isBlank()) this.timezone = timezone.trim();
        if (locale != null && !locale.isBlank()) this.locale = locale.trim();
        if (currency != null && !currency.isBlank()) this.currency = currency.trim();
    }

    // =========================
    // Helpers
    // =========================

    /**
     * Normaliza um slug para o formato canônico.
     * 
     * @param raw slug bruto
     * @return slug normalizado
     * @throws DomainException se o slug for muito curto
     */
    private static String normalizeSlug(String raw) {
        String v = raw.trim().toLowerCase();
        v = v.replaceAll("[^a-z0-9\\-]", "-");
        v = v.replaceAll("-{2,}", "-");
        v = v.replaceAll("(^-|-$)", "");
        if (v.length() < 3) throw new DomainException("slug muito curto");
        return v;
    }

    /**
     * Gera um nome de schema único a partir do slug.
     * 
     * @param slug slug base
     * @return nome do schema no formato "t_<slug>_<random>"
     */
    private static String generateTenantSchemaFromSlug(String slug) {
        String base = (slug == null ? "tenant" : slug.replace("-", "_"));
        base = base.replaceAll("[^a-z0-9_]", "");
        if (base.length() > 40) base = base.substring(0, 40);
        return "t_" + base + "_" + UUID.randomUUID().toString().replace("-", "").substring(0, 8);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountEntitlements.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "account_entitlements")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AccountEntitlements {

    @Id
    @Column(name = "account_id")
    private Long accountId;

    @MapsId
    @OneToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id")
    private Account account;

    @Column(name = "max_users", nullable = false)
    private Integer maxUsers;

    @Column(name = "max_products", nullable = false)
    private Integer maxProducts;

    @Column(name = "max_storage_mb", nullable = false)
    private Integer maxStorageMb;
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountProvisioningEvent.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

import java.time.Instant;

import jakarta.persistence.*;

@Entity
@Table(name = "account_provisioning_events", schema = "public")
public class AccountProvisioningEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Enumerated(EnumType.STRING)
    @Column(name = "event_type", nullable = false, length = 50)
    private ProvisioningStatus status;

    @Column(name = "failure_code", length = 50)
    private String failureCode;

    @Column(name = "message", columnDefinition = "text")
    private String message;

    @Column(name = "details_json", columnDefinition = "text")
    private String detailsJson;

    @Column(name = "created_at", nullable = false, columnDefinition = "timestamptz")
    private Instant createdAt;

    protected AccountProvisioningEvent() { }

    public AccountProvisioningEvent(
            Long accountId,
            ProvisioningStatus status,
            ProvisioningFailureCode failureCode,
            String message,
            String detailsJson,
            Instant createdAt
    ) {
        this.accountId = accountId;
        this.status = status;
        this.failureCode = (failureCode == null ? null : failureCode.name());
        this.message = message;
        this.detailsJson = detailsJson;
        this.createdAt = createdAt;
    }

    public Long getId() { return id; }
    public Long getAccountId() { return accountId; }
    public ProvisioningStatus getStatus() { return status; }
    public String getFailureCode() { return failureCode; }
    public String getMessage() { return message; }
    public String getDetailsJson() { return detailsJson; }
    public Instant getCreatedAt() { return createdAt; }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountStatus.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum AccountStatus {
    FREE_TRIAL("Trial Gratuito"),
    ACTIVE("Ativa"),
    SUSPENDED("Suspensa"),
    CANCELLED("Cancelada"),
    EXPIRED("Expirada"),
	PROVISIONING("Provisionamento");

    private final String description;

    AccountStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    /** Regra de negócio: permite operar (independente de datas finas do trial). */
    public boolean isOperational() {
        return this == FREE_TRIAL || this == ACTIVE;
    }

    public boolean isTrial() {
        return this == FREE_TRIAL;
    }

    public boolean isSuspended() {
        return this == SUSPENDED;
    }

    public boolean isCancelled() {
        return this == CANCELLED || this == EXPIRED;
    }

 
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/AccountType.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum AccountType {
    TENANT,
    PLATFORM
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/LegalEntityType.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum LegalEntityType {
    INDIVIDUAL,   // pessoa física
    COMPANY       // pessoa jurídica
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/ProvisioningFailureCode.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum ProvisioningFailureCode {
    VALIDATION_ERROR,
    PUBLIC_PERSISTENCE_ERROR,
    SCHEMA_CREATION_ERROR,
    TENANT_MIGRATION_ERROR,
    TENANT_ADMIN_CREATION_ERROR,
    UNKNOWN
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/ProvisioningStatus.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum ProvisioningStatus {
    STARTED,
    SUCCESS,
    FAILED
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/SubscriptionPlan.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

public enum SubscriptionPlan {
    FREE,
    PRO,
    ENTERPRISE,

    /**
     * Plano interno do sistema (Control Plane).
     * BUILTIN != cliente, não tem trial, não tem billing, não tem entitlements.
     */
    BUILT_IN_PLAN
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/domain/TaxIdType.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.domain;

import lombok.Getter;

@Getter
public enum TaxIdType {
    CPF,
    CNPJ;

   
    }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountEntitlementsRepository.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountEntitlements;

import java.time.Instant;
import java.util.Optional;

public interface AccountEntitlementsRepository extends JpaRepository<AccountEntitlements, Long> {

    Optional<AccountEntitlements> findByAccount_Id(Long accountId);

    /**
     * Upsert/Idempotente no estilo do V13:
     * - insere default
     * - se já existir, não faz nada
     *
     * Retorna 1 se inseriu, 0 se já existia.
     *
     * IMPORTANTE:
     * Deve ser executado dentro de uma TX write-capable (via PublicSchemaUnitOfWork.tx()).
     *
     * Regra AppClock:
     *  Receber instantes via parâmetros.
     */
    @Modifying
    @Query(
        value = """
            INSERT INTO public.account_entitlements (
                account_id, max_users, max_products, max_storage_mb, created_at, updated_at
            )
            VALUES (
                :accountId, :maxUsers, :maxProducts, :maxStorageMb, :createdAt, :updatedAt
            )
            ON CONFLICT (account_id) DO NOTHING
            """,
        nativeQuery = true
    )
    int insertDefaultIfMissing(
            @Param("accountId") Long accountId,
            @Param("maxUsers") Integer maxUsers,
            @Param("maxProducts") Integer maxProducts,
            @Param("maxStorageMb") Integer maxStorageMb,
            @Param("createdAt") Instant createdAt,
            @Param("updatedAt") Instant updatedAt
    );
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountProvisioningEventRepository.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.persistence;

import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

import brito.com.multitenancy001.controlplane.accounts.domain.AccountProvisioningEvent;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningStatus;

public interface AccountProvisioningEventRepository extends JpaRepository<AccountProvisioningEvent, Long> {

    Page<AccountProvisioningEvent> findByAccountId(Long accountId, Pageable pageable);

    Optional<AccountProvisioningEvent> findTopByAccountIdOrderByCreatedAtDesc(Long accountId);

    Optional<AccountProvisioningEvent> findTopByAccountIdAndStatusOrderByCreatedAtDesc(
            Long accountId,
            ProvisioningStatus status
    );
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountRepository.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.persistence;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountType;
import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {

    boolean existsByTaxCountryCodeAndTaxIdTypeAndTaxIdNumberAndDeletedFalse(
            String taxCountryCode, TaxIdType taxIdType, String taxIdNumber
    );

    List<Account> findAllByDeletedFalse();

    Optional<Account> findBySlugAndDeletedFalseIgnoreCase(String slug);

    Optional<AccountResolverProjection> findProjectionByIdAndDeletedFalse(Long id);

    Optional<AccountResolverProjection> findProjectionBySlugAndDeletedFalseIgnoreCase(String slug);

    Optional<Account> findByIdAndDeletedFalse(Long id);

    @Query("""
            SELECT a
              FROM Account a
             WHERE a.id = :id
               AND a.deleted = false
               AND a.status IN ('ACTIVE', 'FREE_TRIAL')
           """)
    Optional<Account> findEnabledById(@Param("id") Long id);

    Optional<Account> findAnyById(Long id);

    @Query("SELECT COUNT(a) FROM Account a WHERE a.deleted = false AND a.status IN :statuses")
    long countByStatusesAndDeletedFalse(@Param("statuses") List<AccountStatus> statuses);

    default long countOperationalAccounts() {
        return countByStatusesAndDeletedFalse(List.of(AccountStatus.ACTIVE, AccountStatus.FREE_TRIAL));
    }

    Page<Account> findByStatusAndDeletedFalse(AccountStatus status, Pageable pageable);

    @Query("""
            SELECT a
              FROM Account a
             WHERE a.deleted = false
               AND a.audit.createdAt BETWEEN :start AND :end
           """)
    Page<Account> findAccountsCreatedBetween(
            @Param("start") Instant start,
            @Param("end") Instant end,
            Pageable pageable
    );

    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND (
            LOWER(a.displayName) LIKE LOWER(CONCAT('%', :term, '%'))
            OR (a.legalName IS NOT NULL AND LOWER(a.legalName) LIKE LOWER(CONCAT('%', :term, '%')))
          )
    """)
    Page<Account> searchByDisplayName(@Param("term") String term, Pageable pageable);

    List<Account> findByStatusAndDeletedFalse(AccountStatus status);

    List<Account> findByPaymentDueDateBeforeAndDeletedFalse(LocalDate date);

    // =========================
    // Scheduler (IDs-only)
    // =========================

    @Query("""
        SELECT a.id
          FROM Account a
         WHERE a.deleted = false
           AND a.trialEndAt <= :date
           AND a.status = :status
    """)
    List<Long> findExpiredTrialIdsNotDeleted(@Param("date") Instant date, @Param("status") AccountStatus status);

    @Query("""
        SELECT a.id
          FROM Account a
         WHERE a.deleted = false
           AND a.status = :status
           AND a.paymentDueDate < :today
    """)
    List<Long> findOverdueAccountIdsNotDeleted(@Param("status") AccountStatus status, @Param("today") LocalDate today);

    // =========================
    // Métodos antigos (mantidos)
    // =========================

 
    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND a.status = :status
          AND a.paymentDueDate < :today
    """)
    List<Account> findOverdueAccountsNotDeleted(@Param("status") AccountStatus status, @Param("today") LocalDate today);

    // =========================
    // Control Plane account (public schema)
    // =========================

    /**
     * ✅ Semântica do domínio:
     * Conta do Control Plane = built-in/platform.
     *
     * isBuiltInAccount() := origin == BUILT_IN || type == PLATFORM
     *
     * Retorna LISTA para permitir validação explícita de cardinalidade.
     */
    @Query("""
        SELECT a FROM Account a
        WHERE a.deleted = false
          AND (a.origin = :builtInOrigin OR a.type = :platformType)
    """)
    List<Account> findControlPlaneAccounts(
            @Param("builtInOrigin") EntityOrigin builtInOrigin,
            @Param("platformType") AccountType platformType
    );

    /**
     * Helper semântico do projeto:
     * - exige exatamente 1 conta CP
     * - falha explicitamente se 0 ou >1
     */
    default Account getSingleControlPlaneAccount() {
        List<Account> list = findControlPlaneAccounts(EntityOrigin.BUILT_IN, AccountType.PLATFORM);

        if (list.isEmpty()) {
            throw new IllegalStateException("Nenhuma conta de Control Plane encontrada (esperado exatamente 1).");
        }
        if (list.size() > 1) {
            throw new IllegalStateException("Mais de uma conta de Control Plane encontrada (esperado exatamente 1).");
        }
        return list.get(0);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/accounts/persistence/AccountResolverProjection.java
============================================================
package brito.com.multitenancy001.controlplane.accounts.persistence;

import java.time.Instant;

public interface AccountResolverProjection {
    Long getId();
    String getTenantSchema();

    String getSlug();
    String getDisplayName();

    String getStatus();

    Instant getTrialEndAt();

    String getOrigin();
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/api/admin/ControlPlaneAuthController.java
============================================================
package brito.com.multitenancy001.controlplane.auth.api.admin;

import brito.com.multitenancy001.controlplane.auth.api.dto.ControlPlaneAdminLoginRequest;
import brito.com.multitenancy001.controlplane.auth.api.dto.ControlPlaneRefreshRequest;
import brito.com.multitenancy001.controlplane.auth.app.ControlPlaneAuthService;
import brito.com.multitenancy001.controlplane.auth.app.ControlPlaneLogoutService;
import brito.com.multitenancy001.controlplane.auth.app.ControlPlaneTokenRefreshService;
import brito.com.multitenancy001.controlplane.auth.app.command.ControlPlaneAdminLoginCommand;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.dto.auth.LogoutRequest;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * API de autenticação do Control Plane.
 *
 * Endpoints:
 * - POST /login: login com email+senha
 * - POST /refresh: refresh com rotação (novo refreshToken)
 * - POST /logout: logout forte (revoga sessão server-side)
 */
@RestController
@RequestMapping("/api/controlplane/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class ControlPlaneAuthController {

    private final ControlPlaneAuthService controlPlaneAuthService;
    private final ControlPlaneTokenRefreshService controlPlaneTokenRefreshService;
    private final ControlPlaneLogoutService controlPlaneLogoutService;

    private static JwtResponse toHttp(JwtResult r) {
        return JwtResponse.forEmailLogin(
                r.accessToken(),
                r.refreshToken(),
                r.userId(),
                r.email(),
                r.role(),
                r.accountId(),
                r.tenantSchema()
        );
    }

    @PostMapping("/login")
    public ResponseEntity<JwtResponse> login(@Valid @RequestBody ControlPlaneAdminLoginRequest req) {
        /** comentário: autentica usuário de plataforma e retorna access+refresh */
        JwtResult jwt = controlPlaneAuthService.loginControlPlaneUser(
                new ControlPlaneAdminLoginCommand(req.email(), req.password())
        );
        return ResponseEntity.ok(toHttp(jwt));
    }

    @PostMapping("/refresh")
    public ResponseEntity<JwtResponse> refresh(@Valid @RequestBody ControlPlaneRefreshRequest req) {
        /** comentário: refresh com rotação server-side */
        JwtResult jwt = controlPlaneTokenRefreshService.refresh(req.refreshToken()); // ✅ AQUI o fix
        return ResponseEntity.ok(toHttp(jwt));
    }

    @PostMapping("/logout")
    public ResponseEntity<Void> logout(@Valid @RequestBody LogoutRequest req) {
        /** comentário: logout forte (revoga sessão/refresh no servidor) */
        controlPlaneLogoutService.logout(req.refreshToken(), req.allDevices());
        return ResponseEntity.noContent().build();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/api/dto/ControlPlaneAdminLoginRequest.java
============================================================
package brito.com.multitenancy001.controlplane.auth.api.dto;

import jakarta.validation.constraints.NotBlank;

public record ControlPlaneAdminLoginRequest(
        @NotBlank String email,
        @NotBlank String password
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/api/dto/ControlPlaneRefreshRequest.java
============================================================
package brito.com.multitenancy001.controlplane.auth.api.dto;

import jakarta.validation.constraints.NotBlank;

/**
 * Request de refresh do Control Plane.
 */
public record ControlPlaneRefreshRequest(
        @NotBlank(message = "refreshToken é obrigatório")
        String refreshToken
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/app/ControlPlaneAuthService.java
============================================================
package brito.com.multitenancy001.controlplane.auth.app;

import brito.com.multitenancy001.controlplane.auth.app.command.ControlPlaneAdminLoginCommand;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.integration.audit.ControlPlaneAuthEventAuditIntegrationService;
import brito.com.multitenancy001.integration.auth.ControlPlaneJwtIntegrationService;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.auth.app.AuthRefreshSessionService;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.executor.PublicSchemaExecutor;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityResolver;
import brito.com.multitenancy001.shared.security.SystemRoleName;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Instant;

/**
 * Serviço de login do Control Plane.
 *
 * <p>Responsabilidades:</p>
 * <ul>
 *   <li>Validar request de login.</li>
 *   <li>Resolver identidade via <code>login_identities</code>.</li>
 *   <li>Validar status do usuário (enabled / habilitado para login).</li>
 *   <li>Autenticar via AuthenticationManager (password hash validado pelo DaoAuthenticationProvider).</li>
 *   <li>Emitir access token + refresh token.</li>
 *   <li>Registrar refresh session server-side (logout forte / rotação).</li>
 *   <li>Auditar tentativa / sucesso / negação.</li>
 * </ul>
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneAuthService {

    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    private final AuthenticationManager authenticationManager;
    private final ControlPlaneJwtIntegrationService controlPlaneJwtIntegrationService;
    private final ControlPlaneUserRepository controlPlaneUserRepository;
    private final PublicSchemaExecutor publicSchemaExecutor;

    private final LoginIdentityResolver loginIdentityResolver;

    private final ControlPlaneAuthEventAuditIntegrationService controlPlaneAuthEventAuditIntegrationService;
    private final AppClock appClock;

    private final AuthRefreshSessionService authRefreshSessionService;

    /**
     * Efetua login do usuário do Control Plane e retorna access+refresh tokens.
     *
     * @param cmd comando de login (email/senha).
     * @return JwtResult com tokens e claims essenciais.
     */
    public JwtResult loginControlPlaneUser(ControlPlaneAdminLoginCommand cmd) {

        /** comentário: valida entrada, audita tentativa, autentica, emite tokens, registra sessão e audita sucesso/negação */
        if (cmd == null) throw new ApiException(ApiErrorCode.INVALID_LOGIN, "Requisição inválida", 400);
        if (!StringUtils.hasText(cmd.email())) throw new ApiException(ApiErrorCode.INVALID_LOGIN, "email é obrigatório", 400);
        if (!StringUtils.hasText(cmd.password())) throw new ApiException(ApiErrorCode.INVALID_LOGIN, "password é obrigatório", 400);

        final String emailNorm = EmailNormalizer.normalizeOrNull(cmd.email());
        if (emailNorm == null) throw new ApiException(ApiErrorCode.INVALID_LOGIN, "email inválido", 400);

        final String password = cmd.password();

        auditAttempt(emailNorm, "{\"stage\":\"init\",\"mode\":\"password\"}");

        try {
            return publicSchemaExecutor.inPublic(() -> {

                Long cpUserId = loginIdentityResolver.resolveControlPlaneUserIdByEmail(emailNorm);
                if (cpUserId == null) {
                    auditDenied(emailNorm, "{\"reason\":\"identity_not_found\"}");
                    throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário de plataforma não encontrado", 404);
                }

                ControlPlaneUser user = controlPlaneUserRepository
                        .findByIdAndDeletedFalse(cpUserId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário de plataforma não encontrado", 404));

                Long accountId = user.getAccount().getId();

                Instant now = appClock.instant();

                if (!user.isEnabled()) {
                    auditDenied(emailNorm, "{\"reason\":\"user_not_enabled\"}");
                    throw new ApiException(ApiErrorCode.ACCESS_DENIED, "Usuário não autorizado", 403);
                }

                if (!user.isEnabledForLogin(now)) {
                    auditDenied(emailNorm, "{\"reason\":\"user_not_enabled_for_login\"}");
                    throw new ApiException(ApiErrorCode.ACCESS_DENIED, "Usuário não autorizado", 403);
                }

                Authentication authentication = authenticationManager.authenticate(
                        new UsernamePasswordAuthenticationToken(emailNorm, password)
                );

                /**
                 * FIX:
                 * Durante login, o Authentication costuma ter principal=UserDetails (ex.: org.springframework.security.core.userdetails.User).
                 * O JwtTokenProvider exige subjectId quando o principal NÃO é AuthenticatedUserContext.
                 * Portanto, passamos explicitamente o userId (subject_id) = user.getId().
                 */
                String accessToken = controlPlaneJwtIntegrationService.generateControlPlaneToken(
                        authentication,
                        accountId,
                        DEFAULT_SCHEMA,
                        user.getId()
                );

                String refreshToken = controlPlaneJwtIntegrationService.generateRefreshToken(
                        user.getEmail(),
                        DEFAULT_SCHEMA,
                        accountId
                );

                // registra sessão server-side (logout forte / rotação)
                authRefreshSessionService.onRefreshIssued(
                        brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain.CONTROLPLANE,
                        accountId,
                        user.getId(),
                        null,
                        refreshToken
                );

                user.markLastLogin(now);
                controlPlaneUserRepository.save(user);

                SystemRoleName role = SystemRoleName.fromString(user.getRole() == null ? null : user.getRole().name());

                auditSuccess(emailNorm, "{\"stage\":\"success\"}");

                return new JwtResult(
                        accessToken,
                        refreshToken,
                        user.getId(),
                        user.getEmail(),
                        role,
                        accountId,
                        DEFAULT_SCHEMA
                );
            });
        } catch (BadCredentialsException e) {
            auditDenied(emailNorm, "{\"reason\":\"bad_credentials\"}");
            throw e;
        }
    }

    /**
     * Audita tentativa de login (ATTEMPT).
     *
     * @param emailNorm email normalizado.
     * @param detailsJson json de detalhes.
     */
    private void auditAttempt(String emailNorm, String detailsJson) {

        /** comentário: registra auditoria de tentativa de login do Control Plane */
        controlPlaneAuthEventAuditIntegrationService.record(
                AuthDomain.CONTROLPLANE,
                AuthEventType.LOGIN_INIT,
                AuditOutcome.ATTEMPT,
                emailNorm,
                null,
                null,
                DEFAULT_SCHEMA,
                detailsJson
        );
    }

    /**
     * Audita negação de login (DENIED).
     *
     * @param emailNorm email normalizado.
     * @param detailsJson json de detalhes.
     */
    private void auditDenied(String emailNorm, String detailsJson) {

        /** comentário: registra auditoria de login negado do Control Plane */
        controlPlaneAuthEventAuditIntegrationService.record(
                AuthDomain.CONTROLPLANE,
                AuthEventType.LOGIN_DENIED,
                AuditOutcome.DENIED,
                emailNorm,
                null,
                null,
                DEFAULT_SCHEMA,
                detailsJson
        );
    }

    /**
     * Audita sucesso de login (SUCCESS).
     *
     * @param emailNorm email normalizado.
     * @param detailsJson json de detalhes.
     */
    private void auditSuccess(String emailNorm, String detailsJson) {

        /** comentário: registra auditoria de login bem-sucedido do Control Plane */
        controlPlaneAuthEventAuditIntegrationService.record(
                AuthDomain.CONTROLPLANE,
                AuthEventType.LOGIN_SUCCESS,
                AuditOutcome.SUCCESS,
                emailNorm,
                null,
                null,
                DEFAULT_SCHEMA,
                detailsJson
        );
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/app/ControlPlaneLogoutService.java
============================================================
package brito.com.multitenancy001.controlplane.auth.app;

import brito.com.multitenancy001.integration.audit.ControlPlaneAuthEventAuditIntegrationService;
import brito.com.multitenancy001.integration.auth.ControlPlaneRefreshIdentity;
import brito.com.multitenancy001.integration.auth.ControlPlaneRefreshTokenIntrospectionIntegrationService;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.auth.app.AuthRefreshSessionService;
import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.executor.PublicSchemaExecutor;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityResolver;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

/**
 * Logout forte do Control Plane (opção B).
 *
 * Regras:
 * - Revoga refresh token no servidor (public schema)
 * - allDevices=true revoga todas as sessões do usuário no domínio CONTROLPLANE
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneLogoutService {

    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    private final PublicSchemaExecutor publicSchemaExecutor;
    private final ControlPlaneRefreshTokenIntrospectionIntegrationService refreshIntrospection;
    private final LoginIdentityResolver loginIdentityResolver;

    private final AuthRefreshSessionService refreshSessions;
    private final ControlPlaneAuthEventAuditIntegrationService authAuditService;

    public void logout(String refreshToken, boolean allDevices) {
        /** comentário: resolve identidade e revoga sessão(ões) no servidor */
        if (!StringUtils.hasText(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken é obrigatório", 400);
        }

        publicSchemaExecutor.inPublic(() -> {
            ControlPlaneRefreshIdentity id = refreshIntrospection.parseOrThrow(refreshToken);

            Long userId = loginIdentityResolver.resolveControlPlaneUserIdByEmail(id.email());
            if (userId == null) {
                throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401);
            }

            authAuditService.record(
                    AuthDomain.CONTROLPLANE,
                    AuthEventType.LOGOUT,
                    AuditOutcome.ATTEMPT,
                    id.email(),
                    null,   // ✅ actorEmail
                    userId, // ✅ actorUserId
                    DEFAULT_SCHEMA,
                    "{\"stage\":\"start\",\"allDevices\":" + allDevices + "}"
            );

            if (allDevices) {
                refreshSessions.revokeAllForUser(
                        AuthSessionDomain.CONTROLPLANE,
                        id.accountId(),
                        userId,
                        "{\"reason\":\"logout_all_devices\"}"
                );
            } else {
                refreshSessions.revokeByRefreshTokenOrThrow(
                        refreshToken,
                        "{\"reason\":\"logout\"}"
                );
            }

            authAuditService.record(
                    AuthDomain.CONTROLPLANE,
                    AuthEventType.LOGOUT,
                    AuditOutcome.SUCCESS,
                    id.email(),
                    null,   // ✅ actorEmail
                    userId, // ✅ actorUserId
                    DEFAULT_SCHEMA,
                    "{\"stage\":\"completed\",\"allDevices\":" + allDevices + "}"
            );

            return null;
        });
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/app/ControlPlaneTokenRefreshService.java
============================================================
package brito.com.multitenancy001.controlplane.auth.app;

import brito.com.multitenancy001.integration.audit.ControlPlaneAuthEventAuditIntegrationService;
import brito.com.multitenancy001.integration.auth.ControlPlaneJwtIntegrationService;
import brito.com.multitenancy001.integration.auth.ControlPlaneRefreshIdentity;
import brito.com.multitenancy001.integration.auth.ControlPlaneRefreshTokenIntrospectionIntegrationService;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.auth.app.AuthRefreshSessionService;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.executor.PublicSchemaExecutor;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.SystemRoleName;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

/**
 * Refresh token do Control Plane (com rotação + logout forte).
 *
 * Regras:
 * - refresh emite NOVO refresh token (rotação)
 * - rotateOrThrow atualiza o hash server-side (logout forte depende disso)
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneTokenRefreshService {

    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    private final PublicSchemaExecutor publicExecutor;
    private final ControlPlaneRefreshTokenIntrospectionIntegrationService refreshIntrospection;
    private final MultiContextUserDetailsService userDetailsService;
    private final ControlPlaneJwtIntegrationService jwtIntegration;

    private final AuthRefreshSessionService refreshSessions;
    private final ControlPlaneAuthEventAuditIntegrationService authAuditService;

    public JwtResult refresh(String refreshToken) {
        /** comentário: valida request, emite novos tokens e rotaciona sessão server-side */
        if (!StringUtils.hasText(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken é obrigatório", 400);
        }

        authAuditService.record(
                AuthDomain.CONTROLPLANE,
                AuthEventType.TOKEN_REFRESH,
                AuditOutcome.ATTEMPT,
                null,
                null,   // ✅ actorEmail
                null,   // actorUserId
                DEFAULT_SCHEMA,
                "{\"stage\":\"start\"}"
        );

        return publicExecutor.inPublic(() -> {
            ControlPlaneRefreshIdentity id = refreshIntrospection.parseOrThrow(refreshToken);

            UserDetails ud = userDetailsService.loadControlPlaneUserByEmail(id.email(), id.accountId());
            Authentication auth = new UsernamePasswordAuthenticationToken(ud, null, ud.getAuthorities());

            String newAccess = jwtIntegration.generateControlPlaneToken(auth, id.accountId(), DEFAULT_SCHEMA);
            String newRefresh = jwtIntegration.generateRefreshToken(id.email(), DEFAULT_SCHEMA, id.accountId());

            Long userId = (ud instanceof AuthenticatedUserContext ctx) ? ctx.getUserId() : null;
            String roleName = (ud instanceof AuthenticatedUserContext ctx) ? ctx.getRoleName() : null;
            SystemRoleName role = SystemRoleName.fromString(roleName);

            refreshSessions.rotateOrThrow(
                    AuthSessionDomain.CONTROLPLANE,
                    refreshToken,
                    newRefresh,
                    id.accountId(),
                    userId,
                    null // ✅ CONTROLPLANE não tem tenantSchema
            );

            authAuditService.record(
                    AuthDomain.CONTROLPLANE,
                    AuthEventType.TOKEN_REFRESH,
                    AuditOutcome.SUCCESS,
                    id.email(),
                    null,   // ✅ actorEmail
                    userId, // ✅ actorUserId
                    DEFAULT_SCHEMA,
                    "{\"stage\":\"completed\",\"rotated\":true}"
            );

            return new JwtResult(
                    newAccess,
                    newRefresh,
                    userId,
                    id.email(),
                    role,
                    id.accountId(),
                    DEFAULT_SCHEMA
            );
        });
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/auth/app/command/ControlPlaneAdminLoginCommand.java
============================================================
package brito.com.multitenancy001.controlplane.auth.app.command;



public record ControlPlaneAdminLoginCommand(
        String email,
        String password
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/api/admin/ControlPlanePaymentController.java
============================================================
package brito.com.multitenancy001.controlplane.billing.api.admin;

import brito.com.multitenancy001.controlplane.billing.app.ControlPlanePaymentService;
import brito.com.multitenancy001.shared.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

/**
 * Controller ADMIN (Control Plane) para operações de Billing/Payments.
 *
 * Regras:
 * - Controller NÃO acessa repository.
 * - Payload deve ser validado com @Valid (ControllerComplianceVerifier).
 * - Controller delega para Application Service.
 */
@RestController
@RequestMapping("/api/controlplane/billing/payments")
@RequiredArgsConstructor
public class ControlPlanePaymentController {

    private final ControlPlanePaymentService controlPlanePaymentService;

    /**
     * Admin força/registrar um pagamento para uma conta.
     */
    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_WRITE.asAuthority())")
    public ResponseEntity<PaymentResponse> create(
            /* Valida o payload (@Valid é obrigatório pelo compliance). */
            @Valid @RequestBody AdminPaymentRequest request
    ) {
        return ResponseEntity.ok(controlPlanePaymentService.processPaymentForAccount(request));
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/api/admin/ControlPlanePaymentQueryController.java
============================================================
package brito.com.multitenancy001.controlplane.billing.api.admin;

import brito.com.multitenancy001.controlplane.billing.app.query.ControlPlanePaymentQueryService;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

/**
 * Controller ADMIN (Control Plane) para consultas de Billing/Payments.
 *
 * Responsabilidade:
 * - Expor endpoints de leitura (query) para relatórios e filtros operacionais.
 *
 * Regras:
 * - Somente leitura: delega para Query Service dedicado.
 * - Não expõe entidades JPA; retorna DTOs estáveis para API.
 * - Autorização por permissions do Control Plane.
 *
 * Observação:
 * - Para filtros por período, usar Instant (ISO-8601) no contrato HTTP e armazenar em timestamptz.
 */

@RestController
@RequestMapping("/api/admin/billing/payments/query")
@RequiredArgsConstructor
public class ControlPlanePaymentQueryController {

    private final ControlPlanePaymentQueryService controlPlanePaymentQueryService;

    /**
     * Lista pagamentos por status (ex.: PENDING/COMPLETED/FAILED...).
     */
    @GetMapping("/status/{status}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.asAuthority())")
    public ResponseEntity<List<PaymentResponse>> findByStatus(@PathVariable PaymentStatus status) {
        return ResponseEntity.ok(controlPlanePaymentQueryService.findByStatus(status));
    }

    /**
     * Soma total pago (COMPLETED) por conta em um período.
     */
    @GetMapping("/accounts/{accountId}/total-paid")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.asAuthority())"
                    + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())"
    )
    public ResponseEntity<BigDecimal> getTotalPaidInPeriod(
            @PathVariable Long accountId,
            @RequestParam("startDate") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant startDate,
            @RequestParam("endDate")   @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) Instant endDate
    ) {
        return ResponseEntity.ok(controlPlanePaymentQueryService.getTotalPaidInPeriod(accountId, startDate, endDate));
    }

    /**
     * Quantidade de pagamentos COMPLETED por conta.
     */
    @GetMapping("/accounts/{accountId}/count-completed")
    @PreAuthorize(
            "hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_BILLING_READ.asAuthority())"
                    + " and hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_TENANT_READ.asAuthority())"
    )
    public ResponseEntity<Long> countCompletedPayments(@PathVariable Long accountId) {
        return ResponseEntity.ok(controlPlanePaymentQueryService.countCompletedPayments(accountId));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/app/ControlPlanePaymentService.java
============================================================
package brito.com.multitenancy001.controlplane.billing.app;

import brito.com.multitenancy001.controlplane.accounts.app.AccountStatusService;
import brito.com.multitenancy001.controlplane.accounts.app.command.AccountStatusChangeCommand;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.billing.app.audit.ControlPlaneBillingSecurityAuditRecorder;
import brito.com.multitenancy001.controlplane.billing.domain.Payment;
import brito.com.multitenancy001.controlplane.billing.persistence.ControlPlanePaymentRepository;
import brito.com.multitenancy001.integration.security.ControlPlaneRequestIdentityService;
import brito.com.multitenancy001.shared.api.dto.billing.AdminPaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentRequest;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneOffset;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Application Service do Control Plane para Billing/Payments (public schema).
 *
 * Regras:
 * - Controller NÃO grava auditoria; auditoria é responsabilidade do AppService.
 * - Auditoria SOC2-like:
 *   - create payment -> PAYMENT_CREATED (ATTEMPT/SUCCESS/DENIED/FAILURE)
 *   - status change -> PAYMENT_STATUS_CHANGED (ATTEMPT/SUCCESS/DENIED/FAILURE)
 * - Details SEMPRE estruturado (Map/record), nunca string montada na unha.
 * - Nunca registrar segredos (token gateway, dados sensíveis).
 * - Fonte de tempo única: AppClock (Instant).
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ControlPlanePaymentService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;

    private final AccountRepository accountRepository;
    private final ControlPlanePaymentRepository controlPlanePaymentRepository;
    private final ControlPlaneRequestIdentityService requestIdentity;
    private final AppClock appClock;
    private final AccountStatusService accountStatusService;

    private final ControlPlaneBillingSecurityAuditRecorder billingAudit;

    // =========================================================
    // Scheduled
    // =========================================================

    @Scheduled(cron = "${app.payment.check-cron:0 0 0 * * *}")
    public void checkPayments() {
        /* Job: aplica regras automáticas de trial expirado, overdue e expiração de pending. */
        log.info("Iniciando verificação de pagamentos...");
        Instant now = appClock.instant();

        List<Long> expiredTrialIds = publicSchemaUnitOfWork.readOnly(() ->
                accountRepository.findExpiredTrialIdsNotDeleted(now, AccountStatus.FREE_TRIAL)
        );

        for (Long accountId : expiredTrialIds) {
            suspendAccountById(accountId, "Trial expirado");
        }

        LocalDate todayUtc = LocalDate.ofInstant(now, ZoneOffset.UTC);

        List<Long> overdueAccountIds = publicSchemaUnitOfWork.readOnly(() ->
                accountRepository.findOverdueAccountIdsNotDeleted(AccountStatus.ACTIVE, todayUtc)
        );

        for (Long accountId : overdueAccountIds) {
            suspendAccountById(accountId, "Pagamento atrasado");
        }

        checkExpiredPendingPayments(now);
    }

    private void suspendAccountById(Long accountId, String reason) {
        /* Aplica suspensão de account (side-effect + email). */
    	accountStatusService.changeAccountStatus(
    		    accountId,
    		    new AccountStatusChangeCommand(AccountStatus.SUSPENDED, reason, "billing_job")
    		);

        Account account = publicSchemaUnitOfWork.readOnly(() ->
                accountRepository.findAnyById(accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404))
        );

        sendSuspensionEmail(account, reason);
    }

    private void checkExpiredPendingPayments(Instant now) {
        /* Expira pagamentos PENDING antigos (ex.: 30min) e audita mudança de status. */
        Instant thirtyMinutesAgo = now.minusSeconds(30 * 60);

        publicSchemaUnitOfWork.tx(() -> {
            List<Payment> expiredPayments = controlPlanePaymentRepository
                    .findByStatusAndAudit_CreatedAtBefore(PaymentStatus.PENDING, thirtyMinutesAgo);

            for (Payment payment : expiredPayments) {
                Long accountId = payment.getAccount() != null ? payment.getAccount().getId() : null;
                String accountEmail = payment.getAccount() != null ? payment.getAccount().getLoginEmail() : null;

                Map<String, Object> details = billingAudit.baseDetails("payment_status_expire_pending_job", accountId, accountEmail);
                details.put("paymentId", payment.getId());
                details.put("fromStatus", PaymentStatus.PENDING.name());
                details.put("toStatus", PaymentStatus.EXPIRED.name());
                details.put("reason", "Expired pending > 30 minutes");

                billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);

                try {
                    payment.setStatus(PaymentStatus.EXPIRED);
                    controlPlanePaymentRepository.save(payment);
                    billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);
                } catch (Exception ex) {
                    details.put("exception", ex.getClass().getSimpleName());
                    billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);
                    throw ex;
                }
            }
        });
    }

    // =========================================================
    // Commands
    // =========================================================

    public PaymentResponse processPaymentForAccount(AdminPaymentRequest adminPaymentRequest) {
        /* Cria pagamento para uma account (admin) e processa gateway. */
        if (adminPaymentRequest == null || adminPaymentRequest.accountId() == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        }

        Instant now = appClock.instant();

        // Pré-audit: create payment attempt
        Map<String, Object> createDetails = billingAudit.baseDetails("payment_create_admin", adminPaymentRequest.accountId(), null);
        createDetails.put("amount", adminPaymentRequest.amount());
        createDetails.put("paymentMethod", adminPaymentRequest.paymentMethod());
        createDetails.put("paymentGateway", adminPaymentRequest.paymentGateway());
        createDetails.put("description", adminPaymentRequest.description());

        billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_CREATED, adminPaymentRequest.accountId(), null, createDetails);

        Long paymentId;
        String accountEmail;

        try {
            PaymentCreatedSnapshot snap = publicSchemaUnitOfWork.tx(() -> {
                Account account = accountRepository.findById(adminPaymentRequest.accountId())
                        .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404));

                validatePayment(account, adminPaymentRequest.amount(), now);

                Payment payment = Payment.builder()
                        .account(account)
                        .amount(adminPaymentRequest.amount())
                        .paymentMethod(adminPaymentRequest.paymentMethod())
                        .paymentGateway(adminPaymentRequest.paymentGateway())
                        .description(adminPaymentRequest.description())
                        .status(PaymentStatus.PENDING)
                        .paymentDate(now)
                        .build();

                Payment saved = controlPlanePaymentRepository.save(payment);
                return new PaymentCreatedSnapshot(saved.getId(), account.getLoginEmail());
            });

            paymentId = snap.paymentId();
            accountEmail = snap.accountEmail();

            createDetails.put("paymentId", paymentId);
            createDetails.put("status", PaymentStatus.PENDING.name());

            billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_CREATED, adminPaymentRequest.accountId(), accountEmail, createDetails);

        } catch (ApiException ex) {
            recordOutcomeForApiException(SecurityAuditActionType.PAYMENT_CREATED, adminPaymentRequest.accountId(), null, createDetails, ex);
            throw ex;
        } catch (Exception ex) {
            createDetails.put("exception", ex.getClass().getSimpleName());
            billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_CREATED, adminPaymentRequest.accountId(), null, createDetails);
            throw ex;
        }

        boolean ok = processWithPaymentGateway(
                paymentId,
                new PaymentRequest(
                        adminPaymentRequest.amount(),
                        adminPaymentRequest.paymentMethod(),
                        adminPaymentRequest.paymentGateway(),
                        adminPaymentRequest.description()
                )
        );

        if (ok) {
            Map<String, Object> statusDetails = billingAudit.baseDetails("payment_status_change_complete", adminPaymentRequest.accountId(), accountEmail);
            statusDetails.put("paymentId", paymentId);
            statusDetails.put("fromStatus", PaymentStatus.PENDING.name());
            statusDetails.put("toStatus", PaymentStatus.COMPLETED.name());

            billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, adminPaymentRequest.accountId(), accountEmail, statusDetails);

            try {
                Payment payment = publicSchemaUnitOfWork.tx(() -> completePaymentById(paymentId, now));
                billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, adminPaymentRequest.accountId(), accountEmail, statusDetails);
                return mapToResponse(payment);
            } catch (ApiException ex) {
                recordOutcomeForApiException(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, adminPaymentRequest.accountId(), accountEmail, statusDetails, ex);
                throw ex;
            } catch (Exception ex) {
                statusDetails.put("exception", ex.getClass().getSimpleName());
                billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, adminPaymentRequest.accountId(), accountEmail, statusDetails);
                throw ex;
            }
        }

        // Falhou gateway: status -> FAILED (auditar)
        Map<String, Object> failDetails = billingAudit.baseDetails("payment_status_change_fail_gateway", adminPaymentRequest.accountId(), accountEmail);
        failDetails.put("paymentId", paymentId);
        failDetails.put("fromStatus", PaymentStatus.PENDING.name());
        failDetails.put("toStatus", PaymentStatus.FAILED.name());
        failDetails.put("reason", "Falha no processamento do pagamento");

        billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, adminPaymentRequest.accountId(), accountEmail, failDetails);

        try {
            publicSchemaUnitOfWork.tx(() -> {
                failPaymentById(paymentId, "Falha no processamento do pagamento");
                return null;
            });
            billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, adminPaymentRequest.accountId(), accountEmail, failDetails);
        } catch (ApiException ex) {
            recordOutcomeForApiException(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, adminPaymentRequest.accountId(), accountEmail, failDetails, ex);
            throw ex;
        } catch (Exception ex) {
            failDetails.put("exception", ex.getClass().getSimpleName());
            billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, adminPaymentRequest.accountId(), accountEmail, failDetails);
            throw ex;
        }

        throw new ApiException(ApiErrorCode.PAYMENT_FAILED, "Falha no processamento do pagamento", 402);
    }

    public PaymentResponse processPaymentForMyAccount(PaymentRequest paymentRequest) {
        /* Cria pagamento para a account do usuário logado e processa gateway. */
        if (paymentRequest == null) {
            throw new ApiException(ApiErrorCode.INVALID_REQUEST, "Request inválido", 400);
        }

        Long accountId = requestIdentity.getCurrentAccountId();
        Instant now = appClock.instant();

        Map<String, Object> createDetails = billingAudit.baseDetails("payment_create_self", accountId, null);
        createDetails.put("amount", paymentRequest.amount());
        createDetails.put("paymentMethod", paymentRequest.paymentMethod());
        createDetails.put("paymentGateway", paymentRequest.paymentGateway());
        createDetails.put("description", paymentRequest.description());

        billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_CREATED, accountId, null, createDetails);

        Long paymentId;
        String accountEmail;

        try {
            PaymentCreatedSnapshot snap = publicSchemaUnitOfWork.tx(() -> {
                Account account = accountRepository.findById(accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404));

                validatePayment(account, paymentRequest.amount(), now);

                Payment payment = Payment.builder()
                        .account(account)
                        .amount(paymentRequest.amount())
                        .paymentMethod(paymentRequest.paymentMethod())
                        .paymentGateway(paymentRequest.paymentGateway())
                        .description(paymentRequest.description())
                        .status(PaymentStatus.PENDING)
                        .paymentDate(now)
                        .build();

                Payment saved = controlPlanePaymentRepository.save(payment);
                return new PaymentCreatedSnapshot(saved.getId(), account.getLoginEmail());
            });

            paymentId = snap.paymentId();
            accountEmail = snap.accountEmail();

            createDetails.put("paymentId", paymentId);
            createDetails.put("status", PaymentStatus.PENDING.name());

            billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_CREATED, accountId, accountEmail, createDetails);

        } catch (ApiException ex) {
            recordOutcomeForApiException(SecurityAuditActionType.PAYMENT_CREATED, accountId, null, createDetails, ex);
            throw ex;
        } catch (Exception ex) {
            createDetails.put("exception", ex.getClass().getSimpleName());
            billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_CREATED, accountId, null, createDetails);
            throw ex;
        }

        boolean ok = processWithPaymentGateway(paymentId, paymentRequest);

        if (ok) {
            Map<String, Object> statusDetails = billingAudit.baseDetails("payment_status_change_complete", accountId, accountEmail);
            statusDetails.put("paymentId", paymentId);
            statusDetails.put("fromStatus", PaymentStatus.PENDING.name());
            statusDetails.put("toStatus", PaymentStatus.COMPLETED.name());

            billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, statusDetails);

            try {
                Payment payment = publicSchemaUnitOfWork.tx(() -> completePaymentById(paymentId, now));
                billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, statusDetails);
                return mapToResponse(payment);
            } catch (ApiException ex) {
                recordOutcomeForApiException(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, statusDetails, ex);
                throw ex;
            } catch (Exception ex) {
                statusDetails.put("exception", ex.getClass().getSimpleName());
                billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, statusDetails);
                throw ex;
            }
        }

        Map<String, Object> failDetails = billingAudit.baseDetails("payment_status_change_fail_gateway", accountId, accountEmail);
        failDetails.put("paymentId", paymentId);
        failDetails.put("fromStatus", PaymentStatus.PENDING.name());
        failDetails.put("toStatus", PaymentStatus.FAILED.name());
        failDetails.put("reason", "Falha no processamento do pagamento");

        billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, failDetails);

        try {
            publicSchemaUnitOfWork.tx(() -> {
                failPaymentById(paymentId, "Falha no processamento do pagamento");
                return null;
            });
            billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, failDetails);
        } catch (ApiException ex) {
            recordOutcomeForApiException(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, failDetails, ex);
            throw ex;
        } catch (Exception ex) {
            failDetails.put("exception", ex.getClass().getSimpleName());
            billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, failDetails);
            throw ex;
        }

        throw new ApiException(ApiErrorCode.PAYMENT_FAILED, "Falha no processamento do pagamento", 402);
    }

    public PaymentResponse completePaymentManually(Long paymentId) {
        /* Completa um pagamento PENDING manualmente e audita mudança de status. */
        if (paymentId == null) {
            throw new ApiException(ApiErrorCode.PAYMENT_ID_REQUIRED, "paymentId é obrigatório", 400);
        }

        Instant now = appClock.instant();

        Payment payment = publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findById(paymentId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404))
        );

        Long accountId = payment.getAccount() != null ? payment.getAccount().getId() : null;
        String accountEmail = payment.getAccount() != null ? payment.getAccount().getLoginEmail() : null;

        Map<String, Object> details = billingAudit.baseDetails("payment_complete_manual", accountId, accountEmail);
        details.put("paymentId", paymentId);
        details.put("fromStatus", payment.getStatus() != null ? payment.getStatus().name() : null);
        details.put("toStatus", PaymentStatus.COMPLETED.name());

        billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);

        try {
            Payment completed = publicSchemaUnitOfWork.tx(() -> {
                Payment p = controlPlanePaymentRepository.findById(paymentId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404));

                if (p.getStatus() != PaymentStatus.PENDING) {
                    throw new ApiException(ApiErrorCode.INVALID_PAYMENT_STATUS, "Pagamento não está pendente", 409);
                }

                return completePaymentById(paymentId, now);
            });

            billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);
            return mapToResponse(completed);

        } catch (ApiException ex) {
            recordOutcomeForApiException(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details, ex);
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);
            throw ex;
        }
    }

    public PaymentResponse refundPayment(Long paymentId, BigDecimal amount, String reason) {
        /* Reembolso (parcial/total) e audita mudança de status (ou evento de refund). */
        if (paymentId == null) {
            throw new ApiException(ApiErrorCode.PAYMENT_ID_REQUIRED, "paymentId é obrigatório", 400);
        }

        Instant now = appClock.instant();

        Payment before = publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findById(paymentId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404))
        );

        Long accountId = before.getAccount() != null ? before.getAccount().getId() : null;
        String accountEmail = before.getAccount() != null ? before.getAccount().getLoginEmail() : null;

        Map<String, Object> details = billingAudit.baseDetails("payment_refund", accountId, accountEmail);
        details.put("paymentId", paymentId);
        details.put("amount", amount);
        details.put("reason", reason);
        details.put("fromStatus", before.getStatus() != null ? before.getStatus().name() : null);
        details.put("toStatus", "REFUNDED_OR_PARTIAL"); // sem depender de enum específico

        billingAudit.recordAttempt(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);

        try {
            Payment payment = publicSchemaUnitOfWork.tx(() -> {
                Payment p = controlPlanePaymentRepository.findById(paymentId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404));

                if (!p.canBeRefunded(now)) {
                    throw new ApiException(ApiErrorCode.PAYMENT_NOT_REFUNDABLE, "Pagamento não pode ser reembolsado", 409);
                }

                if (amount == null) {
                    p.refundFully(now, reason);
                } else {
                    p.refundPartially(now, amount, reason);
                }

                return controlPlanePaymentRepository.save(p);
            });

            billingAudit.recordSuccess(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);
            return mapToResponse(payment);

        } catch (ApiException ex) {
            recordOutcomeForApiException(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details, ex);
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            billingAudit.recordFailure(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, accountId, accountEmail, details);
            throw ex;
        }
    }

    // =========================================================
    // Queries
    // =========================================================

    public PaymentResponse getPaymentByIdForMyAccount(Long paymentId) {
        /* Query: pagamento por id escopado à account do usuário logado. */
        Long accountId = requestIdentity.getCurrentAccountId();

        Payment payment = publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findScopedByIdAndAccountId(paymentId, accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404))
        );

        return mapToResponse(payment);
    }

    public List<PaymentResponse> getPaymentsByMyAccount() {
        /* Query: lista pagamentos da account do usuário logado. */
        Long accountId = requestIdentity.getCurrentAccountId();
        return getPaymentsByAccount(accountId);
    }

    public boolean hasActivePaymentMyAccount() {
        /* Query: verifica pagamento ativo para a account do usuário logado. */
        Long accountId = requestIdentity.getCurrentAccountId();
        return hasActivePayment(accountId);
    }

    public List<PaymentResponse> getPaymentsByAccount(Long accountId) {
        /* Query: lista pagamentos por accountId. */
        return publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findByAccount_Id(accountId)
                        .stream()
                        .map(this::mapToResponse)
                        .collect(Collectors.toList())
        );
    }

    public boolean hasActivePayment(Long accountId) {
        /* Query: existe pagamento ativo? */
        Instant now = appClock.instant();
        return publicSchemaUnitOfWork.readOnly(() -> controlPlanePaymentRepository.existsActivePayment(accountId, now));
    }

    public PaymentResponse getPaymentById(Long paymentId) {
        /* Query: pagamento por id (admin). */
        Payment payment = publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findById(paymentId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404))
        );
        return mapToResponse(payment);
    }

    public BigDecimal getTotalRevenue(Instant startDate, Instant endDate) {
        /* Query: receita agregada no período. */
        List<Object[]> revenueByAccount = publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.getRevenueByAccount(startDate, endDate)
        );

        return revenueByAccount.stream()
                .map(obj -> (BigDecimal) obj[1])
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    public boolean paymentExistsForAccount(Long paymentId, Long accountId) {
        /* Query: verifica existência de paymentId para accountId. */
        if (paymentId == null) {
            throw new ApiException(ApiErrorCode.PAYMENT_ID_REQUIRED, "paymentId é obrigatório", 400);
        }
        if (accountId == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        }
        return publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.existsByIdAndAccount_Id(paymentId, accountId)
        );
    }

    public List<PaymentResponse> getPaymentsByAccountAndStatus(Long accountId, PaymentStatus status) {
        /* Query: lista pagamentos por accountId + status. */
        if (accountId == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        }
        if (status == null) {
            throw new ApiException(ApiErrorCode.INVALID_STATUS, "status é obrigatório", 400);
        }

        return publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findByAccount_IdAndStatus(accountId, status)
                        .stream()
                        .map(this::mapToResponse)
                        .toList()
        );
    }

    public PaymentResponse getPaymentByTransactionId(String transactionId) {
        /* Query: pagamento por transactionId. */
        if (transactionId == null || transactionId.isBlank()) {
            throw new ApiException(ApiErrorCode.INVALID_TRANSACTION_ID, "transactionId é obrigatório", 400);
        }

        Payment payment = publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findByTransactionId(transactionId.trim())
                        .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404))
        );

        return mapToResponse(payment);
    }

    public boolean existsByTransactionId(String transactionId) {
        /* Query: existe payment por transactionId? */
        if (transactionId == null || transactionId.isBlank()) {
            throw new ApiException(ApiErrorCode.INVALID_TRANSACTION_ID, "transactionId é obrigatório", 400);
        }
        return publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.existsByTransactionId(transactionId.trim())
        );
    }

    public List<PaymentResponse> getPaymentsByValidUntilBeforeAndStatus(Instant date, PaymentStatus status) {
        /* Query: lista pagamentos por validUntil < date e status. */
        if (date == null) {
            throw new ApiException(ApiErrorCode.INVALID_DATE, "date é obrigatório", 400);
        }
        if (status == null) {
            throw new ApiException(ApiErrorCode.INVALID_STATUS, "status é obrigatório", 400);
        }

        return publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findByValidUntilBeforeAndStatus(date, status)
                        .stream()
                        .map(this::mapToResponse)
                        .toList()
        );
    }

    public List<PaymentResponse> getCompletedPaymentsByAccount(Long accountId) {
        /* Query: lista pagamentos completados por accountId. */
        if (accountId == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        }

        return publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findCompletedPaymentsByAccount(accountId)
                        .stream()
                        .map(this::mapToResponse)
                        .toList()
        );
    }

    public List<PaymentResponse> getPaymentsInPeriod(Instant startDate, Instant endDate) {
        /* Query: lista pagamentos no período. */
        if (startDate == null || endDate == null) {
            throw new ApiException(ApiErrorCode.INVALID_DATE_RANGE, "startDate e endDate são obrigatórios", 400);
        }
        if (endDate.isBefore(startDate)) {
            throw new ApiException(ApiErrorCode.INVALID_DATE_RANGE, "endDate deve ser >= startDate", 400);
        }

        return publicSchemaUnitOfWork.readOnly(() ->
                controlPlanePaymentRepository.findPaymentsInPeriod(startDate, endDate)
                        .stream()
                        .map(this::mapToResponse)
                        .toList()
        );
    }

    // =========================================================
    // Domain-ish helpers
    // =========================================================

    private Payment completePaymentById(Long paymentId, Instant now) {
        /* Domain helper: marca payment como COMPLETED e ativa account (paymentDueDate). */
        Payment payment = controlPlanePaymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404));

        Account account = payment.getAccount();
        if (account == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada para o pagamento", 404);
        }

        payment.markAsCompleted(now);
        controlPlanePaymentRepository.save(payment);

        account.setStatus(AccountStatus.ACTIVE);
        account.setPaymentDueDate(calculateNextDueDate(payment.getValidUntil(), now));
        accountRepository.save(account);

        return payment;
    }

    private void failPaymentById(Long paymentId, String reason) {
        /* Domain helper: marca payment como FAILED com reason (sem segredos). */
        Payment payment = controlPlanePaymentRepository.findById(paymentId)
                .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404));

        payment.markAsFailed(reason);
        controlPlanePaymentRepository.save(payment);
    }

    private void validatePayment(Account account, BigDecimal amount, Instant now) {
        /* Valida regras de pagamento (valor, conta, duplicidade de pagamento ativo). */
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new ApiException(ApiErrorCode.INVALID_AMOUNT, "Valor do pagamento inválido", 400);
        }

        if (account.isDeleted()) {
            throw new ApiException(ApiErrorCode.ACCOUNT_DELETED, "Conta deletada", 410);
        }

        if (account.isBuiltInAccount()) {
            throw new ApiException(ApiErrorCode.BUILTIN_ACCOUNT_NO_BILLING, "Conta BUILTIN não possui billing", 409);
        }

        boolean hasActive = controlPlanePaymentRepository.existsActivePayment(account.getId(), now);
        if (hasActive) {
            throw new ApiException(ApiErrorCode.PAYMENT_ALREADY_EXISTS, "Já existe um pagamento ativo para esta conta", 409);
        }
    }

    // =========================================================
    // Side-effects / mapping
    // =========================================================

    private void sendSuspensionEmail(Account account, String reason) {
        /* Side-effect: notificação de suspensão. */
        log.info("Enviando email de suspensão para: {}", account.getLoginEmail());
    }

    private void sendPaymentConfirmationEmail(Account account, Payment payment) {
        /* Side-effect: confirmação de pagamento. */
        log.info("Enviando confirmação de pagamento para: {}", account.getLoginEmail());
    }

    private LocalDate calculateNextDueDate(Instant validUntil, Instant now) {
        /* Calcula próxima data de vencimento como data civil UTC (LocalDate <-> DATE). */
        Instant base = (validUntil != null ? validUntil : now.plusSeconds(30L * 24 * 3600));
        return LocalDate.ofInstant(base, ZoneOffset.UTC);
    }

    private boolean processWithPaymentGateway(Long paymentId, PaymentRequest paymentRequest) {
        /* Stub do gateway (simulado). Não logar dados sensíveis. */
        log.info("Processando pagamento={} com gateway: {}", paymentId, paymentRequest.paymentGateway());

        try {
            Thread.sleep(1000);
            return Math.random() < 0.9;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Erro ao processar pagamento no gateway", e);
            return false;
        }
    }

    private PaymentResponse mapToResponse(Payment payment) {
        /* Mapeia entidade Payment -> DTO de resposta. */
        PaymentResponse response = new PaymentResponse(
                payment.getId(),
                payment.getAccount().getId(),

                payment.getAmount(),
                payment.getPaymentMethod(),
                payment.getPaymentGateway(),
                payment.getStatus(),

                payment.getDescription(),

                payment.getPaymentDate(),
                payment.getValidUntil(),
                payment.getRefundedAt(),

                payment.getAudit() != null ? payment.getAudit().getCreatedAt() : null,
                payment.getAudit() != null ? payment.getAudit().getUpdatedAt() : null
        );

        if (payment.getStatus() == PaymentStatus.COMPLETED) {
            sendPaymentConfirmationEmail(payment.getAccount(), payment);
        }

        return response;
    }

    // =========================================================
    // Audit helper
    // =========================================================

    private void recordOutcomeForApiException(SecurityAuditActionType type,
                                              Long accountId,
                                              String accountEmail,
                                              Map<String, Object> details,
                                              ApiException ex) {
        /* Aplica regra: 401/403 -> DENIED; demais -> FAILURE (com error/status). */
        details.put("error", ex.getError());
        details.put("status", ex.getStatus());

        if (ex.getStatus() == 401 || ex.getStatus() == 403) {
            billingAudit.recordDenied(type, accountId, accountEmail, details);
        } else {
            billingAudit.recordFailure(type, accountId, accountEmail, details);
        }
    }

    // =========================================================
    // Small internal DTO
    // =========================================================

    private record PaymentCreatedSnapshot(Long paymentId, String accountEmail) {}
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/app/audit/ControlPlaneBillingSecurityAuditRecorder.java
============================================================
package brito.com.multitenancy001.controlplane.billing.app.audit;

import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditService;
import brito.com.multitenancy001.integration.security.ControlPlaneRequestIdentityService;
import brito.com.multitenancy001.shared.audit.AuditDetails;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Recorder de auditoria de segurança para Billing/Payments (CONTROL PLANE).
 *
 * Objetivo:
 * - Centralizar auditoria append-only (public schema) usando SecurityAuditService.
 * - Padronizar details como JSON estruturado (Map/record) via JsonDetailsMapper.
 *
 * Regras:
 * - Deve ser chamado por AppServices/UseCases (não Controller).
 * - Nunca registrar segredos (ex.: dados de cartão, tokens de gateway, JWT/refresh token).
 * - Preferir IDs, status, valores agregados e referências seguras.
 *
 * Nota importante (boundary):
 * - ControlPlaneRequestIdentityService expõe apenas accountId e userId.
 * - Logo, este recorder NÃO depende de email do ator. actorEmail será null.
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneBillingSecurityAuditRecorder {

    private static final String SCOPE = "controlplane.billing";

    private final ControlPlaneRequestIdentityService requestIdentity;
    private final SecurityAuditService securityAuditService;
    private final JsonDetailsMapper jsonDetailsMapper;

    public Map<String, Object> baseDetails(String event, Long accountId, String accountEmail) {
        /* Cria details base padronizado para billing (control plane). */
        Long actorUserId = requestIdentity.getCurrentUserId();

        Map<String, Object> d = AuditDetails.base(SCOPE, event);

        // Mantém compatibilidade: grava actorUserId, mas sem email do ator (boundary não fornece).
        d.put("actorUserId", actorUserId);

        // Em billing, o “target” é a account (e opcionalmente email do login)
        if (accountId != null) d.put("accountId", accountId);
        if (accountEmail != null) d.put("accountEmail", accountEmail);

        return d;
    }

    public void recordAttempt(SecurityAuditActionType type, Long accountId, String accountEmail, Map<String, Object> details) {
        /* Registra tentativa (ATTEMPT) para ação sensível em billing. */
        record(type, AuditOutcome.ATTEMPT, accountId, accountEmail, details);
    }

    public void recordSuccess(SecurityAuditActionType type, Long accountId, String accountEmail, Map<String, Object> details) {
        /* Registra sucesso (SUCCESS) para ação sensível em billing. */
        record(type, AuditOutcome.SUCCESS, accountId, accountEmail, details);
    }

    public void recordDenied(SecurityAuditActionType type, Long accountId, String accountEmail, Map<String, Object> details) {
        /* Registra negação (DENIED) para ação sensível em billing. */
        record(type, AuditOutcome.DENIED, accountId, accountEmail, details);
    }

    public void recordFailure(SecurityAuditActionType type, Long accountId, String accountEmail, Map<String, Object> details) {
        /* Registra falha (FAILURE) para ação sensível em billing. */
        record(type, AuditOutcome.FAILURE, accountId, accountEmail, details);
    }

    private void record(SecurityAuditActionType actionType,
                        AuditOutcome outcome,
                        Long accountId,
                        String accountEmail,
                        Map<String, Object> details) {
        /* Grava evento append-only no public schema via SecurityAuditService. */
        Long actorUserId = requestIdentity.getCurrentUserId();

        String detailsJson = toJson(details);

        // Boundary: não temos actorEmail via requestIdentity -> enviar null.
        securityAuditService.record(
                actionType,
                outcome,
                null,          // actorEmail (não disponível no boundary atual)
                actorUserId,
                accountEmail,  // targetEmail (opcional; pode ser null)
                null,          // targetUserId não se aplica aqui
                accountId,     // accountId alvo
                null,          // tenantSchema (billing é public)
                detailsJson
        );
    }

    private String toJson(Object details) {
        /* Converte details (Map/record/String) em JSON string compatível com jsonb. */
        if (details == null) return null;
        return jsonDetailsMapper.toJsonNode(details).toString();
    }

    public static Map<String, Object> safeExtra(Map<String, Object> extra) {
        /* Normaliza extra como LinkedHashMap para estabilidade do JSON. */
        if (extra == null || extra.isEmpty()) return null;
        return new LinkedHashMap<>(extra);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/app/query/ControlPlanePaymentQueryService.java
============================================================
package brito.com.multitenancy001.controlplane.billing.app.query;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.billing.domain.Payment;
import brito.com.multitenancy001.controlplane.billing.persistence.ControlPlanePaymentRepository;
import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.billing.PaymentQueryService;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ControlPlanePaymentQueryService implements PaymentQueryService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;

    private final ControlPlanePaymentRepository controlPlanePaymentRepository;
    private final AppClock appClock;

    @Override
    public List<PaymentResponse> findByStatus(PaymentStatus status) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (status == null) throw new ApiException(ApiErrorCode.PAYMENT_STATUS_REQUIRED, "status é obrigatório", 400);

            return controlPlanePaymentRepository.findByStatus(status)
                    .stream()
                    .map(this::mapToResponse)
                    .toList();
        });
    }

    @Override
    public BigDecimal getTotalPaidInPeriod(Long accountId, Instant startDate, Instant endDate) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
            if (startDate == null || endDate == null) {
                throw new ApiException(ApiErrorCode.DATE_RANGE_REQUIRED, "startDate/endDate são obrigatórios", 400);
            }

            BigDecimal total = controlPlanePaymentRepository.getTotalPaidInPeriod(accountId, startDate, endDate);
            return total != null ? total : BigDecimal.ZERO;
        });
    }

    @Override
    public long countCompletedPayments(Long accountId) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);

            Long count = controlPlanePaymentRepository.countCompletedPayments(accountId);
            return count != null ? count : 0L;
        });
    }

    @Override
    public List<PaymentResponse> listByAccount(Long accountId) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);

            return controlPlanePaymentRepository.findByAccount_IdOrderByAudit_CreatedAtDesc(accountId)
                    .stream()
                    .map(this::mapToResponse)
                    .toList();
        });
    }

    @Override
    public PaymentResponse getByAccount(Long accountId, Long paymentId) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
            if (paymentId == null) throw new ApiException(ApiErrorCode.PAYMENT_ID_REQUIRED, "paymentId é obrigatório", 400);

            Payment payment = controlPlanePaymentRepository.findByIdAndAccount_Id(paymentId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.PAYMENT_NOT_FOUND, "Pagamento não encontrado", 404));

            return mapToResponse(payment);
        });
    }

    @Override
    public boolean hasActivePayment(Long accountId) {
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
            return controlPlanePaymentRepository.existsActivePayment(accountId, appClock.instant());
        });
    }

    private PaymentResponse mapToResponse(Payment payment) {
        return new PaymentResponse(
                payment.getId(),
                payment.getAccount().getId(),

                payment.getAmount(),
                payment.getPaymentMethod(),
                payment.getPaymentGateway(),
                payment.getStatus(),

                payment.getDescription(),

                payment.getPaymentDate(),
                payment.getValidUntil(),
                payment.getRefundedAt(),

                payment.getAudit() != null ? payment.getAudit().getCreatedAt() : null,
                payment.getAudit() != null ? payment.getAudit().getUpdatedAt() : null
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/domain/Payment.java
============================================================
package brito.com.multitenancy001.controlplane.billing.domain;

import jakarta.persistence.*;
import lombok.*;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.UUID;

@Entity
@Table(name = "payments", indexes = {
        @Index(name = "idx_payment_account", columnList = "account_id"),
        @Index(name = "idx_payment_status", columnList = "status"),
        @Index(name = "idx_payment_date", columnList = "payment_date")
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment implements Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Column(nullable = false, precision = 14, scale = 2)
    private BigDecimal amount;

    @Column(name = "payment_date", nullable = false, columnDefinition = "timestamptz")
    private Instant paymentDate;

    @Column(name = "valid_until", columnDefinition = "timestamptz")
    private Instant validUntil;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private PaymentStatus status = PaymentStatus.PENDING;

    @Column(name = "transaction_id", unique = true, length = 100)
    private String transactionId;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", nullable = false, length = 50)
    private PaymentMethod paymentMethod;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_gateway", nullable = false, length = 50)
    private PaymentGateway paymentGateway;

    @Column(name = "currency", length = 3, nullable = false)
    @Builder.Default
    private String currency = "BRL";

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "metadata_json", columnDefinition = "TEXT")
    private String metadataJson;

    @Column(name = "invoice_url", columnDefinition = "TEXT")
    private String invoiceUrl;

    @Column(name = "receipt_url", columnDefinition = "TEXT")
    private String receiptUrl;

    // ===== AUDIT (ator)
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Column(name = "refunded_at", columnDefinition = "timestamptz")
    private Instant refundedAt;

    @Column(name = "refund_amount", precision = 10, scale = 2)
    private BigDecimal refundAmount;

    @Column(name = "refund_reason", length = 500)
    private String refundReason;

    @PrePersist
    protected void onCreate() {
        if (this.transactionId == null) {
            this.transactionId = "PAY_" + UUID.randomUUID().toString()
                    .replace("-", "")
                    .substring(0, 16)
                    .toUpperCase();
        }

        if (this.paymentDate == null) {
            throw new IllegalStateException("paymentDate deve ser definido pela aplicação (Clock/AppClock).");
        }

        if (this.status == PaymentStatus.COMPLETED && this.validUntil == null) {
            this.validUntil = calculateDefaultValidUntil(this.paymentDate);
        }
    }

    private Instant calculateDefaultValidUntil(Instant baseDate) {
        return baseDate.plus(30, ChronoUnit.DAYS);
    }

    public void markAsCompleted(Instant now) {
        this.status = PaymentStatus.COMPLETED;
        if (this.paymentDate == null) this.paymentDate = now;
        if (this.validUntil == null) this.validUntil = calculateDefaultValidUntil(this.paymentDate);
    }

    public void markAsFailed(String reason) {
        this.status = PaymentStatus.FAILED;
        if (this.metadataJson == null) {
            this.metadataJson = "{\"failure_reason\":\"" + reason + "\"}";
        }
    }

    public boolean canBeRefunded(Instant now) {
        if (this.status != PaymentStatus.COMPLETED) return false;
        if (this.refundedAt != null) return false;
        if (this.paymentDate == null) return false;

        // até 90 dias após paymentDate
        Instant limit = now.minus(90, ChronoUnit.DAYS);
        return this.paymentDate.isAfter(limit);
    }

    public void refundPartially(Instant now, BigDecimal amount, String reason) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0 || amount.compareTo(this.amount) > 0) {
            throw new IllegalArgumentException("Valor de reembolso inválido");
        }
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento não pode ser reembolsado");
        }

        this.refundAmount = amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }

    public void refundFully(Instant now, String reason) {
        if (!canBeRefunded(now)) {
            throw new IllegalStateException("Pagamento não pode ser reembolsado");
        }

        this.refundAmount = this.amount;
        this.refundReason = reason;
        this.refundedAt = now;
        this.status = PaymentStatus.REFUNDED;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/billing/persistence/ControlPlanePaymentRepository.java
============================================================
package brito.com.multitenancy001.controlplane.billing.persistence;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.controlplane.billing.domain.Payment;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlanePaymentRepository extends JpaRepository<Payment, Long> {

    // =========================================================
    // API "DDD": accountId (o domínio trabalha com ids)
    // Internamente (JPA): account.id (property-path)
    // =========================================================

    // ---------- scoped ----------
    default Optional<Payment> findScopedByIdAndAccountId(Long id, Long accountId) {
        return findByIdAndAccount_Id(id, accountId);
    }

    default Optional<Payment> findByIdAndAccountId(Long id, Long accountId) {
        return findByIdAndAccount_Id(id, accountId);
    }

    default boolean existsByIdAndAccountId(Long id, Long accountId) {
        return existsByIdAndAccount_Id(id, accountId);
    }

    // ---------- queries por account ----------
    default List<Payment> findByAccountId(Long accountId) {
        return findByAccount_Id(accountId);
    }

    default Page<Payment> findByAccountId(Long accountId, Pageable pageable) {
        return findByAccount_Id(accountId, pageable);
    }

    default List<Payment> findByAccountIdAndStatus(Long accountId, PaymentStatus status) {
        return findByAccount_IdAndStatus(accountId, status);
    }

    default List<Payment> findByAccountIdOrderByCreatedAtDesc(Long accountId) {
        // compat: se alguém ainda chamar esse nome antigo
        return findByAccount_IdOrderByAudit_CreatedAtDesc(accountId);
    }

    default List<Payment> findByAccountIdOrderByAudit_CreatedAtDesc(Long accountId) {
        return findByAccount_IdOrderByAudit_CreatedAtDesc(accountId);
    }

    // =========================================================
    // Métodos reais (JPA property-path) - NÃO use diretamente nos services
    // =========================================================

    Optional<Payment> findByIdAndAccount_Id(Long id, Long accountId);
    boolean existsByIdAndAccount_Id(Long id, Long accountId);

    List<Payment> findByAccount_Id(Long accountId);
    Page<Payment> findByAccount_Id(Long accountId, Pageable pageable);
    List<Payment> findByAccount_IdAndStatus(Long accountId, PaymentStatus status);

    List<Payment> findByAccount_IdOrderByAudit_CreatedAtDesc(Long accountId);

    // =========================================================
    // Outras queries
    // =========================================================

    Optional<Payment> findByTransactionId(String transactionId);
    boolean existsByTransactionId(String transactionId);

    List<Payment> findByStatus(PaymentStatus status);

    // ✅ audit.createdAt (clean, sem JPQL)
    List<Payment> findByStatusAndAudit_CreatedAtBefore(PaymentStatus status, Instant date);

    List<Payment> findByValidUntilBeforeAndStatus(Instant date, PaymentStatus status);

    @Query("""
        select p
          from Payment p
         where p.account.id = :accountId
           and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
         order by p.paymentDate desc
    """)
    List<Payment> findCompletedPaymentsByAccount(@Param("accountId") Long accountId);

    @Query("""
        select coalesce(sum(p.amount), 0)
          from Payment p
         where p.account.id = :accountId
           and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
           and p.paymentDate between :startDate and :endDate
    """)
    BigDecimal getTotalPaidInPeriod(
            @Param("accountId") Long accountId,
            @Param("startDate") Instant startDate,
            @Param("endDate") Instant endDate
    );

    @Query("""
        select count(p)
          from Payment p
         where p.account.id = :accountId
           and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
    """)
    Long countCompletedPayments(@Param("accountId") Long accountId);

    @Query("""
        select p
          from Payment p
         where p.paymentDate between :startDate and :endDate
    """)
    List<Payment> findPaymentsInPeriod(
            @Param("startDate") Instant startDate,
            @Param("endDate") Instant endDate
    );

    @Query("""
        select p.account.id, sum(p.amount)
          from Payment p
         where p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
           and p.paymentDate between :startDate and :endDate
         group by p.account.id
    """)
    List<Object[]> getRevenueByAccount(
            @Param("startDate") Instant startDate,
            @Param("endDate") Instant endDate
    );

    @Query("""
        select (count(p) > 0)
          from Payment p
         where p.account.id = :accountId
           and p.status = brito.com.multitenancy001.shared.domain.billing.PaymentStatus.COMPLETED
           and p.validUntil is not null
           and p.validUntil >= :now
    """)
    boolean existsActivePayment(@Param("accountId") Long accountId, @Param("now") Instant now);
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/scheduling/app/AccountJobScheduleService.java
============================================================
package brito.com.multitenancy001.controlplane.scheduling.app;

import brito.com.multitenancy001.controlplane.scheduling.domain.AccountJobSchedule;
import brito.com.multitenancy001.controlplane.scheduling.persistence.AccountJobScheduleRepository;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.zone.ZoneOffsetTransition;
import java.time.zone.ZoneRules;
import java.util.List;

@Service
@RequiredArgsConstructor
public class AccountJobScheduleService {

    private final AccountJobScheduleRepository accountJobScheduleRepository;
    private final AppClock appClock;

    /**
     * Calcula o próximo run baseado em "horário civil do tenant".
     * Regra: guarda LocalTime + ZoneId, e converte para Instant só na execução.
     */
    public Instant computeNextRun(Instant now, LocalTime localTime, ZoneId zoneId) {
        var zonedNow = now.atZone(zoneId);

        LocalDate date = zonedNow.toLocalDate();
        var candidateToday = safeZoned(date, localTime, zoneId);

        if (candidateToday.isAfter(zonedNow)) {
            return candidateToday.toInstant();
        }

        var candidateTomorrow = safeZoned(date.plusDays(1), localTime, zoneId);
        return candidateTomorrow.toInstant();
    }

    /**
     * Resolve DST (gap/overlap) de forma determinística:
     * - gap (horário inexistente): ajusta para o primeiro horário válido após a transição.
     * - overlap (horário duplicado): escolhe sempre o offset "mais cedo" (primeiro da lista).
     */
    private java.time.ZonedDateTime safeZoned(LocalDate date, LocalTime time, ZoneId zoneId) {
        LocalDateTime ldt = LocalDateTime.of(date, time);

        ZoneRules rules = zoneId.getRules();
        List<ZoneOffset> offsets = rules.getValidOffsets(ldt);

        // Normal: 1 offset válido
        if (offsets.size() == 1) {
            return java.time.ZonedDateTime.ofLocal(ldt, zoneId, offsets.get(0));
        }

        // Overlap: 2 offsets válidos (horário duplicado)
        if (offsets.size() == 2) {
            // escolha determinística: offset "mais cedo"
            return java.time.ZonedDateTime.ofLocal(ldt, zoneId, offsets.get(0));
        }

        // Gap: 0 offsets válidos (horário inexistente)
        ZoneOffsetTransition transition = rules.getTransition(ldt);
        if (transition != null) {
            return transition.getDateTimeAfter().atZone(zoneId);
        }

        // Fallback extremo: se não houver transição (muito raro), joga +1h
        return ldt.plusHours(1).atZone(zoneId);
    }

    public AccountJobSchedule ensureNextRun(AccountJobSchedule s) {
        Instant now = appClock.instant();
        if (s.getNextRunAt() == null) {
            Instant next = computeNextRun(now, s.getLocalTime(), ZoneId.of(s.getZoneId()));
            s.setNextRunAt(next);
        }
        s.setUpdatedAt(now);
        return accountJobScheduleRepository.save(s);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/scheduling/domain/AccountJobSchedule.java
============================================================
package brito.com.multitenancy001.controlplane.scheduling.domain;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.time.LocalTime;

/**
 * Entidade de agendamento de jobs por Account (Control Plane / schema public).
 *
 * Responsabilidade:
 * - Persistir a configuração de execução recorrente de um job por account.
 *
 * Regras:
 * - Horário civil do tenant é representado por (localTime + zoneId).
 * - Os instantes calculados para execução (lastRunAt/nextRunAt) são armazenados como Instant.
 * - Persistência deve usar timestamptz para todos os Instant.
 *
 * Observações:
 * - A entidade não executa jobs; apenas descreve quando um job deve rodar.
 * - Cálculo de próximo run pertence ao Application Service (ex.: AccountJobScheduleService).
 */



@Getter
@Setter
@Entity
@Table(name = "account_job_schedules")
public class AccountJobSchedule {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(name = "job_key", nullable = false, length = 80)
    private String jobKey;

    @Column(name = "local_time", nullable = false)
    private LocalTime localTime;

    @Column(name = "zone_id", nullable = false, length = 60)
    private String zoneId;

    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;

    // ✅ Padronizado: Instant -> timestamptz
    @Column(name = "last_run_at", columnDefinition = "timestamptz")
    private Instant lastRunAt;

    // ✅ Padronizado: Instant -> timestamptz
    @Column(name = "next_run_at", columnDefinition = "timestamptz")
    private Instant nextRunAt;

    // ✅ Padronizado: Instant -> timestamptz
    @Column(name = "created_at", nullable = false, columnDefinition = "timestamptz")
    private Instant createdAt;

    // ✅ Padronizado: Instant -> timestamptz
    @Column(name = "updated_at", nullable = false, columnDefinition = "timestamptz")
    private Instant updatedAt;
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/scheduling/infra/AccountJobScheduler.java
============================================================
package brito.com.multitenancy001.controlplane.scheduling.infra;

import brito.com.multitenancy001.controlplane.scheduling.persistence.AccountJobScheduleRepository;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataAccessException;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * Scheduler de jobs do Control Plane.
 *
 * Regras:
 * - Nunca pode derrubar a aplicação
 * - Se schema não estiver pronto, loga e retorna
 * - Infra NÃO bloqueia Newman / E2E
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class AccountJobScheduler {

    private final AccountJobScheduleRepository accountJobScheduleRepository;
    private final AppClock appClock;

    /**
     * Executa jobs vencidos.
     *
     * IMPORTANTE:
     * - Fail-soft: se tabela não existir ou DB não estiver pronto,
     *   apenas loga e sai.
     */
    @Scheduled(fixedDelayString = "${app.jobs.scan-delay-ms:60000}")
    public void runDueJobs() {
        /* comentário: varre jobs vencidos e nunca derruba a aplicação */
        try {
            accountJobScheduleRepository.findDue(appClock.instant())
                    .forEach(job -> {
                        // execução real do job (se existir)
                    });
        } catch (DataAccessException ex) {
            log.warn(
                    "Scheduler ignorado (schema ainda não pronto ou migration ausente). Motivo: {}",
                    ex.getMostSpecificCause() != null ? ex.getMostSpecificCause().getMessage() : ex.getMessage()
            );
        } catch (Exception ex) {
            log.error("Erro inesperado no AccountJobScheduler", ex);
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/scheduling/persistence/AccountJobScheduleRepository.java
============================================================
package brito.com.multitenancy001.controlplane.scheduling.persistence;

import brito.com.multitenancy001.controlplane.scheduling.domain.AccountJobSchedule;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.Instant;
import java.util.List;

/**
 * Repository do agendamento de jobs por account (schema public).
 */
public interface AccountJobScheduleRepository extends JpaRepository<AccountJobSchedule, Long> {

    /**
     * Retorna jobs habilitados e vencidos (due) para execução.
     */
    @Query("""
        select s
        from AccountJobSchedule s
        where s.enabled = true
          and s.nextRunAt is not null
          and s.nextRunAt <= :now
        order by s.nextRunAt asc
    """)
    List<AccountJobSchedule> findDue(@Param("now") Instant now);
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneEndpointPreAuthorizeVerifier.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.security.access.prepost.PreAuthorize;

import java.lang.reflect.Method;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Fail-fast: garante que endpoints do Control Plane tenham @PreAuthorize,
 * exceto os explicitamente allowlisted (ex.: auth/login).
 *
 * Desative em testes/local se quiser:
 *   app.security.controlplane.enforce-preauthorize=false
 */
@Component
public class ControlPlaneEndpointPreAuthorizeVerifier implements ApplicationRunner {

    private final RequestMappingHandlerMapping mapping;

    @Value("${app.security.controlplane.enforce-preauthorize:true}")
    private boolean enabled;

    public ControlPlaneEndpointPreAuthorizeVerifier(
            @Qualifier("requestMappingHandlerMapping") RequestMappingHandlerMapping mapping
    ) {
        this.mapping = mapping;
    }

    @Override
    public void run(ApplicationArguments args) {
        if (!enabled) return;

        List<String> missing = new ArrayList<>();

        for (Map.Entry<RequestMappingInfo, HandlerMethod> e : mapping.getHandlerMethods().entrySet()) {
            RequestMappingInfo info = e.getKey();
            HandlerMethod hm = e.getValue();

            Class<?> beanType = hm.getBeanType();
            String pkg = beanType.getPackageName();

            // só Control Plane
            if (!pkg.startsWith("brito.com.multitenancy001.controlplane")) continue;

            // pega paths (compatível com Boot 3 / PathPatterns)
            Set<String> patterns = extractPatterns(info);
            if (patterns.isEmpty()) continue;

            // allowlist de endpoints públicos / especiais
            if (isAllowlisted(patterns)) continue;

            // tem @PreAuthorize no método OU na classe?
            Method m = hm.getMethod();
            boolean has = hasPreAuthorize(beanType) || hasPreAuthorize(m);

            if (!has) {
                String methods = (info.getMethodsCondition() != null && !info.getMethodsCondition().getMethods().isEmpty())
                        ? info.getMethodsCondition().getMethods().toString()
                        : "[ANY]";

                String line = methods + " " + patterns + " -> " + beanType.getSimpleName() + "#" + m.getName();
                missing.add(line);
            }
        }

        if (!missing.isEmpty()) {
            String msg = "Endpoints do Control Plane sem @PreAuthorize (fail-fast):\n"
                    + missing.stream().sorted().collect(Collectors.joining("\n"));
            throw new IllegalStateException(msg);
        }
    }

    private boolean hasPreAuthorize(Class<?> type) {
        return AnnotatedElementUtils.hasAnnotation(type, PreAuthorize.class);
    }

    private boolean hasPreAuthorize(Method m) {
        return AnnotatedElementUtils.hasAnnotation(m, PreAuthorize.class);
    }

    private boolean isAllowlisted(Set<String> patterns) {
        for (String p : patterns) {
            if (!StringUtils.hasText(p)) continue;

            // auth do controlplane (login/refresh/confirm etc.)
            if (p.startsWith("/api/controlplane/auth")) return true;

            // signup público do produto (não é admin)
            if (p.startsWith("/api/signup")) return true;

            // se você tiver actuator exposto, geralmente fica fora do pacote controlplane
        }
        return false;
    }

    private Set<String> extractPatterns(RequestMappingInfo info) {
        try {
            // Boot 3 com PathPatterns
            if (info.getPathPatternsCondition() != null) {
                return new LinkedHashSet<>(info.getPathPatternsCondition().getPatternValues());
            }
        } catch (Throwable ignored) {}

        try {
            // fallback (ant style)
            if (info.getPatternsCondition() != null) {
                return new LinkedHashSet<>(info.getPatternsCondition().getPatterns());
            }
        } catch (Throwable ignored) {}

        return Set.of();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlanePermission.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.PermissionCode;

public enum ControlPlanePermission implements PermissionCode {

    // =========================
    // ME (self-service)
    // =========================
    CP_ME_READ,
    CP_ME_PASSWORD_CHANGE,

    // =========================
    // TENANT / ACCOUNTS
    // =========================
    CP_TENANT_READ,
    CP_TENANT_CREATE,   // ✅ novo
    CP_TENANT_SUSPEND,
    CP_TENANT_RESUME,
    CP_TENANT_DELETE,

    // =========================
    // BILLING
    // =========================
    CP_BILLING_READ,
    CP_BILLING_WRITE,

    // =========================
    // USERS (Control Plane)
    // =========================
    CP_USER_READ,
    CP_USER_WRITE,
    CP_USER_DELETE,
    CP_USER_PASSWORD_RESET;

    @Override
    public String asAuthority() {
        return name();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRole.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum ControlPlaneRole implements RoleAuthority {

    CONTROLPLANE_OWNER,
    CONTROLPLANE_ADMIN,
    CONTROLPLANE_BILLING_MANAGER,
    CONTROLPLANE_SUPPORT,
    CONTROLPLANE_VIEWER,
    CONTROLPLANE_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isOwner() {
        return this == CONTROLPLANE_OWNER;
    }

    public boolean isBillingManager() {
        return this == CONTROLPLANE_BILLING_MANAGER;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneRolePermissions.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Set;

/**
 * Centraliza a matriz Role -> Permissions do Control Plane.
 *
 * Regras:
 * - sempre devolve Set imutável
 * - toda role deve estar mapeada explicitamente (evita "role nova = permissão vazia" por acidente)
 * - FAIL-FAST: role sem mapeamento explode na inicialização e/ou no uso
 * - FAIL-FAST: role decorativa (set vazio) é bug
 */
public final class ControlPlaneRolePermissions {

    private ControlPlaneRolePermissions() {}

    private static final EnumMap<ControlPlaneRole, Set<ControlPlanePermission>> MAP =
            new EnumMap<>(ControlPlaneRole.class);

    static {
        // OWNER = tudo
        MAP.put(ControlPlaneRole.CONTROLPLANE_OWNER,
                unmodifiable(EnumSet.allOf(ControlPlanePermission.class)));

        // ADMIN = forte, mas sem ações destrutivas (produção-friendly)
        EnumSet<ControlPlanePermission> admin = EnumSet.allOf(ControlPlanePermission.class);
        admin.remove(ControlPlanePermission.CP_TENANT_DELETE);
        admin.remove(ControlPlanePermission.CP_USER_DELETE);
        MAP.put(ControlPlaneRole.CONTROLPLANE_ADMIN, unmodifiable(admin));

        // BILLING_MANAGER = billing + leitura básica do tenant + self-service (/me)
        MAP.put(ControlPlaneRole.CONTROLPLANE_BILLING_MANAGER, unmodifiable(EnumSet.of(
                ControlPlanePermission.CP_ME_READ,
                ControlPlanePermission.CP_ME_PASSWORD_CHANGE,

                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_BILLING_READ,
                ControlPlanePermission.CP_BILLING_WRITE
        )));

        // SUPPORT = READ + SUSPEND/RESUME + PASSWORD_RESET + self-service (/me)
        MAP.put(ControlPlaneRole.CONTROLPLANE_SUPPORT, unmodifiable(EnumSet.of(
                ControlPlanePermission.CP_ME_READ,
                ControlPlanePermission.CP_ME_PASSWORD_CHANGE,

                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_TENANT_SUSPEND,
                ControlPlanePermission.CP_TENANT_RESUME,
                ControlPlanePermission.CP_USER_READ,
                ControlPlanePermission.CP_USER_PASSWORD_RESET
        )));

        // OPERATOR = leitura operacional + self-service (/me) - SEM CP_USER_READ
        MAP.put(ControlPlaneRole.CONTROLPLANE_OPERATOR, unmodifiable(EnumSet.of(
                ControlPlanePermission.CP_ME_READ,
                ControlPlanePermission.CP_ME_PASSWORD_CHANGE,
                ControlPlanePermission.CP_TENANT_READ
                // CP_USER_READ foi removido - operator NÃO pode listar usuários
        )));

        // VIEWER = somente leitura + self-service (/me)
        MAP.put(ControlPlaneRole.CONTROLPLANE_VIEWER, unmodifiable(EnumSet.of(
                ControlPlanePermission.CP_ME_READ,
                ControlPlanePermission.CP_ME_PASSWORD_CHANGE,

                ControlPlanePermission.CP_TENANT_READ,
                ControlPlanePermission.CP_BILLING_READ,
                ControlPlanePermission.CP_USER_READ
        )));

        // FAIL-FAST: garante que todas as roles do enum estão mapeadas e não são vazias
        for (ControlPlaneRole role : ControlPlaneRole.values()) {
            Set<ControlPlanePermission> perms = MAP.get(role);
            if (perms == null) {
                throw new IllegalStateException("Role do ControlPlane sem mapeamento em ControlPlaneRolePermissions: " + role);
            }
            if (perms.isEmpty()) {
                throw new IllegalStateException("Role do ControlPlane com set de permissões vazio (role decorativa): " + role);
            }
        }
    }

    /**
     * Obtém permissões da role do Control Plane.
     *
     * @param role role do Control Plane (obrigatória)
     * @return set imutável de permissões
     */
    public static Set<ControlPlanePermission> permissionsFor(ControlPlaneRole role) {
        // método: valida parâmetros e devolve set imutável
        if (role == null) {
            throw new IllegalArgumentException("Role do ControlPlane é obrigatória (null)");
        }

        Set<ControlPlanePermission> perms = MAP.get(role);
        if (perms == null) {
            throw new IllegalStateException("Role do ControlPlane sem mapeamento em ControlPlaneRolePermissions: " + role);
        }
        if (perms.isEmpty()) {
            throw new IllegalStateException("Role do ControlPlane com set de permissões vazio (role decorativa): " + role);
        }
        return perms;
    }

    private static Set<ControlPlanePermission> unmodifiable(EnumSet<ControlPlanePermission> set) {
        return Collections.unmodifiableSet(set);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneSecurityFlags.java
============================================================
package brito.com.multitenancy001.controlplane.security;

/**
 * Flags de segurança (produção-friendly).
 *
 * Prioridade:
 * 1) System property: app.security.controlplane.admin-can-delete=true|false
 * 2) Env var: APP_SECURITY_CONTROLPLANE_ADMIN_CAN_DELETE=true|false
 * 3) default: false
 */
public final class ControlPlaneSecurityFlags {

    private ControlPlaneSecurityFlags() {}

    public static boolean adminCanDelete() {
        String sys = System.getProperty("app.security.controlplane.admin-can-delete");
        if (sys != null && !sys.isBlank()) {
            return Boolean.parseBoolean(sys.trim());
        }

        String env = System.getenv("APP_SECURITY_CONTROLPLANE_ADMIN_CAN_DELETE");
        if (env != null && !env.isBlank()) {
            return Boolean.parseBoolean(env.trim());
        }

        return false;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneSecurityWiringVerifier.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.security.PreAuthorizePermissionReferenceParser;
import brito.com.multitenancy001.shared.security.PreAuthorizePermissionReferenceParser.EnumConstantRef;
import brito.com.multitenancy001.shared.security.PreAuthorizePermissionReferenceParser.ParsedPermissions;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

import java.lang.reflect.Method;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Verificador de wiring de segurança do Control Plane.
 *
 * Responsabilidades:
 * - Validar que todas as roles possuem permissões explicitamente mapeadas.
 * - Garantir que não existam permissões "decorativas".
 * - Falhar a aplicação no startup em caso de inconsistência.
 *
 * Objetivo:
 * - Fail-fast de configuração de segurança.
 * - Evitar erros silenciosos em produção.
 */
@Component
public class ControlPlaneSecurityWiringVerifier implements ApplicationRunner {

    private final RequestMappingHandlerMapping mapping;

    @Value("${app.security.controlplane.enforce-wiring-verifier:true}")
    private boolean enabled;

    public ControlPlaneSecurityWiringVerifier(
            @Qualifier("requestMappingHandlerMapping") RequestMappingHandlerMapping mapping
    ) {
        this.mapping = mapping;
    }

    @Override
    public void run(ApplicationArguments args) {
        if (!enabled) return;

        List<String> errors = new ArrayList<>();

        // 1) role -> perms: non-empty + scoped
        validateRoleMatrix(errors);

        // 2) @PreAuthorize references -> must exist + must be CP scoped
        validatePreAuthorizeReferences(errors);

        if (!errors.isEmpty()) {
            String msg = "ControlPlaneSecurityWiringVerifier FAIL-FAST:\n"
                    + errors.stream().distinct().sorted().collect(Collectors.joining("\n"));
            throw new IllegalStateException(msg);
        }
    }

    private void validateRoleMatrix(List<String> errors) {
        for (ControlPlaneRole role : ControlPlaneRole.values()) {
            Set<ControlPlanePermission> perms;
            try {
                perms = ControlPlaneRolePermissions.permissionsFor(role);
            } catch (RuntimeException ex) {
                errors.add("[ROLE_MATRIX] role=" + role + " -> erro ao obter permissões: " + ex.getMessage());
                continue;
            }

            if (perms == null || perms.isEmpty()) {
                errors.add("[ROLE_MATRIX] role=" + role + " -> set de permissões vazio (role decorativa)");
                continue;
            }

            // Escopo CP_ estrito (fail-fast via shared)
            try {
                PermissionScopeValidator.validateControlPlanePermissionsStrict(perms);
            } catch (RuntimeException ex) {
                errors.add("[ROLE_MATRIX] role=" + role + " -> permissões fora do escopo CP_: " + ex.getMessage());
            }
        }
    }

    private void validatePreAuthorizeReferences(List<String> errors) {
        for (Map.Entry<RequestMappingInfo, HandlerMethod> e : mapping.getHandlerMethods().entrySet()) {
            RequestMappingInfo info = e.getKey();
            HandlerMethod hm = e.getValue();

            Class<?> beanType = hm.getBeanType();
            String pkg = beanType.getPackageName();

            // só Control Plane
            if (!pkg.startsWith("brito.com.multitenancy001.controlplane")) continue;

            Set<String> patterns = extractPatterns(info);
            if (patterns.isEmpty()) continue;

            // mesmo allowlist do seu verifier de presença
            if (isAllowlisted(patterns)) continue;

            Method method = hm.getMethod();

            // pega o @PreAuthorize do método; se não tiver, tenta no tipo (classe)
            PreAuthorize pa = AnnotatedElementUtils.findMergedAnnotation(method, PreAuthorize.class);
            if (pa == null) {
                pa = AnnotatedElementUtils.findMergedAnnotation(beanType, PreAuthorize.class);
            }

            // Se não tiver, o outro verifier já vai falhar; aqui não duplicamos.
            if (pa == null) continue;

            String expr = pa.value();
            ParsedPermissions parsed = PreAuthorizePermissionReferenceParser.parse(expr);

            // Se a expressão não referenciar nenhuma permissão explícita,
            // não dá para validar existência (ex.: "isAuthenticated()").
            if (parsed.isEmpty()) continue;

            String endpoint = describeEndpoint(info, patterns, beanType, method);

            // 2.1) referências via T(Enum).CONST
            for (EnumConstantRef ref : parsed.enumConstantRefs()) {
                String enumFqn = ref.enumFqn();
                String constName = ref.constantName();

                if (!StringUtils.hasText(enumFqn) || !StringUtils.hasText(constName)) continue;

                // Se apontou pro enum errado (TenantPermission), é vazamento cross-context
                if (enumFqn.endsWith(".TenantPermission")) {
                    errors.add("[PREAUTH_REF] " + endpoint + " -> referência indevida a TenantPermission: "
                            + enumFqn + "." + constName);
                    continue;
                }

                // Esperado: ControlPlanePermission
                if (!enumFqn.endsWith(".ControlPlanePermission")) {
                    // pode ser outra estratégia, mas em geral aqui é bug/noise
                    errors.add("[PREAUTH_REF] " + endpoint + " -> enum inesperado em @PreAuthorize: "
                            + enumFqn + "." + constName + " (esperado ControlPlanePermission)");
                    continue;
                }

                // Existe no enum?
                try {
                    ControlPlanePermission.valueOf(constName);
                } catch (IllegalArgumentException ex) {
                    errors.add("[PREAUTH_REF] " + endpoint + " -> permissão inexistente: ControlPlanePermission."
                            + constName + " (expr=" + expr + ")");
                }
            }

          // 2.2) referências por string literal: 'CP_...' / 'TEN_...'
for (String code : parsed.stringLiteralCodes()) {
    if (!StringUtils.hasText(code)) continue;

    // POLÍTICA: string literal é proibido (use enum + .asAuthority()).
    errors.add("[PREAUTH_LITERAL] " + endpoint + " -> uso de string literal em @PreAuthorize é proibido: '"
            + code + "' (expr=" + expr + ")");
}
        }
    }

    // =========================================================
    // helpers (copiados do estilo do seu verifier atual)
    // =========================================================

    private boolean isAllowlisted(Set<String> patterns) {
        for (String p : patterns) {
            if (!StringUtils.hasText(p)) continue;

            if (p.startsWith("/api/controlplane/auth")) return true;
            if (p.startsWith("/api/signup")) return true;
        }
        return false;
    }

    private Set<String> extractPatterns(RequestMappingInfo info) {
        try {
            if (info.getPathPatternsCondition() != null) {
                return new LinkedHashSet<>(info.getPathPatternsCondition().getPatternValues());
            }
        } catch (Throwable ignored) {}

        try {
            if (info.getPatternsCondition() != null) {
                return new LinkedHashSet<>(info.getPatternsCondition().getPatterns());
            }
        } catch (Throwable ignored) {}

        return Set.of();
    }

    private String describeEndpoint(RequestMappingInfo info, Set<String> patterns, Class<?> beanType, Method m) {
        String methods = (info.getMethodsCondition() != null && !info.getMethodsCondition().getMethods().isEmpty())
                ? info.getMethodsCondition().getMethods().toString()
                : "[ANY]";
        return methods + " " + patterns + " -> " + beanType.getSimpleName() + "#" + m.getName();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/security/ControlPlaneSystemRoleMapper.java
============================================================
package brito.com.multitenancy001.controlplane.security;

import brito.com.multitenancy001.shared.security.SystemRoleName;

public final class ControlPlaneSystemRoleMapper {

    private ControlPlaneSystemRoleMapper() {}

    public static SystemRoleName toSystemRole(ControlPlaneRole role) {
        if (role == null) return null;
        // nomes são iguais
        return SystemRoleName.valueOf(role.name());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/SignupRequest.java
============================================================
package brito.com.multitenancy001.controlplane.signup.api.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;
import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public record SignupRequest(
        @NotBlank(message = "Nome da empresa é obrigatório")
        @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
        String displayName,

        @NotBlank(message = "Email da empresa é obrigatório")
        @Email(message = "Email inválido")
        String loginEmail,

        @NotNull(message = "Tipo de documento é obrigatório (CPF ou CNPJ)")
        TaxIdType taxIdType,

        @NotBlank(message = "Número do documento é obrigatório")
        String taxIdNumber,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
        	    regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
        	    message = "Senha deve ter pelo menos 8 caracteres, contendo letras e números"
        	)
        String password,

        @NotBlank(message = "Confirmação de senha é obrigatória")
        String confirmPassword
) {
    @AssertTrue(message = "As senhas não coincidem")
    public boolean isPasswordMatching() {
        if (password == null || confirmPassword == null) return true;
        return password.equals(confirmPassword);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/SignupResponse.java
============================================================
package brito.com.multitenancy001.controlplane.signup.api.dto;

import brito.com.multitenancy001.controlplane.accounts.api.dto.AccountResponse;

public record SignupResponse(
        AccountResponse account,
        TenantAdminResponse tenantAdmin
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/api/dto/TenantAdminResponse.java
============================================================
package brito.com.multitenancy001.controlplane.signup.api.dto;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * DTO do ControlPlane (Signup).
 *
 * Mantém role tipada sem depender do enum do contexto Tenant.
 */
public record TenantAdminResponse(
        Long id,
        String email,
        TenantRoleName role
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/api/publicweb/AccountSignupController.java
============================================================
package brito.com.multitenancy001.controlplane.signup.api.publicweb;

import brito.com.multitenancy001.controlplane.accounts.api.mapper.AccountApiMapper;
import brito.com.multitenancy001.controlplane.accounts.app.AccountAppService;
import brito.com.multitenancy001.controlplane.signup.api.dto.SignupRequest;
import brito.com.multitenancy001.controlplane.signup.api.dto.SignupResponse;
import brito.com.multitenancy001.controlplane.signup.api.dto.TenantAdminResponse;
import brito.com.multitenancy001.controlplane.signup.app.command.SignupCommand;
import brito.com.multitenancy001.controlplane.signup.app.dto.SignupResult;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/signup")
@RequiredArgsConstructor
public class AccountSignupController {

    private final AccountAppService accountAppService;
    private final AccountApiMapper accountApiMapper;

    @PostMapping
    public ResponseEntity<SignupResponse> signup(@Valid @RequestBody SignupRequest req) {

        SignupResult result = accountAppService.createAccount(new SignupCommand(
                req.displayName(),
                req.loginEmail(),
                req.taxIdType(),
                req.taxIdNumber(),
                req.password(),
                req.confirmPassword()
        ));

        SignupResponse http = new SignupResponse(
                accountApiMapper.toResponse(result.account()),
                new TenantAdminResponse(
                        result.tenantAdmin().id(),
                        result.tenantAdmin().email(),
                        result.tenantAdmin().role()
                )
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(http);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/app/AccountOnboardingService.java
============================================================
package brito.com.multitenancy001.controlplane.signup.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import org.flywaydb.core.api.FlywayException;
import org.springframework.dao.DataAccessException;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.controlplane.accounts.app.AccountFactory;
import brito.com.multitenancy001.controlplane.accounts.app.audit.AccountProvisioningAuditService;
import brito.com.multitenancy001.controlplane.accounts.app.command.CreateAccountCommand;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountStatus;
import brito.com.multitenancy001.controlplane.accounts.domain.ProvisioningFailureCode;
import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.signup.app.command.SignupCommand;
import brito.com.multitenancy001.controlplane.signup.app.dto.SignupResult;
import brito.com.multitenancy001.controlplane.signup.app.dto.TenantAdminResult;
import brito.com.multitenancy001.integration.tenant.TenantProvisioningIntegrationService;
import brito.com.multitenancy001.integration.tenant.TenantSchemaProvisioningIntegrationService;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityProvisioningService;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;


/**
 * Serviço de orquestração do onboarding de uma Account (Control Plane).
 *
 * Responsabilidades:
 * - Criar a Account no Public Schema.
 * - Criar o usuário administrador inicial.
 * - Disparar o provisionamento do schema do tenant.
 * - Inicializar entitlements, planos e estado inicial da conta.
 *
 * Papel arquitetural:
 * - Atua como um "Application Service composto".
 * - Coordena múltiplos serviços especializados sem conter lógica técnica.
 *
 * Regras:
 * - Toda criação de Account deve passar por este serviço.
 * - Não é permitido criar Account "parcial" fora deste fluxo.
 * - Falhas intermediárias devem gerar eventos auditáveis.
 *
 * Importante:
 * - Controllers nunca devem criar Account diretamente.
 * - Regras de consistência entre Account, Tenant e Admin são garantidas aqui.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AccountOnboardingService {

    private static final String DEFAULT_TAX_COUNTRY_CODE = "BR";
    private static final long DEFAULT_TRIAL_DAYS = 14L;

    private final TenantSchemaProvisioningIntegrationService tenantSchemaProvisioningIntegrationService;
    private final TenantProvisioningIntegrationService  tenantProvisioningIntegrationService;

    private final LoginIdentityProvisioningService loginIdentityProvisioningService;

    private final AccountRepository accountRepository;
    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AppClock appClock;

    private final AccountProvisioningAuditService provisioningAuditService;

    public SignupResult createAccount(SignupCommand signupCommand) {
        SignupData data = validateAndNormalize(signupCommand);

        log.info("Tentando criar conta | loginEmail={}", data.loginEmail());

        // 1) Cria Account no PUBLIC (TX CP)
        Account account;
        try {
            account = publicSchemaUnitOfWork.tx(() -> {
                CreateAccountCommand cmd = new CreateAccountCommand(
                        data.displayName(),
                        data.loginEmail(),
                        data.taxCountryCode(),
                        data.taxIdType(),
                        data.taxIdNumber()
                );

                Account created = AccountFactory.newTenantAccount(cmd);

                created.setStatus(AccountStatus.PROVISIONING);

                // ✅ se a factory não setar tenantSchema, garante aqui
                created.ensureTenantSchema();

                return accountRepository.save(created);
            });
        } catch (RuntimeException ex) {
            log.error("❌ Falha criando Account no PUBLIC | loginEmail={}", data.loginEmail(), ex);
            throw ex;
        }

        // 2) Auditoria STARTED
        provisioningAuditService.started(
                account.getId(),
                "Provisioning started",
                buildDetailsJson(account, data, "STARTED", null, null)
        );

        UserSummaryData tenantOwner = null;

        try {
            // 3) Provisionamento fora do TX do CP (envolve infra/DDL/migrations)
            String tenantSchema = account.getTenantSchema();

            try {
                tenantSchemaProvisioningIntegrationService.ensureSchemaExistsAndMigrate(tenantSchema);
            } catch (FlywayException ex) {
                throw provisioningFailed(ProvisioningFailureCode.TENANT_MIGRATION_ERROR, ex);
            } catch (DataAccessException ex) {
                throw provisioningFailed(ProvisioningFailureCode.SCHEMA_CREATION_ERROR, ex);
            } catch (RuntimeException ex) {
                ProvisioningFailureCode code = (ex instanceof ApiException)
                        ? ProvisioningFailureCode.VALIDATION_ERROR
                        : ProvisioningFailureCode.UNKNOWN;
                throw provisioningFailed(code, ex);
            }

            // 4) Criação do tenant owner
            try {
                tenantOwner = tenantProvisioningIntegrationService.createTenantOwner(
                        tenantSchema,
                        account.getId(),
                        account.getDisplayName(),
                        data.loginEmail(),
                        data.password()
                );
            } catch (RuntimeException ex) {
                throw provisioningFailed(ProvisioningFailureCode.TENANT_ADMIN_CREATION_ERROR, ex);
            }

            // 5) Registrar identidade de login no PUBLIC (para /api/tenant/auth/login)
            try {
                publicSchemaUnitOfWork.tx(() -> {
                    loginIdentityProvisioningService.ensureTenantIdentity(data.loginEmail(), account.getId());
                    return null;
                });
            } catch (RuntimeException ex) {
                throw provisioningFailed(ProvisioningFailureCode.PUBLIC_PERSISTENCE_ERROR, ex);
            }

            // 6) Finaliza status/trial no PUBLIC
            Account finalized;
            try {
                finalized = finalizeProvisioning(account.getId());
            } catch (RuntimeException ex) {
                throw provisioningFailed(ProvisioningFailureCode.PUBLIC_PERSISTENCE_ERROR, ex);
            }

            // 7) Auditoria SUCCESS
            provisioningAuditService.success(
                    finalized.getId(),
                    "Provisioning success",
                    buildDetailsJson(finalized, data, "SUCCESS", null, null)
            );

            log.info("✅ Account criada | accountId={} | tenantSchema={} | slug={} | status={} | trialEndAt={}",
                    finalized.getId(),
                    finalized.getTenantSchema(),
                    finalized.getSlug(),
                    finalized.getStatus(),
                    finalized.getTrialEndAt()
            );

            TenantAdminResult tenantAdminResult = new TenantAdminResult(
                    tenantOwner.id(),
                    tenantOwner.email(),
                    tenantOwner.role()
            );

            return new SignupResult(finalized, tenantAdminResult);

        } catch (ProvisioningFailedException wrapped) {
            ProvisioningFailureCode code = wrapped.code();

            String message = safeMessage(wrapped.getCause());
            provisioningAuditService.failed(
                    account.getId(),
                    code,
                    message,
                    buildDetailsJson(account, data, "FAILED", code, wrapped.getCause())
            );

            log.error("❌ Falha no provisioning | accountId={} | tenantSchema={} | code={}",
                    account.getId(), account.getTenantSchema(), code, wrapped.getCause());

            if (wrapped.getCause() instanceof RuntimeException re) {
                throw re;
            }
            throw wrapped;

        } catch (RuntimeException ex) {
            provisioningAuditService.failed(
                    account.getId(),
                    ProvisioningFailureCode.UNKNOWN,
                    safeMessage(ex),
                    buildDetailsJson(account, data, "FAILED", ProvisioningFailureCode.UNKNOWN, ex)
            );

            log.error("❌ Falha inesperada no provisioning | accountId={} | tenantSchema={}",
                    account.getId(), account.getTenantSchema(), ex);

            throw ex;
        }
    }

    private Account finalizeProvisioning(Long accountId) {
        return publicSchemaUnitOfWork.tx(() -> {
            Account managed = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada após criação", 500));

            Instant now = appClock.instant();

            if (managed.getStatus() == AccountStatus.PROVISIONING) {
                managed.setStatus(AccountStatus.FREE_TRIAL);
            }

            if (managed.getStatus() == AccountStatus.FREE_TRIAL && managed.getTrialEndAt() == null) {
                managed.setTrialEndAt(now.plus(DEFAULT_TRIAL_DAYS, ChronoUnit.DAYS));
            }

            return accountRepository.save(managed);
        });
    }

    private SignupData validateAndNormalize(SignupCommand cmd) {
        if (cmd == null) {
            throw new ApiException(ApiErrorCode.INVALID_REQUEST, "Requisição inválida", 400);
        }

        String displayName = safeTrim(cmd.displayName());
        if (!StringUtils.hasText(displayName)) {
            throw new ApiException(ApiErrorCode.INVALID_COMPANY_NAME, "Nome da empresa é obrigatório", 400);
        }

        String loginEmail = EmailNormalizer.normalizeOrNull(cmd.loginEmail());
        if (!StringUtils.hasText(loginEmail)) {
            throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email é obrigatório", 400);
        }
        if (!looksLikeEmail(loginEmail)) {
            throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email inválido", 400);
        }

        TaxIdType taxIdType = cmd.taxIdType();
        if (taxIdType == null) {
            throw new ApiException(ApiErrorCode.INVALID_COMPANY_DOC_TYPE, "Tipo de documento é obrigatório", 400);
        }

        String taxIdNumber = safeTrim(cmd.taxIdNumber());
        if (!StringUtils.hasText(taxIdNumber)) {
            throw new ApiException(ApiErrorCode.INVALID_COMPANY_DOC_NUMBER, "Número do documento é obrigatório", 400);
        }

        String password = safeTrim(cmd.password());
        if (!StringUtils.hasText(password)) {
            throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Senha é obrigatória", 400);
        }

        String confirmPassword = safeTrim(cmd.confirmPassword());
        if (!StringUtils.hasText(confirmPassword)) {
            throw new ApiException(ApiErrorCode.INVALID_CONFIRM_PASSWORD, "Confirmação de senha é obrigatória", 400);
        }

        if (!password.equals(confirmPassword)) {
            throw new ApiException(ApiErrorCode.PASSWORD_MISMATCH, "Senha e confirmação não conferem", 400);
        }

        String taxCountryCode = DEFAULT_TAX_COUNTRY_CODE;

        return new SignupData(
                displayName,
                loginEmail,
                taxCountryCode,
                taxIdType,
                taxIdNumber,
                password
        );
    }

    private String safeTrim(String s) {
        return (s == null ? null : s.trim());
    }

    private boolean looksLikeEmail(String email) {
        return email != null && email.contains("@") && email.contains(".");
    }

    private ProvisioningFailedException provisioningFailed(ProvisioningFailureCode code, Exception ex) {
        return new ProvisioningFailedException(code, ex);
    }

    private String safeMessage(Throwable t) {
        if (t == null) return null;
        String m = t.getMessage();
        return (m == null ? t.getClass().getSimpleName() : m);
    }

    private String buildDetailsJson(
            Account account,
            SignupData data,
            String stage,
            ProvisioningFailureCode code,
            Throwable cause
    ) {
        String accountId = (account == null || account.getId() == null) ? null : String.valueOf(account.getId());
        String tenantSchema = (account == null ? null : account.getTenantSchema());
        String slug = (account == null ? null : account.getSlug());

        String causeClass = (cause == null ? null : cause.getClass().getName());
        String causeMessage = (cause == null ? null : safeMessage(cause));

        return "{"
                + "\"stage\":\"" + stage + "\""
                + ",\"accountId\":\"" + accountId + "\""
                + ",\"tenantSchema\":\"" + tenantSchema + "\""
                + ",\"slug\":\"" + slug + "\""
                + ",\"loginEmail\":\"" + (data == null ? null : data.loginEmail()) + "\""
                + ",\"code\":\"" + (code == null ? null : code.name()) + "\""
                + ",\"causeClass\":\"" + causeClass + "\""
                + ",\"causeMessage\":\"" + causeMessage + "\""
                + "}";
    }

    private record SignupData(
            String displayName,
            String loginEmail,
            String taxCountryCode,
            TaxIdType taxIdType,
            String taxIdNumber,
            String password
    ) {}

    private static class ProvisioningFailedException extends RuntimeException {
        private static final long serialVersionUID = 1L;
        private final ProvisioningFailureCode code;

        public ProvisioningFailedException(ProvisioningFailureCode code, Throwable cause) {
            super(cause);
            this.code = code;
        }

        public ProvisioningFailureCode code() {
            return code;
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/app/command/SignupCommand.java
============================================================
package brito.com.multitenancy001.controlplane.signup.app.command;

import brito.com.multitenancy001.controlplane.accounts.domain.TaxIdType;

public record SignupCommand(
        String displayName,
        String loginEmail,
        TaxIdType taxIdType,
        String taxIdNumber,
        String password,
        String confirmPassword
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/app/dto/SignupResult.java
============================================================
package brito.com.multitenancy001.controlplane.signup.app.dto;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;

public record SignupResult(
        Account account,
        TenantAdminResult tenantAdmin
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/signup/app/dto/TenantAdminResult.java
============================================================
package brito.com.multitenancy001.controlplane.signup.app.dto;

import brito.com.multitenancy001.shared.security.TenantRoleName;

public record TenantAdminResult(
        Long id,
        String email,
        TenantRoleName role
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/ControlPlaneUserController.java
============================================================
// src/main/java/brito/com/multitenancy001/controlplane/users/api/ControlPlaneUserController.java
package brito.com.multitenancy001.controlplane.users.api;

import brito.com.multitenancy001.controlplane.users.api.dto.*;
import brito.com.multitenancy001.controlplane.users.app.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/controlplane/users")  // ← ALTERADO: /api/admin/controlplane-users → /api/controlplane/users
@RequiredArgsConstructor
public class ControlPlaneUserController {

    private final ControlPlaneUserService controlPlaneUserService;

    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.asAuthority())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> createControlPlaneUser(@Valid @RequestBody ControlPlaneUserCreateRequest request) {
        ControlPlaneUserDetailsResponse response = controlPlaneUserService.createControlPlaneUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_READ.asAuthority())")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listControlPlaneUsers() {
        return ResponseEntity.ok(controlPlaneUserService.listControlPlaneUsers());
    }

    @GetMapping("/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_READ.asAuthority())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getControlPlaneUser(userId));
    }

    @PatchMapping("/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.asAuthority())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUser(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserUpdateRequest request
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUser(userId, request));
    }

    @PatchMapping("/{userId}/permissions")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.asAuthority())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> updateControlPlaneUserPermissions(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserPermissionsUpdateRequest request
    ) {
        return ResponseEntity.ok(controlPlaneUserService.updateControlPlaneUserPermissions(userId, request));
    }

    @PatchMapping("/{userId}/reset-password")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_PASSWORD_RESET.asAuthority())")
    public ResponseEntity<Void> resetPassword(
            @PathVariable Long userId,
            @Valid @RequestBody ControlPlaneUserPasswordResetRequest request
    ) {
        controlPlaneUserService.resetControlPlaneUserPassword(userId, request);
        return ResponseEntity.noContent().build();
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_DELETE.asAuthority())")
    public ResponseEntity<Void> deleteControlPlaneUser(@PathVariable Long userId) {
        controlPlaneUserService.softDeleteControlPlaneUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.asAuthority())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> restoreControlPlaneUser(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.restoreControlPlaneUser(userId));
    }

    // =========================================================
    // SUSPEND / RESTORE (ADMIN)
    // =========================================================

    @PostMapping("/{userId}/suspend-by-admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.asAuthority())")
    public ResponseEntity<Void> suspendByAdmin(
            @PathVariable Long userId,
            @Valid @RequestBody(required = false) ControlPlaneUserSuspendRequest request
    ) {
        controlPlaneUserService.suspendControlPlaneUserByAdmin(userId, request);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{userId}/restore-by-admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_WRITE.asAuthority())")
    public ResponseEntity<Void> restoreByAdmin(
            @PathVariable Long userId,
            @Valid @RequestBody(required = false) ControlPlaneUserSuspendRequest request
    ) {
        controlPlaneUserService.restoreControlPlaneUserByAdmin(userId, request);
        return ResponseEntity.noContent().build();
    }

    // =========================================================
    // ENABLED
    // =========================================================

    @GetMapping("/enabled")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_READ.asAuthority())")
    public ResponseEntity<List<ControlPlaneUserDetailsResponse>> listEnabled() {
        return ResponseEntity.ok(controlPlaneUserService.listEnabledControlPlaneUsers());
    }

    @GetMapping("/{userId}/enabled")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_USER_READ.asAuthority())")
    public ResponseEntity<ControlPlaneUserDetailsResponse> getEnabled(@PathVariable Long userId) {
        return ResponseEntity.ok(controlPlaneUserService.getEnabledControlPlaneUser(userId));
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/admin/ControlPlaneMeController.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.admin;

import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneChangeMyPasswordRequest;
import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneMeResponse;
import brito.com.multitenancy001.controlplane.users.app.ControlPlaneUserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/controlplane/me")
@RequiredArgsConstructor
public class ControlPlaneMeController {

    private final ControlPlaneUserService controlPlaneUserService;

    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_ME_READ.asAuthority())")
    public ResponseEntity<ControlPlaneMeResponse> me() {
        return ResponseEntity.ok(controlPlaneUserService.getMe());
    }

    @PatchMapping("/password")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.controlplane.security.ControlPlanePermission).CP_ME_PASSWORD_CHANGE.asAuthority())")
    public ResponseEntity<Void> changeMyPassword(@Valid @RequestBody ControlPlaneChangeMyPasswordRequest request) {
        controlPlaneUserService.changeMyPassword(request);
        return ResponseEntity.noContent().build();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneAdminUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

public record ControlPlaneAdminUserSummaryResponse(
        Long id,

        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneChangeMyPasswordRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record ControlPlaneChangeMyPasswordRequest(
        @NotBlank(message = "Senha atual é obrigatória")
        @Size(min = 8, max = 72, message = "Senha atual deve ter entre 8 e 72 caracteres")
        String currentPassword,

        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, max = 72, message = "Nova senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar senha é obrigatório")
        @Size(min = 8, max = 72, message = "Confirmar senha deve ter entre 8 e 72 caracteres")
        String confirmPassword
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneMeResponse.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import brito.com.multitenancy001.shared.security.SystemRoleName;

public record ControlPlaneMeResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        SystemRoleName  role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserCreateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.List;

@Builder
public record ControlPlaneUserCreateRequest(

        @NotBlank(message = "Nome é obrigatório")
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @NotBlank(message = "Email é obrigatório")
        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email não pode exceder 150 caracteres")
        String email,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
                regexp = ValidationPatterns.PASSWORD_PATTERN,
                message = "Senha fraca / inválida"
        )
        String password,

        @NotNull(message = "Role é obrigatória")
        ControlPlaneRole role,

        List<String> permissions

 
   
) {
    public ControlPlaneUserCreateRequest {
    
        if (email != null) email = email.trim().toLowerCase();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserDetailsResponse.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import brito.com.multitenancy001.shared.security.SystemRoleName;

import java.time.Instant;

public record ControlPlaneUserDetailsResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        SystemRoleName role,

        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled,

        Instant createdAt
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserPasswordResetRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record ControlPlaneUserPasswordResetRequest(
        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, max = 72, message = "Senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar senha é obrigatório")
        @Size(min = 8, max = 72, message = "Confirmar senha deve ter entre 8 e 72 caracteres")
        String confirmPassword
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserPermissionsUpdateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Pattern;

import java.util.List;

public record ControlPlaneUserPermissionsUpdateRequest(
        @NotEmpty(message = "Lista de permissões não pode ser vazia")
        List<
                @Pattern(
                        regexp = "^CP_[A-Z0-9_]+$",
                        message = "Permissões de ControlPlane devem começar com CP_"
                )
                        String
                > permissions
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserSuspendRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import jakarta.validation.constraints.Size;

/**
 * Request para suspender/restaurar suspensão administrativa de um usuário do Control Plane.
 *
 * Regras:
 * - reason é opcional, mas recomendado (SOC2-like).
 * - usado em USER_SUSPENDED / USER_RESTORED.
 */
public record ControlPlaneUserSuspendRequest(
        @Size(max = 300, message = "reason deve ter no máximo 300 caracteres")
        String reason
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/dto/ControlPlaneUserUpdateRequest.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.dto;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

import java.util.List;

public record ControlPlaneUserUpdateRequest(
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email deve ter no máximo 150 caracteres")
        String email,

        ControlPlaneRole role,

        List<
                @Pattern(
                        regexp = "^CP_[A-Z0-9_]+$",
                        message = "Permissões de ControlPlane devem começar com CP_"
                )
                String
        > permissions
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/api/mapper/ControlPlaneUserApiMapper.java
============================================================
package brito.com.multitenancy001.controlplane.users.api.mapper;

import brito.com.multitenancy001.controlplane.users.api.dto.ControlPlaneAdminUserSummaryResponse;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;

import org.springframework.stereotype.Component;

@Component
public class ControlPlaneUserApiMapper {

    public ControlPlaneAdminUserSummaryResponse toAdminSummary(ControlPlaneUser controlPlaneUser) {
        return new ControlPlaneAdminUserSummaryResponse(
                controlPlaneUser.getId(),
   
                controlPlaneUser.getEmail(),
                controlPlaneUser.isSuspendedByAccount(),
                controlPlaneUser.isSuspendedByAdmin()
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserExplicitPermissionsService.java
============================================================
package brito.com.multitenancy001.controlplane.users.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ControlPlaneUserExplicitPermissionsService {

    private static final String BUILTIN_IMMUTABLE_MESSAGE =
            "Usuário BUILT_IN é protegido: não pode ter permissões alteradas; apenas senha pode ser trocada.";

    private static final String MSG_CP_ACCOUNT_INVALID  =
            "Configuração inválida: conta do Control Plane ausente ou duplicada.";

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AccountRepository accountRepository;
    private final ControlPlaneUserRepository controlPlaneUserRepository;

    /**
     * Define permissions explícitas (override) a partir de strings.
     *
     * Regras:
     * - Só aceita "CP_*" (STRICT).
     * - Converte para enum ControlPlanePermission (explode se não existir).
     * - Só permite alterar usuários do Control Plane.
     * - Não permite alterar usuário deleted (deleted=false obrigatório).
     * - BUILT_IN: 409 USER_BUILT_IN_IMMUTABLE
     */
    public void setExplicitPermissionsFromCodes(Long userId, Collection<String> permissionCodes) {

        LinkedHashSet<String> normalized = PermissionScopeValidator.normalizeControlPlaneStrict(permissionCodes);

        Set<ControlPlanePermission> perms = normalized.stream()
                .map(code -> {
                    try {
                        return ControlPlanePermission.valueOf(code);
                    } catch (IllegalArgumentException e) {
                        throw new ApiException(
                                ApiErrorCode.INVALID_PERMISSION,
                                "Permission não existe no enum ControlPlanePermission: " + code,
                                400
                        );
                    }
                })
                .collect(Collectors.toCollection(LinkedHashSet::new));

        publicSchemaUnitOfWork.tx(() -> {

            final Account cp;
            try {
                cp = accountRepository.getSingleControlPlaneAccount();
            } catch (IllegalStateException e) {
                throw new ApiException(
                        ApiErrorCode.CONTROLPLANE_ACCOUNT_INVALID,
                        MSG_CP_ACCOUNT_INVALID  + " " + e.getMessage(),
                        500
                );
            }

            if (userId == null) {
                throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);
            }

            ControlPlaneUser user = controlPlaneUserRepository.findByIdAndDeletedFalse(userId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.getAccount() == null || user.getAccount().getId() == null || !user.getAccount().getId().equals(cp.getId())) {
                throw new ApiException(ApiErrorCode.USER_OUT_OF_SCOPE, "Usuário não pertence ao Control Plane", 403);
            }

            if (user.isBuiltInUser()) {
                throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, BUILTIN_IMMUTABLE_MESSAGE, 409);
            }

            user.replaceExplicitPermissions(perms);
            controlPlaneUserRepository.save(user);
            return null;
        });
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserService.java
============================================================
// src/main/java/brito/com/multitenancy001/controlplane/users/app/ControlPlaneUserService.java
package brito.com.multitenancy001.controlplane.users.app;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.controlplane.users.api.dto.*;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneBuiltInUsers;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.controlplane.users.persistence.ControlPlaneUserRepository;
import brito.com.multitenancy001.integration.security.ControlPlaneRequestIdentityService;
import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditService;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityProvisioningService;
import brito.com.multitenancy001.shared.security.SystemRoleName;
import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Use cases de usuários do Control Plane.
 *
 * Objetivos:
 * - CRUD administrativo (create/update/permissions/reset password/soft delete/restore/suspend/unsuspend).
 * - Endpoints "enabled" (somente usuários habilitados).
 * - Endpoint "me" e troca de senha do próprio usuário.
 *
 * Auditoria SOC2-like:
 * - Trilho append-only com ATTEMPT + SUCCESS/FAILURE/DENIED.
 * - Details estruturado (scope, motivo, alvo, mudanças/deltas).
 * - IP/UA/requestId são capturados pelo SecurityAuditService via RequestMetaContext.
 *
 * Regras:
 * - Usuário BUILT_IN é protegido: não altera/deleta/restaura/suspende; apenas troca de senha.
 * - Todas as operações são restritas ao account "Control Plane" (single CP account).
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneUserService {

    private static final String BUILTIN_IMMUTABLE_MESSAGE =
            "Usuário BUILT_IN é protegido: não pode ser alterado/deletado/restaurado/suspenso; apenas senha pode ser trocada.";

    private static final String MSG_CP_ACCOUNT_INVALID =
            "Configuração inválida: conta do Control Plane ausente ou duplicada.";

    private static final String SCOPE = "CONTROL_PLANE";

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AccountRepository accountRepository;
    private final ControlPlaneUserRepository controlPlaneUserRepository;

    /** Identidade do request (actor). */
    private final ControlPlaneRequestIdentityService requestIdentity;

    private final ControlPlaneUserExplicitPermissionsService explicitPermissionsService;

    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;

    private final LoginIdentityProvisioningService loginIdentityProvisioningService;

    /** Auditoria real (public schema) com RequestMetaContext. */
    private final SecurityAuditService securityAuditService;

    /** Mapper para details estruturado (Map/record -> JsonNode). */
    private final JsonDetailsMapper jsonDetailsMapper;

    // =========================================================
    // ADMIN ENDPOINTS
    // =========================================================

    public ControlPlaneUserDetailsResponse createControlPlaneUser(ControlPlaneUserCreateRequest request) {
        /* Cria um novo usuário do Control Plane (ADMIN). */
        return publicSchemaUnitOfWork.tx(() -> {
            Actor actor = resolveActorOrNull();

            if (request == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "request é obrigatório", 400);
            if (request.role() == null) throw new ApiException(ApiErrorCode.ROLE_REQUIRED, "role é obrigatório", 400);
            if (request.password() == null || request.password().isBlank()) {
                throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "senha é obrigatória", 400);
            }

            Account cp = getControlPlaneAccount();

            String email = normalizeEmailOrThrow(request.email());
            if (ControlPlaneBuiltInUsers.isReservedEmail(email)) {
                throw new ApiException(ApiErrorCode.EMAIL_RESERVED, "Este email é reservado do sistema (BUILT_IN)", 409);
            }

            AuditTarget target = new AuditTarget(email, null);

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "stage", "before_save",
                    "role", request.role() == null ? null : request.role().name(),
                    "permissionsCount", request.permissions() == null ? 0 : request.permissions().size()
            );

            Map<String, Object> success = m(
                    "scope", SCOPE,
                    "stage", "after_save",
                    "role", request.role() == null ? null : request.role().name(),
                    "permissionsCount", request.permissions() == null ? 0 : request.permissions().size()
            );

            return auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_CREATED,
                    actor,
                    target,
                    cp.getId(),
                    null,
                    attempt,
                    success,
                    () -> {
                        boolean emailExists = controlPlaneUserRepository
                                .findByEmailAndAccount_IdAndDeletedFalse(email, cp.getId())
                                .isPresent();
                        if (emailExists) {
                            throw new ApiException(ApiErrorCode.EMAIL_ALREADY_IN_USE, "Já existe um usuário ativo com este email", 409);
                        }

                        String name = normalizeNameOrThrow(request.name());
                        ControlPlaneRole role = request.role();
                        String hash = passwordEncoder.encode(request.password());

                        ControlPlaneUser user = ControlPlaneUser.builder()
                                .account(cp)
                                .origin(EntityOrigin.ADMIN)
                                .name(name)
                                .email(email)
                                .role(role)
                                .build();

                        user.setTemporaryPasswordHash(hash);

                        ControlPlaneUser saved = controlPlaneUserRepository.save(user);

                        if (request.permissions() != null && !request.permissions().isEmpty()) {
                            explicitPermissionsService.setExplicitPermissionsFromCodes(saved.getId(), request.permissions());

                            // SOC2-like: permissions changed no create (evento separado)
                            recordAudit(
                                    SecurityAuditActionType.PERMISSIONS_CHANGED,
                                    AuditOutcome.SUCCESS,
                                    actor,
                                    saved.getEmail(),
                                    saved.getId(),
                                    cp.getId(),
                                    null,
                                    m(
                                            "scope", SCOPE,
                                            "reason", "create",
                                            "permissionsCount", request.permissions().size(),
                                            "permissions", request.permissions()
                                    )
                            );
                        }

                        loginIdentityProvisioningService.ensureControlPlaneIdentity(email, saved.getId());

                        // ✅ NÃO registrar USER_CREATED SUCCESS aqui (o helper já registra).
                        return getControlPlaneUser(saved.getId());
                    }
            );
        });
    }

    public List<ControlPlaneUserDetailsResponse> listControlPlaneUsers() {
        /* Lista usuários (não deletados) do Control Plane. */
        return publicSchemaUnitOfWork.readOnly(() -> {
            Account cp = getControlPlaneAccount();
            return controlPlaneUserRepository.findNotDeletedByAccountId(cp.getId()).stream()
                    .map(this::mapToResponse)
                    .toList();
        });
    }

    public ControlPlaneUserDetailsResponse getControlPlaneUser(Long userId) {
        /* Busca usuário do Control Plane por id. */
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

            Account cp = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository.findById(userId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.getAccount() == null || user.getAccount().getId() == null || !user.getAccount().getId().equals(cp.getId())) {
                throw new ApiException(ApiErrorCode.USER_OUT_OF_SCOPE, "Usuário não pertence ao Control Plane", 403);
            }

            return mapToResponse(user);
        });
    }

   public ControlPlaneUserDetailsResponse updateControlPlaneUser(Long userId, ControlPlaneUserUpdateRequest request) {
    /* Atualiza dados do usuário do Control Plane (ADMIN) com SUCCESS contendo delta/changes. */
    return publicSchemaUnitOfWork.tx(() -> {
        Actor actor = resolveActorOrNull();

        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);
        if (request == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "request é obrigatório", 400);

        Account cp = getControlPlaneAccount();

        ControlPlaneUser user = controlPlaneUserRepository
                .findNotDeletedByIdAndAccountId(userId, cp.getId())
                .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

        if (user.isBuiltInUser()) {
            throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, BUILTIN_IMMUTABLE_MESSAGE, 409);
        }

        String beforeName = user.getName();
        String beforeEmail = user.getEmail();
        ControlPlaneRole beforeRole = user.getRole();

        AuditTarget target = new AuditTarget(user.getEmail(), user.getId());

        Map<String, Object> attempt = m(
                "scope", SCOPE,
                "reason", "update",
                "hasName", request.name() != null,
                "hasEmail", request.email() != null,
                "hasRole", request.role() != null,
                "hasPermissions", request.permissions() != null
        );

        // ✅ SUCCESS mutável preenchido dentro do bloco com delta/changes (sem duplicar USER_UPDATED)
        Map<String, Object> success = new LinkedHashMap<>();
        success.put("scope", SCOPE);
        success.put("reason", "update");

        return auditAttemptSuccessFail(
                SecurityAuditActionType.USER_UPDATED,
                actor,
                target,
                cp.getId(),
                null,
                attempt,
                success,
                () -> {
                    boolean roleChanged = false;
                    boolean permissionsChanged = request.permissions() != null;

                    Map<String, Object> changes = new LinkedHashMap<>();

                    // -------------------------
                    // NAME
                    // -------------------------
                    if (request.name() != null) {
                        String newName = normalizeNameOrThrow(request.name());
                        String currentName = user.getName();

                        if (currentName == null || !currentName.equals(newName)) {
                            user.rename(newName);
                            changes.put("nameBefore", beforeName);
                            changes.put("nameAfter", newName);
                        }
                    }

                    // -------------------------
                    // EMAIL
                    // -------------------------
                    if (request.email() != null) {
                        String newEmail = normalizeEmailOrThrow(request.email());

                        if (ControlPlaneBuiltInUsers.isReservedEmail(newEmail)) {
                            throw new ApiException(ApiErrorCode.EMAIL_RESERVED, "Este email é reservado do sistema (BUILT_IN)", 409);
                        }

                        String currentEmail = EmailNormalizer.normalizeOrNull(user.getEmail());
                        if (currentEmail == null || !currentEmail.equals(newEmail)) {

                            boolean emailExists = controlPlaneUserRepository
                                    .findByEmailAndAccount_IdAndDeletedFalse(newEmail, cp.getId())
                                    .filter(u -> !u.getId().equals(user.getId()))
                                    .isPresent();

                            if (emailExists) {
                                throw new ApiException(ApiErrorCode.EMAIL_ALREADY_IN_USE, "Já existe um usuário ativo com este email", 409);
                            }

                            user.changeEmail(newEmail);
                            loginIdentityProvisioningService.moveControlPlaneIdentity(user.getId(), newEmail);

                            changes.put("emailBefore", beforeEmail);
                            changes.put("emailAfter", newEmail);
                        }
                    }

                    // -------------------------
                    // ROLE
                    // -------------------------
                    if (request.role() != null) {
                        if (beforeRole == null || !beforeRole.equals(request.role())) {
                            user.changeRole(request.role());
                            roleChanged = true;

                            changes.put("roleBefore", beforeRole == null ? null : beforeRole.name());
                            changes.put("roleAfter", user.getRole() == null ? null : user.getRole().name());
                        }
                    }

                    // Persistimos o usuário sempre (mantém semântica atual do seu método)
                    controlPlaneUserRepository.save(user);

                    // -------------------------
                    // PERMISSIONS (evento separado)
                    // -------------------------
                    if (permissionsChanged) {
                        explicitPermissionsService.setExplicitPermissionsFromCodes(userId, request.permissions());

                        recordAudit(
                                SecurityAuditActionType.PERMISSIONS_CHANGED,
                                AuditOutcome.SUCCESS,
                                actor,
                                user.getEmail(),
                                user.getId(),
                                cp.getId(),
                                null,
                                m(
                                        "scope", SCOPE,
                                        "reason", "update",
                                        "permissionsCount", request.permissions() == null ? 0 : request.permissions().size(),
                                        "permissions", request.permissions()
                                )
                        );

                        changes.put("permissionsChanged", true);
                        changes.put("permissionsCount", request.permissions() == null ? 0 : request.permissions().size());
                    }

                    // -------------------------
                    // ROLE_CHANGED (evento separado)
                    // -------------------------
                    if (roleChanged) {
                        recordAudit(
                                SecurityAuditActionType.ROLE_CHANGED,
                                AuditOutcome.SUCCESS,
                                actor,
                                user.getEmail(),
                                user.getId(),
                                cp.getId(),
                                null,
                                m(
                                        "scope", SCOPE,
                                        "from", beforeRole == null ? null : beforeRole.name(),
                                        "to", user.getRole() == null ? null : user.getRole().name()
                                )
                        );
                    }

                    // ✅ fecha SUCCESS do USER_UPDATED com delta/changes
                    success.put("changed", !changes.isEmpty());
                    success.put("changes", changes);

                    return getControlPlaneUser(userId);
                }
        );
    });
}

    public ControlPlaneUserDetailsResponse updateControlPlaneUserPermissions(Long userId, ControlPlaneUserPermissionsUpdateRequest request) {
        /* Atualiza permissões explícitas (ADMIN endpoint dedicado). */
        return publicSchemaUnitOfWork.tx(() -> {
            Actor actor = resolveActorOrNull();

            if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);
            if (request == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "request é obrigatório", 400);

            Account cp = getControlPlaneAccount();

            ControlPlaneUser targetUser = controlPlaneUserRepository.findById(userId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (targetUser.getAccount() == null || targetUser.getAccount().getId() == null || !targetUser.getAccount().getId().equals(cp.getId())) {
                throw new ApiException(ApiErrorCode.USER_OUT_OF_SCOPE, "Usuário não pertence ao Control Plane", 403);
            }

            if (targetUser.isBuiltInUser()) {
                throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, BUILTIN_IMMUTABLE_MESSAGE, 409);
            }

            int permCount = (request.permissions() == null) ? 0 : request.permissions().size();

            AuditTarget target = new AuditTarget(targetUser.getEmail(), targetUser.getId());

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "reason", "permissions_endpoint",
                    "permissionsCount", permCount
            );

            return auditAttemptSuccessFail(
                    SecurityAuditActionType.PERMISSIONS_CHANGED,
                    actor,
                    target,
                    cp.getId(),
                    null,
                    attempt,
                    null,
                    () -> {
                        explicitPermissionsService.setExplicitPermissionsFromCodes(userId, request.permissions());
                        return getControlPlaneUser(userId);
                    }
            );
        });
    }

    public void resetControlPlaneUserPassword(Long userId, ControlPlaneUserPasswordResetRequest request) {
        /* Admin reset de senha (não é troca autenticada). */
        publicSchemaUnitOfWork.tx(() -> {
            Actor actor = resolveActorOrNull();

            if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);
            if (request == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "request é obrigatório", 400);

            if (request.newPassword() == null || request.confirmPassword() == null) {
                throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Senha e confirmação são obrigatórias", 400);
            }
            if (!request.newPassword().equals(request.confirmPassword())) {
                throw new ApiException(ApiErrorCode.PASSWORD_MISMATCH, "Nova senha e confirmação não conferem", 400);
            }

            Account cp = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository
                    .findNotDeletedByIdAndAccountId(userId, cp.getId())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.isBuiltInUser()) {
                throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, BUILTIN_IMMUTABLE_MESSAGE, 409);
            }

            AuditTarget target = new AuditTarget(user.getEmail(), user.getId());

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "reason", "admin_reset"
            );

            auditAttemptSuccessFail(
                    SecurityAuditActionType.PASSWORD_RESET_COMPLETED,
                    actor,
                    target,
                    cp.getId(),
                    null,
                    attempt,
                    attempt,
                    () -> {
                        String hash = passwordEncoder.encode(request.newPassword());
                        user.setTemporaryPasswordHash(hash);
                        controlPlaneUserRepository.save(user);
                        return null;
                    }
            );

            return null;
        });
    }

    public void softDeleteControlPlaneUser(Long userId) {
        /* Soft delete (ADMIN). */
        publicSchemaUnitOfWork.tx(() -> {
            Actor actor = resolveActorOrNull();

            if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

            Account cp = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository
                    .findNotDeletedByIdAndAccountId(userId, cp.getId())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.isBuiltInUser()) {
                throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, BUILTIN_IMMUTABLE_MESSAGE, 409);
            }

            AuditTarget target = new AuditTarget(user.getEmail(), user.getId());

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "reason", "soft_delete"
            );

            auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_SOFT_DELETED,
                    actor,
                    target,
                    cp.getId(),
                    null,
                    attempt,
                    attempt,
                    () -> {
                        user.softDelete();
                        controlPlaneUserRepository.save(user);
                        return null;
                    }
            );

            return null;
        });
    }

    public ControlPlaneUserDetailsResponse restoreControlPlaneUser(Long userId) {
        /* Restaura usuário após soft delete (ADMIN). */
        return publicSchemaUnitOfWork.tx(() -> {
            Actor actor = resolveActorOrNull();

            if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

            Account cp = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository.findById(userId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.getAccount() == null || user.getAccount().getId() == null || !user.getAccount().getId().equals(cp.getId())) {
                throw new ApiException(ApiErrorCode.USER_OUT_OF_SCOPE, "Usuário não pertence ao Control Plane", 403);
            }

            if (user.isBuiltInUser()) {
                throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, BUILTIN_IMMUTABLE_MESSAGE, 409);
            }

            AuditTarget target = new AuditTarget(user.getEmail(), user.getId());

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "reason", "soft_restore"
            );

            return auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_SOFT_RESTORED,
                    actor,
                    target,
                    cp.getId(),
                    null,
                    attempt,
                    attempt,
                    () -> {
                        user.restore();
                        controlPlaneUserRepository.save(user);

                        loginIdentityProvisioningService.ensureControlPlaneIdentity(user.getEmail(), user.getId());

                        return mapToResponse(user);
                    }
            );
        });
    }

    public void suspendControlPlaneUserByAdmin(Long userId, ControlPlaneUserSuspendRequest request) {
        /* Suspende usuário por ação administrativa (ADMIN). */
        publicSchemaUnitOfWork.tx(() -> {
            Actor actor = resolveActorOrNull();

            if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

            Account cp = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository
                    .findNotDeletedByIdAndAccountId(userId, cp.getId())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.isBuiltInUser()) {
                throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, BUILTIN_IMMUTABLE_MESSAGE, 409);
            }

            AuditTarget target = new AuditTarget(user.getEmail(), user.getId());

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "reason", request == null ? null : request.reason(),
                    "by", "admin",
                    "suspendedByAdminBefore", user.isSuspendedByAdmin(),
                    "suspendedByAccount", user.isSuspendedByAccount()
            );

            Map<String, Object> success = new LinkedHashMap<>(attempt);

            auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_SUSPENDED,
                    actor,
                    target,
                    cp.getId(),
                    null,
                    attempt,
                    success,
                    () -> {
                        user.suspendByAdmin();
                        controlPlaneUserRepository.save(user);

                        success.put("suspendedByAdminAfter", user.isSuspendedByAdmin());
                        success.put("enabledAfter", user.isEnabled());
                        return null;
                    }
            );

            return null;
        });
    }

    public void restoreControlPlaneUserByAdmin(Long userId, ControlPlaneUserSuspendRequest request) {
        /* Remove suspensão administrativa (ADMIN) => reabilita usuário (se não houver outras suspensões). */
        publicSchemaUnitOfWork.tx(() -> {
            Actor actor = resolveActorOrNull();

            if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

            Account cp = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository
                    .findNotDeletedByIdAndAccountId(userId, cp.getId())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.isBuiltInUser()) {
                throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, BUILTIN_IMMUTABLE_MESSAGE, 409);
            }

            AuditTarget target = new AuditTarget(user.getEmail(), user.getId());

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "reason", request == null ? null : request.reason(),
                    "by", "admin",
                    "suspendedByAdminBefore", user.isSuspendedByAdmin(),
                    "suspendedByAccount", user.isSuspendedByAccount()
            );

            Map<String, Object> success = new LinkedHashMap<>(attempt);

            auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_RESTORED,
                    actor,
                    target,
                    cp.getId(),
                    null,
                    attempt,
                    success,
                    () -> {
                        user.unsuspendByAdmin();
                        controlPlaneUserRepository.save(user);

                        success.put("suspendedByAdminAfter", user.isSuspendedByAdmin());
                        success.put("enabledAfter", user.isEnabled());
                        return null;
                    }
            );

            return null;
        });
    }

    // =========================================================
    // ENABLED ENDPOINTS
    // =========================================================

    public List<ControlPlaneUserDetailsResponse> listEnabledControlPlaneUsers() {
        /* Lista usuários habilitados do Control Plane. */
        return publicSchemaUnitOfWork.readOnly(() -> {
            Account cp = getControlPlaneAccount();
            List<ControlPlaneUser> users = controlPlaneUserRepository.findEnabledByAccountId(cp.getId());
            return users.stream().map(this::mapToResponse).toList();
        });
    }

    public ControlPlaneUserDetailsResponse getEnabledControlPlaneUser(Long userId) {
        /* Busca usuário habilitado do Control Plane. */
        return publicSchemaUnitOfWork.readOnly(() -> {
            if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

            Account cp = getControlPlaneAccount();

            ControlPlaneUser user = controlPlaneUserRepository
                    .findEnabledByIdAndAccountId(userId, cp.getId())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_ENABLED, "Usuário não encontrado ou não habilitado", 404));

            return mapToResponse(user);
        });
    }

    // =========================================================
    // ME
    // =========================================================

   public ControlPlaneMeResponse getMe() {
    return publicSchemaUnitOfWork.readOnly(() -> {
        Long userId = requestIdentity.getCurrentUserId();
        
        // Busca a conta do Control Plane (sempre existe)
        Account cp = getControlPlaneAccount();
        
        // Busca o usuário diretamente pelo ID
        ControlPlaneUser user = controlPlaneUserRepository.findById(userId)
                .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));
        
        // Verifica se o usuário pertence à conta do Control Plane
        if (user.getAccount() == null || !cp.getId().equals(user.getAccount().getId())) {
            throw new ApiException(ApiErrorCode.FORBIDDEN, "Usuário não pertence ao Control Plane", 403);
        }
        
        return new ControlPlaneMeResponse(
                user.getId(),
                user.getAccount().getId(),
                user.getName(),
                user.getEmail(),
                SystemRoleName.fromString(user.getRole() == null ? null : user.getRole().name()),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.isDeleted(),
                user.isEnabled()
        );
    });
}

    public void changeMyPassword(ControlPlaneChangeMyPasswordRequest request) {
        /* Troca de senha autenticada (self). */
        publicSchemaUnitOfWork.tx(() -> {
            Actor actor = resolveActorOrNull();

            if (request == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "request é obrigatório", 400);
            if (request.currentPassword() == null || request.newPassword() == null || request.confirmPassword() == null) {
                throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Senha atual, nova senha e confirmação são obrigatórias", 400);
            }
            if (!request.newPassword().equals(request.confirmPassword())) {
                throw new ApiException(ApiErrorCode.PASSWORD_MISMATCH, "Nova senha e confirmação não conferem", 400);
            }

            Long accountId = requestIdentity.getCurrentAccountId();
            Long userId = requestIdentity.getCurrentUserId();

            Account cp = getControlPlaneAccount();
            if (accountId == null || userId == null || !cp.getId().equals(accountId)) {
                throw new ApiException(ApiErrorCode.FORBIDDEN, "Usuário não pertence ao Control Plane", 403);
            }

            ControlPlaneUser user = controlPlaneUserRepository.findById(userId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.getAccount() == null || user.getAccount().getId() == null || !user.getAccount().getId().equals(cp.getId())) {
                throw new ApiException(ApiErrorCode.FORBIDDEN, "Usuário não pertence ao Control Plane", 403);
            }

            if (!user.isEnabled()) {
                throw new ApiException(ApiErrorCode.USER_NOT_ENABLED, "Usuário não está habilitado para trocar senha", 403);
            }

            AuditTarget target = new AuditTarget(user.getEmail(), user.getId());

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "reason", "self_change"
            );

            auditAttemptSuccessFail(
                    SecurityAuditActionType.PASSWORD_CHANGED,
                    actor,
                    target,
                    cp.getId(),
                    null,
                    attempt,
                    attempt,
                    () -> {
                        String currentHash = user.getPassword();
                        if (currentHash == null || !passwordEncoder.matches(request.currentPassword(), currentHash)) {
                            throw new ApiException(ApiErrorCode.CURRENT_PASSWORD_INVALID, "Senha atual inválida", 400);
                        }

                        String newHash = passwordEncoder.encode(request.newPassword());
                        user.changePasswordHash(newHash, appClock.instant());

                        controlPlaneUserRepository.save(user);
                        return null;
                    }
            );

            return null;
        });
    }

    // =========================================================
    // Helpers
    // =========================================================

    private static String normalizeEmailOrThrow(String raw) {
        /* Normaliza e valida email. */
        String email = EmailNormalizer.normalizeOrNull(raw);
        if (email == null) throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email inválido", 400);
        return email;
    }

    private static String normalizeNameOrThrow(String raw) {
        /* Normaliza e valida nome. */
        if (raw == null) throw new ApiException(ApiErrorCode.INVALID_NAME, "Nome é obrigatório", 400);
        String name = raw.trim();
        if (name.isBlank()) throw new ApiException(ApiErrorCode.INVALID_NAME, "Nome é obrigatório", 400);
        return name;
    }

    private ControlPlaneUserDetailsResponse mapToResponse(ControlPlaneUser user) {
        /* Mapeia entidade para response DTO. */
        return new ControlPlaneUserDetailsResponse(
                user.getId(),
                user.getAccount().getId(),
                user.getName(),
                user.getEmail(),
                SystemRoleName.fromString(user.getRole() == null ? null : user.getRole().name()),
                user.isSuspendedByAccount(),
                user.isSuspendedByAdmin(),
                user.isDeleted(),
                user.isEnabled(),
                user.getAudit() == null ? null : user.getAudit().getCreatedAt()
        );
    }

    private Account getControlPlaneAccount() {
        /* Busca a conta única do Control Plane (fail-fast se inválida). */
        try {
            return accountRepository.getSingleControlPlaneAccount();
        } catch (IllegalStateException e) {
            throw new ApiException(
                    ApiErrorCode.CONTROLPLANE_ACCOUNT_INVALID,
                    MSG_CP_ACCOUNT_INVALID + " " + e.getMessage(),
                    500
            );
        }
    }

    // =========================================================
    // Audit helper (ATTEMPT + SUCCESS/FAIL/DENIED)
    // =========================================================

    @FunctionalInterface
    private interface AuditCallable<T> {
        T call();
    }

    private <T> T auditAttemptSuccessFail(
            SecurityAuditActionType actionType,
            Actor actor,
            AuditTarget target,
            Long accountId,
            String tenantSchema,
            Map<String, Object> attemptDetails,
            Map<String, Object> successDetails,
            AuditCallable<T> block
    ) {
        /* Padroniza trilha ATTEMPT + SUCCESS/FAIL/DENIED para um caso de uso. */
        recordAudit(actionType, AuditOutcome.ATTEMPT, actor, target.email(), target.userId(), accountId, tenantSchema, attemptDetails);

        try {
            T result = block.call();

            Map<String, Object> sd = (successDetails != null ? successDetails : attemptDetails);
            recordAudit(actionType, AuditOutcome.SUCCESS, actor, target.email(), target.userId(), accountId, tenantSchema, sd);

            return result;
        } catch (ApiException ex) {
            recordAudit(actionType, outcomeFrom(ex), actor, target.email(), target.userId(), accountId, tenantSchema, failureDetails(SCOPE, ex));
            throw ex;
        } catch (Exception ex) {
            recordAudit(actionType, AuditOutcome.FAILURE, actor, target.email(), target.userId(), accountId, tenantSchema, unexpectedFailureDetails(SCOPE, ex));
            throw ex;
        }
    }

    private Actor resolveActorOrNull() {
        /* Resolve o actor do request (best-effort), sem quebrar o fluxo em caso de erro. */
        try {
            Long actorId = requestIdentity.getCurrentUserId();
            Long accountId = requestIdentity.getCurrentAccountId();
            if (actorId == null || accountId == null) return Actor.anonymous();

            return publicSchemaUnitOfWork.readOnly(() -> controlPlaneUserRepository.findById(actorId)
                    .map(u -> new Actor(actorId, u.getEmail()))
                    .orElse(new Actor(actorId, null)));
        } catch (Exception ignored) {
            return Actor.anonymous();
        }
    }

    private void recordAudit(
            SecurityAuditActionType actionType,
            AuditOutcome outcome,
            Actor actor,
            String targetEmail,
            Long targetUserId,
            Long accountId,
            String tenantSchema,
            Map<String, Object> details
    ) {
        /* Grava evento de auditoria com details estruturado. */
        securityAuditService.record(
                actionType,
                outcome,
                actor == null ? null : actor.email(),
                actor == null ? null : actor.userId(),
                targetEmail,
                targetUserId,
                accountId,
                tenantSchema,
                toJson(details)
        );
    }

    private String toJson(Object details) {
        /* Serializa details (Map/record/String) para JSON string compatível com detailsJson do evento. */
        if (details == null) return null;

        JsonNode node = jsonDetailsMapper.toJsonNode(details);
        if (node == null || node.isNull()) return null;

        return node.toString();
    }

    private static AuditOutcome outcomeFrom(ApiException ex) {
        /* Mapeia ApiException para outcome semântico (DENIED vs FAILURE). */
        if (ex == null) return AuditOutcome.FAILURE;
        int s = ex.getStatus();
        return (s == 401 || s == 403) ? AuditOutcome.DENIED : AuditOutcome.FAILURE;
    }

    private static Map<String, Object> failureDetails(String scope, ApiException ex) {
        /* Details estruturado para falhas de negócio/validação. */
        return m(
                "scope", scope,
                "error", ex == null ? null : ex.getError(),
                "status", ex == null ? 0 : ex.getStatus(),
                "message", ex == null ? null : safeMessage(ex.getMessage())
        );
    }

    private static Map<String, Object> unexpectedFailureDetails(String scope, Exception ex) {
        /* Details estruturado para falhas inesperadas (sem vazar stacktrace/segredo). */
        return m(
                "scope", scope,
                "unexpected", ex == null ? null : ex.getClass().getSimpleName(),
                "message", ex == null ? null : safeMessage(ex.getMessage())
        );
    }

    private static String safeMessage(String msg) {
        /* Sanitiza mensagem para evitar quebras/ruído no JSON. */
        if (!StringUtils.hasText(msg)) return null;
        return msg
                .replace("\n", " ")
                .replace("\r", " ")
                .replace("\t", " ")
                .trim();
    }

    private static Map<String, Object> m(Object... kv) {
        /* Cria Map ordenado para JSON estável e legível. */
        Map<String, Object> m = new LinkedHashMap<>();
        if (kv == null) return m;
        for (int i = 0; i + 1 < kv.length; i += 2) {
            Object k = kv[i];
            Object v = kv[i + 1];
            if (k != null) m.put(String.valueOf(k), v);
        }
        return m;
    }

    private record Actor(Long userId, String email) {
        static Actor anonymous() {
            /* Actor "desconhecido" (não quebra o fluxo). */
            return new Actor(null, null);
        }
    }

    private record AuditTarget(String email, Long userId) {}
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/domain/ControlPlaneBuiltInUsers.java
============================================================
package brito.com.multitenancy001.controlplane.users.domain;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;

import java.util.Set;

/**
 * Emails reservados do sistema (BUILT_IN).
 *
 * Regra:
 * - comparação deve ser case-insensitive via CITEXT no banco;
 * - aqui normalizamos uma única vez via EmailNormalizer (trim + lower) para manter consistência.
 */
public final class ControlPlaneBuiltInUsers {

    private ControlPlaneBuiltInUsers() {}

    public static final String SUPERADMIN_EMAIL = "superadmin@platform.local";
    public static final String BILLING_EMAIL    = "billing@platform.local";
    public static final String SUPPORT_EMAIL    = "support@platform.local";
    public static final String OPERATOR_EMAIL   = "operator@platform.local";

    public static final Set<String> RESERVED_EMAILS = Set.of(
            SUPERADMIN_EMAIL,
            BILLING_EMAIL,
            SUPPORT_EMAIL,
            OPERATOR_EMAIL
    );

    public static boolean isReservedEmail(String email) {
        String norm = EmailNormalizer.normalizeOrNull(email);
        if (norm == null) return false;
        return RESERVED_EMAILS.contains(norm);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/domain/ControlPlaneUser.java
============================================================
package brito.com.multitenancy001.controlplane.users.domain;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import jakarta.persistence.*;
import lombok.*;

import java.time.Instant;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(name = "controlplane_users")
@EntityListeners(AuditEntityListener.class)
@Getter
@NoArgsConstructor
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Builder(toBuilder = true)
@ToString(exclude = {"account", "password", "explicitPermissions"})
public class ControlPlaneUser implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Setter(AccessLevel.NONE)
    @Enumerated(EnumType.STRING)
    @Column(name = "user_origin", nullable = false, length = 20)
    @Builder.Default
    private EntityOrigin origin = EntityOrigin.ADMIN;

    public boolean isBuiltInUser() {
        return this.origin == EntityOrigin.BUILT_IN;
    }

    @Setter(AccessLevel.NONE)
    @Column(nullable = false, length = 100)
    private String name;

    @Setter(AccessLevel.NONE)
    @Column(name = "password", nullable = false, length = 255)
    private String password;

    @Setter(AccessLevel.NONE)
    @Column(name = "email", nullable = false, columnDefinition = "citext")
    private String email;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "account_id", nullable = false)
    private Account account;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", length = 50)
    private ControlPlaneRole role;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private boolean mustChangePassword = false;

    @Column(name = "last_login", columnDefinition = "TIMESTAMPTZ")
    private Instant lastLoginAt;

    @Column(name = "locked_until", columnDefinition = "TIMESTAMPTZ")
    private Instant lockedUntil;

    @Column(name = "password_changed_at", columnDefinition = "TIMESTAMPTZ")
    private Instant passwordChangedAt;

    @Column(name = "password_reset_token", length = 200)
    private String passwordResetToken;

    @Column(name = "password_reset_expires", columnDefinition = "TIMESTAMPTZ")
    private Instant passwordResetExpiresAt;

    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
            name = "controlplane_user_permissions",
            joinColumns = @JoinColumn(name = "user_id")
    )
    @Enumerated(EnumType.STRING)
    @Column(name = "permission", length = 120, nullable = false)
    @Builder.Default
    private Set<ControlPlanePermission> explicitPermissions = new LinkedHashSet<>();

    // =========================================================
    // FACTORY (criação explícita, sem @PrePersist/@PreUpdate)
    // =========================================================
    public static ControlPlaneUser createAdminUser(
            Account account,
            String name,
            String email,
            String passwordHash,
            ControlPlaneRole role,
            EntityOrigin origin
    ) {
        if (account == null) throw new IllegalArgumentException("account é obrigatório");
        if (passwordHash == null || passwordHash.isBlank()) throw new IllegalArgumentException("password hash é obrigatório");

        String normalizedEmail = EmailNormalizer.normalizeOrNull(email);
        if (normalizedEmail == null) throw new IllegalArgumentException("email inválido");

        String normalizedName = normalizeName(name);
        if (normalizedName == null) throw new IllegalArgumentException("name é obrigatório");

        return ControlPlaneUser.builder()
                .account(account)
                .name(normalizedName)
                .email(normalizedEmail)
                .password(passwordHash)
                .role(role)
                .origin(origin == null ? EntityOrigin.ADMIN : origin)
                .mustChangePassword(false)
                .deleted(false)
                .suspendedByAccount(false)
                .suspendedByAdmin(false)
                .build();
    }

    public static ControlPlaneUser createBuiltInUser(
            Account account,
            String name,
            String email,
            String passwordHash,
            ControlPlaneRole role
    ) {
        return createAdminUser(account, name, email, passwordHash, role, EntityOrigin.BUILT_IN);
    }

    private static String normalizeName(String name) {
        if (name == null) return null;
        String trimmed = name.trim();
        return trimmed.isBlank() ? null : trimmed;
    }

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    public boolean isSuspended() {
        return suspendedByAccount || suspendedByAdmin;
    }

    public boolean isEnabled() {
        return !deleted && !isSuspended();
    }

    public boolean isAccountNonLocked(Instant now) {
        if (now == null) throw new IllegalArgumentException("now is required (use AppClock.instant() in application layer)");
        return lockedUntil == null || !now.isBefore(lockedUntil);
    }

    public boolean isEnabledForLogin(Instant now) {
        return isEnabled() && isAccountNonLocked(now);
    }

    public void markLastLogin(Instant now) {
        if (now == null) throw new IllegalArgumentException("now é obrigatório");
        this.lastLoginAt = now;
    }

    public void rename(String newName) {
        String normalized = normalizeName(newName);
        if (normalized == null) throw new IllegalArgumentException("name é obrigatório");
        this.name = normalized;
    }

    public void changeEmail(String newEmail) {
        String normalized = EmailNormalizer.normalizeOrNull(newEmail);
        if (normalized == null) throw new IllegalArgumentException("email inválido");
        this.email = normalized;
    }

    public void changePasswordHash(String newPasswordHash, Instant now) {
        if (newPasswordHash == null || newPasswordHash.isBlank()) throw new IllegalArgumentException("password hash é obrigatório");
        if (now == null) throw new IllegalArgumentException("now é obrigatório");

        this.password = newPasswordHash;
        this.mustChangePassword = false;
        this.passwordChangedAt = now;

        this.passwordResetToken = null;
        this.passwordResetExpiresAt = null;
    }

    public void setTemporaryPasswordHash(String newPasswordHash) {
        if (newPasswordHash == null || newPasswordHash.isBlank()) throw new IllegalArgumentException("password hash é obrigatório");

        this.password = newPasswordHash;
        this.mustChangePassword = true;
        this.passwordChangedAt = null;

        this.passwordResetToken = null;
        this.passwordResetExpiresAt = null;
    }

    public void requirePasswordChange() {
        this.mustChangePassword = true;
        this.passwordChangedAt = null;
    }

    public void clearMustChangePassword() {
        this.mustChangePassword = false;
    }

    public void changeRole(ControlPlaneRole newRole) {
        this.role = newRole;
    }

    public void suspendByAccount() { this.suspendedByAccount = true; }
    public void unsuspendByAccount() { this.suspendedByAccount = false; }

    public void suspendByAdmin() { this.suspendedByAdmin = true; }
    public void unsuspendByAdmin() { this.suspendedByAdmin = false; }

    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        if (this.audit != null) this.audit.clearDeleted();
    }

    public void clearSecurityLockState() {
        this.lockedUntil = null;
    }

    public void clearPasswordResetToken() {
        this.passwordResetToken = null;
        this.passwordResetExpiresAt = null;
    }

    public Set<ControlPlanePermission> getExplicitPermissions() {
        return explicitPermissions == null ? Set.of() : Set.copyOf(explicitPermissions);
    }

    public Set<ControlPlanePermission> getPermissions() {
        return getExplicitPermissions();
    }

    public void grantExplicitPermission(ControlPlanePermission p) {
        PermissionScopeValidator.requireControlPlanePermission(p);
        if (this.explicitPermissions == null) this.explicitPermissions = new LinkedHashSet<>();
        this.explicitPermissions.add(p);
    }

    public void revokeExplicitPermission(ControlPlanePermission p) {
        if (this.explicitPermissions == null) return;
        this.explicitPermissions.remove(p);
    }

    public void replaceExplicitPermissions(Set<ControlPlanePermission> newPermissions) {
        if (this.explicitPermissions == null) this.explicitPermissions = new LinkedHashSet<>();
        this.explicitPermissions.clear();
        if (newPermissions == null || newPermissions.isEmpty()) return;

        for (ControlPlanePermission p : newPermissions) {
            PermissionScopeValidator.requireControlPlanePermission(p);
            this.explicitPermissions.add(p);
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/controlplane/users/persistence/ControlPlaneUserRepository.java
============================================================
package brito.com.multitenancy001.controlplane.users.persistence;

import brito.com.multitenancy001.controlplane.security.ControlPlaneRole;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ControlPlaneUserRepository extends JpaRepository<ControlPlaneUser, Long> {

    // =========================================================
    // BASICS
    // =========================================================

    Optional<ControlPlaneUser> findByEmailAndDeletedFalse(String email);

    Optional<ControlPlaneUser> findByEmailAndAccount_IdAndDeletedFalse(String email, Long accountId);

    // =========================================================
    // NOT DELETED (deleted=false) -> default do domínio
    // =========================================================

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.account.id = :accountId AND u.deleted = false")
    List<ControlPlaneUser> findNotDeletedByAccountId(@Param("accountId") Long accountId);

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.id = :id AND u.account.id = :accountId AND u.deleted = false")
    Optional<ControlPlaneUser> findNotDeletedByIdAndAccountId(@Param("id") Long id,
                                                              @Param("accountId") Long accountId);

    /**
     * Agora: usuário BUILT_IN + role CONTROLPLANE_OWNER.
     */
    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.origin = :origin
               AND u.role = :role
           """)
    Optional<ControlPlaneUser> findNotDeletedBuiltInOwner(@Param("accountId") Long accountId,
                                                         @Param("origin") EntityOrigin origin,
                                                         @Param("role") ControlPlaneRole role);

    long countByAccount_IdAndDeletedFalse(Long accountId);

    // =========================================================
    // ADMIN (para telas de Account Admin Details)
    // =========================================================

    /**
     * "Admin" aqui = primeiro usuário operacional (enabled) com role de maior privilégio
     * (OWNER > ADMIN), dentro de uma conta.
     *
     * - Retorna Optional.empty() se não houver usuário elegível.
     * - Não usa getSingleResult para evitar NonUniqueResultException.
     */
    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.suspendedByAccount = false
               AND u.suspendedByAdmin = false
               AND u.role IN ('CONTROLPLANE_OWNER', 'CONTROLPLANE_ADMIN')
             ORDER BY
               CASE WHEN u.role = 'CONTROLPLANE_OWNER' THEN 0 ELSE 1 END,
               u.id ASC
           """)
    List<ControlPlaneUser> findAdminsOrderedByPriority(@Param("accountId") Long accountId);

    default Optional<ControlPlaneUser> findFirstAdminByAccountId(Long accountId) {
        if (accountId == null) return Optional.empty();
        List<ControlPlaneUser> users = findAdminsOrderedByPriority(accountId);
        return (users == null || users.isEmpty()) ? Optional.empty() : Optional.of(users.get(0));
    }

    // =========================================================
    // ENABLED = NOT DELETED + NOT suspended -> default segurança
    // =========================================================

    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.suspendedByAccount = false
               AND u.suspendedByAdmin = false
           """)
    List<ControlPlaneUser> findEnabledByAccountId(@Param("accountId") Long accountId);

    @Query("""
            SELECT u
              FROM ControlPlaneUser u
             WHERE u.id = :id
               AND u.account.id = :accountId
               AND u.deleted = false
               AND u.suspendedByAccount = false
               AND u.suspendedByAdmin = false
           """)
    Optional<ControlPlaneUser> findEnabledByIdAndAccountId(@Param("id") Long id,
                                                          @Param("accountId") Long accountId);

    // =========================================================
    // ANY = BYPASS consciente (inclui deleted) ⚠️
    // =========================================================

    @Query("SELECT u FROM ControlPlaneUser u WHERE u.id = :id AND u.account.id = :accountId")
    Optional<ControlPlaneUser> findAnyByIdAndAccountId(@Param("id") Long id,
                                                       @Param("accountId") Long accountId);

    // =========================================================
    // UNICIDADE NOT DELETED (deleted=false)
    //
    // IMPORTANTE:
    // - A coluna email é CITEXT (case-insensitive no Postgres).
    // - Logo a comparação pode (e deve) ser direta: u.email = :email
    // - A normalização (trim/lower) deve acontecer fora (EmailNormalizer).
    // =========================================================

    @Query("""
            SELECT (COUNT(u) > 0)
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.email = :email
           """)
    boolean existsNotDeletedByEmailIgnoreCase(@Param("accountId") Long accountId,
                                              @Param("email") String email);

    @Query("""
            SELECT (COUNT(u) > 0)
              FROM ControlPlaneUser u
             WHERE u.account.id = :accountId
               AND u.deleted = false
               AND u.email = :email
               AND u.id <> :userId
           """)
    boolean existsOtherNotDeletedByEmailIgnoreCase(@Param("accountId") Long accountId,
                                                   @Param("email") String email,
                                                   @Param("userId") Long userId);

    @Query("""
        select u
        from ControlPlaneUser u
        where u.id = :id
          and u.deleted = false
          and u.suspendedByAdmin = false
          and u.suspendedByAccount = false
    """)
    Optional<ControlPlaneUser> findEnabledById(@Param("id") Long id);
    
    /**
     * Default do domínio (NOT DELETED): igual AccountRepository.
     */
    Optional<ControlPlaneUser> findByIdAndDeletedFalse(Long id);
    
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/config/time/TimeConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.config.time;

import java.time.Clock;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Clock único do sistema.
 * Regra: UTC para correlação perfeita entre logs, auditoria e eventos.
 */
@Configuration
public class TimeConfig {

    @Bean
    public Clock clock() {
        return Clock.systemUTC();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.boot.autoconfigure.flyway.FlywayMigrationInitializer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Role;

import brito.com.multitenancy001.shared.db.Schemas;

/**
 * Flyway do schema PUBLIC (Control Plane).
 *
 * ✅ Migra no bootstrap
 * ✅ Evita race com @Scheduled (use @DependsOn("flywayInitializer"))
 *
 * IMPORTANTE:
 * - bean "flyway" → usado pelo Spring Boot
 * - bean "flywayInitializer" → gatilho oficial de migração
 */
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@Configuration
public class PublicFlywayConfig {

    @Bean(name = "flyway")
    public Flyway flyway(DataSource dataSource) {
        return Flyway.configure()
                .dataSource(dataSource)
                .schemas(Schemas.CONTROL_PLANE)       // "public"
                .defaultSchema(Schemas.CONTROL_PLANE)
                .locations("classpath:db/migration/accounts")
                .baselineOnMigrate(false)
                .validateOnMigrate(true)
                .cleanDisabled(true)
                .load();
    }

    @Bean(name = "flywayInitializer")
    public FlywayMigrationInitializer flywayInitializer(@Qualifier("flyway") Flyway flyway) {
        return new FlywayMigrationInitializer(flyway, null);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicFlywayRunner.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import org.flywaydb.core.Flyway;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * ⚠️ Por padrão DESLIGADO. O Flyway do PUBLIC deve rodar no bootstrap do Spring.
 * Ligue somente se você quiser forçar migração manual (não recomendado).
 */
@Component
@RequiredArgsConstructor
@Slf4j
@ConditionalOnProperty(value = "app.flyway.public.manual", havingValue = "true")
public class PublicFlywayRunner implements ApplicationRunner {

    private final Flyway flyway;

    @Override
    public void run(ApplicationArguments args) {
        log.info("⚠️ app.flyway.public.manual=true -> Executando Flyway PUBLIC manualmente (não recomendado)");
        flyway.migrate();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/flyway/publicschema/PublicSchemaVerifier.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.publicschema;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.db.Schemas;

/**
 * Verificador leve pós-startup para confirmar que o Flyway criou
 * tabelas mínimas do PUBLIC schema.
 *
 * <p>Observação: este componente não cria nada — apenas consulta metadados.</p>
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class PublicSchemaVerifier {

    private final JdbcTemplate jdbcTemplate;

    @EventListener(ApplicationReadyEvent.class)
    public void verifyTables() {
        log.info("🔍 Verificando tabelas criadas pelo Flyway (schema={})...", Schemas.CONTROL_PLANE);

        try {
            Integer accountsCount = jdbcTemplate.queryForObject(
                    "SELECT COUNT(*) " +
                    "  FROM information_schema.tables " +
                    " WHERE table_schema = ? " +
                    "   AND table_name = 'accounts'",
                    Integer.class,
                    Schemas.CONTROL_PLANE
            );

            Integer usersCount = jdbcTemplate.queryForObject(
                    "SELECT COUNT(*) " +
                    "  FROM information_schema.tables " +
                    " WHERE table_schema = ? " +
                    "   AND table_name = 'controlplane_users'",
                    Integer.class,
                    Schemas.CONTROL_PLANE
            );

            log.info("✅ Verificação OK! Tabelas encontradas: accounts={}, controlplane_users={}",
                    accountsCount, usersCount);

            if (log.isDebugEnabled()) {
                String currentSchema = jdbcTemplate.queryForObject("select current_schema()", String.class);
                String searchPath = jdbcTemplate.queryForObject("show search_path", String.class);
                log.debug("ℹ️ DB context | current_schema={} | search_path={}", currentSchema, searchPath);
            }

        } catch (Exception e) {
            log.error("⚠️ Aviso na verificação do PUBLIC schema: {}", e.getMessage(), e);
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/flyway/tenantschema/TenantSchemaFlywayMigrationService.java
============================================================
package brito.com.multitenancy001.infrastructure.flyway.tenantschema;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Service;

import lombok.RequiredArgsConstructor;

/**
 * Serviço de infraestrutura responsável por aplicar migrations Flyway
 * em schemas de tenants.
 *
 * Responsabilidades:
 * - Configurar Flyway dinamicamente por schema.
 * - Executar migrations versionadas do tenant.
 * - Garantir que apenas migrations compatíveis sejam aplicadas.
 *
 * Regras:
 * - Não deve conter lógica de negócio.
 * - Atua exclusivamente na camada de infraestrutura.
 */
@Service
@RequiredArgsConstructor
public class TenantSchemaFlywayMigrationService {

    private final DataSource dataSource;

    public void migrateTenantSchema(String tenantSchema) {
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .schemas(tenantSchema)
                .defaultSchema(tenantSchema)
                .createSchemas(false)
                .locations("classpath:db/migration/tenants")
                .baselineOnMigrate(true)
                .load();

        flyway.migrate();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/jpa/publicschema/PrimaryTransactionManagerAliasConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.jpa.publicschema;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Role;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Alias e "default" TransactionManager do Spring.
 *
 * <p>Por padrão, muitos pontos do ecossistema Spring (e libs) procuram um bean
 * chamado <b>"transactionManager"</b> (às vezes até por nome, não só por tipo).</p>
 *
 * <p>Neste projeto, a regra é:</p>
 * <ul>
 *   <li>Qualquer transação "genérica" (padrão) deve cair no PUBLIC schema (Control Plane).</li>
 *   <li>Tenant schema SEMPRE deve ser explícito (tenantTransactionManager via @TenantTx / TxExecutor / UnitOfWork).</li>
 * </ul>
 *
 * <p>Motivação:</p>
 * <ul>
 *   <li>Evitar que algum componente use um TransactionManager JDBC (DataSourceTransactionManager)
 *       e cause o erro "Pre-bound JDBC Connection found!" ao misturar com JPA.</li>
 *   <li>Tornar o comportamento previsível para quem depende do bean padrão por nome.</li>
 * </ul>
 */
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@Configuration
public class PrimaryTransactionManagerAliasConfig {

    /**
     * Bean padrão do Spring: "transactionManager".
     * Aponta explicitamente para o PUBLIC (JPA).
     */
    @Bean(name = "transactionManager")
    @Primary
    public PlatformTransactionManager transactionManager(
            @Qualifier("publicTransactionManager") PlatformTransactionManager publicTransactionManager
    ) {
        return publicTransactionManager;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/jpa/publicschema/PublicPersistenceConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.jpa.publicschema;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Role;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * Wiring de repositories do schema PUBLIC (Control Plane).
 *
 * Regras:
 * - O EntityManagerFactory default do Spring Boot é o bean "entityManagerFactory" (PUBLIC).
 * - "publicEntityManagerFactory" é APENAS um alias semântico (não pode ser @Primary).
 * - O único @Primary do PUBLIC deve ficar no bean "entityManagerFactory" (config Hibernate).
 *
 * Motivação:
 * - Evitar ambiguidade de injeção de EntityManager quando existem múltiplos EMFs (public + tenant).
 */
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@Configuration
@EnableJpaRepositories(
        basePackages = {
                "brito.com.multitenancy001.controlplane.accounts.persistence",
                "brito.com.multitenancy001.controlplane.users.persistence",
                "brito.com.multitenancy001.controlplane.billing.persistence",
                "brito.com.multitenancy001.controlplane.scheduling.persistence",
                "brito.com.multitenancy001.infrastructure.publicschema"
        },
        entityManagerFactoryRef = "publicEntityManagerFactory",
        transactionManagerRef = "publicTransactionManager"
)
public class PublicPersistenceConfig {

    @Bean(name = "publicEntityManagerFactory")
    public EntityManagerFactory publicEntityManagerFactory(
            @Qualifier("entityManagerFactory") EntityManagerFactory emf
    ) {
        /* Alias semântico para o EMF público (não usar @Primary aqui). */
        return emf;
    }

    @Bean(name = "publicTransactionManager")
    public PlatformTransactionManager publicTransactionManager(
            @Qualifier("publicEntityManagerFactory") EntityManagerFactory emf
    ) {
        /* TransactionManager do PUBLIC (não usar @Primary aqui). */
        return new JpaTransactionManager(emf);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/jpa/tenantschema/TenantPersistenceConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.jpa.tenantschema;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

/**
 * Wiring dos repositories do schema TENANT.
 *
 * Observação:
 * - Seus repositories agora estão em tenant.<módulo>.persistence,
 *   então escaneamos "brito.com.multitenancy001.tenant" como raiz.
 */
@Configuration
@EnableJpaRepositories(
        basePackages = "brito.com.multitenancy001.tenant",
        entityManagerFactoryRef = "tenantEntityManagerFactory",
        transactionManagerRef = "tenantTransactionManager"
)
public class TenantPersistenceConfig {
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/multitenancy/observability/TenantContextMonitor.java
============================================================
package brito.com.multitenancy001.infrastructure.multitenancy.observability;

import brito.com.multitenancy001.shared.api.error.ApiErrorCategory;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

/**
 * Observabilidade do TenantContext em execução de Services.
 *
 * Responsabilidades:
 * - Logar tenant bound/effective
 * - Classificar falhas (AUTH, VALIDATION, BUSINESS, INTERNAL, TENANT_CONTEXT)
 * - Evitar stacktrace para fluxo esperado
 *
 * Não altera fluxo de exceções — apenas observa.
 */
@Aspect
@Component
@Slf4j
public class TenantContextMonitor {

    @Around("@within(org.springframework.stereotype.Service)")
    public Object monitorServiceMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        String boundTenant = TenantContext.getOrNull();
        String effectiveTenant = TenantContext.getOrDefaultPublic();
        
        long startTime = System.currentTimeMillis();

        log.debug("🏁 INÍCIO {} | tenant(bound={}, effective={})",
                methodName, boundTenant, effectiveTenant);

        try {
            Object result = joinPoint.proceed();
            long duration = System.currentTimeMillis() - startTime;

            log.debug("✅ FIM {} ({}ms) | tenant(bound={}, effective={})",
                    methodName, duration,
                    TenantContext.getOrNull(),
                    TenantContext.getOrDefaultPublic());

            return result;

        } catch (Throwable e) {
            long duration = System.currentTimeMillis() - startTime;
            
            // Tratamento especial para erro de contexto de tenant
            if (isTenantContextError(e)) {
                log.warn("🏷️ CONTEXTO_TENANT {} ({}ms) | tenant(bound={}, effective={}) | detalhe: {}",
                        methodName, duration, boundTenant, effectiveTenant, getTenantContextErrorMessage(e));
                throw e;
            }

            // AUTH inválida = fluxo normal
            if (isInvalidLogin(e)) {
                log.info("🔐 AUTENTICACAO {} ({}ms) | tenant(bound={}, effective={}) | motivo: {}",
                        methodName, duration, boundTenant, effectiveTenant, safeMsg(e));
                throw e;
            }

            ApiException apiEx = findApiException(e);
            if (apiEx != null) {
                logApiException(apiEx, methodName, duration, boundTenant, effectiveTenant, e);
                throw e;
            }

            // Erro inesperado
            log.error("❌ ERRO_INESPERADO {} ({}ms) | tenant(bound={}, effective={}) | tipo={} | motivo: {}",
                    methodName, duration, boundTenant, effectiveTenant,
                    e.getClass().getSimpleName(), safeMsg(e), e);
            throw e;
        }
    }

    private boolean isTenantContextError(Throwable e) {
        if (e == null) return false;
        
        if (e instanceof IllegalStateException) {
            String msg = e.getMessage();
            return msg != null && msg.contains("TenantContext.bindTenantSchema");
        }
        
        return false;
    }

    private String getTenantContextErrorMessage(Throwable e) {
        if (e == null) return "Erro desconhecido";
        
        String msg = e.getMessage();
        if (msg != null && msg.contains("TenantContext.bindTenantSchema")) {
            return "Não é possível mudar para o schema do tenant dentro de uma transação existente. " +
                   "A operação no schema public foi concluída, mas a operação no tenant foi ignorada.";
        }
        
        return safeMsg(e);
    }

    private void logApiException(
            ApiException ex,
            String method,
            long duration,
            String boundTenant,
            String effectiveTenant,
            Throwable original
    ) {
        ApiErrorCategory category = ex.getCategory();
        int status = ex.getStatus();

        String baseLog = "{} {} ({}ms) | tenant(bound={}, effective={}) | status={} código={} | {}";

        // INTERNAL = erro real (mostra stacktrace)
        if (category == ApiErrorCategory.INTERNAL || status >= 500) {
            log.error(baseLog, "❌ INTERNO", method, duration, 
                    boundTenant, effectiveTenant, status, ex.getCode().name(), safeMsg(ex), original);
            return;
        }

        // AUTH / SECURITY
        if (category == ApiErrorCategory.AUTH || category == ApiErrorCategory.SECURITY) {
            log.info(baseLog, "🔐 SEGURANCA", method, duration,
                    boundTenant, effectiveTenant, status, ex.getCode().name(), safeMsg(ex));
            return;
        }

        // VALIDATION / REQUEST
        if (category == ApiErrorCategory.VALIDATION || category == ApiErrorCategory.REQUEST) {
            log.warn(baseLog, "⚠️ VALIDACAO", method, duration,
                    boundTenant, effectiveTenant, status, ex.getCode().name(), safeMsg(ex));
            return;
        }

        // CONFLICT
        if (category == ApiErrorCategory.CONFLICT) {
            log.warn(baseLog, "⚡ CONFLITO", method, duration,
                    boundTenant, effectiveTenant, status, ex.getCode().name(), safeMsg(ex));
            return;
        }

        // Regra de negócio
        log.warn(baseLog, "📋 NEGOCIO", method, duration,
                boundTenant, effectiveTenant, status, ex.getCode().name(), 
                String.format("[%s] %s", category.name(), safeMsg(ex)));
    }

    private ApiException findApiException(Throwable ex) {
        if (ex == null) return null;
        if (ex instanceof ApiException api) return api;
        if (ex.getCause() != null && ex.getCause() != ex) {
            return findApiException(ex.getCause());
        }
        return null;
    }

    private boolean isInvalidLogin(Throwable ex) {
        if (ex == null) return false;

        if (ex instanceof BadCredentialsException) return true;
        if (ex instanceof UsernameNotFoundException) return true;

        if (ex.getCause() != null && ex.getCause() != ex) {
            return isInvalidLogin(ex.getCause());
        }

        return false;
    }

    private String safeMsg(Throwable ex) {
        if (ex == null) return "Exceção nula";
        String msg = ex.getMessage();
        if (msg == null || msg.isBlank()) {
            return ex.getClass().getSimpleName();
        }
        // Limitar tamanho da mensagem
        if (msg.length() > 150) {
            msg = msg.substring(0, 147) + "...";
        }
        return msg;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/openapi/OpenApiConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.openapi;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;

import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    public static final String SECURITY_SCHEME_NAME = "bearerAuth";

    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("Multitenancy001 API")
                .description("ControlPlane / Tenant APIs")
                .version("v1"))
            .addSecurityItem(new SecurityRequirement().addList(SECURITY_SCHEME_NAME))
            .components(new Components()
                .addSecuritySchemes(SECURITY_SCHEME_NAME,
                    new SecurityScheme()
                        .type(SecurityScheme.Type.HTTP)
                        .scheme("bearer")
                        .bearerFormat("JWT")
                )
            );
    }




@Bean
public GroupedOpenApi adminApi() {
    return GroupedOpenApi.builder()
        .group("admin")
        .pathsToMatch("/api/admin/**")
        .build();
}

@Bean
public GroupedOpenApi controlPlaneApi() {
    return GroupedOpenApi.builder()
        .group("controlplane")
        .pathsToMatch("/api/controlplane/**")
        .build();
}

@Bean
public GroupedOpenApi tenantApi() {
    return GroupedOpenApi.builder()
        .group("tenant")
        .pathsToMatch("/api/tenant/**", "/api/me/**")
        .build();
}

@Bean
public GroupedOpenApi publicApi() {
    return GroupedOpenApi.builder()
        .group("public")
        .pathsToMatch("/api/signup", "/api/accounts/auth/**")
        .build();
}

}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/TxExecutor.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.support.AopUtils;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.Role;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.transaction.support.TransactionTemplate;

/**
 * Executor transacional centralizado (PUBLIC e TENANT).
 *
 * <p><b>Regras do projeto:</b></p>
 * <ul>
 *   <li>PUBLIC sempre usa {@code publicTransactionManager} (JPA).</li>
 *   <li>TENANT sempre usa {@code tenantTransactionManager} (JPA multi-tenant por schema).</li>
 *   <li>TransactionManager JDBC (DataSourceTransactionManager/JdbcTransactionManager) é proibido.</li>
 * </ul>
 *
 * <p><b>Motivação:</b></p>
 * <ul>
 *   <li>Evitar o erro: "Pre-bound JDBC Connection found! ... running within DataSourceTransactionManager".</li>
 *   <li>Garantir que TransactionTemplate nunca rode em TM incorreto por auto-config.</li>
 *   <li>Centralizar logs de depuração transacional (estado + resources bindados no thread).</li>
 * </ul>
 */
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@Component
public class TxExecutor {

    private static final Logger log = LoggerFactory.getLogger(TxExecutor.class);

    private final PlatformTransactionManager publicTm;
    private final PlatformTransactionManager tenantTm;

    private final TransactionTemplate transactionTemplatePublicTx;
    private final TransactionTemplate transactionTemplatePublicRequiresNew;

    private final TransactionTemplate transactionTemplatePublicReadOnlyTx;
    private final TransactionTemplate transactionTemplatePublicRequiresNewReadOnly;

    private final TransactionTemplate transactionTemplateTenantTx;
    private final TransactionTemplate transactionTemplateTenantRequiresNew;

    private final TransactionTemplate transactionTemplateTenantReadOnlyTx;
    private final TransactionTemplate transactionTemplateTenantRequiresNewReadOnly;

    public TxExecutor(
            @Qualifier("publicTransactionManager") PlatformTransactionManager publicTm,
            @Qualifier("tenantTransactionManager") PlatformTransactionManager tenantTm
    ) {
        assertJpaTransactionManager(publicTm, "publicTransactionManager");
        assertJpaTransactionManager(tenantTm, "tenantTransactionManager");

        this.publicTm = publicTm;
        this.tenantTm = tenantTm;

        // PUBLIC - REQUIRED
        this.transactionTemplatePublicTx = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // PUBLIC - REQUIRES_NEW
        this.transactionTemplatePublicRequiresNew = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // PUBLIC - REQUIRED READONLY
        this.transactionTemplatePublicReadOnlyTx = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.transactionTemplatePublicReadOnlyTx.setReadOnly(true);

        // PUBLIC - REQUIRES_NEW READONLY
        this.transactionTemplatePublicRequiresNewReadOnly = new TransactionTemplate(publicTm);
        this.transactionTemplatePublicRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.transactionTemplatePublicRequiresNewReadOnly.setReadOnly(true);

        // TENANT - REQUIRED
        this.transactionTemplateTenantTx = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        // TENANT - REQUIRES_NEW
        this.transactionTemplateTenantRequiresNew = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantRequiresNew.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);

        // TENANT - REQUIRED READONLY
        this.transactionTemplateTenantReadOnlyTx = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantReadOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        this.transactionTemplateTenantReadOnlyTx.setReadOnly(true);

        // TENANT - REQUIRES_NEW READONLY
        this.transactionTemplateTenantRequiresNewReadOnly = new TransactionTemplate(tenantTm);
        this.transactionTemplateTenantRequiresNewReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        this.transactionTemplateTenantRequiresNewReadOnly.setReadOnly(true);

        log.info("✅ TxExecutor inicializado | publicTm={} | tenantTm={}",
                describeTm(publicTm), describeTm(tenantTm));
    }

    // ---------- PUBLIC ----------
    public <T> T inPublicTx(Supplier<T> fn) {
        return execute("PUBLIC", "REQUIRED", false, () -> transactionTemplatePublicTx.execute(status -> fn.get()));
    }

    public void inPublicTx(Runnable fn) {
        execute("PUBLIC", "REQUIRED", false, () -> {
            transactionTemplatePublicTx.executeWithoutResult(status -> fn.run());
            return null;
        });
    }

    public <T> T inPublicRequiresNew(Supplier<T> fn) {
        return execute("PUBLIC", "REQUIRES_NEW", false, () -> transactionTemplatePublicRequiresNew.execute(status -> fn.get()));
    }

    public void inPublicRequiresNew(Runnable fn) {
        execute("PUBLIC", "REQUIRES_NEW", false, () -> {
            transactionTemplatePublicRequiresNew.executeWithoutResult(status -> fn.run());
            return null;
        });
    }

    public <T> T inPublicReadOnlyTx(Supplier<T> fn) {
        return execute("PUBLIC", "REQUIRED", true, () -> transactionTemplatePublicReadOnlyTx.execute(status -> fn.get()));
    }

    public void inPublicReadOnlyTx(Runnable fn) {
        execute("PUBLIC", "REQUIRED", true, () -> {
            transactionTemplatePublicReadOnlyTx.executeWithoutResult(status -> fn.run());
            return null;
        });
    }

    public <T> T inPublicRequiresNewReadOnly(Supplier<T> fn) {
        return execute("PUBLIC", "REQUIRES_NEW", true, () -> transactionTemplatePublicRequiresNewReadOnly.execute(status -> fn.get()));
    }

    public void inPublicRequiresNewReadOnly(Runnable fn) {
        execute("PUBLIC", "REQUIRES_NEW", true, () -> {
            transactionTemplatePublicRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
            return null;
        });
    }

    // ---------- TENANT ----------
    public <T> T inTenantTx(Supplier<T> fn) {
        return execute("TENANT", "REQUIRED", false, () -> transactionTemplateTenantTx.execute(status -> fn.get()));
    }

    public void inTenantTx(Runnable fn) {
        execute("TENANT", "REQUIRED", false, () -> {
            transactionTemplateTenantTx.executeWithoutResult(status -> fn.run());
            return null;
        });
    }

    public <T> T inTenantRequiresNew(Supplier<T> fn) {
        return execute("TENANT", "REQUIRES_NEW", false, () -> transactionTemplateTenantRequiresNew.execute(status -> fn.get()));
    }

    public void inTenantRequiresNew(Runnable fn) {
        execute("TENANT", "REQUIRES_NEW", false, () -> {
            transactionTemplateTenantRequiresNew.executeWithoutResult(status -> fn.run());
            return null;
        });
    }

    public <T> T inTenantReadOnlyTx(Supplier<T> fn) {
        return execute("TENANT", "REQUIRED", true, () -> transactionTemplateTenantReadOnlyTx.execute(status -> fn.get()));
    }

    public void inTenantReadOnlyTx(Runnable fn) {
        execute("TENANT", "REQUIRED", true, () -> {
            transactionTemplateTenantReadOnlyTx.executeWithoutResult(status -> fn.run());
            return null;
        });
    }

    public <T> T inTenantRequiresNewReadOnly(Supplier<T> fn) {
        return execute("TENANT", "REQUIRES_NEW", true, () -> transactionTemplateTenantRequiresNewReadOnly.execute(status -> fn.get()));
    }

    public void inTenantRequiresNewReadOnly(Runnable fn) {
        execute("TENANT", "REQUIRES_NEW", true, () -> {
            transactionTemplateTenantRequiresNewReadOnly.executeWithoutResult(status -> fn.run());
            return null;
        });
    }

    // ---------------------------------------------------------------------
    // Internals: logging / diagnostics
    // ---------------------------------------------------------------------

    private <T> T execute(String scope, String propagation, boolean readOnly, Supplier<T> supplier) {
        boolean activeBefore = TransactionSynchronizationManager.isActualTransactionActive();
        boolean syncBefore = TransactionSynchronizationManager.isSynchronizationActive();
        Map<Object, Object> resourcesBefore = TransactionSynchronizationManager.getResourceMap();

        long start = System.currentTimeMillis();

        if (log.isDebugEnabled()) {
            log.debug("▶ TX BEGIN (before) | scope={} | propagation={} | readOnly={} | activeTx={} | sync={} | resources={}",
                    scope, propagation, readOnly, activeBefore, syncBefore, summarizeResources(resourcesBefore));
        }

        try {
            T out = supplier.get();

            long ms = System.currentTimeMillis() - start;
            if (log.isDebugEnabled()) {
                log.debug("✅ TX END (after) | scope={} | propagation={} | readOnly={} | tookMs={} | activeTxNow={} | syncNow={} | resourcesNow={}",
                        scope, propagation, readOnly, ms,
                        TransactionSynchronizationManager.isActualTransactionActive(),
                        TransactionSynchronizationManager.isSynchronizationActive(),
                        summarizeResources(TransactionSynchronizationManager.getResourceMap()));
            }
            return out;
        } catch (RuntimeException ex) {
            long ms = System.currentTimeMillis() - start;

            log.error("❌ TX ERROR | scope={} | propagation={} | readOnly={} | tookMs={} | activeTxBefore={} | syncBefore={} | resourcesBefore={} | tmPublic={} | tmTenant={} | exType={} | msg={}",
                    scope, propagation, readOnly, ms,
                    activeBefore, syncBefore, summarizeResources(resourcesBefore),
                    describeTm(publicTm), describeTm(tenantTm),
                    ex.getClass().getSimpleName(), safeMsg(ex), ex);

            throw ex;
        }
    }

    /**
     * Loga um resumo compacto dos resources bindados no thread.
     *
     * <p>Importante para detectar "Pre-bound JDBC Connection": normalmente aparece um resource
     * relacionado a DataSource/ConnectionHolder/JdbcTemplate etc.</p>
     */
    private static String summarizeResources(Map<Object, Object> resources) {
        if (resources == null || resources.isEmpty()) return "[]";

        List<String> out = new ArrayList<>();
        for (var e : resources.entrySet()) {
            Object k = e.getKey();
            Object v = e.getValue();
            String ks = (k == null ? "null" : k.getClass().getName());
            String vs = (v == null ? "null" : v.getClass().getName());
            out.add(ks + "->" + vs);
        }
        return out.toString();
    }

    private static String describeTm(PlatformTransactionManager tm) {
        Class<?> target = AopUtils.getTargetClass(tm);
        if (target == null) target = tm.getClass();
        return target.getName();
    }

    private static String safeMsg(Throwable t) {
        String m = t.getMessage();
        return (m == null ? "" : m.replace("\n", " ").replace("\r", " "));
    }

    private static void assertJpaTransactionManager(PlatformTransactionManager tm, String expectedBeanName) {
        Class<?> target = AopUtils.getTargetClass(tm);
        if (target == null) target = tm.getClass();

        if (!JpaTransactionManager.class.isAssignableFrom(target)) {
            String msg = "\n\n🚫 TransactionManager inválido injetado em TxExecutor.\n"
                    + "Bean esperado: '" + expectedBeanName + "' (JpaTransactionManager)\n"
                    + "Tipo real: " + target.getName() + "\n\n"
                    + "Isso causa: 'Pre-bound JDBC Connection found!...'\n"
                    + "Correção: garanta que '" + expectedBeanName + "' seja JpaTransactionManager.\n";
            throw new IllegalStateException(msg);
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/PublicSchemaHibernateConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.multitenancy.hibernate;

import brito.com.multitenancy001.shared.db.Schemas;
import lombok.RequiredArgsConstructor;
import org.hibernate.cfg.AvailableSettings;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.hibernate5.SpringBeanContainer;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
public class PublicSchemaHibernateConfig {

    private final DataSource dataSource;
    private final ConfigurableListableBeanFactory configurableListableBeanFactory;

    /**
     * EntityManagerFactory do schema PUBLIC (Control Plane).
     *
     * Escaneia:
     * - Entidades do ControlPlane (módulo-first: controlplane.accounts/users/billing etc.)
     * - Entidades técnicas do schema public (ex.: infrastructure.publicschema.auth.TenantLoginChallenge)
     *
     * Obs: não use mais packages antigos como:
     * - brito.com.multitenancy001.controlplane.domain (não existe mais)
     * - brito.com.multitenancy001.shared.persistence (não existe mais)
     */
    @Bean(name = "entityManagerFactory")
    @Primary
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        emf.setPackagesToScan(
                "brito.com.multitenancy001.controlplane",
                "brito.com.multitenancy001.infrastructure.publicschema"
        );

        emf.setPersistenceUnitName("PUBLIC_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();
        props.put(AvailableSettings.DEFAULT_SCHEMA, Schemas.CONTROL_PLANE);

        // Bean container para injeção em listeners/converters/etc
        props.put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(configurableListableBeanFactory));

        emf.setJpaPropertyMap(props);
        return emf;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TenantSchemaConnectionProvider.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;

import javax.sql.DataSource;
import java.sql.*;

@Slf4j
@Component
@RequiredArgsConstructor
public class TenantSchemaConnectionProvider
        extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String> {

    private static final long serialVersionUID = 1L;

    /**
     * ✅ Default/root = Control Plane (hoje: "public")
     */
    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    private final DataSource dataSource;

    @Override
    protected DataSource selectAnyDataSource() {
        return dataSource;
    }

    @Override
    protected DataSource selectDataSource(String tenantIdentifier) {
        return dataSource;
    }

    @Override
    public Connection getConnection(String tenantIdentifier) throws SQLException {

        long threadId = Thread.currentThread().threadId();

        // ✅ TenantContext guarda tenantSchema (null = PUBLIC). Aqui nunca devolve null.
        String threadTenantSchema = TenantContext.getOrDefaultPublic();

        // ✅ Hibernate pode passar vazio/null no root/public — isso é normal.
        String effectiveTenantSchema = StringUtils.hasText(tenantIdentifier)
                ? tenantIdentifier.trim()
                : DEFAULT_SCHEMA;

        if (!StringUtils.hasText(tenantIdentifier)) {
            if (log.isDebugEnabled()) {
                log.debug("🏠 [MT] tenantParam vazio → usando DEFAULT ({}) | thread={} | tenantSchemaThread={}",
                        DEFAULT_SCHEMA, threadId, threadTenantSchema);
            }
        } else if (!effectiveTenantSchema.equals(threadTenantSchema)) {
            log.warn("⚠️ [MT] mismatch tenantSchemaParam vs tenantSchemaThread | thread={} | tenantSchemaParam={} | tenantSchemaThread={}",
                    threadId, effectiveTenantSchema, threadTenantSchema);
        }

        validateTenantSchema(effectiveTenantSchema);

        Connection connection = dataSource.getConnection();

        try (Statement stmt = connection.createStatement()) {

            if (!DEFAULT_SCHEMA.equals(effectiveTenantSchema)) {
                ensureSchemaExists(connection, effectiveTenantSchema);

                String quotedTenant = quoteIdentifier(effectiveTenantSchema);
                String quotedDefault = quoteIdentifier(DEFAULT_SCHEMA);

                String setSearchPath = "SET search_path TO " + quotedTenant + ", " + quotedDefault;
                log.info("🎯 [MT] getConnection | thread={} | tenantSchemaParam={} | tenantSchemaThread={} | SQL={}",
                        threadId, effectiveTenantSchema, threadTenantSchema, setSearchPath);

                stmt.execute(setSearchPath);

            } else {
                String quotedDefault = quoteIdentifier(DEFAULT_SCHEMA);

                String setSearchPath = "SET search_path TO " + quotedDefault + ";";
                log.info("🏠 [MT] getConnection | thread={} | tenantSchemaParam={} | tenantSchemaThread={} | SQL={}",
                        threadId, effectiveTenantSchema, threadTenantSchema, setSearchPath);

                stmt.execute(setSearchPath);
            }

            return connection;

        } catch (SQLException e) {
            log.error("❌ [MT] Erro configurando conexão | effectiveTenantSchema={}", effectiveTenantSchema, e);
            try { connection.close(); } catch (SQLException ignore) {}
            throw e;
        }
    }

    @Override
    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
        long threadId = Thread.currentThread().threadId();

        if (connection == null) {
            if (log.isDebugEnabled()) {
                log.debug("🧹 [MT] releaseConnection ignorado (connection=null) | thread={} | tenantParam={}",
                        threadId, tenantIdentifier);
            }
            return;
        }

        if (connection.isClosed()) {
            if (log.isDebugEnabled()) {
                log.debug("🧹 [MT] releaseConnection ignorado (connection já fechada) | thread={} | tenantParam={}",
                        threadId, tenantIdentifier);
            }
            return;
        }

        try (Statement stmt = connection.createStatement()) {
            String resetSearchPath = "SET search_path TO " + quoteIdentifier(DEFAULT_SCHEMA) + ";";

            if (log.isDebugEnabled()) {
                log.debug("🧹 [MT] releaseConnection | thread={} | tenantParam={} | SQL={}",
                        threadId, tenantIdentifier, resetSearchPath);
            }

            stmt.execute(resetSearchPath);

        } catch (SQLException e) {
            log.warn("⚠️ [MT] Falha ao resetar search_path no releaseConnection | thread={} | tenantParam={}",
                    threadId, tenantIdentifier, e);
        } finally {
            connection.close();

            if (log.isDebugEnabled()) {
                log.debug("🔒 [MT] conexão fechada | thread={} | tenantParam={}", threadId, tenantIdentifier);
            }
        }
    }

    private void ensureSchemaExists(Connection connection, String tenantSchema) throws SQLException {
        String quotedSchema = quoteIdentifier(tenantSchema);

        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE SCHEMA IF NOT EXISTS " + quotedSchema);
        }

        try (PreparedStatement ps = connection.prepareStatement(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = ?")) {
            ps.setString(1, tenantSchema);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    throw new SQLException("Schema " + tenantSchema + " não encontrado após CREATE");
                }
            }
        }
    }

    private void validateTenantSchema(String tenantSchema) {
        if (!StringUtils.hasText(tenantSchema)) {
            throw new IllegalArgumentException("tenantSchema vazio");
        }
        if (!tenantSchema.matches("[A-Za-z_][A-Za-z0-9_]*")) {
            throw new IllegalArgumentException("tenantSchema inválido: " + tenantSchema);
        }
    }

    private String quoteIdentifier(String identifier) {
        return "\"" + identifier + "\"";
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TenantSchemaHibernateConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import org.hibernate.cfg.AvailableSettings;
import org.hibernate.cfg.MultiTenancySettings;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Role;
import org.springframework.orm.hibernate5.SpringBeanContainer;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * Configuração do EntityManagerFactory TENANT usando Hibernate multi-tenancy por SCHEMA.
 *
 * <p>Regras do projeto:</p>
 * <ul>
 *   <li>Entidades TENANT vivem em {@code brito.com.multitenancy001.tenant.*}</li>
 *   <li>O tenant é resolvido por schema via {@link TenantSchemaResolver}</li>
 *   <li>Conexões são fornecidas por {@link TenantSchemaConnectionProvider}</li>
 *   <li>O TransactionManager do TENANT é {@link JpaTransactionManager}</li>
 * </ul>
 */
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@Configuration
@RequiredArgsConstructor
public class TenantSchemaHibernateConfig {

    private final DataSource dataSource;
    private final TenantSchemaConnectionProvider tenantSchemaConnectionProvider;
    private final TenantSchemaResolver currentTenantSchemaResolver;
    private final ConfigurableListableBeanFactory configurableListableBeanFactory;

    @Bean(name = "tenantEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean tenantEntityManagerFactory() {
        LocalContainerEntityManagerFactoryBean emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource);

        /**
         * Entidades do TENANT (módulo-first: tenant.users/products/categories/etc.)
         */
        emf.setPackagesToScan("brito.com.multitenancy001.tenant");

        emf.setPersistenceUnitName("TENANT_PU");
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        Map<String, Object> props = new HashMap<>();

        // DDL sempre via Flyway (você dropa o banco e recria)
        props.put(AvailableSettings.HBM2DDL_AUTO, "none");

        // Log SQL (mantenho como você está usando)
        props.put(AvailableSettings.SHOW_SQL, true);
        props.put(AvailableSettings.FORMAT_SQL, true);

        /**
         * ✅ Multi-tenancy por SCHEMA
         *
         * Obs: Na sua versão, AvailableSettings.MULTI_TENANT não existe.
         * O key compatível é "hibernate.multiTenancy" (string).
         */
        props.put("hibernate.multiTenancy", "SCHEMA");

        // ✅ Provider/Resolver (constantes oficiais)
        props.put(MultiTenancySettings.MULTI_TENANT_CONNECTION_PROVIDER, tenantSchemaConnectionProvider);
        props.put(MultiTenancySettings.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantSchemaResolver);

        // ✅ Hibernate resolve beans do Spring (EntityListeners @Component etc.)
        props.put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(configurableListableBeanFactory));

        emf.setJpaPropertyMap(props);
        return emf;
    }

    @Bean(name = "tenantTransactionManager")
    public PlatformTransactionManager tenantTransactionManager(
            @Qualifier("tenantEntityManagerFactory") jakarta.persistence.EntityManagerFactory emf
    ) {
        return new JpaTransactionManager(emf);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TenantSchemaResolver.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.multitenancy.hibernate;

import lombok.extern.slf4j.Slf4j;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;

@Slf4j
@Component
public class TenantSchemaResolver implements CurrentTenantIdentifierResolver<String> {

    private static final String DEFAULT_SCHEMA = Schemas.CONTROL_PLANE;

    // ---------------------------------------------------------------------
    // ✅ Contexto ativo => tenantSchema
    // ---------------------------------------------------------------------

    public static void bindSchemaToCurrentThread(String tenantSchema) {
        TenantContext.bindTenantSchema(tenantSchema);
    }

    public static String resolveBoundSchemaOrNull() {
        return TenantContext.getOrNull(); // null = PUBLIC
    }

    public static String resolveBoundSchemaOrDefault() {
        String tenantSchema = TenantContext.getOrNull();
        return (tenantSchema != null ? tenantSchema : DEFAULT_SCHEMA);
    }

    public static void unbindSchemaFromCurrentThread() {
        TenantContext.clear();
    }

    // ---------------------------------------------------------------------
    // Hibernate integration
    // ---------------------------------------------------------------------

    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenantSchema = TenantContext.getOrNull(); // null = public
        String resolved = (StringUtils.hasText(tenantSchema) ? tenantSchema : DEFAULT_SCHEMA);

        if (log.isDebugEnabled()) {
            log.debug("🏷️ Hibernate resolveu schema={} (bound={}, default={})",
                    resolved, tenantSchema, DEFAULT_SCHEMA);
        }
        return resolved;
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return false;
    }

    @Override
    public boolean isRoot(String tenantIdentifier) {
        return DEFAULT_SCHEMA.equals(tenantIdentifier);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TransactionManagementConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.multitenancy.hibernate;

import brito.com.multitenancy001.infrastructure.persistence.tx.TenantReadOnlyTx;
import brito.com.multitenancy001.infrastructure.persistence.tx.TenantTx;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.support.AopUtils;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Role;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.annotation.TransactionManagementConfigurer;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.ReflectionUtils;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Configuration
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@EnableTransactionManagement
@RequiredArgsConstructor
public class TransactionManagementConfig implements TransactionManagementConfigurer, SmartInitializingSingleton {

    private static final Logger log = LoggerFactory.getLogger(TransactionManagementConfig.class);

    private static final String TENANT_BASE_PACKAGE = "brito.com.multitenancy001.tenant.";

    private final ApplicationContext applicationContext;

    @Qualifier("publicTransactionManager")
    private final PlatformTransactionManager publicTransactionManager;

    /**
     * ✅ Regra 1: qualquer @Transactional "pelado" (sem especificar manager) deve cair no PUBLIC.
     * Isso torna o comportamento estável e previsível.
     */
    @Override
    public PlatformTransactionManager annotationDrivenTransactionManager() {
        Class<?> target = AopUtils.getTargetClass(publicTransactionManager);
        if (target == null) target = publicTransactionManager.getClass();
        log.info("✅ annotationDrivenTransactionManager() = publicTransactionManager | type={}", target.getName());
        return publicTransactionManager;
    }

    /**
     * ✅ Regra 2: no pacote TENANT, é proibido usar @Transactional diretamente.
     * Deve usar @TenantTx ou @TenantReadOnlyTx (meta-annotations).
     *
     * Se encontrar violações, falha o startup com uma lista de pontos.
     */
    @Override
    public void afterSingletonsInstantiated() {
        log.info("🔎 Verificando uso proibido de @Transactional direto em TENANT... basePackage={}", TENANT_BASE_PACKAGE);

        Set<String> violations = new LinkedHashSet<>();

        // 2.1) Verifica beans normais cuja classe alvo está no pacote tenant
        String[] beanNames = applicationContext.getBeanDefinitionNames();
        for (String beanName : beanNames) {
            Object bean;
            try {
                bean = applicationContext.getBean(beanName);
            } catch (Exception ignored) {
                continue;
            }

            Class<?> targetClass = AopUtils.getTargetClass(bean);
            if (targetClass == null) continue;

            if (isTenantType(targetClass)) {
                violations.addAll(findDirectTransactionalUsages(targetClass));
            }
        }

        // 2.2) Verifica interfaces de Spring Data JPA repositories (proxy)
        Map<String, ?> repositories = applicationContext.getBeansOfType(JpaRepository.class);
        for (Object repoBeanObj : repositories.values()) {

            Class<?> targetClass = AopUtils.getTargetClass(repoBeanObj);
            if (targetClass == null) continue;

            for (Class<?> itf : targetClass.getInterfaces()) {
                if (itf != null && isTenantType(itf)) {
                    violations.addAll(findDirectTransactionalUsages(itf));
                }
            }
        }

        if (!violations.isEmpty()) {
            StringBuilder sb = new StringBuilder();
            sb.append("\n\n");
            sb.append("🚫 Encontrado uso PROIBIDO de @Transactional direto dentro de TENANT.\n");
            sb.append("Regra do projeto: em '").append(TENANT_BASE_PACKAGE).append("..' use APENAS @TenantTx / @TenantReadOnlyTx.\n\n");
            sb.append("Ocorrências:\n");
            for (String v : violations) {
                sb.append(" - ").append(v).append("\n");
            }
            sb.append("\nCorreção: troque @Transactional por @TenantTx ou @TenantReadOnlyTx.\n");
            throw new IllegalStateException(sb.toString());
        }

        log.info("✅ OK: Nenhum @Transactional direto encontrado no pacote TENANT.");
    }

    private boolean isTenantType(Class<?> type) {
        return type.getName().startsWith(TENANT_BASE_PACKAGE);
    }

    private List<String> findDirectTransactionalUsages(Class<?> type) {
        List<String> out = new ArrayList<>();

        boolean hasClassLevelDirectTransactional = type.isAnnotationPresent(Transactional.class);
        boolean hasClassLevelTenantTx = AnnotatedElementUtils.hasAnnotation(type, TenantTx.class)
                || AnnotatedElementUtils.hasAnnotation(type, TenantReadOnlyTx.class);

        if (hasClassLevelDirectTransactional && !hasClassLevelTenantTx) {
            out.add(type.getName() + "  [@Transactional direto no nível de classe]");
        }

        ReflectionUtils.doWithMethods(type, method -> {
            boolean hasTenantTx = AnnotatedElementUtils.hasAnnotation(method, TenantTx.class)
                    || AnnotatedElementUtils.hasAnnotation(method, TenantReadOnlyTx.class)
                    || AnnotatedElementUtils.hasAnnotation(type, TenantTx.class)
                    || AnnotatedElementUtils.hasAnnotation(type, TenantReadOnlyTx.class);

            if (hasTenantTx) return;

            boolean hasAnyTransactional = AnnotatedElementUtils.hasAnnotation(method, Transactional.class)
                    || AnnotatedElementUtils.hasAnnotation(type, Transactional.class);

            if (!hasAnyTransactional) return;

            if (method.isAnnotationPresent(Transactional.class)) {
                out.add(type.getName() + "#" + signature(method));
            }
        }, this::isCandidateMethod);

        return out;
    }

    private boolean isCandidateMethod(Method method) {
        return !method.isBridge() && !method.isSynthetic();
    }

    private String signature(Method m) {
        StringBuilder sb = new StringBuilder();
        sb.append(m.getName()).append("(");
        Class<?>[] p = m.getParameterTypes();
        for (int i = 0; i < p.length; i++) {
            if (i > 0) sb.append(", ");
            sb.append(p[i].getSimpleName());
        }
        sb.append(")");
        return sb.toString();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/multitenancy/hibernate/TransactionManagersVerifier.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.multitenancy.hibernate;

import lombok.RequiredArgsConstructor;
import org.springframework.aop.support.AopUtils;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Role;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

/**
 * Verificador fail-fast para garantir que não exista TransactionManager JDBC
 * (DataSourceTransactionManager/JdbcTransactionManager) ativo de forma acidental.
 *
 * <p>Motivo:</p>
 * <ul>
 *   <li>Se algum fluxo abrir transação com TM JDBC e depois tentar usar JPA,
 *       ocorre: "Pre-bound JDBC Connection found! ... running within DataSourceTransactionManager".</li>
 * </ul>
 *
 * <p>Regra do projeto:</p>
 * <ul>
 *   <li>PUBLIC e TENANT usam JpaTransactionManager.</li>
 *   <li>TM JDBC é proibido neste projeto.</li>
 * </ul>
 */
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@Configuration
@RequiredArgsConstructor
public class TransactionManagersVerifier implements SmartInitializingSingleton {

    private final ApplicationContext applicationContext;

    @Override
    public void afterSingletonsInstantiated() {
        Map<String, PlatformTransactionManager> tms =
                applicationContext.getBeansOfType(PlatformTransactionManager.class);

        Set<String> jdbcManagers = new LinkedHashSet<>();

        for (var e : tms.entrySet()) {
            String name = e.getKey();
            PlatformTransactionManager bean = e.getValue();

            Class<?> targetClass = AopUtils.getTargetClass(bean);
            if (targetClass == null) targetClass = bean.getClass();

            // 1) DataSourceTransactionManager (e subclasses)
            boolean isDsTm = DataSourceTransactionManager.class.isAssignableFrom(targetClass);

            // 2) JdbcTransactionManager (Spring), sem dependência direta (por reflexão)
            boolean isJdbcTm = isClassOrSuperclassNamed(targetClass, "org.springframework.jdbc.support.JdbcTransactionManager");

            if (isDsTm || isJdbcTm) {
                jdbcManagers.add(name + " -> " + targetClass.getName());
            }
        }

        if (!jdbcManagers.isEmpty()) {
            StringBuilder sb = new StringBuilder();
            sb.append("\n\n🚫 Proibido: TransactionManager JDBC encontrado no contexto Spring.\n");
            sb.append("Isso pode causar: 'Pre-bound JDBC Connection found!...'\n\n");
            sb.append("TransactionManagers JDBC detectados:\n");
            for (String s : jdbcManagers) sb.append(" - ").append(s).append("\n");
            sb.append("\nCorreção típica:\n");
            sb.append(" - Garanta que o bean padrão 'transactionManager' aponte para JpaTransactionManager (PUBLIC).\n");
            sb.append(" - Remova qualquer @Bean DataSourceTransactionManager / JdbcTransactionManager.\n");
            sb.append(" - Verifique auto-config do Spring Boot criando TM JDBC por acidente.\n\n");
            throw new IllegalStateException(sb.toString());
        }
    }

    private static boolean isClassOrSuperclassNamed(Class<?> type, String fqcn) {
        Class<?> current = type;
        while (current != null && current != Object.class) {
            if (fqcn.equals(current.getName())) return true;
            current = current.getSuperclass();
        }
        return false;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/transaction/PublicTransactionTemplateProvider.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.transaction;

import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.Role;
import org.springframework.stereotype.Component;

import brito.com.multitenancy001.infrastructure.persistence.TxExecutor;

/**
 * Provider de execução transacional no PUBLIC schema (Control Plane).
 *
 * <p><b>Por que existe?</b></p>
 * <ul>
 *   <li>Alguns pontos do projeto preferem um provider pequeno e sem “templates por contexto”.</li>
 *   <li>Mas a regra arquitetural do projeto é: a fonte de verdade transacional é o {@link TxExecutor}.</li>
 * </ul>
 *
 * <p><b>Decisão importante:</b> este provider <b>não cria</b> {@code new TransactionTemplate(...)} por chamada.
 * Ele delega para o {@link TxExecutor}, que já possui:
 * <ul>
 *   <li>Templates pré-configurados (REQUIRED/REQUIRES_NEW + readOnly)</li>
 *   <li>Verificação de TM (JpaTransactionManager)</li>
 *   <li>Logs de diagnóstico (resources bindados, activeTx, tempo, etc.)</li>
 * </ul>
 *
 * <p>Isso evita divergência de comportamento e reduz chance de “wiring acidental” por auto-config.</p>
 */
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
@Component
public class PublicTransactionTemplateProvider {

    private static final Logger log = LoggerFactory.getLogger(PublicTransactionTemplateProvider.class);

    private final TxExecutor txExecutor;

    public PublicTransactionTemplateProvider(TxExecutor txExecutor) {
        this.txExecutor = txExecutor;
        log.info("✅ PublicTransactionTemplateProvider inicializado (delegando para TxExecutor)");
    }

    // ----------------------------
    // REQUIRED
    // ----------------------------

    public void inPublicTx(Runnable fn) {
        if (fn == null) throw new IllegalArgumentException("fn é obrigatório");
        txExecutor.inPublicTx(fn);
    }

    public <T> T inPublicTx(Supplier<T> fn) {
        if (fn == null) throw new IllegalArgumentException("fn é obrigatório");
        return txExecutor.inPublicTx(fn);
    }

    public void inPublicReadOnlyTx(Runnable fn) {
        if (fn == null) throw new IllegalArgumentException("fn é obrigatório");
        txExecutor.inPublicReadOnlyTx(fn);
    }

    public <T> T inPublicReadOnlyTx(Supplier<T> fn) {
        if (fn == null) throw new IllegalArgumentException("fn é obrigatório");
        return txExecutor.inPublicReadOnlyTx(fn);
    }

    // ----------------------------
    // REQUIRES_NEW
    // ----------------------------

    public void inPublicRequiresNew(Runnable fn) {
        if (fn == null) throw new IllegalArgumentException("fn é obrigatório");
        txExecutor.inPublicRequiresNew(fn);
    }

    public <T> T inPublicRequiresNew(Supplier<T> fn) {
        if (fn == null) throw new IllegalArgumentException("fn é obrigatório");
        return txExecutor.inPublicRequiresNew(fn);
    }

    public void inPublicRequiresNewReadOnly(Runnable fn) {
        if (fn == null) throw new IllegalArgumentException("fn é obrigatório");
        txExecutor.inPublicRequiresNewReadOnly(fn);
    }

    public <T> T inPublicRequiresNewReadOnly(Supplier<T> fn) {
        if (fn == null) throw new IllegalArgumentException("fn é obrigatório");
        return txExecutor.inPublicRequiresNewReadOnly(fn);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/tx/PublicReadOnlyTx.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.tx;

import org.springframework.core.annotation.AliasFor;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.lang.annotation.*;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Transactional(transactionManager = "publicTransactionManager", readOnly = true)
public @interface PublicReadOnlyTx {

    @AliasFor(annotation = Transactional.class, attribute = "propagation")
    Propagation propagation() default Propagation.REQUIRED;
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/tx/PublicTx.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.tx;

import org.springframework.core.annotation.AliasFor;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.lang.annotation.*;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Transactional(transactionManager = "publicTransactionManager")
public @interface PublicTx {

    @AliasFor(annotation = Transactional.class, attribute = "propagation")
    Propagation propagation() default Propagation.REQUIRED;

    @AliasFor(annotation = Transactional.class, attribute = "readOnly")
    boolean readOnly() default false;
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/tx/TenantReadOnlyTx.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.tx;

import org.springframework.core.annotation.AliasFor;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.lang.annotation.*;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Transactional(transactionManager = "tenantTransactionManager", readOnly = true)
public @interface TenantReadOnlyTx {

    @AliasFor(annotation = Transactional.class, attribute = "propagation")
    Propagation propagation() default Propagation.REQUIRED;
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/persistence/tx/TenantTx.java
============================================================
package brito.com.multitenancy001.infrastructure.persistence.tx;

import org.springframework.core.annotation.AliasFor;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.lang.annotation.*;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Transactional(transactionManager = "tenantTransactionManager")
public @interface TenantTx {

    @AliasFor(annotation = Transactional.class, attribute = "propagation")
    Propagation propagation() default Propagation.REQUIRED;

    @AliasFor(annotation = Transactional.class, attribute = "readOnly")
    boolean readOnly() default false;
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEvent.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthDomainConverter;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.net.InetAddress;
import java.time.Instant;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(name = "auth_events")
public class AuthEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "occurred_at", nullable = false, columnDefinition = "timestamptz")
    private Instant occurredAt;

    @Column(name = "request_id")
    private UUID requestId;

    @Column(name = "method")
    private String method;

    @Column(name = "uri")
    private String uri;

    @JdbcTypeCode(SqlTypes.INET)
    @Column(name = "ip", columnDefinition = "inet")
    private InetAddress ip;

    @Column(name = "user_agent")
    private String userAgent;

    @Convert(converter = AuthDomainConverter.class)
    @Column(name = "auth_domain", length = 30)
    private AuthDomain authDomain;

    @Enumerated(EnumType.STRING)
    @Column(name = "event_type", nullable = false, length = 50)
    private AuthEventType eventType;

    @Enumerated(EnumType.STRING)
    @Column(name = "outcome", nullable = false, length = 20)
    private AuditOutcome outcome;

    @Column(name = "principal_email")
    private String principalEmail;

    @Column(name = "principal_user_id")
    private Long principalUserId;

    @Column(name = "account_id")
    private Long accountId;

    @Column(name = "tenant_schema")
    private String tenantSchema;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "details", columnDefinition = "jsonb")
    private String detailsJson;
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEventAuditService.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.net.InetAddress;
import java.time.Instant;

@Service
@RequiredArgsConstructor
public class AuthEventAuditService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final AuthEventRepository authEventRepository;
    private final AppClock appClock;

    public void record(AuthDomain authDomain,
                       AuthEventType eventType,
                       AuditOutcome outcome,
                       String principalEmail,
                       Long principalUserId,
                       Long accountId,
                       String tenantSchema,
                       String detailsJson) {

        RequestMeta meta = RequestMetaContext.getOrNull();
        String resolvedTenant = StringUtils.hasText(tenantSchema) ? tenantSchema : TenantContext.getOrNull();

        publicSchemaUnitOfWork.requiresNew(() -> {
            AuthEvent ev = new AuthEvent();

            Instant occurredAt = appClock.instant();
            ev.setOccurredAt(occurredAt);

            if (meta != null) {
                ev.setRequestId(meta.requestId());
                ev.setMethod(meta.method());
                ev.setUri(meta.uri());
                ev.setIp(parseInetOrNull(meta.ip()));
                ev.setUserAgent(meta.userAgent());
            }

            ev.setAuthDomain(authDomain);
            ev.setEventType(eventType);
            ev.setOutcome(outcome);

            ev.setPrincipalEmail(principalEmail);
            ev.setPrincipalUserId(principalUserId);

            ev.setAccountId(accountId);
            ev.setTenantSchema(resolvedTenant);

            ev.setDetailsJson(detailsJson);

            authEventRepository.save(ev);
        });
    }

    private static InetAddress parseInetOrNull(String rawIp) {
        if (!StringUtils.hasText(rawIp)) return null;
        try {
            return InetAddress.getByName(rawIp);
        } catch (Exception ex) {
            return null;
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/AuthEventRepository.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import org.springframework.data.jpa.repository.JpaRepository;

public interface AuthEventRepository extends JpaRepository<AuthEvent, Long> {
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/PublicAuditDispatcher.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.support.TransactionSynchronization;
import org.springframework.transaction.support.TransactionSynchronizationManager;

import brito.com.multitenancy001.infrastructure.persistence.TxExecutor;

/**
 * Dispatcher de auditoria PUBLIC que evita nesting ilegal de transações
 * (TENANT JPA -> PUBLIC JDBC/JPA) no mesmo thread.
 *
 * <p>Problema que resolve:</p>
 * <ul>
 *   <li>Erro: "Pre-bound JDBC Connection found! JpaTransactionManager does not support running within DataSourceTransactionManager..."</li>
 * </ul>
 *
 * <p>Estratégia:</p>
 * <ul>
 *   <li>Se NÃO há transação ativa no thread: grava imediatamente em PUBLIC (REQUIRES_NEW).</li>
 *   <li>Se HÁ transação ativa (ex: TENANT): agenda a gravação para <b>afterCompletion</b>
 *       (commit ou rollback), quando os resources já foram liberados.</li>
 * </ul>
 *
 * <p>Observação:</p>
 * <ul>
 *   <li>afterCompletion é usado para registrar auditoria tanto de sucesso quanto de falha.</li>
 *   <li>Falhas ao gravar audit não devem derrubar a request de negócio (best-effort), mas são logadas.</li>
 * </ul>
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class PublicAuditDispatcher {

    private final TxExecutor txExecutor;

    /**
     * Executa uma ação de auditoria no schema PUBLIC de forma segura, evitando nesting de transaction managers.
     *
     * @param action ação que grava audit (ex: chamar SecurityAuditService.record(...))
     */
    public void dispatch(Runnable action) {
        if (action == null) throw new IllegalArgumentException("action é obrigatório");

        if (!TransactionSynchronizationManager.isActualTransactionActive()) {
            // Sem tx ativa: grava agora
            runInPublicRequiresNew(action);
            return;
        }

        // Há tx ativa (ex: tenant): agenda para depois do commit/rollback
        TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {
            @Override
            public void afterCompletion(int status) {
                try {
                    runInPublicRequiresNew(action);
                } catch (Exception e) {
                    log.warn("⚠️ Falha ao gravar auditoria PUBLIC em afterCompletion: {}", e.getMessage(), e);
                }
            }
        });
    }

    private void runInPublicRequiresNew(Runnable action) {
        txExecutor.inPublicRequiresNew(() -> {
            action.run();
            return null;
        });
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditEvent.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.net.InetAddress;
import java.time.Instant;
import java.util.UUID;

@Getter
@Setter
@Entity
@Table(name = "security_audit_events")
public class SecurityAuditEvent {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ✅ Padronizado: Instant -> timestamptz
    @Column(name = "occurred_at", nullable = false, columnDefinition = "timestamptz")
    private Instant occurredAt;

    @Column(name = "request_id")
    private UUID requestId;

    @Column(name = "method")
    private String method;

    @Column(name = "uri")
    private String uri;

    @JdbcTypeCode(SqlTypes.INET)
    @Column(name = "ip", columnDefinition = "inet")
    private InetAddress ip;

    @Column(name = "user_agent")
    private String userAgent;

    @Enumerated(EnumType.STRING)
    @Column(name = "action_type", nullable = false)
    private SecurityAuditActionType actionType;

    @Enumerated(EnumType.STRING)
    @Column(name = "outcome", nullable = false)
    private AuditOutcome outcome;

    @Column(name = "actor_email")
    private String actorEmail;

    @Column(name = "actor_user_id")
    private Long actorUserId;

    @Column(name = "target_email")
    private String targetEmail;

    @Column(name = "target_user_id")
    private Long targetUserId;

    @Column(name = "account_id")
    private Long accountId;

    @Column(name = "tenant_schema")
    private String tenantSchema;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "details", columnDefinition = "jsonb")
    private String detailsJson;
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditEventRepository.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import java.time.Instant;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;

public interface SecurityAuditEventRepository extends JpaRepository<SecurityAuditEvent, Long> {



// Adicionar métodos de consulta:

    Page<SecurityAuditEvent> findByActionType(SecurityAuditActionType actionType, Pageable pageable);

    Page<SecurityAuditEvent> findByActorUserId(Long actorUserId, Pageable pageable);

    Page<SecurityAuditEvent> findByTargetUserId(Long targetUserId, Pageable pageable);

    Page<SecurityAuditEvent> findByAccountId(Long accountId, Pageable pageable);

    Page<SecurityAuditEvent> findByOccurredAtBetween(Instant start, Instant end, Pageable pageable);

    @Query("""
        SELECT e FROM SecurityAuditEvent e
        WHERE (:actionType IS NULL OR e.actionType = :actionType)
          AND (:actorUserId IS NULL OR e.actorUserId = :actorUserId)
          AND (:targetUserId IS NULL OR e.targetUserId = :targetUserId)
          AND (:accountId IS NULL OR e.accountId = :accountId)
          AND (:outcome IS NULL OR e.outcome = :outcome)
          AND (:start IS NULL OR e.occurredAt >= :start)
          AND (:end IS NULL OR e.occurredAt <= :end)
        ORDER BY e.occurredAt DESC
        """)
    Page<SecurityAuditEvent> search(
            @Param("actionType") SecurityAuditActionType actionType,
            @Param("actorUserId") Long actorUserId,
            @Param("targetUserId") Long targetUserId,
            @Param("accountId") Long accountId,
            @Param("outcome") AuditOutcome outcome,
            @Param("start") Instant start,
            @Param("end") Instant end,
            Pageable pageable
    );
    
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditQueryService.java
============================================================
// src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditQueryService.java
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.Instant;

/**
 * Serviço de consulta para eventos de auditoria.
 * 
 * <p>Permite buscar e filtrar eventos de auditoria para
 * investigação e compliance.</p>
 */
@Service
@RequiredArgsConstructor
public class SecurityAuditQueryService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final SecurityAuditEventRepository securityAuditEventRepository;

    /**
     * Busca eventos por tipo de ação.
     */
    public Page<SecurityAuditEvent> findByActionType(SecurityAuditActionType actionType, Pageable pageable) {
        return publicSchemaUnitOfWork.readOnly(() -> 
                securityAuditEventRepository.findByActionType(actionType, pageable));
    }

    /**
     * Busca eventos por ator (usuário que executou a ação).
     */
    public Page<SecurityAuditEvent> findByActorUserId(Long actorUserId, Pageable pageable) {
        return publicSchemaUnitOfWork.readOnly(() -> 
                securityAuditEventRepository.findByActorUserId(actorUserId, pageable));
    }

    /**
     * Busca eventos por alvo (usuário afetado pela ação).
     */
    public Page<SecurityAuditEvent> findByTargetUserId(Long targetUserId, Pageable pageable) {
        return publicSchemaUnitOfWork.readOnly(() -> 
                securityAuditEventRepository.findByTargetUserId(targetUserId, pageable));
    }

    /**
     * Busca eventos por conta.
     */
    public Page<SecurityAuditEvent> findByAccountId(Long accountId, Pageable pageable) {
        return publicSchemaUnitOfWork.readOnly(() -> 
                securityAuditEventRepository.findByAccountId(accountId, pageable));
    }

    /**
     * Busca eventos em um período.
     */
    public Page<SecurityAuditEvent> findByOccurredAtBetween(Instant start, Instant end, Pageable pageable) {
        return publicSchemaUnitOfWork.readOnly(() -> 
                securityAuditEventRepository.findByOccurredAtBetween(start, end, pageable));
    }

    /**
     * Busca eventos combinando múltiplos filtros.
     */
    public Page<SecurityAuditEvent> search(
            SecurityAuditActionType actionType,
            Long actorUserId,
            Long targetUserId,
            Long accountId,
            AuditOutcome outcome,
            Instant start,
            Instant end,
            Pageable pageable
    ) {
        return publicSchemaUnitOfWork.readOnly(() -> 
                securityAuditEventRepository.search(
                        actionType, actorUserId, targetUserId, accountId, outcome, start, end, pageable));
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/SecurityAuditService.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StringUtils;

import java.net.InetAddress;
import java.time.Instant;
import java.util.Map;
import java.util.UUID;

/**
 * Serviço central de auditoria de segurança (append-only) gravado em PUBLIC schema.
 *
 * <p><b>Objetivo:</b></p>
 * <ul>
 *   <li>Registrar eventos sensíveis de segurança/billing/users com outcome: ATTEMPT/SUCCESS/DENIED/FAILURE.</li>
 *   <li>Produzir trilha SOC2-like para investigação e compliance.</li>
 * </ul>
 *
 * <p><b>Regras:</b></p>
 * <ul>
 *   <li>Deve ser chamado por AppServices/UseCases (não Controller).</li>
 *   <li>Details deve ser JSON estruturado e nunca conter segredos (tokens, senhas, hashes, etc.).</li>
 *   <li>occurredAt deve vir do AppClock (Instant -> timestamptz).</li>
 * </ul>
 *
 * <p><b>Isolamento transacional:</b>
 * Auditoria PUBLIC não deve "entrar" em TX TENANT. Por isso usamos REQUIRES_NEW e
 * {@code transactionManager = "publicTransactionManager"}.</p>
 *
 * <p><b>Diagnóstico:</b>
 * Este serviço loga quando é invocado com transação já ativa no thread (indicando nesting).</p>
 */
@Service
@RequiredArgsConstructor
public class SecurityAuditService {

    private static final Logger log = LoggerFactory.getLogger(SecurityAuditService.class);

    private final SecurityAuditEventRepository securityAuditEventRepository;
    private final AppClock appClock;
    private final JsonDetailsMapper jsonDetailsMapper;

    /**
     * Registra um evento append-only de segurança.
     *
     * <p><b>TX:</b> sempre PUBLIC e sempre REQUIRES_NEW para não misturar com TENANT.</p>
     */
    @Transactional(
            transactionManager = "publicTransactionManager",
            propagation = Propagation.REQUIRES_NEW
    )
    public void record(
            SecurityAuditActionType actionType,
            AuditOutcome outcome,
            String actorEmail,
            Long actorUserId,
            String targetEmail,
            Long targetUserId,
            Long accountId,
            String tenantSchema,
            String detailsJson
    ) {
        logIfCalledWithActiveTx("record", actionType, outcome, accountId, tenantSchema);
        doRecord(actionType, outcome, actorEmail, actorUserId, targetEmail, targetUserId, accountId, tenantSchema, detailsJson);
    }

    /**
     * Helper para passar objeto estruturado e converter em JSON.
     *
     * <p><b>TX:</b> PUBLIC + REQUIRES_NEW.</p>
     */
    @Transactional(
            transactionManager = "publicTransactionManager",
            propagation = Propagation.REQUIRES_NEW
    )
    public void recordStructured(
            SecurityAuditActionType actionType,
            AuditOutcome outcome,
            String actorEmail,
            Long actorUserId,
            String targetEmail,
            Long targetUserId,
            Long accountId,
            String tenantSchema,
            Object details
    ) {
        logIfCalledWithActiveTx("recordStructured", actionType, outcome, accountId, tenantSchema);

        String detailsJson = (details == null)
                ? null
                : jsonDetailsMapper.toJsonNode(details).toString();

        doRecord(actionType, outcome, actorEmail, actorUserId, targetEmail, targetUserId, accountId, tenantSchema, detailsJson);
    }

    /**
     * Implementação interna (SEM anotação transacional) para evitar confusão com self-invocation
     * e manter a regra: "uma fronteira transacional por método público".
     */
    private void doRecord(
            SecurityAuditActionType actionType,
            AuditOutcome outcome,
            String actorEmail,
            Long actorUserId,
            String targetEmail,
            Long targetUserId,
            Long accountId,
            String tenantSchema,
            String detailsJson
    ) {
        Instant now = appClock.instant();

        RequestMeta meta = RequestMetaContext.getOrNull();
        UUID requestId = meta != null ? meta.requestId() : null;
        InetAddress ip = meta != null ? parseInetAddressOrNull(meta.ip()) : null;
        String userAgent = meta != null ? meta.userAgent() : null;
        String method = meta != null ? meta.method() : null;
        String uri = meta != null ? meta.uri() : null;

        SecurityAuditEvent e = new SecurityAuditEvent();
        e.setOccurredAt(now);

        e.setRequestId(requestId);
        e.setMethod(trimOrNull(method));
        e.setUri(trimOrNull(uri));
        e.setIp(ip);
        e.setUserAgent(trimOrNull(userAgent));

        e.setActionType(actionType);
        e.setOutcome(outcome);

        e.setActorEmail(normalizeEmailOrNull(actorEmail));
        e.setActorUserId(actorUserId);

        e.setTargetEmail(normalizeEmailOrNull(targetEmail));
        e.setTargetUserId(targetUserId);

        e.setAccountId(accountId);
        e.setTenantSchema(trimOrNull(tenantSchema));

        e.setDetailsJson(normalizeDetailsJson(detailsJson));

        if (log.isDebugEnabled()) {
            log.debug("🧾 Audit save | actionType={} | outcome={} | accountId={} | tenantSchema={} | requestId={}",
                    actionType, outcome, accountId, tenantSchema, requestId);
        }

        securityAuditEventRepository.save(e);
    }

    private static void logIfCalledWithActiveTx(
            String method,
            SecurityAuditActionType actionType,
            AuditOutcome outcome,
            Long accountId,
            String tenantSchema
    ) {
        if (!TransactionSynchronizationManager.isActualTransactionActive()) return;

        Map<Object, Object> resources = TransactionSynchronizationManager.getResourceMap();

        log.warn("⚠️ SecurityAuditService.{} chamado com transação já ativa no thread (possível nesting TENANT->PUBLIC/JDBC) | actionType={} | outcome={} | accountId={} | tenantSchema={} | resources={}",
                method, actionType, outcome, accountId, tenantSchema, summarizeResources(resources));
    }

    private static String summarizeResources(Map<Object, Object> resources) {
        if (resources == null || resources.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        boolean first = true;
        for (var e : resources.entrySet()) {
            if (!first) sb.append(", ");
            first = false;
            Object k = e.getKey();
            Object v = e.getValue();
            sb.append(k == null ? "null" : k.getClass().getName())
              .append("->")
              .append(v == null ? "null" : v.getClass().getName());
        }
        sb.append("]");
        return sb.toString();
    }

    private static InetAddress parseInetAddressOrNull(String ip) {
        if (!StringUtils.hasText(ip)) return null;
        try {
            return InetAddress.getByName(ip.trim());
        } catch (Exception ex) {
            return null; // auditoria nunca deve falhar por IP inválido
        }
    }

    private static String trimOrNull(String s) {
        if (!StringUtils.hasText(s)) return null;
        String t = s.trim();
        return t.isEmpty() ? null : t;
    }

    private static String normalizeEmailOrNull(String email) {
        if (!StringUtils.hasText(email)) return null;
        String t = email.trim().toLowerCase();
        return t.isEmpty() ? null : t;
    }

    private static String normalizeDetailsJson(String json) {
        if (!StringUtils.hasText(json)) return null;
        String t = json.trim();
        if (t.isEmpty()) return null;

        if (!(t.startsWith("{") || t.startsWith("["))) {
            return "{\"raw\":\"" + escapeJsonString(t) + "\"}";
        }
        return t;
    }

    private static String escapeJsonString(String s) {
        return s.replace("\\", "\\\\").replace("\"", "\\\"");
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/audit/TenantAuthAuditRecorderPublicSchemaJpa.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.audit;

import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.tenant.auth.app.audit.TenantAuthAuditRecorder;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class TenantAuthAuditRecorderPublicSchemaJpa implements TenantAuthAuditRecorder {

    private final AuthEventAuditService authEventAuditService;

    @Override
    public void record(AuthDomain domain,
                       AuthEventType type,
                       AuditOutcome outcome,
                       String email,
                       Long userId,
                       Long accountId,
                       String tenantSchema,
                       String detailsJson) {

        authEventAuditService.record(domain, type, outcome, email, userId, accountId, tenantSchema, detailsJson);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionEntity.java
============================================================
// src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionEntity.java
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;

/**
 * Entidade JPA (public schema) para sessões de refresh.
 *
 * IMPORTANTE:
 * - Mantém dados mínimos para rotação/revogação
 * - Não armazena token puro (somente hash)
 * - sessionDomain é enum persistido como STRING
 */
@Entity
@Table(name = "auth_refresh_sessions")
@Getter
@Setter
public class AuthRefreshSessionEntity {

    @Id
    @Column(name = "id", nullable = false)
    private UUID id;

    @Enumerated(EnumType.STRING)
    @Column(name = "session_domain", nullable = false, length = 32)
    private AuthSessionDomain sessionDomain;

    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "tenant_schema", length = 128)
    private String tenantSchema;

    @Column(name = "refresh_token_hash", nullable = false, length = 128, unique = true)
    private String refreshTokenHash;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "last_used_at")
    private Instant lastUsedAt;

    @Column(name = "rotated_at")
    private Instant rotatedAt;

    @Column(name = "revoked_at")
    private Instant revokedAt;

    @Column(name = "created_request_id")
    private UUID createdRequestId;

    @Column(name = "last_request_id")
    private UUID lastRequestId;

    @Column(name = "created_ip", length = 64)
    private String createdIp;

    @Column(name = "last_ip", length = 64)
    private String lastIp;

    @Column(name = "created_user_agent", length = 512)
    private String createdUserAgent;

    @Column(name = "last_user_agent", length = 512)
    private String lastUserAgent;

    @Column(name = "revoked_reason_json", columnDefinition = "text")
    private String revokedReasonJson;
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionJpaRepository.java
============================================================
// src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionJpaRepository.java
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;

import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

/**
 * Repositório JPA (public schema) para sessões de refresh.
 */
public interface AuthRefreshSessionJpaRepository extends JpaRepository<AuthRefreshSessionEntity, UUID> {

    Optional<AuthRefreshSessionEntity> findByRefreshTokenHash(String refreshTokenHash);

    @Modifying
    @Query("""
        UPDATE AuthRefreshSessionEntity s
           SET s.revokedAt = :now,
               s.revokedReasonJson = :reasonJson
         WHERE s.id = :id
           AND s.revokedAt IS NULL
    """)
    int revokeIfNotRevoked(UUID id, Instant now, String reasonJson);

    @Modifying
    @Query("""
        UPDATE AuthRefreshSessionEntity s
           SET s.revokedAt = :now,
               s.revokedReasonJson = :reasonJson
         WHERE s.sessionDomain = :domain
           AND s.accountId = :accountId
           AND s.userId = :userId
           AND s.revokedAt IS NULL
    """)
    int revokeAllForUser(AuthSessionDomain domain, Long accountId, Long userId, Instant now, String reasonJson);
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionStorePublicSchemaJpa.java
============================================================
// src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/AuthRefreshSessionStorePublicSchemaJpa.java
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import brito.com.multitenancy001.shared.auth.app.boundary.AuthRefreshSessionData;
import brito.com.multitenancy001.shared.auth.app.boundary.AuthRefreshSessionStore;
import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

/**
 * Implementação JPA do boundary AuthRefreshSessionStore (public schema).
 */
@Component
@RequiredArgsConstructor
public class AuthRefreshSessionStorePublicSchemaJpa implements AuthRefreshSessionStore {

    private final AuthRefreshSessionJpaRepository repo;
    private final PublicSchemaUnitOfWork uow;

    @Override
    public void insert(AuthRefreshSessionData data) {
        /* Insere sessão no public schema. */
        uow.tx(() -> {
            AuthRefreshSessionEntity e = new AuthRefreshSessionEntity();
            e.setId(data.id());
            e.setSessionDomain(data.sessionDomain());
            e.setAccountId(data.accountId());
            e.setUserId(data.userId());
            e.setTenantSchema(data.tenantSchema());
            e.setRefreshTokenHash(data.refreshTokenHash());

            e.setCreatedAt(data.createdAt());
            e.setLastUsedAt(data.lastUsedAt());
            e.setRotatedAt(data.rotatedAt());
            e.setRevokedAt(data.revokedAt());

            e.setCreatedRequestId(data.createdRequestId());
            e.setLastRequestId(data.lastRequestId());

            e.setCreatedIp(data.createdIp());
            e.setLastIp(data.lastIp());

            e.setCreatedUserAgent(data.createdUserAgent());
            e.setLastUserAgent(data.lastUserAgent());

            e.setRevokedReasonJson(data.revokedReasonJson());

            repo.save(e);
            return null;
        });
    }

    @Override
    public Optional<AuthRefreshSessionData> findByRefreshTokenHash(String refreshTokenHash) {
        /* Busca sessão no public schema. */
        return uow.readOnly(() ->
                repo.findByRefreshTokenHash(refreshTokenHash).map(AuthRefreshSessionStorePublicSchemaJpa::toData)
        );
    }

    @Override
    public void rotate(UUID sessionId,
                       String newRefreshTokenHash,
                       Instant now,
                       UUID requestId,
                       String ip,
                       String userAgent) {
        /* Rotação do refresh hash + last_used. */
        uow.tx(() -> {
            AuthRefreshSessionEntity e = repo.findById(sessionId).orElse(null);
            if (e == null) return null;
            if (e.getRevokedAt() != null) return null;

            e.setRefreshTokenHash(newRefreshTokenHash);
            e.setRotatedAt(now);
            e.setLastUsedAt(now);

            e.setLastRequestId(requestId);
            e.setLastIp(ip);
            e.setLastUserAgent(userAgent);

            repo.save(e);
            return null;
        });
    }

    @Override
    public void revoke(UUID sessionId, Instant now, String revokedReasonJson) {
        /* Revoga sessão (idempotente). */
        uow.tx(() -> {
            repo.revokeIfNotRevoked(sessionId, now, revokedReasonJson);
            return null;
        });
    }

    @Override
    public int revokeAllForUser(AuthSessionDomain sessionDomain, Long accountId, Long userId, Instant now, String revokedReasonJson) {
        /* Revoga todas as sessões do usuário naquele domínio. */
        return uow.tx(() -> repo.revokeAllForUser(sessionDomain, accountId, userId, now, revokedReasonJson));
    }

    private static AuthRefreshSessionData toData(AuthRefreshSessionEntity e) {
        return new AuthRefreshSessionData(
                e.getId(),
                e.getSessionDomain(),
                e.getAccountId(),
                e.getUserId(),
                e.getTenantSchema(),
                e.getRefreshTokenHash(),
                e.getCreatedAt(),
                e.getLastUsedAt(),
                e.getRotatedAt(),
                e.getRevokedAt(),
                e.getCreatedRequestId(),
                e.getLastRequestId(),
                e.getCreatedIp(),
                e.getLastIp(),
                e.getCreatedUserAgent(),
                e.getLastUserAgent(),
                e.getRevokedReasonJson()
        );
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/RefreshTokenHasherSha256.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import brito.com.multitenancy001.shared.auth.app.boundary.RefreshTokenHasher;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;

/**
 * Hash canônico de refresh token (SHA-256 hex).
 */
@Component
public class RefreshTokenHasherSha256 implements RefreshTokenHasher {

    @Override
    public String hash(String refreshToken) {
        // Comentário: gera SHA-256 hex estável
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] digest = md.digest(refreshToken.getBytes(StandardCharsets.UTF_8));
            return toHex(digest);
        } catch (Exception e) {
            throw new IllegalStateException("Falha ao hashear refreshToken", e);
        }
    }

    private static String toHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 2);
        for (byte b : bytes) sb.append(String.format("%02x", b));
        return sb.toString();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallengeEntity.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

@Entity
@Table(name = "tenant_login_challenges", schema = "public")
@Getter
@Setter
public class TenantLoginChallengeEntity {

    private static final Duration DEFAULT_TTL = Duration.ofMinutes(10);

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", updatable = false, nullable = false)
    private UUID id;

    @Column(name = "email", nullable = false, columnDefinition = "citext")
    private String email;

    @Column(name = "candidate_account_ids", nullable = false, columnDefinition = "text")
    private String candidateAccountIds;

    @Column(name = "created_at", nullable = false, columnDefinition = "timestamptz")
    private Instant createdAt;

    @Column(name = "expires_at", nullable = false, columnDefinition = "timestamptz")
    private Instant expiresAt;

    @Column(name = "used_at", columnDefinition = "timestamptz")
    private Instant usedAt;

    // =========================================================
    // FACTORY (criação explícita; sem @PrePersist)
    // =========================================================
    public static TenantLoginChallengeEntity create(Instant now, String email, Set<Long> candidateAccountIds) {
        if (now == null) throw new IllegalArgumentException("now é obrigatório (use AppClock.instant())");

        String normalizedEmail = EmailNormalizer.normalizeOrNull(email);
        if (normalizedEmail == null) throw new IllegalArgumentException("email inválido");

        TenantLoginChallengeEntity c = new TenantLoginChallengeEntity();
        c.email = normalizedEmail;
        c.createdAt = now;
        c.expiresAt = now.plus(DEFAULT_TTL);
        c.setCandidateAccountIds(candidateAccountIds);
        return c;
    }

    public static TenantLoginChallengeEntity create(Instant now, Duration ttl, String email, Set<Long> candidateAccountIds) {
        if (now == null) throw new IllegalArgumentException("now é obrigatório (use AppClock.instant())");
        if (ttl == null || ttl.isNegative() || ttl.isZero()) throw new IllegalArgumentException("ttl inválido");

        String normalizedEmail = EmailNormalizer.normalizeOrNull(email);
        if (normalizedEmail == null) throw new IllegalArgumentException("email inválido");

        TenantLoginChallengeEntity c = new TenantLoginChallengeEntity();
        c.email = normalizedEmail;
        c.createdAt = now;
        c.expiresAt = now.plus(ttl);
        c.setCandidateAccountIds(candidateAccountIds);
        return c;
    }

    // =========================================================
    // DOMAIN
    // =========================================================
    public boolean isExpired(Instant now) {
        if (now == null) throw new IllegalArgumentException("now é obrigatório");
        return now.isAfter(expiresAt);
    }

    public boolean isUsed() {
        return usedAt != null;
    }

    public void markUsed(Instant now) {
        if (now == null) throw new IllegalArgumentException("now é obrigatório");
        if (this.usedAt != null) return;
        this.usedAt = now;
    }

    public Set<Long> candidateAccountIds() {
        if (candidateAccountIds == null || candidateAccountIds.isBlank()) return Set.of();

        return Arrays.stream(candidateAccountIds.split(","))
                .map(String::trim)
                .filter(s -> !s.isBlank())
                .map(Long::valueOf)
                .collect(Collectors.toCollection(LinkedHashSet::new));
    }

    public void setCandidateAccountIds(Set<Long> ids) {
        if (ids == null || ids.isEmpty()) {
            this.candidateAccountIds = "";
            return;
        }
        this.candidateAccountIds = ids.stream()
                .filter(Objects::nonNull)
                .distinct()
                .sorted()
                .map(String::valueOf)
                .collect(Collectors.joining(","));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallengeJpaRepository.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import org.springframework.data.jpa.repository.JpaRepository;

import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

public interface TenantLoginChallengeJpaRepository extends JpaRepository<TenantLoginChallengeEntity, UUID> {

    Optional<TenantLoginChallengeEntity> findByIdAndExpiresAtAfterAndUsedAtIsNull(UUID id, Instant now);
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/publicschema/auth/TenantLoginChallengeStoreJpa.java
============================================================
package brito.com.multitenancy001.infrastructure.publicschema.auth;

import brito.com.multitenancy001.tenant.auth.app.boundary.TenantLoginChallengeStore;
import brito.com.multitenancy001.tenant.auth.domain.TenantLoginChallenge;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.LinkedHashSet;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class TenantLoginChallengeStoreJpa implements TenantLoginChallengeStore {

    private final TenantLoginChallengeJpaRepository tenantLoginChallengeJpaRepository;

    @Override
    public UUID create(Instant now, String normalizedEmail, Set<Long> candidateAccountIds) {
        TenantLoginChallengeEntity e = TenantLoginChallengeEntity.create(now, normalizedEmail, candidateAccountIds);
        e = tenantLoginChallengeJpaRepository.save(e);
        return e.getId();
    }

    @Override
    public Optional<TenantLoginChallenge> findValid(UUID id, Instant now) {
        return tenantLoginChallengeJpaRepository.findByIdAndExpiresAtAfterAndUsedAtIsNull(id, now)
                .map(this::toDomain);
    }

    @Override
    public void markUsed(UUID id, Instant now) {
        tenantLoginChallengeJpaRepository.findById(id).ifPresent(e -> {
            if (e.isUsed()) return;
            e.markUsed(now);
            tenantLoginChallengeJpaRepository.save(e);
        });
    }

    private TenantLoginChallenge toDomain(TenantLoginChallengeEntity e) {
        Set<Long> ids = e.candidateAccountIds();
        if (ids == null) ids = new LinkedHashSet<>();
        return new TenantLoginChallenge(
                e.getId(),
                e.getEmail(),
                ids,
                e.getCreatedAt(),
                e.getExpiresAt(),
                e.getUsedAt()
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/AuthenticatedUserContext.java
============================================================
// src/main/java/brito/com/multitenancy001/infrastructure/security/AuthenticatedUserContext.java
package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.io.Serial;
import java.time.Instant;
import java.util.*;

/**
 * Principal autenticado do sistema (infra).
 *
 * Regras:
 * - Este é o "principal" canônico usado por JWT/filters/token provider (compat com o projeto atual).
 * - NÃO depende de TenantUser como UserDetails (domínio puro).
 * - NÃO usa Instant.now() (qualquer decisão temporal recebe "now" por parâmetro).
 * - Exponibiliza getters que o projeto já utiliza (JwtTokenProvider, SecurityUtils, MustChangePasswordFilter etc.).
 *
 * Observação:
 * - Esta classe existe para compatibilidade do stack atual.
 * - O caminho futuro é evoluir gradualmente para principals específicos (TenantUserPrincipal/ControlPlaneUserPrincipal),
 *   mas sem quebrar o resto do security stack no meio.
 */
@Getter
public final class AuthenticatedUserContext implements UserDetails {

    @Serial
    private static final long serialVersionUID = 1L;

    // ==========
    // Identity
    // ==========
    private final Long userId;
    private final String email;

    /**
     * Para tenant: accountId/tenantSchema preenchidos.
     * Para control plane: podem ser null.
     */
    private final Long accountId;
    private final String tenantSchema;

    // ==========
    // Role / Authorities
    // ==========
    private final String roleName;       // ex: TENANT_OWNER / CONTROLPLANE_ADMIN
    private final String roleAuthority;  // ex: ROLE_TENANT_OWNER / ROLE_CONTROLPLANE_ADMIN
    private final Set<GrantedAuthority> authorities;

    // ==========
    // Security flags
    // ==========
    private final boolean enabled;
    private final boolean accountNonLocked;
    private final boolean mustChangePassword;

    /**
     * Hash da senha (quando aplicável em fluxos que dependem disso).
     * Pode ser null em refresh/jwt auth dependendo do fluxo.
     */
    private final String passwordHashOrNull;

    private AuthenticatedUserContext(
            Long userId,
            String email,
            Long accountId,
            String tenantSchema,
            String roleName,
            String roleAuthority,
            Set<GrantedAuthority> authorities,
            boolean enabled,
            boolean accountNonLocked,
            boolean mustChangePassword,
            String passwordHashOrNull
    ) {
        /* Constrói o contexto autenticado. */
        this.userId = Objects.requireNonNull(userId, "userId");
        this.email = Objects.requireNonNull(email, "email");
        this.accountId = accountId;
        this.tenantSchema = tenantSchema;
        this.roleName = roleName;
        this.roleAuthority = roleAuthority;
        this.authorities = Collections.unmodifiableSet(new LinkedHashSet<>(authorities == null ? Set.of() : authorities));
        this.enabled = enabled;
        this.accountNonLocked = accountNonLocked;
        this.mustChangePassword = mustChangePassword;
        this.passwordHashOrNull = passwordHashOrNull;
    }

    // ==========
    // Factories (Tenant)
    // ==========

    /**
     * Factory usado pelos flows antigos do tenant (ex.: TenantAuthMechanicsSpringSecurity).
     *
     * @param user entidade de domínio do tenant (DDD puro)
     * @param tenantSchema schema do tenant (string)
     * @param now instante (vem do AppClock)
     * @param authorities authorities já calculadas (role + perms)
     */
    public static AuthenticatedUserContext fromTenantUser(
            TenantUser user,
            String tenantSchema,
            Instant now,
            Set<GrantedAuthority> authorities
    ) {
        /* Constrói AuthenticatedUserContext para TenantUser, sem Instant.now(). */
        Objects.requireNonNull(user, "user");
        Objects.requireNonNull(now, "now");

        String email = Objects.requireNonNullElse(user.getEmail(), "");
        Long userId = Objects.requireNonNull(user.getId(), "tenant user.id");
        Long accountId = Objects.requireNonNull(user.getAccountId(), "tenant user.accountId");

        TenantRole role = user.getRole();
        String roleName = role != null ? role.name() : null;
        String roleAuthority = role != null ? role.asAuthority() : null;

        boolean enabled = user.isEnabledDomain();
        boolean accountNonLocked = user.isAccountNonLockedAt(now);
        boolean mustChangePassword = user.isMustChangePassword();

        Set<GrantedAuthority> auth = new LinkedHashSet<>();
        if (authorities != null) auth.addAll(authorities);

        // fallback de authorities se chamador não passou
        if (auth.isEmpty()) {
            if (roleAuthority != null) auth.add(new SimpleGrantedAuthority(roleAuthority));
            for (TenantPermission p : user.getPermissions()) {
                if (p == null) continue;
                auth.add(new SimpleGrantedAuthority(p.asAuthority()));
            }
        }

        return new AuthenticatedUserContext(
                userId,
                email,
                accountId,
                tenantSchema,
                roleName,
                roleAuthority,
                auth,
                enabled,
                accountNonLocked,
                mustChangePassword,
                user.getPassword() // hash (campo real)
        );
    }

    /**
     * Overload de compat (alguns call-sites passam Collection).
     */
    public static AuthenticatedUserContext fromTenantUser(
            TenantUser user,
            String tenantSchema,
            Instant now,
            Collection<? extends GrantedAuthority> authorities
    ) {
        /* Compat overload: Collection -> Set. */
        Set<GrantedAuthority> set = new LinkedHashSet<>();
        if (authorities != null) set.addAll(authorities);
        return fromTenantUser(user, tenantSchema, now, set);
    }

    // ==========
    // Factories (Control Plane)
    // ==========
    /**
     * Factory genérico para Control Plane (sem depender de entidade específica aqui).
     * Use em refresh/jwt parsing quando você já tem claims.
     */
    public static AuthenticatedUserContext fromControlPlaneClaims(
            Long userId,
            String email,
            String roleName,
            String roleAuthority,
            Set<GrantedAuthority> authorities
    ) {
        /* Constrói contexto do Control Plane sem entidade e sem Instant.now(). */
        return new AuthenticatedUserContext(
                Objects.requireNonNull(userId, "userId"),
                Objects.requireNonNull(email, "email"),
                null,
                null,
                roleName,
                roleAuthority,
                authorities == null ? Set.of() : authorities,
                true,
                true,
                false,
                null
        );
    }

    // ==========
    // Helpers usados por filtros/services
    // ==========

    public void assertEnabledForLogin() {
        /* Fail-fast para fluxos de login/refresh quando necessário. */
        if (!enabled) {
            throw new ApiException(ApiErrorCode.USER_NOT_ENABLED, "Usuário não está habilitado");
        }
        if (!accountNonLocked) {
            // Não assumo que exista um ApiErrorCode específico; reaproveito USER_NOT_ENABLED.
            throw new ApiException(ApiErrorCode.USER_NOT_ENABLED, "Usuário está bloqueado");
        }
    }

    // ==========
    // UserDetails
    // ==========
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return passwordHashOrNull;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityConstants.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.shared.domain.audit.AuthDomain;

import java.util.Objects;

/**
 * Constantes de segurança (infra).
 * Mantém strings de domínios e rotas em um só lugar.
 */
public final class SecurityConstants {

    private SecurityConstants() {}

    public static final class AuthDomains {
        private AuthDomains() {}

        // ✅ Strings canônicas para JWT (sem "strings mágicas" espalhadas)
        public static final String TENANT = AuthDomain.TENANT.tokenValue();
        public static final String CONTROLPLANE = AuthDomain.CONTROLPLANE.tokenValue();
        public static final String REFRESH = AuthDomain.REFRESH.tokenValue();
        public static final String PASSWORD_RESET = AuthDomain.PASSWORD_RESET.tokenValue();

        // ✅ Converte enum -> string JWT
        public static String tokenValue(AuthDomain domain) {
            return domain == null ? null : domain.tokenValue();
        }

        // ✅ Converte string JWT/legado -> enum
        public static AuthDomain parseOrNull(String raw) {
            return AuthDomain.fromTokenValueOrNull(raw);
        }

        public static boolean is(String raw, AuthDomain expected) {
            return Objects.equals(parseOrNull(raw), expected);
        }
    }

    public static final class ApiPaths {
        private ApiPaths() {}

        public static final String ADMIN_PREFIX = "/api/admin/";
        public static final String CONTROLPLANE_PREFIX = "/api/controlplane/";
        public static final String TENANT_PREFIX = "/api/tenant/";

        // ✅ TENANT "me" fora do prefixo /api/tenant
        public static final String ME = "/api/me";
        public static final String ME_PREFIX = "/api/me/";
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityFailureCode.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

public enum SecurityFailureCode {
    USER_DISABLED,
    INVALID_USER
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/SecurityUtils.java
============================================================
package brito.com.multitenancy001.infrastructure.security;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.security.TenantRole;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

@Component
public class SecurityUtils {

    public Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getUserId();
        }
        throw new ApiException(ApiErrorCode.UNAUTHENTICATED, "Usuário não autenticado", 401);
    }

    public Long getCurrentAccountId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getAccountId();
        }
        throw new ApiException(ApiErrorCode.UNAUTHENTICATED, "Usuário não autenticado", 401);
    }

    public String getCurrentTenantSchema() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getTenantSchema();
        }
        throw new ApiException(ApiErrorCode.UNAUTHENTICATED, "Usuário não autenticado", 401);
    }

    public String getCurrentEmail() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getEmail();
        }
        return authentication != null ? authentication.getName() : null;
    }

    public String getCurrentRoleAuthority() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof AuthenticatedUserContext ctx) {
            return ctx.getRoleAuthority();
        }
        throw new ApiException(ApiErrorCode.UNAUTHENTICATED, "Usuário não autenticado", 401);
    }

    public boolean isAuthenticated() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null && authentication.isAuthenticated();
    }

    // ---------------------------------------------------------------------
    // Aliases de compatibilidade (para wrappers legacy em integration.*)
    // ---------------------------------------------------------------------

    public Long getAuthenticatedUserId() {
        return getCurrentUserId();
    }

    public String getAuthenticatedEmail() {
        return getCurrentEmail();
    }

    private String extractRoleName(String roleAuthority) {
        if (roleAuthority == null || roleAuthority.isBlank() || !roleAuthority.startsWith("ROLE_")) {
            throw new ApiException(ApiErrorCode.FORBIDDEN, "Role inválida no contexto", 403);
        }
        return roleAuthority.substring("ROLE_".length()).trim();
    }

    public TenantRole getCurrentTenantRole() {
        String roleName = extractRoleName(getCurrentRoleAuthority());
        try {
            return TenantRole.valueOf(roleName);
        } catch (IllegalArgumentException e) {
            throw new ApiException(ApiErrorCode.FORBIDDEN, "Role de tenant não reconhecida: " + roleName, 403);
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/authorities/AuthoritiesFactory.java
============================================================
package brito.com.multitenancy001.infrastructure.security.authorities;

import brito.com.multitenancy001.controlplane.security.ControlPlanePermission;
import brito.com.multitenancy001.controlplane.security.ControlPlaneRolePermissions;
import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.LinkedHashSet;
import java.util.Set;

public final class AuthoritiesFactory {

    private AuthoritiesFactory() {}

    public static Set<GrantedAuthority> forControlPlane(ControlPlaneUser user) {
        if (user == null) return Set.of();

        // 1) PERMISSIONS (strings)
        Set<String> mergedPerms = new LinkedHashSet<>();

        // defaults por role
        for (ControlPlanePermission p : ControlPlaneRolePermissions.permissionsFor(user.getRole())) {
            if (p == null) continue;
            mergedPerms.add(p.asAuthority());
        }

        // permissões explícitas do usuário
        if (user.getPermissions() != null) {
            for (ControlPlanePermission p : user.getPermissions()) {
                if (p == null) continue;
                mergedPerms.add(p.asAuthority());
            }
        }

        // fail-fast + normalize CP_
        mergedPerms = PermissionScopeValidator.normalizeControlPlaneStrict(mergedPerms);

        // 2) BUILD authorities (permissions + role)
        Set<GrantedAuthority> authorities = new LinkedHashSet<>();

        // role como authority (ROLE_...)
        if (user.getRole() != null) {
            authorities.add(new SimpleGrantedAuthority(user.getRole().asAuthority()));
        }

        // permissions
        for (String perm : mergedPerms) {
            if (perm == null || perm.isBlank()) continue;
            authorities.add(new SimpleGrantedAuthority(perm.trim()));
        }

        return authorities;
    }

    public static Set<GrantedAuthority> forTenant(TenantUser user) {
        if (user == null) return Set.of();

        // 1) PERMISSIONS (tipadas)
        Set<TenantPermission> mergedPerms = new LinkedHashSet<>();

        // defaults por role
        if (user.getRole() != null) {
            mergedPerms.addAll(TenantRolePermissions.permissionsFor(user.getRole()));
        }

        // permissões explícitas do usuário
        if (user.getPermissions() != null) {
            mergedPerms.addAll(user.getPermissions());
        }

        // fail-fast tipado (não deixa sair do escopo Tenant)
        mergedPerms = PermissionScopeValidator.validateTenantPermissionsStrict(mergedPerms);

        // 2) BUILD authorities (permissions + role)
        Set<GrantedAuthority> authorities = new LinkedHashSet<>();

        // role como authority (ROLE_...)
        if (user.getRole() != null) {
            authorities.add(new SimpleGrantedAuthority(user.getRole().asAuthority()));
        }

        // permissions
        for (TenantPermission p : mergedPerms) {
            if (p == null) continue;
            authorities.add(new SimpleGrantedAuthority(p.asAuthority()));
        }

        return authorities;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/config/RestAccessDeniedHandler.java
============================================================
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.shared.api.error.ApiEnumErrorResponse;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class RestAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper objectMapper;
    private final AppClock appClock;

    @Override
    public void handle(
            HttpServletRequest request,
            HttpServletResponse response,
            AccessDeniedException accessDeniedException
    ) throws IOException, ServletException {

        String message = resolveMessage(accessDeniedException);

        ApiEnumErrorResponse body = ApiEnumErrorResponse.builder()
                .timestamp(appClock.instant())
                .error(ApiErrorCode.FORBIDDEN.name())
                .message(message)     // ✅ agora devolve a mensagem real quando existir
                .details(null)
                .build();

        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");

        response.getWriter().write(objectMapper.writeValueAsString(body));
    }

    private String resolveMessage(AccessDeniedException ex) {
        if (ex == null) return "Acesso negado";
        String msg = ex.getMessage();
        if (msg == null) return "Acesso negado";
        msg = msg.trim();
        return msg.isEmpty() ? "Acesso negado" : msg;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/config/RestAuthenticationEntryPoint.java
============================================================
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.shared.api.error.ApiEnumErrorResponse;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper objectMapper;
    private final AppClock appClock;

    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException {

        ApiEnumErrorResponse body = ApiEnumErrorResponse.builder()
                .timestamp(appClock.instant())
                .error(ApiErrorCode.UNAUTHENTICATED.name())
                .message("Não autenticado ou token inválido")
                .details(null)
                .build();

        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding("UTF-8");

        response.getWriter().write(objectMapper.writeValueAsString(body));
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/config/SecurityConfig.java
============================================================
package brito.com.multitenancy001.infrastructure.security.config;

import brito.com.multitenancy001.infrastructure.security.filter.JwtAuthenticationFilter;
import brito.com.multitenancy001.infrastructure.security.filter.MustChangePasswordFilter;
import brito.com.multitenancy001.infrastructure.security.filter.RequestLoggingFilter;
import brito.com.multitenancy001.infrastructure.security.filter.RequestMetaContextFilter;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;

import java.util.List;

/**
 * Configuração de segurança (JWT stateless).
 *
 * Ordem de filtros:
 * 1) RequestMetaContextFilter (correlation id / ip / user-agent)
 * 2) JwtAuthenticationFilter (autenticação JWT)
 * 3) MustChangePasswordFilter (política 428)
 * 4) RequestLoggingFilter (log final)
 *
 * Ajuste:
 * - libera /api/tenant/auth/logout e /api/controlplane/auth/logout como public endpoints
 *   (logout é baseado em refreshToken no body, e não depende do access token).
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtTokenProvider jwtTokenProvider;

    /**
     * Mantido para CONTROLPLANE (e outros contextos que você use).
     */
    private final MultiContextUserDetailsService multiContextUserDetailsService;

    /**
     * NOVO: usado pelo JwtAuthenticationFilter para TENANT (carregar user via repository).
     */
    private final TenantUserRepository tenantUserRepository;
    private final AppClock appClock;

    private final RestAuthenticationEntryPoint restAuthenticationEntryPoint;
    private final RestAccessDeniedHandler restAccessDeniedHandler;

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter(
                jwtTokenProvider,
                multiContextUserDetailsService,
                tenantUserRepository,
                appClock,
                restAuthenticationEntryPoint,
                restAccessDeniedHandler
        );
    }

    @Bean
    public MustChangePasswordFilter mustChangePasswordFilter() {
        return new MustChangePasswordFilter();
    }

    @Bean
    public RequestMetaContextFilter requestMetaContextFilter() {
        return new RequestMetaContextFilter();
    }

    @Bean
    public RequestLoggingFilter requestLoggingFilter() {
        return new RequestLoggingFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())

            // ✅ CORS (opcional, mas recomendado) + X-Request-Id
            .cors(cors -> cors.configurationSource(request -> {
                CorsConfiguration config = new CorsConfiguration();

                config.setAllowedOriginPatterns(List.of(
                        "http://localhost:*",
                        "http://127.0.0.1:*"
                ));

                config.setAllowedMethods(List.of("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));

                config.setAllowedHeaders(List.of(
                        "Authorization",
                        "Content-Type",
                        "Accept",
                        "X-Request-Id",
                        "X-Tenant"
                ));

                config.setExposedHeaders(List.of(
                        "Authorization",
                        "X-Request-Id"
                ));

                config.setAllowCredentials(true);
                config.setMaxAge(3600L);
                return config;
            }))

            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .exceptionHandling(ex -> ex
                    .authenticationEntryPoint(restAuthenticationEntryPoint) // 401
                    .accessDeniedHandler(restAccessDeniedHandler)           // 403
            )
            .authorizeHttpRequests(authz -> authz
                .requestMatchers(
                    "/v3/api-docs/**",
                    "/swagger-ui.html",
                    "/swagger-ui/**",
                    "/actuator/health",

                    // ✅ CONTROL PLANE AUTH
                    "/api/controlplane/auth/login",
                    "/api/controlplane/auth/refresh",
                    "/api/controlplane/auth/logout",

                    // ✅ TENANT AUTH
                    "/api/tenant/auth/login",
                    "/api/tenant/auth/login/confirm",
                    "/api/tenant/auth/refresh",
                    "/api/tenant/auth/logout",

                    // ✅ TENANT: troca de senha (JWT, mas precisa passar pelo filtro 428)
                    // OBS: Security precisa deixar chegar no controller; o MustChangePasswordFilter decide 428 vs allow.
                    "/api/tenant/me/password",

                    // ✅ reset por token (público)
                    "/api/tenant/password/forgot",
                    "/api/tenant/password/reset",

                    "/api/accounts/auth/checkuser",
                    "/api/signup"
                ).permitAll()

                // rotas autenticadas
                .requestMatchers("/api/admin/me/password").authenticated()
                .requestMatchers("/api/me/**").authenticated()

                .requestMatchers("/api/admin/**").authenticated()
                .requestMatchers("/api/controlplane/**").authenticated()
                .requestMatchers("/api/tenant/**").authenticated()

                .anyRequest().denyAll()
            );

        // ✅ 1) meta primeiro
        http.addFilterBefore(requestMetaContextFilter(), UsernamePasswordAuthenticationFilter.class);

        // ✅ 2) JWT cedo
        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

        // ✅ 3) política de senha
        http.addFilterAfter(mustChangePasswordFilter(), JwtAuthenticationFilter.class);

        // ✅ 4) log final do request
        http.addFilterAfter(requestLoggingFilter(), MustChangePasswordFilter.class);

        return http.build();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/JwtAuthenticationFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.SecurityConstants;
import brito.com.multitenancy001.infrastructure.security.authorities.AuthoritiesFactory;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

/**
 * Filtro JWT.
 *
 * Regras (mantidas):
 * - Sem Bearer: passa
 * - Token inválido: 401 via entryPoint
 * - Mismatch domínio (tenant token em controlplane ou vice-versa): 403 via AccessDeniedHandler
 * - TENANT:
 *   - valida tenantSchema + accountId + X-Tenant
 *   - bind TenantContext.scope(schema)
 *   - (AJUSTE) carrega usuário via TenantUserRepository dentro do schema do tenant (sem MultiContextUserDetailsService)
 * - CONTROLPLANE: mantém MultiContextUserDetailsService
 */
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private static final String TENANT_HEADER = "X-Tenant";

    private final JwtTokenProvider jwtTokenProvider;

    /**
     * Mantido para CONTROLPLANE (e outros casos que você ainda queira).
     */
    private final MultiContextUserDetailsService multiContextUserDetailsService;

    /**
     * NOVO: para autenticar TENANT via repository (robusto em schema-per-tenant).
     */
    private final TenantUserRepository tenantUserRepository;
    private final AppClock appClock;

    private final AuthenticationEntryPoint authenticationEntryPoint; // 401
    private final AccessDeniedHandler accessDeniedHandler;           // 403

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest req,
            @NonNull HttpServletResponse res,
            @NonNull FilterChain chain
    ) throws ServletException, IOException {
        /** comentário: autentica request via Bearer JWT quando aplicável */

        final String authHeader = req.getHeader("Authorization");

        // Sem Bearer: deixa o Spring decidir (permitAll passa; protegido vira 401 via entryPoint global)
        if (!StringUtils.hasText(authHeader) || !authHeader.startsWith("Bearer ")) {
            chain.doFilter(req, res);
            return;
        }

        final String jwt = authHeader.substring(7).trim();
        if (!StringUtils.hasText(jwt)) {
            authenticationEntryPoint.commence(req, res, new BadCredentialsException("Missing JWT token"));
            return;
        }

        // Token inválido/adulterado/expirado => 401 (sem stacktrace)
        if (!jwtTokenProvider.validateToken(jwt)) {
            authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT token"));
            return;
        }

        final AuthDomain authDomain = jwtTokenProvider.getAuthDomainEnum(jwt);
        final String email = normalizeLower(jwtTokenProvider.getEmailFromToken(jwt));

        if (!StringUtils.hasText(email)) {
            authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (email)"));
            return;
        }

        // Se já tem auth no contexto, segue
        if (SecurityContextHolder.getContext().getAuthentication() != null) {
            chain.doFilter(req, res);
            return;
        }

        // authDomain ausente => token ruim => 401
        if (authDomain == null) {
            SecurityContextHolder.clearContext();
            authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (authDomain)"));
            return;
        }

        // ======================
        // Regras de domínio por rota
        // ======================
        boolean needsControlPlane = requiresControlPlane(req);
        boolean needsTenant = requiresTenant(req);

        if (needsControlPlane && authDomain == AuthDomain.TENANT) {
            // ✅ 403 DIRETO
            accessDeniedHandler.handle(req, res,
                    new org.springframework.security.access.AccessDeniedException("Tenant token cannot access control plane routes"));
            return;
        }

        if (needsTenant && authDomain == AuthDomain.CONTROLPLANE) {
            // ✅ 403 DIRETO
            accessDeniedHandler.handle(req, res,
                    new org.springframework.security.access.AccessDeniedException("Control plane token cannot access tenant routes"));
            return;
        }

        // ======================
        // TENANT
        // ======================
        if (authDomain == AuthDomain.TENANT) {

            final String tenantSchema = normalize(jwtTokenProvider.getTenantSchemaFromToken(jwt));
            if (!StringUtils.hasText(tenantSchema)) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (tenantSchema)"));
                return;
            }
            if (Schemas.CONTROL_PLANE.equalsIgnoreCase(tenantSchema)) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid tenant schema"));
                return;
            }
            if (!tenantSchema.matches("^[a-zA-Z0-9_]+$")) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid tenant schema format"));
                return;
            }

            Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
            if (accountId == null) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (accountId)"));
                return;
            }

            // ✅ mismatch do header TEM que ser 403
            final String headerTenant = normalize(req.getHeader(TENANT_HEADER));
            if (StringUtils.hasText(headerTenant) && !headerTenant.equalsIgnoreCase(tenantSchema)) {
                accessDeniedHandler.handle(req, res,
                        new org.springframework.security.access.AccessDeniedException("X-Tenant header does not match token tenant"));
                return;
            }

            // ✅ Bind tenant por TODA a request (daqui pra frente)
            try (TenantContext.Scope ignored = TenantContext.scope(tenantSchema)) {

                // ==========================================================
                // AJUSTE PRINCIPAL:
                // - não usa MultiContextUserDetailsService
                // - busca TenantUser via repository no tenant schema
                // ==========================================================
                TenantUser user = tenantUserRepository
                        .findByEmailAndAccountIdAndDeletedFalse(email, accountId)
                        .orElse(null);

                if (user == null) {
                    SecurityContextHolder.clearContext();
                    authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid authentication context"));
                    return;
                }

                if (user.isSuspendedByAccount() || user.isSuspendedByAdmin() || user.isDeleted()) {
                    SecurityContextHolder.clearContext();
                    accessDeniedHandler.handle(req, res,
                            new org.springframework.security.access.AccessDeniedException("User is inactive"));
                    return;
                }

                var authorities = AuthoritiesFactory.forTenant(user);

                AuthenticatedUserContext principal = AuthenticatedUserContext.fromTenantUser(
                        user,
                        tenantSchema,
                        appClock.instant(),
                        authorities
                );

                setAuth(req, principal, authorities);

                chain.doFilter(req, res);
                return;

            } catch (org.springframework.security.access.AccessDeniedException e) {
                SecurityContextHolder.clearContext();
                accessDeniedHandler.handle(req, res, e);
                return;
            } catch (Exception e) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid authentication context"));
                return;
            }
        }

        // ======================
        // CONTROLPLANE
        // ======================
        if (authDomain == AuthDomain.CONTROLPLANE) {

            String context = normalize(jwtTokenProvider.getContextFromToken(jwt));
            if (StringUtils.hasText(context) && !Schemas.CONTROL_PLANE.equalsIgnoreCase(context)) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (context)"));
                return;
            }

            Long accountId = jwtTokenProvider.getAccountIdFromToken(jwt);
            if (accountId == null) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid JWT claims (accountId)"));
                return;
            }

            try {
                UserDetails userDetails = multiContextUserDetailsService.loadControlPlaneUserByEmail(email, accountId);
                setAuth(req, userDetails);
                chain.doFilter(req, res);
                return;
            } catch (Exception e) {
                SecurityContextHolder.clearContext();
                authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid authentication context"));
                return;
            }
        }

        // Qualquer outro authDomain é inválido => 401 (sem stacktrace)
        SecurityContextHolder.clearContext();
        authenticationEntryPoint.commence(req, res, new BadCredentialsException("Invalid authDomain"));
    }

    /**
     * Mantido para CONTROLPLANE (UserDetails).
     */
    private void setAuth(HttpServletRequest request, UserDetails userDetails) {
        /** comentário: seta Authentication no SecurityContext usando UserDetails */
        UsernamePasswordAuthenticationToken auth =
                new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
        auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(auth);
    }

    /**
     * NOVO overload para TENANT (principal tipado + authorities).
     */
    private void setAuth(
            HttpServletRequest request,
            AuthenticatedUserContext principal,
            java.util.Collection<? extends org.springframework.security.core.GrantedAuthority> authorities
    ) {
        /** comentário: seta Authentication no SecurityContext usando principal tipado do tenant */
        UsernamePasswordAuthenticationToken auth =
                new UsernamePasswordAuthenticationToken(principal, null, authorities);
        auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        SecurityContextHolder.getContext().setAuthentication(auth);
    }

    private boolean requiresControlPlane(HttpServletRequest req) {
        /** comentário: detecta rotas do controlplane */
        String path = req.getRequestURI();
        return path.startsWith(SecurityConstants.ApiPaths.ADMIN_PREFIX)
                || path.startsWith(SecurityConstants.ApiPaths.CONTROLPLANE_PREFIX);
    }

    private boolean requiresTenant(HttpServletRequest req) {
        /** comentário: detecta rotas tenant (inclui /me) */
        String path = req.getRequestURI();
        boolean isMe = SecurityConstants.ApiPaths.ME.equals(path)
                || path.startsWith(SecurityConstants.ApiPaths.ME_PREFIX);
        return path.startsWith(SecurityConstants.ApiPaths.TENANT_PREFIX) || isMe;
    }

    private String normalize(String s) {
        if (s == null) return null;
        String t = s.trim();
        return t.isEmpty() ? null : t;
    }

    private String normalizeLower(String s) {
        String t = normalize(s);
        return (t == null) ? null : t.toLowerCase();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/MustChangePasswordFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Map;

public class MustChangePasswordFilter extends OncePerRequestFilter {

    // =========================
    // ADMIN
    // =========================
    private static final String ADMIN_CHANGE_PASSWORD_PATH = "/api/admin/me/password";
    private static final String ADMIN_ME_PATH              = "/api/admin/me";
    private static final String ADMIN_LOGIN_PATH           = "/api/admin/auth/login";
    private static final String ADMIN_REFRESH_PATH         = "/api/admin/auth/refresh";

    // =========================
    // TENANT
    // =========================
    private static final String TENANT_CHANGE_PASSWORD_PATH = "/api/tenant/me/password";
    private static final String TENANT_LOGIN_PATH           = "/api/tenant/auth/login";
    private static final String TENANT_LOGIN_CONFIRM_PATH   = "/api/tenant/auth/login/confirm";
    private static final String TENANT_REFRESH_PATH         = "/api/tenant/auth/refresh";

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        String method = request.getMethod();
        String path = request.getRequestURI();

        // ✅ libera preflight (CORS)
        if ("OPTIONS".equalsIgnoreCase(method)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera login/refresh (admin + tenant)
        if (path.startsWith(ADMIN_LOGIN_PATH)
                || path.startsWith(ADMIN_REFRESH_PATH)
                || path.startsWith(TENANT_LOGIN_PATH)
                || path.startsWith(TENANT_LOGIN_CONFIRM_PATH)
                || path.startsWith(TENANT_REFRESH_PATH)
        ) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ libera troca de senha (admin + tenant)
        if (path.startsWith(ADMIN_CHANGE_PASSWORD_PATH) || path.startsWith(TENANT_CHANGE_PASSWORD_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication == null || !(authentication.getPrincipal() instanceof AuthenticatedUserContext ctx)) {
            filterChain.doFilter(request, response);
            return;
        }

        // ✅ (mantém seu comportamento atual) libera /api/admin/me
        // (tenant /api/tenant/me continua retornando 428 enquanto mustChangePassword=true,
        //  que é exatamente o que você está vendo hoje.)
        if (path.startsWith(ADMIN_ME_PATH)) {
            filterChain.doFilter(request, response);
            return;
        }

        if (ctx.isMustChangePassword()) {
            response.setStatus(428);
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);

            Map<String, Object> body = Map.of(
                    "error",ApiErrorCode.MUST_CHANGE_PASSWORD.name(),
                    "message", "Você precisa alterar a senha antes de continuar.",
                    "status", 428,
                    "details", Map.of(
                            "userId", ctx.getUserId(),
                            "email", ctx.getEmail(),
                            "accountId", ctx.getAccountId()
                    )
            );

            response.getWriter().write(objectMapper.writeValueAsString(body));
            return;
        }

        filterChain.doFilter(request, response);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/RequestLoggingFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j
public class RequestLoggingFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws ServletException, IOException {

        long threadId = Thread.currentThread().threadId();
        String method = req.getMethod();
        String uri = req.getRequestURI();

        try {
            chain.doFilter(req, res);
        } finally {
            String tenant = TenantContext.getOrNull();
            String tenantForLog = (tenant == null ? "PUBLIC" : tenant);

            RequestMeta meta = RequestMetaContext.getOrNull();
            String requestId = (meta != null && meta.requestId() != null) ? meta.requestId().toString() : "-";
            String ip = (meta != null && meta.ip() != null) ? meta.ip() : "-";

            log.info("🌐 [REQ] {} {} | tenant={} | status={} | ip={} | requestId={} | thread={}",
                    method, uri, tenantForLog, res.getStatus(), ip, requestId, threadId);
        }
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/actuator")
                || path.startsWith("/swagger")
                || path.startsWith("/v3/api-docs")
                || path.startsWith("/favicon.ico");
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/RequestMetaContextFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.UUID;

public class RequestMetaContextFilter extends OncePerRequestFilter {

    public static final String REQUEST_ID_HEADER = "X-Request-Id";
    public static final String FORWARDED_FOR_HEADER = "X-Forwarded-For";

    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws ServletException, IOException {

        RequestMeta meta = new RequestMeta(
                resolveRequestId(req),
                req.getMethod(),
                req.getRequestURI(),
                resolveClientIp(req),
                resolveUserAgent(req)
        );

        RequestMetaContext.set(meta);

        if (meta.requestId() != null) {
            res.setHeader(REQUEST_ID_HEADER, meta.requestId().toString());
        }

        try {
            chain.doFilter(req, res);
        } finally {
            // ✅ limpeza centralizada
            try { TenantContext.clear(); } catch (Exception ignore) {}
            RequestMetaContext.clear();
        }
    }

    private UUID resolveRequestId(HttpServletRequest req) {
        String raw = req.getHeader(REQUEST_ID_HEADER);
        if (StringUtils.hasText(raw)) {
            try { return UUID.fromString(raw.trim()); } catch (Exception ignore) {}
        }
        return UUID.randomUUID();
    }

    private String resolveClientIp(HttpServletRequest req) {
        String xff = req.getHeader(FORWARDED_FOR_HEADER);
        if (StringUtils.hasText(xff)) {
            String first = xff.split(",")[0].trim();
            if (StringUtils.hasText(first)) return first;
        }
        return req.getRemoteAddr();
    }

    private String resolveUserAgent(HttpServletRequest req) {
        String ua = req.getHeader("User-Agent");
        return StringUtils.hasText(ua) ? ua.trim() : null;
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/actuator")
                || path.startsWith("/swagger")
                || path.startsWith("/v3/api-docs")
                || path.startsWith("/favicon.ico");
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/filter/TenantHeaderTenantContextFilter.java
============================================================
package brito.com.multitenancy001.infrastructure.security.filter;

import brito.com.multitenancy001.shared.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Slf4j
public class TenantHeaderTenantContextFilter extends OncePerRequestFilter {

    public static final String TENANT_HEADER = "X-Tenant";

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        final long threadId = Thread.currentThread().threadId();
        final String method = request.getMethod();
        final String uri = request.getRequestURI();

        final String rawHeader = request.getHeader(TENANT_HEADER);
        final String tenantHeader = (rawHeader == null ? null : rawHeader.trim()); // entrada crua
        final String tenantSchemaFromHeader = StringUtils.hasText(tenantHeader) ? tenantHeader : null; // pronto p/ bind (public=null)
        final String tenantForLog = (tenantSchemaFromHeader != null ? tenantSchemaFromHeader : "PUBLIC");

        // ✅ Se tem Bearer, QUEM MANDA É O TOKEN (não o header)
        final String authHeader = request.getHeader("Authorization");
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {

            log.info("🌐 [REQ] {} {} | X-Tenant(header)={} | thread={}",
                    method, uri, tenantForLog, threadId);

            filterChain.doFilter(request, response);
            return;
        }

        // ✅ Sem Bearer -> pode bindar por header (entrada crua -> tenantSchema)
        try (TenantContext.Scope ignored = TenantContext.scope(tenantSchemaFromHeader)) {
            log.info("🌐 [REQ] {} {} | X-Tenant(bound)={} | thread={}",
                    method, uri, tenantForLog, threadId);
            filterChain.doFilter(request, response);
        }
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/actuator")
                || path.startsWith("/swagger")
                || path.startsWith("/v3/api-docs")
                || path.startsWith("/favicon.ico");
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/jwt/JwtTokenProvider.java
============================================================
package brito.com.multitenancy001.infrastructure.security.jwt;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.SecurityConstants;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Provider central de JWT da aplicação.
 *
 * Regras:
 * - Usa AppClock como fonte única de tempo.
 * - NÃO assume que authentication.getPrincipal() é sempre AuthenticatedUserContext:
 *   em alguns fluxos pode vir UserDetails (ex.: org.springframework.security.core.userdetails.User).
 * - Para manter claims consistentes (userId/roleName/roleAuthority), o caller pode (e deve)
 *   passar o userId (subject_id) quando o principal não for AuthenticatedUserContext.
 */
@Component
public class JwtTokenProvider {

    public static final String CLAIM_AUTHORITIES = "authorities";
    public static final String CLAIM_AUTH_DOMAIN = "authDomain";
    public static final String CLAIM_CONTEXT = "context";
    public static final String CLAIM_ACCOUNT_ID = "accountId";
    public static final String CLAIM_USER_ID = "userId";

    public static final String CLAIM_ROLE_NAME = "roleName";
    public static final String CLAIM_ROLE_AUTHORITY = "roleAuthority";

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private long jwtExpirationInMs;

    @Value("${app.jwt.refresh.expiration}")
    private long refreshExpirationInMs;

    private final AppClock appClock;
    private SecretKey key;

    public JwtTokenProvider(AppClock appClock) {
        this.appClock = appClock;
    }

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            throw new IllegalArgumentException("JWT secret must be at least 256 bits (32 chars)");
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    private Date issuedAt() {
        return Date.from(appClock.instant());
    }

    private Date expiresAtInMs(long ttlMillis) {
        Instant exp = appClock.instant().plusMillis(ttlMillis);
        return Date.from(exp);
    }

    /**
     * Gera Access Token do Control Plane.
     *
     * IMPORTANTE:
     * - Se o principal NÃO for AuthenticatedUserContext, você DEVE passar userId (subject_id),
     *   senão o token não consegue preencher CLAIM_USER_ID com segurança.
     */
    public String generateControlPlaneToken(Authentication authentication, Long accountId, String context, Long userId) {
        /* Resolve principal de forma segura */
        ResolvedPrincipal p = resolvePrincipal(authentication, userId);

        return Jwts.builder()
                .subject(p.email())
                .claim(CLAIM_AUTHORITIES, p.authoritiesCsv())
                .claim(CLAIM_AUTH_DOMAIN, SecurityConstants.AuthDomains.CONTROLPLANE)
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, p.userId())
                .claim(CLAIM_ROLE_NAME, p.roleName())
                .claim(CLAIM_ROLE_AUTHORITY, p.roleAuthority())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /**
     * Backward-compatible (mantém assinatura antiga).
     *
     * Regras:
     * - Mantido para não quebrar callers antigos.
     * - Se o principal não for AuthenticatedUserContext, vai falhar com erro claro,
     *   porque esta assinatura não permite informar userId.
     */
    public String generateControlPlaneToken(Authentication authentication, Long accountId, String context) {
        return generateControlPlaneToken(authentication, accountId, context, null);
    }

    /**
     * Gera Access Token de Tenant.
     *
     * IMPORTANTE:
     * - Se o principal NÃO for AuthenticatedUserContext, você DEVE passar userId (subject_id),
     *   senão o token não consegue preencher CLAIM_USER_ID com segurança.
     */
    public String generateTenantToken(Authentication authentication, Long accountId, String context, Long userId) {
        /* Resolve principal de forma segura */
        ResolvedPrincipal p = resolvePrincipal(authentication, userId);

        return Jwts.builder()
                .subject(p.email())
                .claim(CLAIM_AUTHORITIES, p.authoritiesCsv())
                .claim(CLAIM_AUTH_DOMAIN, SecurityConstants.AuthDomains.TENANT)
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .claim(CLAIM_USER_ID, p.userId())
                .claim(CLAIM_ROLE_NAME, p.roleName())
                .claim(CLAIM_ROLE_AUTHORITY, p.roleAuthority())
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(jwtExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    /**
     * Backward-compatible (mantém assinatura antiga).
     */
    public String generateTenantToken(Authentication authentication, Long accountId, String context) {
        return generateTenantToken(authentication, accountId, context, null);
    }

    /**
     * Refresh token NÃO precisa de authorities; ele serve para renovar sessão.
     * Guardamos apenas: subject(email) + authDomain + context(tenantSchema) + accountId
     *
     * IMPORTANTE:
     * - Sempre incluir jti/id aleatório para garantir rotação real (token string muda)
     *   mesmo quando emitido no mesmo millisecond.
     */
    public String generateRefreshToken(String email, String context, Long accountId) {
        return Jwts.builder()
                .id(UUID.randomUUID().toString()) // ✅ garante token diferente sempre
                .subject(email)
                .claim(CLAIM_AUTH_DOMAIN, SecurityConstants.AuthDomains.REFRESH)
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(refreshExpirationInMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public String generatePasswordResetToken(String email, String context, Long accountId) {
        long oneHourMs = 3_600_000L;

        return Jwts.builder()
                .subject(email)
                .claim(CLAIM_AUTH_DOMAIN, SecurityConstants.AuthDomains.PASSWORD_RESET)
                .claim(CLAIM_CONTEXT, context)
                .claim(CLAIM_ACCOUNT_ID, accountId)
                .issuedAt(issuedAt())
                .expiration(expiresAtInMs(oneHourMs))
                .signWith(key, Jwts.SIG.HS512)
                .compact();
    }

    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    public String getEmailFromToken(String token) {
        return getAllClaimsFromToken(token).getSubject();
    }

    public String getContextFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String context = claims.get(CLAIM_CONTEXT, String.class);
        if (context == null) context = claims.get("tenantSchema", String.class);

        String authDomain = getAuthDomain(token);

        if (SecurityConstants.AuthDomains.is(authDomain, AuthDomain.TENANT)
                && Schemas.CONTROL_PLANE.equalsIgnoreCase(context)) {

            throw new JwtException("Invalid context for TENANT token: public");
        }

        return context;
    }

    public AuthDomain getAuthDomainEnum(String token) {
        return SecurityConstants.AuthDomains.parseOrNull(getAuthDomain(token));
    }

    public String getTenantSchemaFromToken(String token) {
        return getContextFromToken(token);
    }

    public Long getAccountIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ACCOUNT_ID, Long.class);
    }

    public Long getUserIdFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_USER_ID, Long.class);
    }

    public String getAuthDomain(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authDomain = claims.get(CLAIM_AUTH_DOMAIN, String.class);
        if (!StringUtils.hasText(authDomain)) {
            authDomain = claims.get("type", String.class); // compat tokens antigos
        }

        return authDomain;
    }

    public String getRoleNameFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ROLE_NAME, String.class);
    }

    public String getRoleAuthorityFromToken(String token) {
        return getAllClaimsFromToken(token).get(CLAIM_ROLE_AUTHORITY, String.class);
    }

    public List<String> getAuthoritiesFromToken(String token) {
        Claims claims = getAllClaimsFromToken(token);

        String authorities = claims.get(CLAIM_AUTHORITIES, String.class);
        if (!StringUtils.hasText(authorities)) {
            authorities = claims.get("roles", String.class); // compat tokens antigos
        }

        return splitCsv(authorities);
    }

    private List<String> splitCsv(String csv) {
        if (!StringUtils.hasText(csv)) return List.of();

        return Arrays.stream(csv.split(","))
                .map(String::trim)
                .filter(StringUtils::hasText)
                .distinct()
                .toList();
    }

    public boolean isTokenExpired(String token) {
        try {
            Claims claims = getAllClaimsFromToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(Date.from(appClock.instant()));
        } catch (Exception e) {
            return true;
        }
    }

    public boolean validateToken(String token) {
        try {
            getAllClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public boolean isControlPlaneToken(String token) {
        return SecurityConstants.AuthDomains.is(getAuthDomain(token), AuthDomain.CONTROLPLANE);
    }

    public boolean isTenantToken(String token) {
        return SecurityConstants.AuthDomains.is(getAuthDomain(token), AuthDomain.TENANT);
    }

    /**
     * Resolve o "principal" de forma segura para geração do token.
     *
     * Regras:
     * - Se for AuthenticatedUserContext: usa tudo dele (userId, roleName, roleAuthority, authorities).
     * - Se for UserDetails/qualquer outro: usa email + authorities do Authentication, e exige userId explícito.
     */
    private ResolvedPrincipal resolvePrincipal(Authentication authentication, Long explicitUserId) {

        Object principal = authentication == null ? null : authentication.getPrincipal();

        // Caso 1: seu principal custom (melhor cenário)
        if (principal instanceof AuthenticatedUserContext user) {
            String authoritiesCsv = user.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.joining(","));

            return new ResolvedPrincipal(
                    user.getEmail(),
                    authoritiesCsv,
                    user.getUserId(),
                    user.getRoleName(),
                    user.getRoleAuthority()
            );
        }

        // Caso 2: principal do Spring (org.springframework.security.core.userdetails.User etc.)
        // Aqui NÃO existe userId/roleName/roleAuthority, então o caller deve passar userId (subject_id).
        if (explicitUserId == null) {
            throw new ApiException(
                    ApiErrorCode.INTERNAL_SERVER_ERROR,
                    "Principal não é AuthenticatedUserContext; informe userId (subject_id) ao gerar o token",
                    new PrincipalDetails(principal, authentication)
            );
        }

        String email = resolveEmail(authentication, principal);

        String authoritiesCsv = (authentication == null ? List.<GrantedAuthority>of() : authentication.getAuthorities())
                .stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));

        // Tentativa best-effort de roleAuthority para manter claim preenchida:
        // pega a primeira authority que pareça ser "role".
        String roleAuthority = guessRoleAuthority(authentication);
        String roleName = null; // não dá para inferir com 100% de certeza sem seu principal custom

        return new ResolvedPrincipal(
                email,
                authoritiesCsv,
                explicitUserId,
                roleName,
                roleAuthority
        );
    }

    /**
     * Resolve o email (subject) de forma robusta.
     */
    private String resolveEmail(Authentication authentication, Object principal) {
        // 1) principal UserDetails
        if (principal instanceof UserDetails ud && StringUtils.hasText(ud.getUsername())) {
            return ud.getUsername();
        }

        // 2) authentication.getName()
        if (authentication != null && StringUtils.hasText(authentication.getName())) {
            return authentication.getName();
        }

        // 3) fallback hard
        throw new ApiException(
                ApiErrorCode.INTERNAL_SERVER_ERROR,
                "Não foi possível resolver email do principal para geração de token",
                new PrincipalDetails(principal, authentication)
        );
    }

    /**
     * Heurística para tentar manter "roleAuthority" preenchida quando o principal não é o seu contexto custom.
     */
    private String guessRoleAuthority(Authentication authentication) {
        if (authentication == null || authentication.getAuthorities() == null) return null;

        List<String> auths = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .filter(StringUtils::hasText)
                .toList();

        // Preferência 1: ROLE_*
        for (String a : auths) {
            if (a.startsWith("ROLE_")) return a;
        }

        // Preferência 2: algo com CONTROLPLANE_ ou TENANT_ (depende do seu padrão)
        for (String a : auths) {
            if (a.contains("CONTROLPLANE_") || a.contains("TENANT_")) return a;
        }

        // Fallback: primeira authority, se existir
        return auths.isEmpty() ? null : auths.get(0);
    }

    /**
     * DTO interno para evitar casts e manter claims consistentes.
     */
    private record ResolvedPrincipal(
            String email,
            String authoritiesCsv,
            Long userId,
            String roleName,
            String roleAuthority
    ) {}

    /**
     * Details estruturado para facilitar debug/observability.
     */
    private record PrincipalDetails(
            String principalType,
            String authName,
            List<String> authorities
    ) {
        private PrincipalDetails(Object principal, Authentication authentication) {
            this(
                    principal == null ? "null" : principal.getClass().getName(),
                    authentication == null ? null : authentication.getName(),
                    authentication == null ? List.of()
                            : authentication.getAuthorities().stream()
                            .map(GrantedAuthority::getAuthority)
                            .toList()
            );
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/MultiContextUserDetailsService.java
============================================================
package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.controlplane.users.domain.ControlPlaneUser;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.authorities.AuthoritiesFactory;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.NoResultException;
import jakarta.persistence.TypedQuery;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Locale;

/**
 * UserDetailsService multi-contexto (Tenant + Control Plane).
 *
 * <p>Objetivo:</p>
 * <ul>
 *   <li>Resolver o "tipo de sujeito" (Tenant vs Control Plane) via tabela <code>public.login_identities</code>.</li>
 *   <li>No caso Control Plane (LOGIN com AuthenticationManager/DaoAuthenticationProvider):
 *       retornar um <code>org.springframework.security.core.userdetails.User</code> com password hash.</li>
 *   <li>No caso JWT/refresh/filtros: disponibilizar loaders que retornam <code>AuthenticatedUserContext</code>.</li>
 * </ul>
 *
 * <p>Importante:</p>
 * <ul>
 *   <li>Control Plane login exige password hash em <code>UserDetails</code> (senão ocorre "Empty encoded password").</li>
 *   <li>Tenant login normalmente não passa por AuthenticationManager (por causa de schema-per-tenant e resolução de tenant),
 *       então <code>loadUserByUsername</code> é focado em suportar o Control Plane com segurança.</li>
 * </ul>
 */
@Service
@RequiredArgsConstructor
public class MultiContextUserDetailsService implements UserDetailsService {

    private static final String SUBJECT_TYPE_CONTROLPLANE_USER = "CONTROLPLANE_USER";
    private static final String SUBJECT_TYPE_TENANT_USER = "TENANT_USER";

    /**
     * EMF do PUBLIC (Control Plane).
     */
    private final @Qualifier("publicEntityManagerFactory") EntityManagerFactory publicEmf;

    /**
     * EMF do TENANT (schema-per-tenant).
     */
    private final @Qualifier("tenantEntityManagerFactory") EntityManagerFactory tenantEmf;

    private final AppClock appClock;

    /**
     * Método padrão do Spring Security para resolver o usuário por "username".
     * Aqui, o username é o email.
     *
     * <p>Regra crítica:</p>
     * <ul>
     *   <li>Se for CONTROLPLANE_USER: retorna <code>User</code> (com password hash) para o AuthenticationManager.</li>
     *   <li>Se for TENANT_USER: mantém fallback para carregar algo (evita quebrar chamadas antigas),
     *       mas não é o caminho ideal para login de tenant.</li>
     * </ul>
     *
     * @param username email (username) recebido pelo Spring Security.
     * @return UserDetails apropriado.
     * @throws UsernameNotFoundException se não encontrado/ inválido.
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        /** comentário: valida e normaliza o username/email para resolver subject_type e carregar o UserDetails correto */
        if (username == null || username.isBlank()) {
            throw new UsernameNotFoundException("Email é obrigatório");
        }

        String normalized = username.trim().toLowerCase(Locale.ROOT);

        try {
            String subjectType = resolveSubjectTypeByEmail(normalized);

            // ✅ caminho correto para LOGIN do Control Plane (AuthenticationManager precisa de password hash)
            if (SUBJECT_TYPE_CONTROLPLANE_USER.equals(subjectType)) {
                return loadControlPlaneUserForLoginByEmail(normalized);
            }

            // Tenant: fallback para compatibilidade (não é recomendado como caminho de login em schema-per-tenant)
            if (SUBJECT_TYPE_TENANT_USER.equals(subjectType)) {
                return loadTenantUserByEmail(normalized, null);
            }

            // fallback final: tenta tenant para não quebrar fluxos antigos
            return loadTenantUserByEmail(normalized, null);

        } catch (ApiException e) {
            throw new UsernameNotFoundException(e.getMessage(), e);
        }
    }

    /**
     * Resolve o tipo de sujeito (subject_type) a partir do email, consultando a tabela public.login_identities.
     *
     * @param normalizedEmail Email normalizado.
     * @return subject_type (ou null se não encontrado).
     */
    private String resolveSubjectTypeByEmail(String normalizedEmail) {

        /** comentário: consulta public.login_identities para descobrir se o email pertence a CONTROLPLANE_USER ou TENANT_USER */
        return withPublicEntityManager(em -> {
            try {
                String sql = """
                    SELECT li.subject_type
                    FROM public.login_identities li
                    WHERE li.email = :email
                """;

                @SuppressWarnings("unchecked")
                List<Object> results = em.createNativeQuery(sql)
                        .setParameter("email", normalizedEmail)
                        .setMaxResults(1)
                        .getResultList();

                if (results.isEmpty()) {
                    return null;
                }

                Object result = results.get(0);
                return result != null ? result.toString() : null;

            } catch (Exception ignored) {
                return null;
            }
        });
    }

    /**
     * Carrega um usuário do Tenant pelo email e accountId.
     *
     * @param email     Email.
     * @param accountId accountId opcional.
     * @return UserDetails (AuthenticatedUserContext) do tenant.
     */
    public UserDetails loadTenantUserByEmail(String email, Long accountId) {

        /** comentário: carrega TenantUser do schema tenant (depende de tenant schema já resolvido no contexto da app) */
        if (email == null || email.isBlank()) {
            throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Email é obrigatório");
        }

        Instant now = appClock.instant();
        String normalized = email.trim().toLowerCase(Locale.ROOT);

        TenantUser user = withTenantEntityManager(em -> {
            TypedQuery<TenantUser> query;

            if (accountId == null) {
                query = em.createQuery(
                        "SELECT u FROM TenantUser u WHERE LOWER(u.email) = :email AND u.deleted = false",
                        TenantUser.class
                );
            } else {
                query = em.createQuery(
                        "SELECT u FROM TenantUser u WHERE LOWER(u.email) = :email AND u.accountId = :accountId AND u.deleted = false",
                        TenantUser.class
                );
                query.setParameter("accountId", accountId);
            }

            query.setParameter("email", normalized);
            query.setMaxResults(1);

            try {
                return query.getSingleResult();
            } catch (NoResultException e) {
                throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado");
            }
        });

        String tenantSchema = null; // preenchido pelo JwtAuthenticationFilter
        var authorities = AuthoritiesFactory.forTenant(user);

        return AuthenticatedUserContext.fromTenantUser(user, tenantSchema, now, authorities);
    }

    /**
     * Carrega um usuário do Control Plane como "contexto autenticado" (AuthenticatedUserContext).
     * Use este método para JWT/refresh/filtros, não para login via AuthenticationManager.
     *
     * @param email  Email.
     * @param userId userId opcional (mantido por compat).
     * @return AuthenticatedUserContext (como UserDetails).
     */
    public UserDetails loadControlPlaneUserByEmail(String email, Long userId) {

        /** comentário: carrega ControlPlaneUser no schema public e monta AuthenticatedUserContext (sem password) */
        if (email == null || email.isBlank()) {
            throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Email é obrigatório");
        }

        String normalized = email.trim().toLowerCase(Locale.ROOT);

        ControlPlaneUser user = withPublicEntityManager(em -> {
            TypedQuery<ControlPlaneUser> query = em.createQuery(
                    "SELECT u FROM ControlPlaneUser u WHERE LOWER(u.email) = :email AND u.deleted = false",
                    ControlPlaneUser.class
            );
            query.setParameter("email", normalized);
            query.setMaxResults(1);

            try {
                return query.getSingleResult();
            } catch (NoResultException e) {
                throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado");
            }
        });

        var authorities = AuthoritiesFactory.forControlPlane(user);

        return AuthenticatedUserContext.fromControlPlaneClaims(
                user.getId(),
                user.getEmail(),
                user.getRole() != null ? user.getRole().name() : null,
                user.getRole() != null ? user.getRole().asAuthority() : null,
                authorities
        );
    }

    /**
     * Carrega um usuário do Control Plane para LOGIN (AuthenticationManager).
     * Retorna UserDetails do Spring com password hash do banco.
     *
     * @param normalizedEmail email já normalizado.
     * @return UserDetails com password hash.
     */
    public UserDetails loadControlPlaneUserForLoginByEmail(String normalizedEmail) {

        /** comentário: carrega ControlPlaneUser e devolve org.springframework.security.core.userdetails.User com password hash */
        if (normalizedEmail == null || normalizedEmail.isBlank()) {
            throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Email é obrigatório");
        }

        ControlPlaneUser user = withPublicEntityManager(em -> {
            TypedQuery<ControlPlaneUser> query = em.createQuery(
                    "SELECT u FROM ControlPlaneUser u WHERE LOWER(u.email) = :email AND u.deleted = false",
                    ControlPlaneUser.class
            );
            query.setParameter("email", normalizedEmail);
            query.setMaxResults(1);

            try {
                return query.getSingleResult();
            } catch (NoResultException e) {
                throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado");
            }
        });

        String passwordHash = user.getPassword();
        if (passwordHash == null || passwordHash.isBlank()) {
            throw new ApiException(ApiErrorCode.INVALID_USER, "Usuário sem password hash cadastrado");
        }

        var authorities = AuthoritiesFactory.forControlPlane(user);

        return User.withUsername(user.getEmail())
                .password(passwordHash)
                .authorities(authorities)
                .accountExpired(false)
                .accountLocked(false)
                .credentialsExpired(false)
                .disabled(false)
                .build();
    }

    /**
     * Executa callback com EntityManager do schema PUBLIC (Control Plane), garantindo fechamento.
     *
     * @param cb callback.
     * @return resultado.
     * @param <T> tipo.
     */
    private <T> T withPublicEntityManager(EntityManagerCallback<T> cb) {

        /** comentário: cria/fecha EntityManager do publicEmf para execução segura de queries */
        EntityManager em = publicEmf.createEntityManager();
        try {
            return cb.apply(em);
        } finally {
            try {
                em.close();
            } catch (Exception ignored) {
                // no-op
            }
        }
    }

    /**
     * Executa callback com EntityManager do TENANT, garantindo fechamento.
     *
     * @param cb callback.
     * @return resultado.
     * @param <T> tipo.
     */
    private <T> T withTenantEntityManager(EntityManagerCallback<T> cb) {

        /** comentário: cria/fecha EntityManager do tenantEmf para execução segura de queries */
        EntityManager em = tenantEmf.createEntityManager();
        try {
            return cb.apply(em);
        } finally {
            try {
                em.close();
            } catch (Exception ignored) {
                // no-op
            }
        }
    }

    /**
     * Callback funcional para operações com EntityManager.
     *
     * @param <T> tipo do retorno.
     */
    @FunctionalInterface
    private interface EntityManagerCallback<T> {
        T apply(EntityManager em);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/TenantUserPrincipal.java
============================================================
// src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/TenantUserPrincipal.java
package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.shared.security.AuthenticatedPrincipal;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.Instant;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Set;

/**
 * Principal de segurança do Tenant (infra).
 *
 * Regras:
 * - Implementa UserDetails FORA do domínio (DDD limpo).
 * - Usa AppClock como fonte única de tempo (proíbe Instant.now()).
 * - Authorities calculadas aqui (role + permissions).
 */
public final class TenantUserPrincipal implements UserDetails, AuthenticatedPrincipal {

    private static final long serialVersionUID = 1L;

    private final TenantUser user;
    private final AppClock appClock;
    private final Set<GrantedAuthority> authorities;

    public TenantUserPrincipal(TenantUser user, AppClock appClock) {
        /* Constrói o principal do tenant com authorities e clock. */
        this.user = Objects.requireNonNull(user, "user");
        this.appClock = Objects.requireNonNull(appClock, "appClock");
        this.authorities = buildAuthorities(user);
    }

    private static Set<GrantedAuthority> buildAuthorities(TenantUser user) {
        /* Constrói authorities: role + permissions explícitas tipadas. */
        Set<GrantedAuthority> out = new LinkedHashSet<>();

        TenantRole role = user.getRole();
        if (role != null) out.add(new SimpleGrantedAuthority(role.asAuthority()));

        for (TenantPermission p : user.getPermissions()) {
            if (p == null) continue;
            out.add(new SimpleGrantedAuthority(p.asAuthority()));
        }

        return out;
    }

    public TenantUser getUser() {
        return user;
    }

    public Long getAccountId() {
        return user.getAccountId();
    }

    public String getName() {
        return user.getName();
    }

    @Override
    public Long getUserId() {
        return user.getId();
    }

    @Override
    public String getEmail() {
        return user.getEmail();
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        /* Authorities do tenant: role + permissions (fail-fast). */
        return authorities;
    }

    @Override
    public String getPassword() {
        /* Campo real da entidade: password (hash). */
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        /* Username = email. */
        return user.getEmail();
    }

    @Override
    public boolean isAccountNonExpired() {
        /* Sem expiração por enquanto. */
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        /* Sem expiração por enquanto. */
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        /* Avalia lock usando AppClock (fonte única do tempo). */
        Instant now = appClock.instant();
        return user.isAccountNonLockedAt(now);
    }

    @Override
    public boolean isEnabled() {
        /* Enabled de negócio (sem lock). */
        return user.isEnabledDomain();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/TenantUserPrincipalFactory.java
============================================================
// src/main/java/brito/com/multitenancy001/infrastructure/security/userdetails/TenantUserPrincipalFactory.java
package brito.com.multitenancy001.infrastructure.security.userdetails;

import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

/**
 * Factory para construir TenantUserPrincipal.
 *
 * Regras:
 * - Centraliza criação do principal.
 * - Garante AppClock como dependência única de tempo.
 */
@Component
@RequiredArgsConstructor
public class TenantUserPrincipalFactory {

    private final AppClock appClock;

    public TenantUserPrincipal create(TenantUser user) {
        /* Cria principal do tenant com AppClock. */
        return new TenantUserPrincipal(user, appClock);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/startup/DatabaseMissingFailFastListener.java
============================================================
package brito.com.multitenancy001.infrastructure.startup;

import java.sql.SQLException;

import org.springframework.boot.context.event.ApplicationFailedEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.core.env.ConfigurableEnvironment;

public class DatabaseMissingFailFastListener implements ApplicationListener<ApplicationFailedEvent> {

    private static final String SQLSTATE_DB_DOES_NOT_EXIST = "3D000";

    @Override
    public void onApplicationEvent(ApplicationFailedEvent event) {
        Throwable root = rootCause(event.getException());

        SQLException sqlEx = findSqlException(root);
        if (sqlEx == null) return;

        if (!SQLSTATE_DB_DOES_NOT_EXIST.equals(sqlEx.getSQLState())) return;

        String dbName = extractDbName(sqlEx.getMessage());

        String url = null;
        String user = null;

        try {
            if (event.getApplicationContext() != null) {
                var env = event.getApplicationContext().getEnvironment();
                url = env.getProperty("spring.datasource.url");
                user = env.getProperty("spring.datasource.username");
            } else {
                // fallback: em alguns casos extremos o context pode não existir
                ConfigurableEnvironment env = event.getSpringApplication().run().getEnvironment();
                url = env.getProperty("spring.datasource.url");
                user = env.getProperty("spring.datasource.username");
            }
        } catch (Throwable ignored) {
            // não interfere em nada caso não consiga ler env
        }

        System.err.println();
        System.err.println("============================================================");
        System.err.println("❌ Não foi possível iniciar a aplicação");
        System.err.println();
        System.err.println("Motivo: o banco de dados do PostgreSQL"
                + (dbName != null ? " \"" + dbName + "\"" : "") + " não existe.");
        System.err.println();

        if (url != null && !url.isBlank()) {
            System.err.println("Config atual:");
            System.err.println("  - spring.datasource.url = " + url);
            if (user != null && !user.isBlank()) {
                System.err.println("  - spring.datasource.username = " + user);
            }
            System.err.println();
        }

        System.err.println("✅ Como resolver:");
        System.err.println("  1) Crie o banco:");
        System.err.println("     createdb -U postgres " + (dbName != null ? dbName : "<NOME_DO_BANCO>"));
        System.err.println("  2) Ou ajuste a URL do datasource no application-dev.properties");
        System.err.println();
        System.err.println("Encerrando a aplicação (fail-fast).");
        System.err.println("============================================================");
        System.err.println();

        System.exit(2);
    }

    private static Throwable rootCause(Throwable t) {
        Throwable cur = t;
        while (cur != null && cur.getCause() != null && cur.getCause() != cur) {
            cur = cur.getCause();
        }
        return cur != null ? cur : t;
    }

    private static SQLException findSqlException(Throwable t) {
        Throwable cur = t;
        while (cur != null) {
            if (cur instanceof SQLException se) return se;
            cur = cur.getCause();
        }
        return null;
    }

    private static String extractDbName(String msg) {
        if (msg == null) return null;
        int i = msg.indexOf('"');
        if (i < 0) return null;
        int j = msg.indexOf('"', i + 1);
        if (j < 0) return null;
        String inside = msg.substring(i + 1, j).trim();
        return inside.isBlank() ? null : inside;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantExecutor.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.db.Schemas;
import brito.com.multitenancy001.shared.kernel.error.ApiException;

import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * Executor central do contexto de Tenant.
 *
 * <p>Responsabilidade: garantir que o {@link TenantContext} esteja corretamente bindado
 * para um schema de tenant válido durante a execução de um bloco.</p>
 *
 * <p>Esse bind é o que permite que o Hibernate multi-tenant por schema escolha
 * o schema correto (ex.: via CurrentTenantIdentifierResolver / MultiTenantConnectionProvider).</p>
 */
@Component
public class TenantExecutor {

    private static final Logger log = LoggerFactory.getLogger(TenantExecutor.class);

    private final TenantSchemaProvisioningWorker tenantSchemaProvisioningWorker;

    public TenantExecutor(TenantSchemaProvisioningWorker tenantSchemaProvisioningWorker) {
        this.tenantSchemaProvisioningWorker = tenantSchemaProvisioningWorker;
    }

    // ---------------------------------------------------------------------
    // Execução: tenant pronto => sempre tenantSchema
    // ---------------------------------------------------------------------

    public <T> T runInTenantSchema(String tenantSchema, Supplier<T> fn) {
        String normalizedTenantSchema = normalizeTenantSchemaOrNull(tenantSchema);

        if (normalizedTenantSchema == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(normalizedTenantSchema)) {
            throw new ApiException(ApiErrorCode.TENANT_INVALID, "Tenant inválido", 404);
        }

        if (log.isDebugEnabled()) {
            log.debug("[TENANT] bind -> schema={}", normalizedTenantSchema);
        }

        try (TenantContext.Scope ignored = TenantContext.scope(normalizedTenantSchema)) {
            return fn.get();
        } finally {
            if (log.isDebugEnabled()) {
                log.debug("[TENANT] unbind -> back to PUBLIC");
            }
        }
    }

    public void runInTenantSchema(String tenantSchema, Runnable fn) {
        runInTenantSchema(tenantSchema, () -> {
            fn.run();
            return null;
        });
    }

    /**
     * Executa apenas se schema e tabela existirem; caso contrário retorna {@code defaultValue}.
     *
     * <p>Útil para rotinas que podem rodar antes do provisionamento completo do tenant.</p>
     */
    public <T> T runInTenantSchemaIfReady(String tenantSchema, String requiredTable, Supplier<T> fn, T defaultValue) {
        String normalizedTenantSchema = normalizeTenantSchemaOrNull(tenantSchema);

        if (normalizedTenantSchema == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(normalizedTenantSchema)) return defaultValue;
        if (!tenantSchemaProvisioningWorker.schemaExists(normalizedTenantSchema)) return defaultValue;
        if (requiredTable != null && !tenantSchemaProvisioningWorker.tableExists(normalizedTenantSchema, requiredTable)) return defaultValue;

        return runInTenantSchema(normalizedTenantSchema, fn);
    }

    public <T> T runInTenantSchemaIfReady(String tenantSchema, String requiredTable, Supplier<T> fn) {
        return runInTenantSchemaIfReady(tenantSchema, requiredTable, fn, null);
    }

    public void runInTenantSchemaIfReady(String tenantSchema, String requiredTable, Runnable fn) {
        runInTenantSchemaIfReady(tenantSchema, requiredTable, () -> {
            fn.run();
            return null;
        }, null);
    }

    /**
     * Valida que schema (e opcionalmente tabela) existe; caso contrário lança {@link ApiException}.
     */
    public void assertTenantSchemaReadyOrThrow(String tenantSchema, String requiredTable) {
        String normalizedTenantSchema = normalizeTenantSchemaOrNull(tenantSchema);

        if (normalizedTenantSchema == null || Schemas.CONTROL_PLANE.equalsIgnoreCase(normalizedTenantSchema)) {
            throw new ApiException(ApiErrorCode.TENANT_INVALID, "Tenant inválido", 404);
        }
        if (!tenantSchemaProvisioningWorker.schemaExists(normalizedTenantSchema)) {
            throw new ApiException(ApiErrorCode.TENANT_SCHEMA_NOT_FOUND, "Schema do tenant não existe", 404);
        }
        if (requiredTable != null && !tenantSchemaProvisioningWorker.tableExists(normalizedTenantSchema, requiredTable)) {
            throw new ApiException(ApiErrorCode.TENANT_TABLE_NOT_FOUND, "Tabela " + requiredTable + " não existe no tenant", 404);
        }
    }

    public <T> T runInTenantSchemaOrThrow(String tenantSchema, String requiredTable, Supplier<T> fn) {
        assertTenantSchemaReadyOrThrow(tenantSchema, requiredTable);
        return runInTenantSchema(tenantSchema, fn);
    }

    public <T> T runInTenantSchemaOrThrow(String tenantSchema, Supplier<T> fn) {
        return runInTenantSchemaOrThrow(tenantSchema, null, fn);
    }

    private static String normalizeTenantSchemaOrNull(String tenantSchema) {
        String s = (tenantSchema == null ? null : tenantSchema.trim());
        return (s == null || s.isBlank()) ? null : s;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantRequiredTables.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

/**
 * Lista central de tabelas "âncora" do schema TENANT.
 *
 * Uso típico:
 * - tenantExecutor.runInSchemaOrThrow(schema, TenantRequiredTables.TENANT_USERS, () -> ...)
 * - tenantExecutor.runInSchemaIfReady(schema, TenantRequiredTables.PRODUCTS, () -> ..., defaultValue)
 *
 * Dica:
 * - escolha UMA tabela bem “core” (ex: TENANT_USERS) como "schema ready"
 * - use outras quando o caso exigir (ex: PRODUCTS)
 */
public final class TenantRequiredTables {

    private TenantRequiredTables() {}

    /** Tabela âncora: se existir, o schema tenant foi migrado (mínimo). */
    public static final String TENANT_USERS = "tenant_users";

    /** Permissões do tenant user. */
    public static final String TENANT_USER_PERMISSIONS = "tenant_user_permissions";

    /** Catálogo */
    public static final String CATEGORIES = "categories";
    public static final String SUBCATEGORIES = "subcategories";
    public static final String SUPPLIERS = "suppliers";
    public static final String PRODUCTS = "products";

    /** Vendas */
    public static final String SALES = "sales";
    public static final String SALES_ITEMS = "sales_items";

    /** “Pronto” para uso geral do tenant (âncora padrão) */
    public static String readinessAnchor() {
        return TENANT_USERS;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningService.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;


/**
 * Serviço de provisionamento de schema de Tenant.
 *
 * Responsabilidades:
 * - Criar fisicamente o schema do tenant no banco de dados.
 * - Executar migrations Flyway específicas do tenant.
 * - Garantir idempotência e segurança contra provisionamento duplicado.
 *
 * Regras de arquitetura:
 * - Executa SEMPRE no contexto do Public Schema.
 * - NÃO expõe detalhes de Flyway, JDBC ou DDL para camadas superiores.
 * - NÃO contém regras de negócio de Account (apenas infraestrutura de tenant).
 *
 * Regras de negócio implícitas:
 * - Um tenant só é considerado operacional após a conclusão bem-sucedida
 *   do provisionamento do schema e das migrations.
 * - Falhas devem ser reportadas via eventos de provisioning (auditáveis).
 *
 * Observações:
 * - Este serviço é tipicamente acionado durante o onboarding de uma Account.
 * - Não deve ser chamado diretamente por controllers.
 */
@Component
@RequiredArgsConstructor
public class TenantSchemaProvisioningService {

    private final TenantSchemaProvisioningWorker tenantSchemaProvisioningWorker;

    /**
     * Account.tenantSchema é o identificador persistido do schema do tenant.
     * tenantSchema é o mesmo valor, usado como contexto de execução na infraestrutura.
     */
    public boolean ensureSchemaExistsAndMigrate(String tenantSchema) {
        return tenantSchemaProvisioningWorker.ensureSchemaExistsAndMigrate(tenantSchema);
    }

    public void tryDropSchema(String tenantSchema) {
        tenantSchemaProvisioningWorker.tryDropSchema(tenantSchema);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaProvisioningWorker.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.Duration;
import java.util.Objects;

import javax.sql.DataSource;

import org.springframework.jdbc.datasource.SingleConnectionDataSource;
import org.springframework.stereotype.Service;

import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.provisioning.infra.TenantFlywayMigrator;
import lombok.RequiredArgsConstructor;

/**
 * Provisionamento de schema TENANT (Postgres):
 * - cria schema se não existir
 * - roda flyway do tenant
 *
 * ✅ Zero corrida: usa pg_advisory_lock e executa Flyway NA MESMA connection
 * ✅ Clean: sem sleep, sem "depende de timing"
 *
 * Também expõe checks (schemaExists/tableExists) para o TenantExecutor.
 */
@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningWorker {

    private static final Duration DEFAULT_LOCK_TIMEOUT = Duration.ofSeconds(30);

    private final DataSource dataSource;

    // =========================================================
    // Provisioning
    // =========================================================

    /**
     * Account.tenantSchema é o identificador persistido do schema do tenant.
     * tenantSchema é o mesmo valor, usado como contexto de execução na infraestrutura.
     */
    public boolean ensureSchemaExistsAndMigrate(String tenantSchema) {
        validateTenantSchema(tenantSchema);

        try (Connection conn = dataSource.getConnection()) {

            long lockKey = advisoryKey(tenantSchema);

            if (!tryAdvisoryLock(conn, lockKey, DEFAULT_LOCK_TIMEOUT)) {
                throw new ApiException(
                        ApiErrorCode.TENANT_SCHEMA_LOCK_TIMEOUT,
                        "Não foi possível obter lock de provisionamento do schema '" + tenantSchema + "'",
                        409
                );
            }

            try {
                createSchemaIfNotExists(conn, tenantSchema);

                // Flyway do tenant usando a MESMA connection (lock continua válido)
                SingleConnectionDataSource single = new SingleConnectionDataSource(conn, true);
                try {
                    TenantFlywayMigrator.migrate(single, tenantSchema);
                } finally {
                    try {
                        single.destroy();
                    } catch (Exception ignored) {
                        // best-effort
                    }
                }

                return true;

            } finally {
                advisoryUnlock(conn, lockKey);
            }

        } catch (SQLException e) {
            throw new ApiException(
                    ApiErrorCode.TENANT_SCHEMA_PROVISIONING_FAILED,
                    "Falha ao provisionar schema '" + tenantSchema + "': " + e.getMessage(),
                    500
            );
        }
    }

    public void tryDropSchema(String tenantSchema) {
        validateTenantSchema(tenantSchema);

        try (Connection conn = dataSource.getConnection()) {

            long lockKey = advisoryKey(tenantSchema);

            if (!tryAdvisoryLock(conn, lockKey, DEFAULT_LOCK_TIMEOUT)) {
                throw new ApiException(
                        ApiErrorCode.TENANT_SCHEMA_LOCK_TIMEOUT,
                        "Não foi possível obter lock para drop do schema '" + tenantSchema + "'",
                        409
                );
            }

            try {
                dropSchemaIfExists(conn, tenantSchema);
            } finally {
                advisoryUnlock(conn, lockKey);
            }

        } catch (SQLException e) {
            throw new ApiException(
                    ApiErrorCode.TENANT_SCHEMA_DROP_FAILED,
                    "Falha ao dropar schema '" + tenantSchema + "': " + e.getMessage(),
                    500
            );
        }
    }

    // =========================================================
    // Read-only checks (usados por TenantExecutor)
    // =========================================================

    public boolean schemaExists(String tenantSchema) {
        validateTenantSchema(tenantSchema);

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement("""
                 select exists (
                     select 1
                       from information_schema.schemata
                      where schema_name = ?
                 )
             """)) {

            ps.setString(1, tenantSchema);

            try (ResultSet rs = ps.executeQuery()) {
                rs.next();
                return rs.getBoolean(1);
            }

        } catch (SQLException e) {
            throw new ApiException(
                    ApiErrorCode.TENANT_SCHEMA_EXISTS_CHECK_FAILED,
                    "Falha ao verificar schema '" + tenantSchema + "': " + e.getMessage(),
                    500
            );
        }
    }

    public boolean tableExists(String tenantSchema, String tableName) {
        validateTenantSchema(tenantSchema);

        if (tableName == null || tableName.isBlank()) {
            throw new ApiException(ApiErrorCode.TABLE_REQUIRED, "requiredTable é obrigatório", 400);
        }

        String t = tableName.trim();

        if (!t.matches("^[a-z][a-z0-9_]*$")) {
            throw new ApiException(ApiErrorCode.TABLE_INVALID, "Nome de tabela inválido: " + t, 400);
        }

        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement("""
                 select exists (
                     select 1
                       from information_schema.tables
                      where table_schema = ?
                        and table_name = ?
                 )
             """)) {

            ps.setString(1, tenantSchema);
            ps.setString(2, t);

            try (ResultSet rs = ps.executeQuery()) {
                rs.next();
                return rs.getBoolean(1);
            }

        } catch (SQLException e) {
            throw new ApiException(
                    ApiErrorCode.TENANT_TABLE_EXISTS_CHECK_FAILED,
                    "Falha ao verificar tabela '" + tenantSchema + "." + t + "': " + e.getMessage(),
                    500
            );
        }
    }

    // =========================================================
    // SQL helpers
    // =========================================================

    private void createSchemaIfNotExists(Connection conn, String tenantSchema) throws SQLException {
        String sql = "create schema if not exists " + tenantSchema;
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.execute();
        }
    }

    private void dropSchemaIfExists(Connection conn, String tenantSchema) throws SQLException {
        String sql = "drop schema if exists " + tenantSchema + " cascade";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.execute();
        }
    }

    // =========================================================
    // Advisory lock helpers (Postgres)
    // =========================================================

    private boolean tryAdvisoryLock(Connection conn, long key, Duration timeout) throws SQLException {
        Objects.requireNonNull(timeout, "timeout");

        // sem atraso: tenta uma vez
        try (PreparedStatement ps = conn.prepareStatement("select pg_try_advisory_lock(?)")) {
            ps.setLong(1, key);
            try (var rs = ps.executeQuery()) {
                rs.next();
                return rs.getBoolean(1);
            }
        }
    }

    private void advisoryUnlock(Connection conn, long key) {
        try (PreparedStatement ps = conn.prepareStatement("select pg_advisory_unlock(?)")) {
            ps.setLong(1, key);
            ps.execute();
        } catch (SQLException ignored) {
            // best-effort
        }
    }

    private long advisoryKey(String tenantSchema) {
        return fnv1a64(tenantSchema);
    }

    private long fnv1a64(String s) {
        long hash = 0xcbf29ce484222325L;
        for (int i = 0; i < s.length(); i++) {
            hash ^= s.charAt(i);
            hash *= 0x100000001b3L;
        }
        return hash;
    }

    // =========================================================
    // Validation
    // =========================================================

    private void validateTenantSchema(String tenantSchema) {
        if (tenantSchema == null || tenantSchema.isBlank()) {
            // mantém mensagem/código pra não mexer em comportamento percebido
            throw new ApiException(ApiErrorCode.SCHEMA_REQUIRED, "tenantSchema é obrigatório", 400);
        }

        String s = tenantSchema.trim();

        if (s.length() > 63) {
            throw new ApiException(ApiErrorCode.SCHEMA_INVALID, "tenantSchema excede 63 caracteres", 400);
        }

        if (!s.matches("^[a-z][a-z0-9_]*$")) {
            throw new ApiException(
                    ApiErrorCode.SCHEMA_INVALID,
                    "tenantSchema inválido. Use apenas [a-z0-9_] e comece com letra. Ex: t_minha_loja_abcdef",
                    400
            );
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaReadinessService.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;

/**
 * Helpers prontos para executar código no tenant
 * SOMENTE quando o schema + tabelas mínimas existirem.
 *
 * ✅ Evita passar string de tabela na mão (usa TenantRequiredTables)
 * ✅ Usa o TenantExecutor por baixo (sem duplicar regra)
 *
 * Padrão semântico:
 * - runInSchemaIfReady / runInSchemaOrThrow / assertSchemaReadyOrThrow
 */
@Component
@RequiredArgsConstructor
public class TenantSchemaReadinessService {

    private final TenantExecutor tenantExecutor;

    // ---------------------------------------------------------------------
    // USERS
    // ---------------------------------------------------------------------

    public <T> T runIfUsersReady(String tenantSchema, Supplier<T> supplier, T defaultValue) {
        return tenantExecutor.runInTenantSchemaIfReady(tenantSchema, TenantRequiredTables.TENANT_USERS, supplier, defaultValue);
    }

    public <T> T runIfUsersReady(String tenantSchema, Supplier<T> supplier) {
        return tenantExecutor.runInTenantSchemaIfReady(tenantSchema, TenantRequiredTables.TENANT_USERS, supplier);
    }

    public void runIfUsersReady(String tenantSchema, Runnable runnable) {
        tenantExecutor.runInTenantSchemaIfReady(tenantSchema, TenantRequiredTables.TENANT_USERS, runnable);
    }

    public void assertUsersReadyOrThrow(String tenantSchema) {
        tenantExecutor.assertTenantSchemaReadyOrThrow(tenantSchema, TenantRequiredTables.TENANT_USERS);
    }

    public <T> T runUsersOrThrow(String tenantSchema, Supplier<T> supplier) {
        return tenantExecutor.runInTenantSchemaOrThrow(tenantSchema, TenantRequiredTables.TENANT_USERS, supplier);
    }

    public void runUsersOrThrow(String tenantSchema, Runnable runnable) {
        tenantExecutor.runInTenantSchemaOrThrow(tenantSchema, TenantRequiredTables.TENANT_USERS, () -> {
        	runnable.run();
            return null;
        });
    }

    // ---------------------------------------------------------------------
    // PRODUCTS
    // ---------------------------------------------------------------------

    public <T> T runIfProductsReady(String tenantSchema, Supplier<T> fn, T defaultValue) {
        return tenantExecutor.runInTenantSchemaIfReady(tenantSchema, TenantRequiredTables.PRODUCTS, fn, defaultValue);
    }

    public <T> T runIfProductsReady(String tenantSchema, Supplier<T> fn) {
        return tenantExecutor.runInTenantSchemaIfReady(tenantSchema, TenantRequiredTables.PRODUCTS, fn);
    }

    public void runIfProductsReady(String tenantSchema, Runnable fn) {
        tenantExecutor.runInTenantSchemaIfReady(tenantSchema, TenantRequiredTables.PRODUCTS, fn);
    }

    public void assertProductsReadyOrThrow(String tenantSchema) {
        tenantExecutor.assertTenantSchemaReadyOrThrow(tenantSchema, TenantRequiredTables.PRODUCTS);
    }

    public <T> T runProductsOrThrow(String tenantSchema, Supplier<T> fn) {
        return tenantExecutor.runInTenantSchemaOrThrow(tenantSchema, TenantRequiredTables.PRODUCTS, fn);
    }

    public void runProductsOrThrow(String tenantSchema, Runnable fn) {
        tenantExecutor.runInTenantSchemaOrThrow(tenantSchema, TenantRequiredTables.PRODUCTS, () -> {
            fn.run();
            return null;
        });
    }

    // ---------------------------------------------------------------------
    // GENÉRICO (se quiser usar com outras tabelas do TenantRequiredTables)
    // ---------------------------------------------------------------------

    public <T> T runIfReady(String tenantSchema, String requiredTable, Supplier<T> fn, T defaultValue) {
        return tenantExecutor.runInTenantSchemaIfReady(tenantSchema, requiredTable, fn, defaultValue);
    }

    public <T> T runOrThrow(String tenantSchema, String requiredTable, Supplier<T> fn) {
        return tenantExecutor.runInTenantSchemaOrThrow(tenantSchema, requiredTable, fn);
    }

    public void assertReadyOrThrow(String tenantSchema, String requiredTable) {
        tenantExecutor.assertTenantSchemaReadyOrThrow(tenantSchema, requiredTable);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/TenantSchemaUnitOfWork.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant;

import java.util.Map;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.transaction.support.TransactionSynchronizationManager;

import brito.com.multitenancy001.infrastructure.persistence.TxExecutor;
import lombok.RequiredArgsConstructor;

/**
 * Unidade de trabalho explícita para operações no Tenant Schema.
 *
 * <p><b>Responsabilidades:</b></p>
 * <ul>
 *   <li>Executar um bloco garantindo que o {@code TenantContext} esteja bindado para o schema correto.</li>
 *   <li>Centralizar fronteiras transacionais TENANT (write / read-only / requires-new).</li>
 *   <li>Evitar {@code @Transactional} espalhado e reduzir chances de wiring incorreto.</li>
 * </ul>
 *
 * <p><b>Observabilidade:</b> loga quando um tenant TX é iniciado com transação já ativa no thread,
 * o que pode indicar nesting indesejado e ajudar a diagnosticar "Pre-bound JDBC Connection found!".</p>
 */
@Component
@RequiredArgsConstructor
public class TenantSchemaUnitOfWork {

    private static final Logger log = LoggerFactory.getLogger(TenantSchemaUnitOfWork.class);

    private final TenantExecutor tenantExecutor;
    private final TxExecutor transactionExecutor;

    // REQUIRED
    public <T> T tx(String tenantSchema, Supplier<T> fn) {
        warnIfActiveTx("tx(REQUIRED)", tenantSchema);
        return tenantExecutor.runInTenantSchema(tenantSchema, () -> transactionExecutor.inTenantTx(fn));
    }

    public void tx(String tenantSchema, Runnable fn) {
        warnIfActiveTx("tx(REQUIRED)", tenantSchema);
        tenantExecutor.runInTenantSchema(tenantSchema, () -> transactionExecutor.inTenantTx(fn));
    }

    // READ ONLY
    public <T> T readOnly(String tenantSchema, Supplier<T> fn) {
        warnIfActiveTx("readOnly(REQUIRED, readOnly=true)", tenantSchema);
        return tenantExecutor.runInTenantSchema(tenantSchema, () -> transactionExecutor.inTenantReadOnlyTx(fn));
    }

    public void readOnly(String tenantSchema, Runnable fn) {
        warnIfActiveTx("readOnly(REQUIRED, readOnly=true)", tenantSchema);
        tenantExecutor.runInTenantSchema(tenantSchema, () -> transactionExecutor.inTenantReadOnlyTx(fn));
    }

    // REQUIRES_NEW
    public <T> T requiresNew(String tenantSchema, Supplier<T> fn) {
        warnIfActiveTx("requiresNew(REQUIRES_NEW)", tenantSchema);
        return tenantExecutor.runInTenantSchema(tenantSchema, () -> transactionExecutor.inTenantRequiresNew(fn));
    }

    public void requiresNew(String tenantSchema, Runnable fn) {
        warnIfActiveTx("requiresNew(REQUIRES_NEW)", tenantSchema);
        tenantExecutor.runInTenantSchema(tenantSchema, () -> transactionExecutor.inTenantRequiresNew(fn));
    }

    // REQUIRES_NEW READ ONLY
    public <T> T requiresNewReadOnly(String tenantSchema, Supplier<T> fn) {
        warnIfActiveTx("requiresNewReadOnly(REQUIRES_NEW, readOnly=true)", tenantSchema);
        return tenantExecutor.runInTenantSchema(tenantSchema, () -> transactionExecutor.inTenantRequiresNewReadOnly(fn));
    }

    public void requiresNewReadOnly(String tenantSchema, Runnable fn) {
        warnIfActiveTx("requiresNewReadOnly(REQUIRES_NEW, readOnly=true)", tenantSchema);
        tenantExecutor.runInTenantSchema(tenantSchema, () -> transactionExecutor.inTenantRequiresNewReadOnly(fn));
    }

    private static void warnIfActiveTx(String op, String tenantSchema) {
        if (!TransactionSynchronizationManager.isActualTransactionActive()) return;

        Map<Object, Object> resources = TransactionSynchronizationManager.getResourceMap();
        log.warn("⚠️ TENANT UoW chamado com transação já ativa no thread | op={} | tenantSchema={} | resources={}",
                op, tenantSchema, summarizeResources(resources));
    }

    private static String summarizeResources(Map<Object, Object> resources) {
        if (resources == null || resources.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        boolean first = true;
        for (var e : resources.entrySet()) {
            if (!first) sb.append(", ");
            first = false;
            Object k = e.getKey();
            Object v = e.getValue();
            sb.append(k == null ? "null" : k.getClass().getName())
              .append("->")
              .append(v == null ? "null" : v.getClass().getName());
        }
        sb.append("]");
        return sb.toString();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/infrastructure/tenant/auth/TenantAuthMechanicsSpringSecurity.java
============================================================
package brito.com.multitenancy001.infrastructure.tenant.auth;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.authorities.AuthoritiesFactory;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountSnapshot;
import brito.com.multitenancy001.shared.security.SystemRoleName;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantAuthMechanics;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantRefreshIdentity;
import brito.com.multitenancy001.tenant.security.TenantRoleMapper;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

/**
 * Implementação do TenantAuthMechanics usando Repository + PasswordEncoder + JWT.
 *
 * Motivação (Rota 1):
 * - Em schema-per-tenant, o caminho AuthenticationManager -> UserDetailsService pode cair em um EntityManager
 *   sem mapeamento de TenantUser e falhar com UnknownEntityException (convertendo em 401 indevido).
 * - Para destravar E2E de forma robusta, validamos credenciais via repository no schema do tenant
 *   e usamos passwordEncoder.matches(raw, encoded).
 *
 * Ajustes:
 * - resolveRefreshIdentity(refreshToken) NÃO faz query (somente parse/validação JWT)
 * - refreshTenantJwt(refreshToken) faz 1 query e emite NOVO refresh token (rotação)
 */
@Component
@RequiredArgsConstructor
public class TenantAuthMechanicsSpringSecurity implements TenantAuthMechanics {

    private static final String INVALID_CREDENTIALS_MSG = "usuario ou senha invalidos";

    private final TenantExecutor tenantExecutor;
    private final TenantUserRepository tenantUserRepository;
    private final JwtTokenProvider jwtTokenProvider;
    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;

    @Override
    public boolean verifyPasswordInTenant(AccountSnapshot account, String normalizedEmail, String rawPassword) {
        /** comentário: valida senha dentro do schema do tenant */
        if (account == null || account.id() == null) return false;

        String tenantSchema = account.tenantSchema();
        if (!StringUtils.hasText(tenantSchema)) return false;

        tenantSchema = tenantSchema.trim();

        if (!StringUtils.hasText(normalizedEmail) || !StringUtils.hasText(rawPassword)) return false;

        String finalTenantSchema = tenantSchema;

        try {
            return tenantExecutor.runInTenantSchema(finalTenantSchema, () -> {

                TenantUser user = tenantUserRepository
                        .findByEmailAndAccountIdAndDeletedFalse(normalizedEmail, account.id())
                        .orElse(null);

                if (user == null) return false;

                // Opcional: não vaza motivo, só retorna false
                if (user.isSuspendedByAccount() || user.isSuspendedByAdmin() || user.isDeleted()) return false;

                String encoded = user.getPassword(); // ajuste se seu entity usar outro nome
                if (!StringUtils.hasText(encoded)) return false;

                return passwordEncoder.matches(rawPassword, encoded);
            });
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public JwtResult authenticateWithPassword(AccountSnapshot account, String normalizedEmail, String rawPassword) {
        /** comentário: autentica com senha e emite access+refresh (sem AuthenticationManager) */
        if (account == null || account.id() == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404);
        }

        String tenantSchema = account.tenantSchema();
        if (!StringUtils.hasText(tenantSchema)) {
            throw new ApiException(ApiErrorCode.ACCOUNT_NOT_READY, "Conta sem schema", 409);
        }

        tenantSchema = tenantSchema.trim();

        if (!StringUtils.hasText(normalizedEmail) || !StringUtils.hasText(rawPassword)) {
            throw new ApiException(ApiErrorCode.INVALID_LOGIN, "email e senha são obrigatórios", 400);
        }

        String finalTenantSchema = tenantSchema;

        try {
            return tenantExecutor.runInTenantSchema(finalTenantSchema, () -> {

                TenantUser user = tenantUserRepository
                        .findByEmailAndAccountIdAndDeletedFalse(normalizedEmail, account.id())
                        .orElseThrow(() -> new ApiException(ApiErrorCode.INVALID_USER, INVALID_CREDENTIALS_MSG, 401));

                ensureUserActive(user);

                String encoded = user.getPassword(); // ajuste se seu entity usar outro nome
                if (!StringUtils.hasText(encoded) || !passwordEncoder.matches(rawPassword, encoded)) {
                    throw new ApiException(ApiErrorCode.INVALID_USER, INVALID_CREDENTIALS_MSG, 401);
                }

                tenantUserRepository.updateLastLogin(user.getId(), appClock.instant());

                var authorities = AuthoritiesFactory.forTenant(user);

                AuthenticatedUserContext principal = AuthenticatedUserContext.fromTenantUser(
                        user,
                        finalTenantSchema,
                        appClock.instant(),
                        authorities
                );

                var authentication = new org.springframework.security.authentication.UsernamePasswordAuthenticationToken(
                        principal,
                        null,
                        authorities
                );

                String accessToken = jwtTokenProvider.generateTenantToken(authentication, account.id(), finalTenantSchema);

                String refreshToken = jwtTokenProvider.generateRefreshToken(
                        user.getEmail(),
                        finalTenantSchema,
                        account.id()
                );

                SystemRoleName role = TenantRoleMapper.toSystemRoleOrNull(user.getRole());

                return new JwtResult(
                        accessToken,
                        refreshToken,
                        user.getId(),
                        user.getEmail(),
                        role,
                        account.id(),
                        finalTenantSchema
                );
            });
        } catch (ApiException e) {
            throw e;
        } catch (Exception e) {
            throw new ApiException(ApiErrorCode.AUTH_ERROR, "Falha ao autenticar", 500);
        }
    }

    @Override
    public JwtResult issueJwtForAccountAndEmail(AccountSnapshot account, String normalizedEmail) {
        /** comentário: emite tokens sem senha (confirm) */
        if (account == null || account.id() == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404);
        }

        String tenantSchema = account.tenantSchema();
        if (!StringUtils.hasText(tenantSchema)) {
            throw new ApiException(ApiErrorCode.ACCOUNT_NOT_READY, "Conta sem schema", 409);
        }

        tenantSchema = tenantSchema.trim();

        if (!StringUtils.hasText(normalizedEmail)) {
            throw new ApiException(ApiErrorCode.INVALID_LOGIN, "email é obrigatório", 400);
        }

        String finalTenantSchema = tenantSchema;

        return tenantExecutor.runInTenantSchema(finalTenantSchema, () -> {

            TenantUser user = tenantUserRepository
                    .findByEmailAndAccountIdAndDeletedFalse(normalizedEmail, account.id())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.INVALID_LOGIN, "Usuário não encontrado", 401));

            ensureUserActive(user);

            tenantUserRepository.updateLastLogin(user.getId(), appClock.instant());

            var authorities = AuthoritiesFactory.forTenant(user);

            AuthenticatedUserContext principal = AuthenticatedUserContext.fromTenantUser(
                    user,
                    finalTenantSchema,
                    appClock.instant(),
                    authorities
            );

            var authentication = new org.springframework.security.authentication.UsernamePasswordAuthenticationToken(
                    principal,
                    null,
                    authorities
            );

            String accessToken = jwtTokenProvider.generateTenantToken(authentication, account.id(), finalTenantSchema);

            String refreshToken = jwtTokenProvider.generateRefreshToken(
                    user.getEmail(),
                    finalTenantSchema,
                    account.id()
            );

            SystemRoleName role = TenantRoleMapper.toSystemRoleOrNull(user.getRole());

            return new JwtResult(
                    accessToken,
                    refreshToken,
                    user.getId(),
                    user.getEmail(),
                    role,
                    account.id(),
                    finalTenantSchema
            );
        });
    }

    @Override
    public TenantRefreshIdentity resolveRefreshIdentity(String refreshToken) {
        /** comentário: valida refresh e resolve identidade mínima (sem query) */
        if (!StringUtils.hasText(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken é obrigatório", 400);
        }

        if (!jwtTokenProvider.validateToken(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401);
        }

        AuthDomain authDomain = jwtTokenProvider.getAuthDomainEnum(refreshToken);
        if (authDomain != AuthDomain.REFRESH) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401);
        }

        final String tenantSchemaRaw = jwtTokenProvider.getTenantSchemaFromToken(refreshToken);
        if (!StringUtils.hasText(tenantSchemaRaw)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401);
        }
        final String tenantSchema = tenantSchemaRaw.trim();

        final String email = jwtTokenProvider.getEmailFromToken(refreshToken);
        if (!StringUtils.hasText(email)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido (email ausente)", 401);
        }

        final Long accountId = jwtTokenProvider.getAccountIdFromToken(refreshToken);
        if (accountId == null) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido (accountId ausente)", 401);
        }

        return new TenantRefreshIdentity(email.trim(), accountId, tenantSchema);
    }

    @Override
    public JwtResult refreshTenantJwt(String refreshToken) {
        /** comentário: refresh do tenant com rotação (novo refresh token) */
        TenantRefreshIdentity id = resolveRefreshIdentity(refreshToken);

        return tenantExecutor.runInTenantSchema(id.tenantSchema(), () -> {

            TenantUser user = tenantUserRepository
                    .findByEmailAndAccountIdAndDeletedFalse(id.email(), id.accountId())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401));

            ensureUserActive(user);

            tenantUserRepository.updateLastLogin(user.getId(), appClock.instant());

            var authorities = AuthoritiesFactory.forTenant(user);

            AuthenticatedUserContext principal = AuthenticatedUserContext.fromTenantUser(
                    user,
                    id.tenantSchema(),
                    appClock.instant(),
                    authorities
            );

            var authentication = new org.springframework.security.authentication.UsernamePasswordAuthenticationToken(
                    principal,
                    null,
                    authorities
            );

            String newAccessToken = jwtTokenProvider.generateTenantToken(authentication, id.accountId(), id.tenantSchema());

            String newRefreshToken = jwtTokenProvider.generateRefreshToken(
                    user.getEmail(),
                    id.tenantSchema(),
                    id.accountId()
            );

            SystemRoleName role = TenantRoleMapper.toSystemRoleOrNull(user.getRole());

            return new JwtResult(
                    newAccessToken,
                    newRefreshToken,
                    user.getId(),
                    user.getEmail(),
                    role,
                    id.accountId(),
                    id.tenantSchema()
            );
        });
    }

    private static void ensureUserActive(TenantUser user) {
        /** comentário: bloqueia usuário suspenso/inativo/deletado */
        if (user.isSuspendedByAccount() || user.isSuspendedByAdmin() || user.isDeleted()) {
            throw new ApiException(ApiErrorCode.USER_INACTIVE, "Usuário inativo", 403);
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/audit/ControlPlaneAuthAuditIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.audit;

import brito.com.multitenancy001.infrastructure.publicschema.audit.AuthEventAuditService;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Integração ControlPlane -> Infra (auditoria de autenticação).
 *
 * Regras:
 * - controlplane.* NÃO importa infrastructure.publicschema.audit.* (aqui é integration).
 * - detailsJson SEMPRE via JsonDetailsMapper (nunca escapeJson manual).
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneAuthAuditIntegrationService {

    private final AuthEventAuditService authEventAuditService;
    private final JsonDetailsMapper jsonDetailsMapper;

    public void auditLoginSuccess(Long userId, String email) {
        /** comentário: registra sucesso de login do Control Plane */
        authEventAuditService.record(
                AuthDomain.CONTROLPLANE,
                AuthEventType.LOGIN_SUCCESS,
                AuditOutcome.SUCCESS,
                email,
                userId,
                null,
                null,
                null
        );
    }

    public void auditLoginFailure(String email, String reason) {
        /** comentário: registra falha de login do Control Plane com reason estruturado */
        String detailsJson = (reason == null) ? null : toJson(m("reason", reason));

        authEventAuditService.record(
                AuthDomain.CONTROLPLANE,
                AuthEventType.LOGIN_FAILURE,
                AuditOutcome.FAILURE,
                email,
                null,
                null,
                null,
                detailsJson
        );
    }

    private String toJson(Object details) {
        /** comentário: converte details (Map/record/String) em JSON string compatível com jsonb */
        if (details == null) return null;
        return jsonDetailsMapper.toJsonNode(details).toString();
    }

    private static Map<String, Object> m(Object... kv) {
        /** comentário: cria LinkedHashMap em pares key/value com ordem estável */
        Map<String, Object> m = new LinkedHashMap<>();
        if (kv == null) return m;
        if (kv.length % 2 != 0) throw new IllegalArgumentException("m(kv): quantidade ímpar de argumentos");
        for (int i = 0; i < kv.length; i += 2) {
            Object k = kv[i];
            Object v = kv[i + 1];
            if (k == null) continue;
            m.put(String.valueOf(k), v);
        }
        return m;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/audit/ControlPlaneAuthEventAuditIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.audit;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.publicschema.audit.AuthEventAuditService;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import lombok.RequiredArgsConstructor;

/**
 * Integração: ControlPlane -> Infrastructure (AuthEventAuditService).
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneAuthEventAuditIntegrationService {

    private final AuthEventAuditService authEventAuditService;

    /**
     * Wrapper compatível com o AuthEventAuditService atual:
     * record(AuthDomain, AuthEventType, AuditOutcome, principalEmail, principalUserId, accountId, tenantSchema, detailsJson)
     */
    public void record(
            AuthDomain domain,
            AuthEventType eventType,
            AuditOutcome outcome,
            String subjectEmail,
            String actorEmail,
            Long actorUserId,
            String tenantSchema,
            String detailsJson
    ) {
        // subjectEmail é o "principalEmail" persistido.
        // actorUserId (quando existir) é o "principalUserId".
        // accountId: este wrapper antigo não recebia; fica null por enquanto.
        authEventAuditService.record(
                domain,
                eventType,
                outcome,
                subjectEmail,
                actorUserId,
                null,
                tenantSchema,
                detailsJson
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/audit/ControlPlaneSecurityAuditIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.audit;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditService;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import lombok.RequiredArgsConstructor;

/**
 * Integração: ControlPlane -> Infrastructure (SecurityAuditService).
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneSecurityAuditIntegrationService {

    private final SecurityAuditService securityAuditService;

    public void record(
            SecurityAuditActionType actionType,
            AuditOutcome outcome,
            String actorEmail,
            Long actorUserId,
            String targetEmail,
            Long targetUserId,
            Long accountId,
            String tenantSchema,
            String detailsJson
    ) {
        securityAuditService.record(
                actionType,
                outcome,
                actorEmail,
                actorUserId,
                targetEmail,
                targetUserId,
                accountId,
                tenantSchema,
                detailsJson
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneAuthenticationIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.auth;

import brito.com.multitenancy001.infrastructure.security.AuthenticatedUserContext;
import brito.com.multitenancy001.infrastructure.security.userdetails.MultiContextUserDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

/**
 * Integração: ControlPlane -> Infrastructure.
 *
 * Objetivo:
 * - Permitir que o ControlPlane monte um Authentication "válido" (principal + authorities)
 *   sem importar classes de infrastructure diretamente.
 *
 * Uso típico:
 * - Refresh: reconstruir Authentication a partir do email/accountId do refresh token
 *   para gerar um novo access token.
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneAuthenticationIntegrationService {

    private final MultiContextUserDetailsService multiContextUserDetailsService;

    public Authentication buildControlPlaneAuthentication(String email, Long accountId) {
        /** comentário: carrega principal CP (com authorities) e cria Authentication */
        AuthenticatedUserContext principal = (AuthenticatedUserContext)
                multiContextUserDetailsService.loadControlPlaneUserByEmail(email, accountId);

        return new UsernamePasswordAuthenticationToken(
                principal,
                null,
                principal.getAuthorities()
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneJwtIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.auth;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

/**
 * Integração (Control Plane -> Infrastructure): emissão de tokens JWT.
 *
 * <p>Responsabilidade:</p>
 * <ul>
 *   <li>Isolar Control Plane dos detalhes internos do JwtTokenProvider.</li>
 *   <li>Expor métodos de emissão de access/refresh token com contratos explícitos.</li>
 * </ul>
 *
 * <p>Regra importante:</p>
 * <ul>
 *   <li>Quando o {@link Authentication#getPrincipal()} NÃO for {@code AuthenticatedUserContext},
 *       é obrigatório informar o {@code userId/subjectId} ao emitir o access token, para preencher
 *       as claims de identidade do usuário.</li>
 * </ul>
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneJwtIntegrationService {

    private final JwtTokenProvider jwtTokenProvider;

    /**
     * Gera Access Token do Control Plane (assinatura "legacy"/compatível).
     *
     * <p>ATENÇÃO:</p>
     * <ul>
     *   <li>Se o principal NÃO for {@code AuthenticatedUserContext}, este método vai falhar com erro claro,
     *       pois não há {@code subjectId} para preencher as claims.</li>
     *   <li>Para fluxos de login (principal geralmente é {@code UserDetails}), use a sobrecarga com {@code userId}.</li>
     * </ul>
     */
    public String generateControlPlaneToken(Authentication authentication, Long accountId, String schema) {
        return jwtTokenProvider.generateControlPlaneToken(authentication, accountId, schema);
    }

    /**
     * Gera Access Token do Control Plane informando explicitamente o subject_id (userId).
     *
     * <p>Use esta sobrecarga quando o {@link Authentication#getPrincipal()} não for
     * {@code AuthenticatedUserContext} (ex.: durante login, quando o Authentication
     * pode carregar um {@code UserDetails}).</p>
     *
     * @param authentication authentication já validado pelo Spring Security
     * @param accountId id da conta (claim)
     * @param schema contexto/tenant schema (claim)
     * @param userId subject_id (controlplane_user.id) para preencher CLAIM_USER_ID
     * @return JWT access token assinado
     */
    public String generateControlPlaneToken(Authentication authentication, Long accountId, String schema, Long userId) {
        return jwtTokenProvider.generateControlPlaneToken(authentication, accountId, schema, userId);
    }

    /**
     * Gera Refresh Token do Control Plane.
     *
     * <p>Refresh token não depende do principal e não precisa de subjectId.</p>
     */
    public String generateRefreshToken(String email, String schema, Long accountId) {
        return jwtTokenProvider.generateRefreshToken(email, schema, accountId);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneRefreshIdentity.java
============================================================
package brito.com.multitenancy001.integration.auth;

/**
 * Identidade derivada do refresh token do ControlPlane.
 */
public record ControlPlaneRefreshIdentity(
        String email,
        Long accountId,
        String schema
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneRefreshTokenIntrospectionIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.auth;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

/**
 * Integração: ControlPlane -> Infrastructure (introspecção do refresh token).
 *
 * Regra:
 * - controlplane.* não importa infrastructure.*
 * - integração encapsula JwtTokenProvider
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneRefreshTokenIntrospectionIntegrationService {

    private final JwtTokenProvider jwtTokenProvider;

    public ControlPlaneRefreshIdentity parseOrThrow(String refreshToken) {
        // Comentário: valida refresh token e extrai identidade mínima
        if (!StringUtils.hasText(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken é obrigatório", 400);
        }
        if (!jwtTokenProvider.validateToken(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401);
        }

        AuthDomain authDomain = jwtTokenProvider.getAuthDomainEnum(refreshToken);
        if (authDomain != AuthDomain.REFRESH) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401);
        }

        String schema = jwtTokenProvider.getTenantSchemaFromToken(refreshToken);
        String email = jwtTokenProvider.getEmailFromToken(refreshToken);
        Long accountId = jwtTokenProvider.getAccountIdFromToken(refreshToken);

        if (!StringUtils.hasText(schema) || !StringUtils.hasText(email) || accountId == null) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401);
        }

        return new ControlPlaneRefreshIdentity(email.trim(), accountId, schema.trim());
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/auth/ControlPlaneTokenIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.auth;

import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

/**
 * Integração ControlPlane -> Infra (JWT).
 *
 * Regras:
 * - controlplane.* NÃO importa infrastructure.security.jwt.*
 * - Esta classe é o "anti-corruption layer" para geração de tokens.
 *
 * Observação importante:
 * - Em alguns fluxos, authentication.getPrincipal() pode vir como UserDetails
 *   (ex.: org.springframework.security.core.userdetails.User), e NÃO como
 *   AuthenticatedUserContext. Nesse caso, JwtTokenProvider exige o userId (subjectId)
 *   explícito para preencher claims (userId/roleName/roleAuthority) de forma segura.
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneTokenIntegrationService {

    private final JwtTokenProvider jwtTokenProvider;

    /**
     * Cria access token do Control Plane.
     *
     * Regra:
     * - Se o principal NÃO for AuthenticatedUserContext, informe subjectId (userId) para evitar ClassCastException.
     */
    public String createAccessToken(Authentication authentication, Long accountId, String context, Long subjectId) {
        /* Delegação explícita com subjectId para suportar principal=UserDetails */
        return jwtTokenProvider.generateControlPlaneToken(authentication, accountId, context, subjectId);
    }

    /**
     * Backward-compatible.
     *
     * Regra:
     * - Mantido para não quebrar callers antigos.
     * - Se o principal não for AuthenticatedUserContext, JwtTokenProvider irá falhar com erro claro,
     *   pois não há subjectId para preencher as claims.
     */
    public String createAccessToken(Authentication authentication, Long accountId, String context) {
        /* Mantém compatibilidade; preferir a assinatura com subjectId */
        return jwtTokenProvider.generateControlPlaneToken(authentication, accountId, context);
    }

    /**
     * Cria refresh token (não precisa de subjectId).
     */
    public String createRefreshToken(String email, String context, Long accountId) {
        /* Refresh token não depende do principal */
        return jwtTokenProvider.generateRefreshToken(email, context, accountId);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/security/ControlPlaneRequestIdentityService.java
============================================================
package brito.com.multitenancy001.integration.security;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

/**
 * Integração: ControlPlane -> Infrastructure (SecurityUtils).
 *
 * Objetivo:
 * - Evitar ControlPlane importar infrastructure.security.* diretamente.
 * - Expôr identidade do request de forma mínima e semântica.
 *
 * Regras:
 * - Métodos aqui são "façade" do SecurityUtils.
 * - Não adiciona lógica de negócio; apenas expõe dados do contexto de segurança.
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneRequestIdentityService {

    private final SecurityUtils securityUtils;

    public Long getCurrentAccountId() {
        /* Retorna accountId do usuário autenticado no contexto atual. */
        return securityUtils.getCurrentAccountId();
    }

    public Long getCurrentUserId() {
        /* Retorna userId do usuário autenticado no contexto atual. */
        return securityUtils.getCurrentUserId();
    }

    public String getCurrentEmail() {
        /* Retorna email (ou name fallback) do usuário autenticado no contexto atual. */
        return securityUtils.getCurrentEmail();
    }

    public String getCurrentPrincipal() {
        /* Alias semântico: “principal/login do request” (não compromete nome/email). */
        return securityUtils.getCurrentEmail();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/security/ControlPlaneSecurityContextService.java
============================================================
package brito.com.multitenancy001.integration.security;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import lombok.RequiredArgsConstructor;

/**
 * Integração ControlPlane -> Infra (segurança).
 *
 * Regra: controlplane.* NÃO importa infrastructure.security.*
 */
@Service
@RequiredArgsConstructor
public class ControlPlaneSecurityContextService {

    private final SecurityUtils securityUtils;

    public Long authenticatedUserId() {
        return securityUtils.getAuthenticatedUserId();
    }

    public String authenticatedEmail() {
        return securityUtils.getAuthenticatedEmail();
    }

    public boolean isAuthenticated() {
        return securityUtils.isAuthenticated();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/security/TenantRequestIdentityService.java
============================================================
package brito.com.multitenancy001.integration.security;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

/**
 * Integração: Tenant (Application) -> Infrastructure (SecurityUtils).
 *
 * Objetivo:
 * - Evitar tenant.* (application) importar infrastructure.security.* diretamente.
 * - Centralizar leitura da identidade do request (accountId, userId, tenantSchema, email).
 *
 * Regras:
 * - Este serviço é "thin": apenas delega para SecurityUtils.
 * - Lança ApiException (UNAUTHENTICATED/INVALID_USER etc.) conforme as regras do SecurityUtils.
 */
@Service
@RequiredArgsConstructor
public class TenantRequestIdentityService {

    private final SecurityUtils securityUtils;

    public Long getCurrentAccountId() {
        /* Lê accountId do principal autenticado (ou lança UNAUTHENTICATED). */
        return securityUtils.getCurrentAccountId();
    }

    public Long getCurrentUserId() {
        /* Lê userId do principal autenticado (ou lança UNAUTHENTICATED). */
        return securityUtils.getCurrentUserId();
    }

    public String getCurrentTenantSchema() {
        /* Lê tenantSchema do principal autenticado (ou lança UNAUTHENTICATED). */
        return securityUtils.getCurrentTenantSchema();
    }

    public String getCurrentEmail() {
        /* Lê email do principal autenticado (ou lança UNAUTHENTICATED). */
        return securityUtils.getAuthenticatedEmail();
    }

    public boolean isAuthenticated() {
        /* Indica se existe principal autenticado no contexto atual. */
        return securityUtils.isAuthenticated();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/tenant/TenantProvisioningIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.tenant;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.contracts.TenantUserOperations;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.provisioning.app.TenantUserProvisioningService;
import brito.com.multitenancy001.tenant.users.app.TenantUserAdminTxService;
import lombok.RequiredArgsConstructor;

/**
 * Fronteira explícita de integração: ControlPlane -> Tenant.
 * 
 * <p>Esta classe implementa o contrato {@link TenantUserOperations}, permitindo que
 * o Control Plane execute operações em usuários de tenants de forma desacoplada.</p>
 *
 * <p>Responsabilidades:</p>
 * <ul>
 *   <li>Atuar como adaptador entre o contexto Control Plane e o contexto Tenant.</li>
 *   <li>Gerenciar a troca de schema do tenant via {@link TenantExecutor}.</li>
 *   <li>Delegar a execução das regras de negócio para os serviços apropriados do Tenant.</li>
 * </ul>
 *
 * <p>Regras Arquiteturais:</p>
 * <ul>
 *   <li>O pacote {@code controlplane.*} NÃO pode importar classes deste serviço diretamente.
 *       Ele deve depender apenas da interface {@link TenantUserOperations}.</li>
 *   <li>Esta classe, por estar em {@code integration.tenant}, pode (e deve) conhecer
 *       os detalhes de implementação do Tenant.</li>
 *   <li>Toda operação que requer o contexto do tenant deve ser executada dentro de
 *       um bloco {@code tenantExecutor.runInTenantSchema(...)}.</li>
 * </ul>
 *
 * @see TenantUserOperations
 * @see TenantExecutor
 * @see TenantUserAdminTxService
 * @see TenantUserProvisioningService
 */
@Service
@RequiredArgsConstructor
public class TenantProvisioningIntegrationService implements TenantUserOperations {

    private final TenantExecutor tenantExecutor;

    // Tenant app services (executam dentro do schema do tenant)
    private final TenantUserAdminTxService tenantUserAdminTxService;

    // Provisioning (já cuida de readiness + tx + schema switch internamente)
    private final TenantUserProvisioningService tenantUserProvisioningService;

    @Override
    public List<UserSummaryData> listUserSummaries(
            String tenantSchema,
            Long accountId,
            boolean onlyOperational
    ) {
        requireAccountId(accountId);
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.listUserSummaries(accountId, onlyOperational)
        );
    }

    @Override
    public void setUserSuspendedByAdmin(
            String tenantSchema,
            Long accountId,
            Long userId,
            boolean suspended
    ) {
        requireAccountId(accountId);
        requireUserId(userId);

        tenantExecutor.runInTenantSchema(tenantSchema, () -> {
            tenantUserAdminTxService.setSuspendedByAdmin(accountId, userId, suspended);
            return null;
        });
    }

    @Override
    public int suspendAllUsersByAccount(String tenantSchema, Long accountId) {
        requireAccountId(accountId);
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.suspendAllUsersByAccount(accountId)
        );
    }

    @Override
    public int unsuspendAllUsersByAccount(String tenantSchema, Long accountId) {
        requireAccountId(accountId);
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.unsuspendAllUsersByAccount(accountId)
        );
    }

    @Override
    public int softDeleteAllUsersByAccount(String tenantSchema, Long accountId) {
        requireAccountId(accountId);
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.softDeleteAllUsersByAccount(accountId)
        );
    }

    @Override
    public int restoreAllUsersByAccount(String tenantSchema, Long accountId) {
        requireAccountId(accountId);
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.restoreAllUsersByAccount(accountId)
        );
    }

    /**
     * Provisiona o usuário OWNER inicial (TENANT_OWNER) no schema do tenant.
     * 
     * <p><b>Nota:</b> Este método NÃO faz parte do contrato {@link TenantUserOperations}
     * porque é uma operação específica do fluxo de onboarding, que só é chamada
     * pelo Control Plane durante a criação de uma nova conta. Ela permanece aqui
     * como um serviço de integração especializado.</p>
     *
     * @param tenantSchema O schema do tenant alvo.
     * @param accountId    O ID da conta.
     * @param name         O nome do owner.
     * @param email        O email do owner.
     * @param rawPassword  A senha em texto puro.
     * @return Um resumo dos dados do usuário criado.
     * @throws ApiException Se os parâmetros forem inválidos ou o provisionamento falhar.
     */
    public UserSummaryData createTenantOwner(
            String tenantSchema,
            Long accountId,
            String name,
            String email,
            String rawPassword
    ) {
        requireAccountId(accountId);

        // Este service já faz assertTenantSchemaReady + runInTenantSchema + tx internamente
        return tenantUserProvisioningService.createTenantOwner(
                tenantSchema,
                accountId,
                name,
                email,
                rawPassword
        );
    }

    // =========================================================
    // Guards
    // =========================================================

    private void requireAccountId(Long accountId) {
        if (accountId == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId obrigatório", 400);
        }
    }

    private void requireUserId(Long userId) {
        if (userId == null) {
            throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId obrigatório", 400);
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/tenant/TenantSchemaProvisioningIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.tenant;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.tenant.TenantSchemaProvisioningService;
import lombok.RequiredArgsConstructor;

/**
 * Integração ControlPlane -> Infra (provisionamento/migração de schema).
 *
 * Regra: controlplane.* NÃO importa infrastructure.*
 */
@Service
@RequiredArgsConstructor
public class TenantSchemaProvisioningIntegrationService {

    private final TenantSchemaProvisioningService tenantSchemaProvisioningService;

    /**
     * Garante que o schema exista e que as migrations do tenant rodem.
     * Retorna true se o schema está pronto.
     */
    public boolean ensureSchemaExistsAndMigrate(String tenantSchema) {
        return tenantSchemaProvisioningService.ensureSchemaExistsAndMigrate(tenantSchema);
    }

    /**
     * Alias de compatibilidade (caso algum código antigo ainda chame).
     * Mantemos o nome antigo, mas a semântica real é "ensure + migrate".
     */
    @Deprecated
    public boolean provisionTenantSchema(String tenantSchema) {
        return ensureSchemaExistsAndMigrate(tenantSchema);
    }

    public void tryDropSchema(String tenantSchema) {
        tenantSchemaProvisioningService.tryDropSchema(tenantSchema);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/integration/tenant/TenantUsersIntegrationService.java
============================================================
package brito.com.multitenancy001.integration.tenant;

import java.util.List;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.tenant.users.app.TenantUserAdminTxService;
import lombok.RequiredArgsConstructor;

/**
 * Camada explícita de INTEGRAÇÃO (Application Service cross-context).
 *
 * - É CONCRETO (sem port/interface).
 * - Vive fora de infrastructure.* para evitar dependência ControlPlane -> infrastructure.
 * - Faz o "schema switch" via TenantExecutor e delega regras para o Tenant (app).
 *
 * Observação:
 * - Recebe tenantSchema porque INTEGRAÇÃO (cross-context) precisa escolher o schema alvo.
 * - TenantUserAdminTxService não conhece schema; só aplica regras do Tenant.
 */
@Service
@RequiredArgsConstructor
public class TenantUsersIntegrationService {

    private final TenantExecutor tenantExecutor;
    private final TenantUserAdminTxService tenantUserAdminTxService;

    public int suspendAllUsersByAccount(String tenantSchema, Long accountId) {
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.suspendAllUsersByAccount(accountId)
        );
    }

    public int unsuspendAllUsersByAccount(String tenantSchema, Long accountId) {
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.unsuspendAllUsersByAccount(accountId)
        );
    }

    public int softDeleteAllUsersByAccount(String tenantSchema, Long accountId) {
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.softDeleteAllUsersByAccount(accountId)
        );
    }

    public int restoreAllUsersByAccount(String tenantSchema, Long accountId) {
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.restoreAllUsersByAccount(accountId)
        );
    }

    public List<UserSummaryData> listUserSummaries(String tenantSchema, Long accountId, boolean onlyOperational) {
        return tenantExecutor.runInTenantSchema(tenantSchema,
                () -> tenantUserAdminTxService.listUserSummaries(accountId, onlyOperational)
        );
    }

    public void setSuspendedByAdmin(String tenantSchema, Long accountId, Long userId, boolean suspended) {
        tenantExecutor.runInTenantSchema(tenantSchema,
                () -> {
                    tenantUserAdminTxService.setSuspendedByAdmin(accountId, userId, suspended);
                    return null;
                }
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/account/UserLimitPolicy.java
============================================================
package brito.com.multitenancy001.shared.account;

public enum UserLimitPolicy {
    SEATS_IN_USE,        // deleted=false
    SEATS_ENABLED,
    ACTIVE_USERS_ONLY    // deleted=false AND suspendedByAccount=false AND suspendedByAdmin=false
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/compliance/ControllerComplianceExempt.java
============================================================
package brito.com.multitenancy001.shared.api.compliance;

import java.lang.annotation.*;

/**
 * Marca controllers (ou métodos) que devem ser ignorados pelo ControllerComplianceVerifier.
 *
 * Uso típico:
 * - Endpoints técnicos/infra (health, actuator proxies, dev-only)
 * - Controllers legados em migração (temporário)
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface ControllerComplianceExempt {

    /**
     * Motivo textual para facilitar rastreio.
     */
    String value() default "";
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/compliance/ControllerComplianceVerifier.java
============================================================
package brito.com.multitenancy001.shared.api.compliance;

import jakarta.persistence.Entity;
import jakarta.persistence.EntityManager;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.aop.support.AopUtils;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.ApplicationContext;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.data.repository.Repository;
import org.springframework.http.ResponseEntity;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Verificador automático de compliance arquitetural de Controllers.
 *
 * Objetivo:
 * - Garantir que Controllers sigam regras mínimas de arquitetura e DDD.
 *
 * Regras verificadas:
 * - Controller não pode acessar Repository diretamente.
 * - Controller deve expor DTOs (request/response), não entidades.
 * - Controller deve depender apenas de Application Services.
 *
 * Papel arquitetural:
 * - Mecanismo de "fail fast" durante startup.
 * - Evita regressões arquiteturais silenciosas ao longo do tempo.
 *
 * Importante:
 * - Controllers explicitamente excepcionais devem usar @ControllerComplianceExempt.
 * - Este verificador protege a integridade do projeto a longo prazo.
 */
@Component
@RequiredArgsConstructor
public class ControllerComplianceVerifier implements ApplicationRunner {

    private final ApplicationContext applicationContext;

    @Override
    public void run(ApplicationArguments args) {
        /* Comentário do método: executa o scan de controllers e falha o startup caso encontre violações. */

        List<String> violations = new ArrayList<>();

        Map<String, Object> controllers = findControllerBeans();

        for (Map.Entry<String, Object> entry : controllers.entrySet()) {
            String beanName = entry.getKey();
            Object bean = entry.getValue();

            Class<?> beanClass = AopUtils.getTargetClass(bean);
            if (beanClass == null) {
                continue;
            }

            if (isExempt(beanClass)) {
                continue;
            }

            violations.addAll(checkControllerBean(beanName, beanClass));
        }

        if (!violations.isEmpty()) {
            String message = buildFailFastMessage(violations);
            throw new IllegalStateException(message);
        }
    }

    private Map<String, Object> findControllerBeans() {
        /* Comentário do método: coleta todos os beans anotados com @RestController ou @Controller. */

        Map<String, Object> rest = applicationContext.getBeansWithAnnotation(RestController.class);
        Map<String, Object> mvc = applicationContext.getBeansWithAnnotation(Controller.class);

        // Merge (rest tem prioridade)
        Map<String, Object> all = new LinkedHashMap<>();
        all.putAll(mvc);
        all.putAll(rest);
        return all;
    }

    private List<String> checkControllerBean(String beanName, Class<?> controllerClass) {
        /* Comentário do método: aplica todas as regras de compliance para o controller alvo. */

        List<String> v = new ArrayList<>();

        // 1) Proibidos no controller: Repository, EntityManager, JdbcTemplate
        v.addAll(checkForbiddenDependencies(beanName, controllerClass));

        // 2) @Transactional no controller
        v.addAll(checkTransactionalUsage(beanName, controllerClass));

        // 3) @RequestBody sem @Valid
        v.addAll(checkRequestBodyValidation(beanName, controllerClass));

        // 4) Retornando entidades JPA / Optional
        v.addAll(checkReturnTypes(beanName, controllerClass));

        return v;
    }

    private List<String> checkForbiddenDependencies(String beanName, Class<?> controllerClass) {
        /* Comentário do método: detecta campos injetados proibidos (repo/entityManager/jdbc). */

        List<String> v = new ArrayList<>();

        for (Field f : getAllFields(controllerClass)) {
            Class<?> type = f.getType();

            // ignora constantes
            if (Modifier.isStatic(f.getModifiers())) continue;

            if (isExempt(f)) continue;

            if (Repository.class.isAssignableFrom(type) || type.getSimpleName().endsWith("Repository")) {
                v.add(fmt(beanName, controllerClass,
                        "FORBIDDEN_DEPENDENCY",
                        "Controller injeta repository direto: field '" + f.getName() + "' type=" + type.getName()));
            }

            if (EntityManager.class.isAssignableFrom(type)) {
                v.add(fmt(beanName, controllerClass,
                        "FORBIDDEN_DEPENDENCY",
                        "Controller injeta EntityManager: field '" + f.getName() + "'"));
            }

            if (JdbcTemplate.class.isAssignableFrom(type) || type.getSimpleName().endsWith("JdbcTemplate")) {
                v.add(fmt(beanName, controllerClass,
                        "FORBIDDEN_DEPENDENCY",
                        "Controller injeta JdbcTemplate: field '" + f.getName() + "'"));
            }
        }

        return v;
    }

    private List<String> checkTransactionalUsage(String beanName, Class<?> controllerClass) {
        /* Comentário do método: impede @Transactional em classe ou métodos do controller. */

        List<String> v = new ArrayList<>();

        if (hasAnnotation(controllerClass, Transactional.class)) {
            v.add(fmt(beanName, controllerClass,
                    "TRANSACTIONAL_IN_CONTROLLER",
                    "@Transactional anotado no controller (classe)"));
        }

        for (Method m : getAllMethods(controllerClass)) {
            if (isExempt(m)) continue;

            if (hasAnnotation(m, Transactional.class)) {
                v.add(fmt(beanName, controllerClass,
                        "TRANSACTIONAL_IN_CONTROLLER",
                        "@Transactional anotado no controller (método): " + signature(m)));
            }
        }

        return v;
    }

    private List<String> checkRequestBodyValidation(String beanName, Class<?> controllerClass) {
        /* Comentário do método: garante @Valid junto de @RequestBody (principalmente em create/update). */

        List<String> v = new ArrayList<>();

        for (Method m : getAllMethods(controllerClass)) {
            if (isExempt(m)) continue;

            Parameter[] params = m.getParameters();
            for (Parameter p : params) {

                if (!hasAnnotation(p, RequestBody.class)) continue;

                boolean hasValid = hasAnnotation(p, Valid.class);
                if (!hasValid) {
                    v.add(fmt(beanName, controllerClass,
                            "MISSING_VALIDATION",
                            "Parâmetro @RequestBody sem @Valid em " + signature(m) +
                                    " param='" + p.getName() + "' type=" + p.getType().getName()));
                }
            }
        }

        return v;
    }

    private List<String> checkReturnTypes(String beanName, Class<?> controllerClass) {
        /* Comentário do método: impede retorno de @Entity/Optional e detecta ResponseEntity<Entity>. */

        List<String> v = new ArrayList<>();

        for (Method m : getAllMethods(controllerClass)) {
            if (isExempt(m)) continue;

            Class<?> rawReturn = m.getReturnType();

            // Optional direto
            if (Optional.class.isAssignableFrom(rawReturn)) {
                v.add(fmt(beanName, controllerClass,
                        "OPTIONAL_RETURN",
                        "Método retorna Optional diretamente (anti-pattern): " + signature(m)));
                continue;
            }

            // Entidade direta
            if (isJpaEntity(rawReturn)) {
                v.add(fmt(beanName, controllerClass,
                        "ENTITY_EXPOSED",
                        "Método retorna @Entity diretamente: " + signature(m) + " return=" + rawReturn.getName()));
                continue;
            }

            // ResponseEntity<T> onde T é @Entity
            if (ResponseEntity.class.isAssignableFrom(rawReturn)) {
                Type generic = m.getGenericReturnType();
                Type inner = extractSingleGenericArg(generic);
                if (inner instanceof Class<?> innerClass && isJpaEntity(innerClass)) {
                    v.add(fmt(beanName, controllerClass,
                            "ENTITY_EXPOSED",
                            "Método retorna ResponseEntity<@Entity>: " + signature(m) + " inner=" + innerClass.getName()));
                }
            }
        }

        return v;
    }

    private static boolean isJpaEntity(Class<?> type) {
        /* Comentário do método: verifica se o tipo é anotado com @Entity. */
        if (type == null) return false;
        return hasAnnotation(type, Entity.class);
    }

    private static Type extractSingleGenericArg(Type type) {
        /* Comentário do método: extrai o T de ResponseEntity<T> ou retorna null. */
        if (!(type instanceof ParameterizedType pt)) return null;
        Type[] args = pt.getActualTypeArguments();
        if (args == null || args.length != 1) return null;
        return args[0];
    }

    private static List<Field> getAllFields(Class<?> type) {
        /* Comentário do método: retorna todos os campos herdados + declarados. */
        List<Field> fields = new ArrayList<>();
        Class<?> current = type;
        while (current != null && current != Object.class) {
            fields.addAll(Arrays.asList(current.getDeclaredFields()));
            current = current.getSuperclass();
        }
        return fields;
    }

    private static List<Method> getAllMethods(Class<?> type) {
        /* Comentário do método: retorna métodos declarados + herdados (exceto Object). */
        Map<String, Method> unique = new LinkedHashMap<>();
        Class<?> current = type;
        while (current != null && current != Object.class) {
            for (Method m : current.getDeclaredMethods()) {
                unique.putIfAbsent(methodKey(m), m);
            }
            current = current.getSuperclass();
        }
        return new ArrayList<>(unique.values());
    }

    private static String methodKey(Method m) {
        /* Comentário do método: cria chave única por assinatura. */
        String params = Arrays.stream(m.getParameterTypes()).map(Class::getName).collect(Collectors.joining(","));
        return m.getName() + "(" + params + ")";
    }

    private static String signature(Method m) {
        /* Comentário do método: formata uma assinatura humana do método. */
        String params = Arrays.stream(m.getParameterTypes())
                .map(Class::getSimpleName)
                .collect(Collectors.joining(", "));
        return m.getDeclaringClass().getSimpleName() + "#" + m.getName() + "(" + params + ")";
    }

    private static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> ann) {
        /* Comentário do método: checa anotação considerando meta-annotations (sem raw types). */
        return AnnotatedElementUtils.hasAnnotation(element, ann);
    }

    private static boolean isExempt(AnnotatedElement element) {
        /* Comentário do método: ignora itens anotados com @ControllerComplianceExempt. */
        return hasAnnotation(element, ControllerComplianceExempt.class);
    }

    private static String fmt(String beanName, Class<?> controllerClass, String code, String msg) {
        /* Comentário do método: padroniza mensagens para facilitar leitura no fail-fast. */
        return "[" + code + "] bean=" + beanName + " controller=" + controllerClass.getName() + " :: " + msg;
    }

    private static String buildFailFastMessage(List<String> violations) {
        /* Comentário do método: monta mensagem final (agrupada) para exception de startup. */
        StringBuilder sb = new StringBuilder(4096);
        sb.append("\n");
        sb.append("============================================================\n");
        sb.append("CONTROLLER COMPLIANCE VERIFIER - FAIL FAST\n");
        sb.append("============================================================\n");
        sb.append("Foram encontradas violações de arquitetura em Controllers.\n");
        sb.append("Corrija antes de prosseguir.\n\n");

        // agrupa por controller para ficar fácil
        Map<String, List<String>> grouped = new LinkedHashMap<>();
        for (String v : violations) {
            int idx = v.indexOf("controller=");
            int end = v.indexOf(" :: ");
            String key = (idx >= 0 && end > idx) ? v.substring(idx, end) : "controller=UNKNOWN";
            grouped.computeIfAbsent(key, k -> new ArrayList<>()).add(v);
        }

        for (Map.Entry<String, List<String>> e : grouped.entrySet()) {
            sb.append("- ").append(e.getKey()).append("\n");
            for (String line : e.getValue()) {
                sb.append("  - ").append(line).append("\n");
            }
            sb.append("\n");
        }

        sb.append("Regras principais:\n");
        sb.append("  - Controller -> AppService (nunca Repository/EntityManager/JdbcTemplate)\n");
        sb.append("  - Sem @Transactional em Controllers\n");
        sb.append("  - @RequestBody deve ter @Valid\n");
        sb.append("  - API não expõe @Entity diretamente\n");
        sb.append("============================================================\n");
        return sb.toString();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/GenericMessageResponse.java
============================================================
package brito.com.multitenancy001.shared.api.dto;

import jakarta.validation.constraints.NotBlank;

/**
 * Response genérica padronizada para respostas "mensagem".
 *
 * Motivação:
 * - Evitar ResponseEntity<String> com mensagens soltas (contrato instável).
 * - Padronizar respostas simples (ex.: "ok", "token gerado", "senha redefinida").
 */
public record GenericMessageResponse(

        @NotBlank
        String message

) {
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/auth/JwtResponse.java
============================================================
package brito.com.multitenancy001.shared.api.dto.auth;

import brito.com.multitenancy001.shared.security.SystemRoleName;

public record JwtResponse(
        String accessToken,
        String refreshToken,

        /**
         * HTTP Authorization scheme (ex: "Bearer").
         * NÃO confundir com o "authDomain" do JWT (TENANT/CONTROLPLANE/etc).
         */
        String tokenType,

        Long userId,

        /**
         * ✅ Identidade canônica de login (única).
         */
        String email,

        /**
         * ✅ Role "name" (ex: CONTROLPLANE_OWNER, TENANT_ADMIN)
         */
        SystemRoleName  role,

        Long accountId,

        /**
         * ✅ Para tenant: schema do tenant. Para controlplane: Schemas.CONTROL_PLANE.
         */
        String tenantSchema
) {
    public JwtResponse {
        if (tokenType == null || tokenType.isBlank()) tokenType = "Bearer";
    }

    /** ✅ Construtor curto (sem tokenType). */
    public JwtResponse(
            String accessToken,
            String refreshToken,
            Long userId,
            String email,
            SystemRoleName  role,
            Long accountId,
            String tenantSchema
    ) {
        this(accessToken, refreshToken, "Bearer", userId, email, role, accountId, tenantSchema);
    }

    public static JwtResponse forEmailLogin(
            String accessToken,
            String refreshToken,
            Long userId,
            String email,
            SystemRoleName  role,
            Long accountId,
            String tenantSchema
    ) {
        return new JwtResponse(accessToken, refreshToken, "Bearer", userId, email, role, accountId, tenantSchema);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/auth/LogoutRequest.java
============================================================
package brito.com.multitenancy001.shared.api.dto.auth;

import jakarta.validation.constraints.NotBlank;

/**
 * Request de logout forte.
 *
 * Opção B (logout forte):
 * - O servidor revoga a sessão/refresh token no banco (public schema)
 *
 * Campos:
 * - refreshToken: token de refresh atual (obrigatório)
 * - allDevices: se true, revoga todas as sessões do usuário naquele domínio (TENANT/CONTROLPLANE)
 */
public record LogoutRequest(
        @NotBlank(message = "refreshToken é obrigatório")
        String refreshToken,
        boolean allDevices
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/billing/AdminPaymentRequest.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record AdminPaymentRequest(
        @NotNull Long accountId,

        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotNull PaymentMethod paymentMethod,
        @NotNull PaymentGateway paymentGateway,

        String description
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentRequest.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public record PaymentRequest(
        @NotNull
        @DecimalMin(value = "0.01", message = "amount deve ser > 0")
        BigDecimal amount,

        @NotNull PaymentMethod paymentMethod,
        @NotNull PaymentGateway paymentGateway,

        String description
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/dto/billing/PaymentResponse.java
============================================================
package brito.com.multitenancy001.shared.api.dto.billing;

import brito.com.multitenancy001.shared.domain.billing.PaymentGateway;
import brito.com.multitenancy001.shared.domain.billing.PaymentMethod;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.Instant;

public record PaymentResponse(
        Long id,
        Long accountId,

        BigDecimal amount,
        PaymentMethod paymentMethod,
        PaymentGateway paymentGateway,
        PaymentStatus paymentStatus,

        String description,

        Instant paidAt,
        Instant validUntil,
        Instant refundedAt,

        Instant createdAt,
        Instant updatedAt
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/error/ApiEnumErrorResponse.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;

import java.time.Instant;
import java.util.List;

@Builder
public record ApiEnumErrorResponse(
        Instant timestamp,
        String error,
        String message,

        // opcional: erros de enum/constraint
        String field,
        String invalidValue,
        List<String> allowedValues,

        // ✅ qualquer payload extra (ex.: lista de tenants para seleção)
        Object details
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorCategory.java
============================================================
package brito.com.multitenancy001.shared.api.error;

/**
 * Categoria de erro (alto nível) para organização e observabilidade.
 *
 * Importante:
 * - adicionar novos valores é ok
 * - renomear/remover é breaking (pode afetar logs, métricas, etc.)
 */
public enum ApiErrorCategory {

    // Entrada / validação
    VALIDATION,
    REQUEST,

    // Auth / segurança
    AUTH,
    SECURITY,

    // Contextos
    CONTROLPLANE,
    TENANT,

    // Domínios
    ACCOUNTS,
    USERS,
    BILLING,

    // Catálogos do Tenant
    PRODUCTS,
    CATEGORIES,
    SUBCATEGORIES,
    SUPPLIERS,
    SALES,
    REPORTS,
    INVENTORY,

    // Planos/limites
    ENTITLEMENTS,
    QUOTAS,

    // Provisionamento / jobs
    PROVISIONING,

    // Concorrência / conflitos
    CONFLICT,

    // Falhas internas
    INTERNAL
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorCode.java
============================================================
// src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorCode.java
package brito.com.multitenancy001.shared.api.error;

import java.util.Locale;
import java.util.Optional;

/**
 * Catálogo tipado de códigos de erro.
 *
 * - name() é o "código externo" (ex.: ACCOUNT_NOT_FOUND)
 * - category é organização semântica
 * - httpStatus é o status padrão
 * - defaultMessage é uma mensagem padrão (pode ser sobrescrita)
 */
public enum ApiErrorCode {

    // =========================
    // Accounts (Control Plane)
    // =========================
    ACCOUNT_REQUIRED(ApiErrorCategory.ACCOUNTS, 400, "Conta é obrigatória"),
    ACCOUNT_ID_REQUIRED(ApiErrorCategory.ACCOUNTS, 400, "accountId é obrigatório"),
    ACCOUNT_NOT_FOUND(ApiErrorCategory.ACCOUNTS, 404, "Conta não encontrada"),
    ACCOUNT_NOT_ENABLED(ApiErrorCategory.ACCOUNTS, 404, "Conta não encontrada ou não operacional"),
    ACCOUNT_NOT_READY(ApiErrorCategory.ACCOUNTS, 409, "Conta não está pronta"),
    ACCOUNT_INACTIVE(ApiErrorCategory.ACCOUNTS, 409, "Conta inativa"),
    ACCOUNT_DELETED(ApiErrorCategory.ACCOUNTS, 409, "Conta removida"),
    ACCOUNT_STATUSES_REQUIRED(ApiErrorCategory.ACCOUNTS, 400, "statuses é obrigatório"),
    BUILTIN_ACCOUNT_PROTECTED(ApiErrorCategory.SECURITY, 403, "Operação não permitida para contas do sistema"),
    BUILTIN_ACCOUNT_NO_BILLING(ApiErrorCategory.SECURITY, 403, "Conta do sistema não possui billing"),

    INVALID_ACCOUNT(ApiErrorCategory.ACCOUNTS, 400, "Conta inválida"),

    ENTITLEMENTS_NOT_FOUND(ApiErrorCategory.ACCOUNTS, 404, "Entitlements não encontrados"),

    // =========================
    // Users
    // =========================
    USER_REQUIRED(ApiErrorCategory.USERS, 400, "Usuário é obrigatório"),
    USER_ID_REQUIRED(ApiErrorCategory.USERS, 400, "userId é obrigatório"),
    USER_NOT_FOUND(ApiErrorCategory.USERS, 404, "Usuário não encontrado"),
    USER_NOT_ENABLED(ApiErrorCategory.USERS, 403, "Usuário não habilitado"),
    USER_INACTIVE(ApiErrorCategory.USERS, 403, "Usuário inativo"),
    USER_OUT_OF_SCOPE(ApiErrorCategory.SECURITY, 403, "Usuário fora do escopo"),

    ROLE_REQUIRED(ApiErrorCategory.USERS, 400, "role é obrigatório"),
    FROM_USER_REQUIRED(ApiErrorCategory.USERS, 400, "fromUser é obrigatório"),
    TO_USER_REQUIRED(ApiErrorCategory.USERS, 400, "toUser é obrigatório"),

    // ✅ ADICIONADOS (para remover string code)
    USER_BUILT_IN_IMMUTABLE(ApiErrorCategory.SECURITY, 409,
            "Usuário BUILT_IN é protegido: não pode ter permissões alteradas; apenas senha pode ser trocada."),
    CONTROLPLANE_ACCOUNT_INVALID(ApiErrorCategory.INTERNAL, 500,
            "Configuração inválida: conta do Control Plane ausente ou duplicada."),
    INVALID_PERMISSION(ApiErrorCategory.SECURITY, 400, "Permissão inválida"),

    // ✅ ADICIONADO (para regras de ownership no Tenant)
    TENANT_OWNER_REQUIRED(ApiErrorCategory.CONFLICT, 409,
            "Tenant deve possuir ao menos um owner ativo"),

    // =========================
    // Auth / Security
    // =========================
    INVALID_CREDENTIALS(ApiErrorCategory.AUTH, 401, "Usuário ou senha inválidos"),
    INVALID_LOGIN(ApiErrorCategory.AUTH, 401, "Login inválido"),
    INVALID_USER(ApiErrorCategory.AUTH, 401, "Usuário inválido"),
    UNAUTHENTICATED(ApiErrorCategory.AUTH, 401, "Não autenticado"),
    UNAUTHORIZED(ApiErrorCategory.SECURITY, 401, "Não autorizado"),
    FORBIDDEN(ApiErrorCategory.SECURITY, 403, "Acesso negado"),
    ACCESS_DENIED(ApiErrorCategory.SECURITY, 403, "Acesso negado"),
    CHALLENGE_NOT_FOUND(ApiErrorCategory.AUTH, 404, "Challenge não encontrado, expirado ou já usado"),

    INVALID_REFRESH(ApiErrorCategory.AUTH, 401, "Refresh inválido"),
    INVALID_CHALLENGE(ApiErrorCategory.AUTH, 400, "Challenge inválido"),
    INVALID_SELECTION(ApiErrorCategory.AUTH, 400, "Seleção inválida"),

    TOKEN_REQUIRED(ApiErrorCategory.AUTH, 401, "Token é obrigatório"),
    TOKEN_INVALID(ApiErrorCategory.AUTH, 401, "Token inválido"),
    TOKEN_EXPIRED(ApiErrorCategory.AUTH, 401, "Token expirado"),
    INVALID_TOKEN(ApiErrorCategory.AUTH, 401, "Token inválido"),

    AUTH_ERROR(ApiErrorCategory.AUTH, 500, "Erro de autenticação"),
    
    MUST_CHANGE_PASSWORD(ApiErrorCategory.AUTH, 428, "É necessário trocar a senha antes de continuar"),


    // Password
    INVALID_PASSWORD(ApiErrorCategory.AUTH, 400, "Senha inválida"),
    WEAK_PASSWORD(ApiErrorCategory.AUTH, 400, "Senha fraca"),
    PASSWORD_MISMATCH(ApiErrorCategory.AUTH, 400, "Senhas não conferem"),
    CURRENT_PASSWORD_REQUIRED(ApiErrorCategory.AUTH, 400, "Senha atual é obrigatória"),
    CURRENT_PASSWORD_INVALID(ApiErrorCategory.AUTH, 400, "Senha atual inválida"),
    NEW_PASSWORD_REQUIRED(ApiErrorCategory.AUTH, 400, "Nova senha é obrigatória"),
    CONFIRM_PASSWORD_REQUIRED(ApiErrorCategory.AUTH, 400, "Confirmação de senha é obrigatória"),
    INVALID_CONFIRM_PASSWORD(ApiErrorCategory.AUTH, 400, "Confirmação de senha inválida"),

    // Email
    INVALID_EMAIL(ApiErrorCategory.VALIDATION, 400, "E-mail inválido"),
    EMAIL_ALREADY_EXISTS(ApiErrorCategory.CONFLICT, 409, "E-mail já existe"),
    EMAIL_ALREADY_IN_USE(ApiErrorCategory.CONFLICT, 409, "E-mail já está em uso"),
    EMAIL_RESERVED(ApiErrorCategory.CONFLICT, 409, "E-mail reservado"),

    // =========================
    // Tenant / Multitenancy
    // =========================
    TENANT_SELECTION_REQUIRED(ApiErrorCategory.CONFLICT, 409, "Seleção de tenant é obrigatória"),

    TENANT_CONTEXT_REQUIRED(ApiErrorCategory.TENANT, 400, "Tenant context é obrigatório"),
    TENANT_INVALID(ApiErrorCategory.TENANT, 400, "Tenant inválido"),
    TENANT_SCHEMA_NOT_FOUND(ApiErrorCategory.TENANT, 404, "Tenant schema não encontrado"),
    TENANT_TABLE_NOT_FOUND(ApiErrorCategory.TENANT, 404, "Tabela do tenant não encontrada"),

    // ✅ ADICIONADOS (para remover string code no provisioning worker)
    TENANT_SCHEMA_LOCK_TIMEOUT(ApiErrorCategory.CONFLICT, 409,
            "Não foi possível obter lock de provisionamento do schema do tenant"),
    TENANT_SCHEMA_PROVISIONING_FAILED(ApiErrorCategory.INTERNAL, 500,
            "Falha ao provisionar schema do tenant"),
    TENANT_SCHEMA_DROP_FAILED(ApiErrorCategory.INTERNAL, 500,
            "Falha ao dropar schema do tenant"),
    TENANT_SCHEMA_EXISTS_CHECK_FAILED(ApiErrorCategory.INTERNAL, 500,
            "Falha ao verificar existência do schema do tenant"),
    TENANT_TABLE_EXISTS_CHECK_FAILED(ApiErrorCategory.INTERNAL, 500,
            "Falha ao verificar existência de tabela do tenant"),

    SCHEMA_REQUIRED(ApiErrorCategory.TENANT, 400, "Schema é obrigatório"),
    SCHEMA_INVALID(ApiErrorCategory.TENANT, 400, "Schema inválido"),
    TABLE_REQUIRED(ApiErrorCategory.TENANT, 400, "Table é obrigatório"),
    TABLE_INVALID(ApiErrorCategory.TENANT, 400, "Table inválido"),

    // =========================
    // Billing / Payments
    // =========================
    PAYMENT_ID_REQUIRED(ApiErrorCategory.BILLING, 400, "paymentId é obrigatório"),
    PAYMENT_NOT_FOUND(ApiErrorCategory.BILLING, 404, "Pagamento não encontrado"),
    PAYMENT_FAILED(ApiErrorCategory.BILLING, 409, "Pagamento falhou"),
    PAYMENT_ALREADY_EXISTS(ApiErrorCategory.CONFLICT, 409, "Pagamento já existe"),
    PAYMENT_STATUS_REQUIRED(ApiErrorCategory.BILLING, 400, "status do pagamento é obrigatório"),
    PAYMENT_NOT_REFUNDABLE(ApiErrorCategory.BILLING, 409, "Pagamento não reembolsável"),
    INVALID_PAYMENT_STATUS(ApiErrorCategory.BILLING, 400, "Status de pagamento inválido"),
    INVALID_TRANSACTION_ID(ApiErrorCategory.BILLING, 400, "TransactionId inválido"),

    // =========================
    // Products
    // =========================
    PRODUCT_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "Produto é obrigatório"),
    PRODUCT_ID_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "productId é obrigatório"),
    PRODUCT_NOT_FOUND(ApiErrorCategory.PRODUCTS, 404, "Produto não encontrado"),
    PRODUCT_DELETED(ApiErrorCategory.PRODUCTS, 409, "Produto removido"),
    PRODUCT_NAME_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "Nome do produto é obrigatório"),
    PRODUCT_PRICE_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "Preço do produto é obrigatório"),
    SKU_ALREADY_EXISTS(ApiErrorCategory.CONFLICT, 409, "SKU já existe"),
    INVALID_PRICE(ApiErrorCategory.PRODUCTS, 400, "Preço inválido"),
    INVALID_PRICE_RANGE(ApiErrorCategory.PRODUCTS, 400, "Intervalo de preço inválido"),
    PRICE_TOO_HIGH(ApiErrorCategory.PRODUCTS, 400, "Preço alto demais"),
    INVALID_AMOUNT(ApiErrorCategory.PRODUCTS, 400, "Valor inválido"),
    INVALID_BRAND(ApiErrorCategory.PRODUCTS, 400, "Marca inválida"),
    BRAND_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "Marca é obrigatória"),
    INVALID_STOCK(ApiErrorCategory.PRODUCTS, 400, "Estoque inválido"),
    INVALID_STOCK_RANGE(ApiErrorCategory.PRODUCTS, 400, "Intervalo de estoque inválido"),
    INVALID_LEAD_TIME(ApiErrorCategory.PRODUCTS, 400, "Lead time inválido"),
    INVALID_STORAGE_DELTA(ApiErrorCategory.PRODUCTS, 400, "Delta de estoque inválido"),
    
    // =========================
    // Generic fields (reutilizáveis)
    // =========================
    SKU_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "sku é obrigatório"),
    PRICE_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "price é obrigatório"),
    PRICE_RANGE_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "minPrice e maxPrice são obrigatórios"),
    STOCK_CHANGE_REQUIRED(ApiErrorCategory.PRODUCTS, 400, "quantityChange é obrigatório"),


    // =========================
    // Categories / Subcategories
    // =========================
    CATEGORY_REQUIRED(ApiErrorCategory.CATEGORIES, 400, "Categoria é obrigatória"),
    CATEGORY_ID_REQUIRED(ApiErrorCategory.CATEGORIES, 400, "categoryId é obrigatório"),
    CATEGORY_NOT_FOUND(ApiErrorCategory.CATEGORIES, 404, "Categoria não encontrada"),
    CATEGORY_DELETED(ApiErrorCategory.CATEGORIES, 409, "Categoria removida"),
    CATEGORY_NAME_REQUIRED(ApiErrorCategory.CATEGORIES, 400, "Nome da categoria é obrigatório"),
    CATEGORY_NAME_ALREADY_EXISTS(ApiErrorCategory.CONFLICT, 409, "Nome da categoria já existe"),

    SUBCATEGORY_REQUIRED(ApiErrorCategory.SUBCATEGORIES, 400, "Subcategoria é obrigatória"),
    SUBCATEGORY_ID_REQUIRED(ApiErrorCategory.SUBCATEGORIES, 400, "subcategoryId é obrigatório"),
    SUBCATEGORY_NOT_FOUND(ApiErrorCategory.SUBCATEGORIES, 404, "Subcategoria não encontrada"),
    SUBCATEGORY_DELETED(ApiErrorCategory.SUBCATEGORIES, 409, "Subcategoria removida"),
    SUBCATEGORY_ALREADY_EXISTS(ApiErrorCategory.CONFLICT, 409, "Subcategoria já existe"),
    SUBCATEGORY_NAME_REQUIRED(ApiErrorCategory.SUBCATEGORIES, 400, "Nome da subcategoria é obrigatório"),
    INVALID_SUBCATEGORY(ApiErrorCategory.SUBCATEGORIES, 400, "Subcategoria inválida"),

    // =========================
    // Suppliers
    // =========================
    SUPPLIER_REQUIRED(ApiErrorCategory.SUPPLIERS, 400, "Fornecedor é obrigatório"),
    SUPPLIER_ID_REQUIRED(ApiErrorCategory.SUPPLIERS, 400, "supplierId é obrigatório"),
    SUPPLIER_NOT_FOUND(ApiErrorCategory.SUPPLIERS, 404, "Fornecedor não encontrado"),
    SUPPLIER_DELETED(ApiErrorCategory.SUPPLIERS, 409, "Fornecedor removido"),
    SUPPLIER_NAME_REQUIRED(ApiErrorCategory.SUPPLIERS, 400, "Nome do fornecedor é obrigatório"),
    SUPPLIER_EMAIL_REQUIRED(ApiErrorCategory.SUPPLIERS, 400, "E-mail do fornecedor é obrigatório"),
    SUPPLIER_DOCUMENT_REQUIRED(ApiErrorCategory.SUPPLIERS, 400, "Documento do fornecedor é obrigatório"),
    SUPPLIER_DOCUMENT_ALREADY_EXISTS(ApiErrorCategory.CONFLICT, 409, "Documento do fornecedor já existe"),

    // =========================
    // Generic validation / request
    // =========================
    INVALID_REQUEST(ApiErrorCategory.REQUEST, 400, "Requisição inválida"),
    VALIDATION_ERROR(ApiErrorCategory.VALIDATION, 400, "Erro de validação"),

    INVALID_NAME(ApiErrorCategory.VALIDATION, 400, "Nome inválido"),
    INVALID_SLUG(ApiErrorCategory.VALIDATION, 400, "Slug inválido"),
    INVALID_STATUS(ApiErrorCategory.VALIDATION, 400, "Status inválido"),
    STATUS_REQUIRED(ApiErrorCategory.VALIDATION, 400, "Status é obrigatório"),
    INVALID_SEARCH(ApiErrorCategory.VALIDATION, 400, "Busca inválida"),

    INVALID_RANGE(ApiErrorCategory.VALIDATION, 400, "Intervalo inválido"),
    RANGE_TOO_LARGE(ApiErrorCategory.VALIDATION, 400, "Intervalo grande demais"),

    DATE_REQUIRED(ApiErrorCategory.VALIDATION, 400, "Data é obrigatória"),
    DATE_RANGE_REQUIRED(ApiErrorCategory.VALIDATION, 400, "Intervalo de datas é obrigatório"),
    INVALID_DATE(ApiErrorCategory.VALIDATION, 400, "Data inválida"),
    INVALID_DATE_RANGE(ApiErrorCategory.VALIDATION, 400, "Intervalo de datas inválido"),

    INVALID_COMPANY_NAME(ApiErrorCategory.VALIDATION, 400, "Nome da empresa inválido"),
    INVALID_COMPANY_DOC_TYPE(ApiErrorCategory.VALIDATION, 400, "Tipo de documento inválido"),
    INVALID_COMPANY_DOC_NUMBER(ApiErrorCategory.VALIDATION, 400, "Número de documento inválido"),

    INVALID_ORIGIN(ApiErrorCategory.VALIDATION, 400, "Origem inválida"),
    INVALID_RATING(ApiErrorCategory.VALIDATION, 400, "Rating inválido"),

    INVALID_ROLE(ApiErrorCategory.USERS, 400, "Role inválida"),
    INVALID_TRANSFER(ApiErrorCategory.USERS, 400, "Transfer inválido"),

    // =========================
    // Quotas / Entitlements
    // =========================
    QUOTA_MAX_USERS_REACHED(ApiErrorCategory.QUOTAS, 409, "Limite de usuários atingido"),
    QUOTA_MAX_STORAGE_REACHED(ApiErrorCategory.QUOTAS, 409, "Limite de storage atingido"),
    QUOTA_MAX_PRODUCTS_REACHED(ApiErrorCategory.QUOTAS, 409, "Limite de produtos atingido"),
    INVALID_ENTITLEMENT(ApiErrorCategory.ENTITLEMENTS, 400, "Entitlement inválido"),
    ENTITLEMENTS_UNEXPECTED_NULL(ApiErrorCategory.ENTITLEMENTS, 500, "Entitlements inesperadamente nulo"),

    // =========================
    // Conflict
    // =========================
    DUPLICATE_ENTRY(ApiErrorCategory.CONFLICT, 409, "Registro duplicado"),

    // =========================
    // Internal
    // =========================
    INTERNAL_ERROR(ApiErrorCategory.INTERNAL, 500, "Erro interno"),
    INTERNAL_SERVER_ERROR(ApiErrorCategory.INTERNAL, 500, "Erro interno inesperado"),
    FEATURE_NOT_IMPLEMENTED(ApiErrorCategory.INTERNAL, 501, "Funcionalidade ainda não implementada");

    private final ApiErrorCategory category;
    private final int httpStatus;
    private final String defaultMessage;

    ApiErrorCode(ApiErrorCategory category, int httpStatus, String defaultMessage) {
        this.category = category;
        this.httpStatus = httpStatus;
        this.defaultMessage = defaultMessage;
    }

    public ApiErrorCategory category() {
        return category;
    }

    public int httpStatus() {
        return httpStatus;
    }

    public String defaultMessage() {
        return defaultMessage;
    }

    /**
     * Parse seguro a partir de um código legado (String).
     *
     * Exemplos aceitos:
     * - "account_not_found"
     * - "ACCOUNT-NOT-FOUND"
     * - " account not found "
     * - "AccountNotFound" (best-effort)
     */
    public static Optional<ApiErrorCode> tryParse(String legacyCode) {
        if (legacyCode == null || legacyCode.isBlank()) return Optional.empty();

        String s = legacyCode.trim();

        // 1) normaliza separadores comuns para "_"
        s = s.replace('-', '_')
             .replace(' ', '_')
             .replace('.', '_')
             .replace('/', '_');

        // 2) camelCase/PascalCase -> snake-ish (best effort)
        // "AccountNotFound" => "Account_Not_Found"
        s = s.replaceAll("([a-z])([A-Z])", "$1_$2");

        // 3) collapse múltiplos underscores
        s = s.replaceAll("_+", "_");

        // 4) upper
        String normalized = s.toUpperCase(Locale.ROOT);

        try {
            return Optional.of(ApiErrorCode.valueOf(normalized));
        } catch (IllegalArgumentException ex) {
            return Optional.empty();
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/error/ApiErrorResponse.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import lombok.Builder;

import java.time.Instant;
import java.util.List;

@Builder
public record ApiErrorResponse(
        Instant timestamp,
        String error,
        String message,
        List<String> details
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/api/error/GlobalExceptionHandler.java
============================================================
package brito.com.multitenancy001.shared.api.error;

import brito.com.multitenancy001.shared.domain.DomainException;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RestControllerAdvice
@RequiredArgsConstructor
@Slf4j
public class GlobalExceptionHandler {

    private final AppClock appClock;

    private Instant appNow() {
        return appClock.instant();
    }

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleNotReadable(HttpMessageNotReadableException ex) {
        Instant ts = appNow();

        Throwable cause = ex.getCause();

        if (cause instanceof InvalidFormatException ife) {
            Class<?> targetType = ife.getTargetType();

            if (targetType != null && targetType.isEnum()) {
                String fieldName = ife.getPath().isEmpty() ? "status" : ife.getPath().get(0).getFieldName();
                String invalidValue = ife.getValue() != null ? ife.getValue().toString() : "null";

                List<String> allowedValues = Arrays.stream(targetType.getEnumConstants())
                        .map(Object::toString)
                        .toList();

                return ResponseEntity.badRequest().body(
                        ApiEnumErrorResponse.builder()
                                .timestamp(ts)
                                .error("INVALID_ENUM")
                                .message("Valor inválido para o campo " + fieldName)
                                .field(fieldName)
                                .invalidValue(invalidValue)
                                .allowedValues(allowedValues)
                                .build()
                );
            }
        }

        return ResponseEntity.badRequest().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error("INVALID_REQUEST_BODY")
                        .message("Corpo da requisição inválido")
                        .build()
        );
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        Instant ts = appNow();

        String errorMessage = ex.getMostSpecificCause() != null ? ex.getMostSpecificCause().getMessage() : ex.getMessage();
        if (!StringUtils.hasText(errorMessage)) errorMessage = "";

        log.debug("DataIntegrityViolationException: {}", errorMessage);

        if (errorMessage.contains("tax_id_number")) {
            String cnpj = extractValue(errorMessage, "tax_id_number");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(ts)
                            .error("DUPLICATE_NUMBER")
                            .message("Já existe uma conta com o Number: " + cnpj)
                            .field("taxIdNumber")
                            .invalidValue(cnpj)
                            .build()
            );
        }

        if (errorMessage.contains("LoginEmail")) {
            String email = extractValue(errorMessage, "LoginEmail");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(ts)
                            .error("DUPLICATE_EMAIL")
                            .message("Já existe uma conta com o email " + email)
                            .field("loginEmail")
                            .invalidValue(email)
                            .build()
            );
        }

        if (errorMessage.contains("slug")) {
            String slug = extractValue(errorMessage, "slug");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(ts)
                            .error("DUPLICATE_SLUG")
                            .message("Já existe uma conta com o slug " + slug)
                            .field("slug")
                            .invalidValue(slug)
                            .build()
            );
        }

        if (errorMessage.contains("tenant_schema")) {
            String schema = extractValue(errorMessage, "tenant_schema");
            return ResponseEntity.status(409).body(
                    ApiEnumErrorResponse.builder()
                            .timestamp(ts)
                            .error("DUPLICATE_SCHEMA")
                            .message("Erro interno: schema " + schema + " já existe")
                            .build()
            );
        }

        return ResponseEntity.status(409).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error("DUPLICATE_ENTRY")
                        .message("Registro duplicado. Verifique os dados informados.")
                        .build()
        );
    }

    private String extractValue(String message, String fieldName) {
        try {
            Pattern pattern = Pattern.compile("\\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher = pattern.matcher(message);
            if (matcher.find()) return matcher.group(1);

            Pattern pattern2 = Pattern.compile("Key \\(" + Pattern.quote(fieldName) + "\\)=\\(([^\\)]+)\\)");
            Matcher matcher2 = pattern2.matcher(message);
            if (matcher2.find()) return matcher2.group(1);

        } catch (Exception e) {
            log.debug("Erro ao extrair valor do erro de constraint: {}", e.getMessage());
        }

        return "não identificado";
    }

    @ExceptionHandler(ApiException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleApi(ApiException ex) {
        Instant ts = appNow();

        return ResponseEntity.status(ex.getStatus()).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error(ex.getError())
                        .message(ex.getMessage())
                        .field(ex.getField())
                        .invalidValue(ex.getInvalidValue())
                        .allowedValues(ex.getAllowedValues())
                        .details(ex.getDetails())
                        .build()
        );
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Instant ts = appNow();

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .toList();

        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .timestamp(ts)
                .error("VALIDATION_ERROR")
                .message("Erro de validação")
                .details(errors)
                .build();

        return ResponseEntity.badRequest().body(errorResponse);
    }

    /**
     * ✅ Se faltar @RequestParam obrigatório, é 400 (request inválida), não 500.
     * Ex.: GET /api/tenant/categories/search sem ?name=...
     */
    @ExceptionHandler(MissingServletRequestParameterException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleMissingRequestParam(MissingServletRequestParameterException ex) {
        Instant ts = appNow();

        String param = ex.getParameterName();
        log.warn("Missing request parameter: {}", param);

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error("MISSING_REQUEST_PARAMETER")
                        .message("Parâmetro obrigatório ausente: " + param)
                        .field(param)
                        .invalidValue(null)
                        .allowedValues(null)
                        .details(null)
                        .build()
        );
    }

    /**
     * ✅ NOVO: quando o path/query param vem com tipo inválido (ex.: UUID esperado e recebeu "1"),
     * isso deve ser 400 e não 500.
     *
     * Ex.: GET /api/tenant/products/1 quando o controller espera UUID.
     */
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleTypeMismatch(MethodArgumentTypeMismatchException ex) {
        Instant ts = appNow();

        String field = ex.getName(); // nome do path var / param
        Object value = ex.getValue();
        String invalidValue = value == null ? "null" : value.toString();

        String expectedType = ex.getRequiredType() != null ? ex.getRequiredType().getSimpleName() : "unknown";

        log.warn("Type mismatch for '{}': value='{}', expected={}", field, invalidValue, expectedType);

        return ResponseEntity.badRequest().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error("INVALID_PARAMETER")
                        .message("Parâmetro inválido: " + field)
                        .field(field)
                        .invalidValue(invalidValue)
                        .allowedValues(List.of(expectedType))
                        .details(null)
                        .build()
        );
    }

    @ExceptionHandler({
            BadCredentialsException.class,
            InternalAuthenticationServiceException.class,
            AuthenticationException.class
    })
    public ResponseEntity<ApiEnumErrorResponse> handleAuthentication(AuthenticationException ex) {
        Instant ts = appNow();

        log.warn("Authentication failed: {}", ex.getMessage());

        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error("INVALID_USER")
                        .message("usuario ou senha invalidos")
                        .build()
        );
    }

    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleAuthorizationDenied(AuthorizationDeniedException ex) {
        Instant ts = appNow();

        log.warn("Acesso negado (AuthorizationDenied): {}", ex.getMessage());

        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error(ApiErrorCode.FORBIDDEN.name())
                        .message("Acesso negado")
                        .build()
        );
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiEnumErrorResponse> handleAccessDenied(AccessDeniedException ex) {
        Instant ts = appNow();

        log.warn("Acesso negado (AccessDenied): {}", ex.getMessage());

        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error(ApiErrorCode.FORBIDDEN.name())
                        .message("Acesso negado")
                        .build()
        );
    }

    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ApiErrorResponse> handleDomainException(DomainException ex) {
        Instant ts = appNow();

        ApiErrorResponse body = ApiErrorResponse.builder()
                .timestamp(ts)
                .error("DOMAIN_RULE_VIOLATION")
                .message(ex.getMessage())
                .build();

        return ResponseEntity.badRequest().body(body);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiEnumErrorResponse> handleGeneric(Exception ex) {
        Instant ts = appNow();

        log.error("Unhandled exception: {}", ex.getMessage(), ex);

        return ResponseEntity.internalServerError().body(
                ApiEnumErrorResponse.builder()
                        .timestamp(ts)
                        .error("INTERNAL_SERVER_ERROR")
                        .message("Erro interno inesperado. Contate o suporte.")
                        .build()
        );
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/audit/AuditDetails.java
============================================================
package brito.com.multitenancy001.shared.audit;

import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Builder padrão para details (JSON) de auditoria.
 *
 * Objetivo:
 * - Padronizar payloads de auditoria (Map) para virar JSON via JsonDetailsMapper.
 * - Garantir campos recorrentes (scope, requestId/correlationId, alvo, mudanças).
 *
 * Regras:
 * - NUNCA incluir segredos (senha, refresh token, JWT, etc).
 * - Preferir valores primitivos/strings/listas pequenas.
 */
public final class AuditDetails {

    private AuditDetails() {}

    public static Map<String, Object> base(String scope, String event) {
        /* Monta o mapa base com scope/event e correlationId (requestId). */
        Map<String, Object> m = new LinkedHashMap<>();
        m.put("scope", scope);
        m.put("event", event);

        RequestMeta meta = RequestMetaContext.getOrNull();
        if (meta != null && meta.requestId() != null) {
            m.put("correlationId", meta.requestId().toString());
        }
        return m;
    }

    public static Map<String, Object> withTarget(Map<String, Object> base, Long targetUserId, String targetEmail) {
        /* Adiciona alvo (target) no mapa base. */
        if (base == null) base = new LinkedHashMap<>();
        if (targetUserId != null) base.put("targetUserId", targetUserId);
        if (targetEmail != null && !targetEmail.isBlank()) base.put("targetEmail", targetEmail);
        return base;
    }

    public static Map<String, Object> withActor(Map<String, Object> base, Long actorUserId, String actorEmail) {
        /* Adiciona ator (actor) no mapa base. */
        if (base == null) base = new LinkedHashMap<>();
        if (actorUserId != null) base.put("actorUserId", actorUserId);
        if (actorEmail != null && !actorEmail.isBlank()) base.put("actorEmail", actorEmail);
        return base;
    }

    public static Map<String, Object> withChanges(Map<String, Object> base, Object changes) {
        /* Adiciona mudanças (delta) no mapa base. */
        if (base == null) base = new LinkedHashMap<>();
        if (changes != null) base.put("changes", changes);
        return base;
    }

    public static Map<String, Object> withReason(Map<String, Object> base, String reason) {
        /* Adiciona reason no mapa base (sem stacktrace). */
        if (base == null) base = new LinkedHashMap<>();
        if (reason != null && !reason.isBlank()) base.put("reason", reason);
        return base;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/auth/app/AuthRefreshSessionService.java
============================================================
// src/main/java/brito/com/multitenancy001/shared/auth/app/AuthRefreshSessionService.java
package brito.com.multitenancy001.shared.auth.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.auth.app.boundary.AuthRefreshSessionData;
import brito.com.multitenancy001.shared.auth.app.boundary.AuthRefreshSessionStore;
import brito.com.multitenancy001.shared.auth.app.boundary.RefreshTokenHasher;
import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;
import brito.com.multitenancy001.shared.context.RequestMeta;
import brito.com.multitenancy001.shared.context.RequestMetaContext;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Instant;
import java.util.UUID;

/**
 * Application service de sessões de refresh (logout forte + rotação).
 *
 * Regras:
 * - Emitir sessão ao fazer login (refresh gerado)
 * - Rotacionar sessão a cada refresh (troca do hash)
 * - Revogar sessão ao logout forte
 *
 * Semântica:
 * - CONTROLPLANE: tenantSchema deve ser null.
 * - TENANT: tenantSchema é obrigatório.
 */
@Service
@RequiredArgsConstructor
public class AuthRefreshSessionService {

    private final AuthRefreshSessionStore store;
    private final RefreshTokenHasher hasher;
    private final AppClock appClock;

    /**
     * Registra uma sessão nova no servidor quando um refresh token é emitido.
     */
    public void onRefreshIssued(AuthSessionDomain sessionDomain,
                               Long accountId,
                               Long userId,
                               String tenantSchemaOrNull,
                               String refreshToken) {
        /* Validação + persistência de sessão (server-side refresh sessions). */
        if (sessionDomain == null) {
            throw new ApiException(ApiErrorCode.INTERNAL_ERROR, "sessionDomain ausente", 500);
        }
        if (accountId == null || userId == null) {
            throw new ApiException(ApiErrorCode.INTERNAL_ERROR, "accountId/userId ausente", 500);
        }
        if (!StringUtils.hasText(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken ausente", 400);
        }

        String tenantSchema = normalizeTenantSchema(sessionDomain, tenantSchemaOrNull);

        Instant now = appClock.instant();
        RequestMeta meta = RequestMetaContext.getOrNull();

        UUID requestId = meta != null ? meta.requestId() : null;
        String ip = meta != null ? meta.ip() : null;
        String userAgent = meta != null ? meta.userAgent() : null;

        AuthRefreshSessionData data = new AuthRefreshSessionData(
                UUID.randomUUID(),
                sessionDomain,
                accountId,
                userId,
                tenantSchema,
                hasher.hash(refreshToken),
                now,
                now,
                null,
                null,
                requestId,
                requestId,
                ip,
                ip,
                userAgent,
                userAgent,
                null
        );

        store.insert(data);
    }

    /**
     * Rotaciona o refresh token (old -> new) validando que o old existe e não está revogado.
     */
    public void rotateOrThrow(AuthSessionDomain sessionDomain,
                              String oldRefreshToken,
                              String newRefreshToken,
                              Long expectedAccountId,
                              Long expectedUserId,
                              String expectedTenantSchemaOrNull) {
        /* Valida old, busca sessão, valida ownership e rotaciona hash. */
        if (sessionDomain == null) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido (domínio)", 401);
        }
        if (!StringUtils.hasText(oldRefreshToken) || !StringUtils.hasText(newRefreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401);
        }

        String oldHash = hasher.hash(oldRefreshToken);

        AuthRefreshSessionData s = store.findByRefreshTokenHash(oldHash)
                .orElseThrow(() -> new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken revogado/expirado", 401));

        if (s.revokedAt() != null) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken revogado", 401);
        }

        if (s.sessionDomain() != sessionDomain) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido (domínio)", 401);
        }
        if (expectedAccountId != null && !expectedAccountId.equals(s.accountId())) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido (account)", 401);
        }
        if (expectedUserId != null && !expectedUserId.equals(s.userId())) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido (user)", 401);
        }

        String expectedTenant = normalizeTenantSchema(sessionDomain, expectedTenantSchemaOrNull);
        String actualTenant = s.tenantSchema() != null ? s.tenantSchema().trim() : null;

        if (sessionDomain == AuthSessionDomain.TENANT && !expectedTenant.equals(actualTenant)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido (tenantSchema)", 401);
        }

        Instant now = appClock.instant();
        RequestMeta meta = RequestMetaContext.getOrNull();

        UUID requestId = meta != null ? meta.requestId() : null;
        String ip = meta != null ? meta.ip() : null;
        String userAgent = meta != null ? meta.userAgent() : null;

        store.rotate(
                s.id(),
                hasher.hash(newRefreshToken),
                now,
                requestId,
                ip,
                userAgent
        );
    }

    /**
     * Logout forte: revoga uma sessão pelo refresh token.
     */
    public void revokeByRefreshTokenOrThrow(String refreshToken, String revokedReasonJson) {
        /* Resolve sessão pelo hash e revoga (idempotente). */
        if (!StringUtils.hasText(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken é obrigatório", 400);
        }

        String hash = hasher.hash(refreshToken);

        AuthRefreshSessionData s = store.findByRefreshTokenHash(hash)
                .orElseThrow(() -> new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401));

        if (s.revokedAt() != null) {
            return; // idempotente
        }

        store.revoke(s.id(), appClock.instant(), revokedReasonJson);
    }

    /**
     * Logout forte (all devices): revoga todas as sessões do usuário naquele domínio.
     */
    public int revokeAllForUser(AuthSessionDomain sessionDomain,
                                Long accountId,
                                Long userId,
                                String revokedReasonJson) {
        /* Revoga em massa por domínio + user. */
        if (sessionDomain == null || accountId == null || userId == null) {
            throw new ApiException(ApiErrorCode.INTERNAL_ERROR, "Parâmetros inválidos para revokeAll", 500);
        }
        return store.revokeAllForUser(sessionDomain, accountId, userId, appClock.instant(), revokedReasonJson);
    }

    private static String normalizeTenantSchema(AuthSessionDomain sessionDomain, String tenantSchemaOrNull) {
        /* Normaliza regra TENANT vs CONTROLPLANE para tenantSchema. */
        if (sessionDomain == AuthSessionDomain.CONTROLPLANE) {
            return null;
        }

        String schema = tenantSchemaOrNull != null ? tenantSchemaOrNull.trim() : null;
        if (!StringUtils.hasText(schema)) {
            throw new ApiException(ApiErrorCode.INTERNAL_ERROR, "tenantSchema ausente para sessão TENANT", 500);
        }
        return schema;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/auth/app/boundary/AuthRefreshSessionData.java
============================================================
// src/main/java/brito/com/multitenancy001/shared/auth/app/boundary/AuthRefreshSessionData.java
package brito.com.multitenancy001.shared.auth.app.boundary;

import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;

import java.time.Instant;
import java.util.UUID;

/**
 * DTO de persistência (boundary) para sessão de refresh.
 *
 * Contrato:
 * - sessionDomain é tipado (evita "TENANT"/"CONTROLPLANE" solto).
 * - tenantSchema é obrigatório apenas para TENANT e deve ser null para CONTROLPLANE.
 */
public record AuthRefreshSessionData(
        UUID id,
        AuthSessionDomain sessionDomain,
        Long accountId,
        Long userId,
        String tenantSchema,
        String refreshTokenHash,

        Instant createdAt,
        Instant lastUsedAt,
        Instant rotatedAt,
        Instant revokedAt,

        UUID createdRequestId,
        UUID lastRequestId,

        String createdIp,
        String lastIp,

        String createdUserAgent,
        String lastUserAgent,

        String revokedReasonJson
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/auth/app/boundary/AuthRefreshSessionStore.java
============================================================
// src/main/java/brito/com/multitenancy001/shared/auth/app/boundary/AuthRefreshSessionStore.java
package brito.com.multitenancy001.shared.auth.app.boundary;

import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;

import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

/**
 * Boundary para persistência de sessões de refresh (public schema).
 *
 * Regra de arquitetura:
 * - shared.* depende apenas de shared.*
 * - infrastructure.* implementa este boundary via JPA
 */
public interface AuthRefreshSessionStore {

    /**
     * Insere uma nova sessão.
     */
    void insert(AuthRefreshSessionData data);

    /**
     * Busca sessão pelo hash do refresh token.
     */
    Optional<AuthRefreshSessionData> findByRefreshTokenHash(String refreshTokenHash);

    /**
     * Atualiza sessão por rotação do refresh token.
     * (hash antigo -> hash novo)
     */
    void rotate(UUID sessionId,
                String newRefreshTokenHash,
                Instant now,
                UUID requestId,
                String ip,
                String userAgent);

    /**
     * Revoga uma sessão específica.
     */
    void revoke(UUID sessionId,
                Instant now,
                String revokedReasonJson);

    /**
     * Revoga todas as sessões do usuário no domínio + account.
     */
    int revokeAllForUser(AuthSessionDomain sessionDomain,
                         Long accountId,
                         Long userId,
                         Instant now,
                         String revokedReasonJson);
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/auth/app/boundary/RefreshTokenHasher.java
============================================================
package brito.com.multitenancy001.shared.auth.app.boundary;

/**
 * Boundary para hashing de refresh token.
 *
 * Motivo:
 * - Nunca persistir token puro
 * - shared não deve depender de implementação concreta (infra)
 */
public interface RefreshTokenHasher {

    /**
     * Hash canônico do refresh token (ex.: SHA-256 hex).
     */
    String hash(String refreshToken);
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/auth/app/dto/JwtResult.java
============================================================
package brito.com.multitenancy001.shared.auth.app.dto;

import brito.com.multitenancy001.shared.security.SystemRoleName;

public record JwtResult(
        String accessToken,
        String refreshToken,
        String tokenType,
        Long userId,
        String email,
        SystemRoleName role,
        Long accountId,
        String tenantSchema
) {
    public JwtResult {
        if (tokenType == null || tokenType.isBlank()) tokenType = "Bearer";
    }

    public JwtResult(
            String accessToken,
            String refreshToken,
            Long userId,
            String email,
            SystemRoleName role,
            Long accountId,
            String tenantSchema
    ) {
        this(accessToken, refreshToken, "Bearer", userId, email, role, accountId, tenantSchema);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/auth/domain/AuthSessionDomain.java
============================================================
// src/main/java/brito/com/multitenancy001/shared/auth/domain/AuthSessionDomain.java
package brito.com.multitenancy001.shared.auth.domain;

/**
 * Domínio (contexto) de uma sessão de autenticação/refresh.
 *
 * Regras:
 * - TENANT: sessão do contexto "tenant" (exige tenantSchema preenchido).
 * - CONTROLPLANE: sessão do contexto "control plane" (tenantSchema deve ser null).
 */
public enum AuthSessionDomain {
    TENANT,
    CONTROLPLANE
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/billing/PaymentQueryService.java
============================================================
package brito.com.multitenancy001.shared.billing;

import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.domain.billing.PaymentStatus;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

/**
 * Facade de leitura de pagamentos (origem: Control Plane / schema público).
 *
 * Objetivo: permitir que o contexto TENANT consulte pagamentos
 * sem depender diretamente de classes do pacote controlplane.*.
 *
 * Implementação padrão: ControlPlanePaymentQueryService.
 */
public interface PaymentQueryService {

    List<PaymentResponse> findByStatus(PaymentStatus status);

    BigDecimal getTotalPaidInPeriod(Long accountId, Instant startDate, Instant endDate);

    long countCompletedPayments(Long accountId);

    List<PaymentResponse> listByAccount(Long accountId);

    PaymentResponse getByAccount(Long accountId, Long paymentId);

    boolean hasActivePayment(Long accountId);
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/context/RequestMeta.java
============================================================
package brito.com.multitenancy001.shared.context;

import java.util.UUID;

public record RequestMeta(
        UUID requestId,
        String method,
        String uri,
        String ip,
        String userAgent
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/context/RequestMetaContext.java
============================================================
package brito.com.multitenancy001.shared.context;

import org.slf4j.MDC;

import java.util.UUID;

public final class RequestMetaContext {

    private static final ThreadLocal<RequestMeta> HOLDER = new ThreadLocal<>();

    private RequestMetaContext() { }

    public static void set(RequestMeta meta) {
        HOLDER.set(meta);
        if (meta != null && meta.requestId() != null) {
            MDC.put("requestId", meta.requestId().toString());
        }
    }

    public static RequestMeta getOrNull() {
        return HOLDER.get();
    }

    public static UUID requestIdOrNull() {
        RequestMeta meta = HOLDER.get();
        return meta == null ? null : meta.requestId();
    }

    public static void clear() {
        try { HOLDER.remove(); } catch (Exception ignore) {}
        try { MDC.remove("requestId"); } catch (Exception ignore) {}
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/context/TenantContext.java
============================================================
package brito.com.multitenancy001.shared.context;

import brito.com.multitenancy001.shared.db.Schemas;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StringUtils;

@Slf4j
public class TenantContext {

    /**
     * Observação semântica:
     * - PUBLIC = sem tenantSchema (null)
     */
    public static final String PUBLIC_SCHEMA = Schemas.CONTROL_PLANE;

    private static final ThreadLocal<String> TENANT_THREAD_LOCAL = new ThreadLocal<>();

    /**
     * ✅ Retorna o tenantSchema REALMENTE bindado (ou null).
     * public = null
     */
    public static String getOrNull() {
        String tenantSchema = TENANT_THREAD_LOCAL.get();
        return StringUtils.hasText(tenantSchema) ? tenantSchema : null;
    }

    /**
     * ✅ Quando você quer um fallback explícito para public.
     */
    public static String getOrDefaultPublic() {
        String tenantSchema = getOrNull();
        return (tenantSchema != null ? tenantSchema : PUBLIC_SCHEMA);
    }

    public static boolean isPublic() {
        return getOrNull() == null;
    }

    /**
     * ✅ Regra:
     * - NÃO pode mudar tenantSchema dentro de transação.
     * - MAS pode chamar bindTenantSchema() de forma idempotente (sem mudança) dentro de transação.
     *
     * Entrada aqui é "tenantSchema" (já no sentido de execução / contexto).
     * Para "entrada crua" (tenantSchema), isso deve ser tratado antes (provisioning / validação).
     */
    public static void bindTenantSchema(String tenantSchema) {

        String normalizedTenantSchema = (tenantSchema != null ? tenantSchema.trim() : null);
        String targetTenantSchema = StringUtils.hasText(normalizedTenantSchema) ? normalizedTenantSchema : null; // public = null
        String previousTenantSchema = getOrNull(); // já normalizado (public = null)

        // ✅ Sem mudança: não re-binda e evita log repetido
        if ((previousTenantSchema == null && targetTenantSchema == null)
                || (previousTenantSchema != null && previousTenantSchema.equals(targetTenantSchema))) {

            if (log.isDebugEnabled()) {
                log.debug("🔄 TenantContext.bindTenantSchema sem mudança | thread={} | tenantSchema={}",
                        Thread.currentThread().threadId(),
                        (targetTenantSchema != null ? targetTenantSchema : "PUBLIC(null)"));
            }
            return;
        }

        // 🚫 Mudança REAL -> não permitir dentro de transação
        if (TransactionSynchronizationManager.isActualTransactionActive()) {
            throw new IllegalStateException(
                    "🔥 TenantContext.bindTenantSchema chamado DENTRO de transação! tenantSchema=" + tenantSchema
            );
        }

        // aplica mudança
        if (targetTenantSchema == null) {
            TENANT_THREAD_LOCAL.remove();
            log.info("🔄 Tenant bindado para PUBLIC (null) | anterior={} | thread={}",
                    previousTenantSchema, Thread.currentThread().threadId());
        } else {
            TENANT_THREAD_LOCAL.set(targetTenantSchema);
            log.info("🔄 Tenant bindado | thread={} | {} -> {}",
                    Thread.currentThread().threadId(), previousTenantSchema, targetTenantSchema);
        }
    }

    /**
     * Remove qualquer tenantSchema (equivalente a PUBLIC).
     * Prefira usar publicScope()/scope() com try-with-resources.
     */
    public static void clear() {
        String previousTenantSchema = getOrNull();
        if (previousTenantSchema == null) {
            if (log.isDebugEnabled()) {
                log.debug("🧹 TenantContext.clear sem mudança (já estava PUBLIC) | thread={}",
                        Thread.currentThread().threadId());
            }
            return;
        }

        TENANT_THREAD_LOCAL.remove();
        log.info("🧹 Tenant desbindado | thread={} | anterior={}",
                Thread.currentThread().threadId(), previousTenantSchema);
    }

    // ✅ escopo seguro (restaura o tenantSchema anterior ao sair)
    public static Scope scope(String tenantSchema) {
        String previousTenantSchema = getOrNull();
        bindTenantSchema(tenantSchema);
        return new Scope(previousTenantSchema);
    }

    // ✅ escopo PUBLIC explícito (restaura o tenantSchema anterior ao sair)
    public static Scope publicScope() {
        String previousTenantSchema = getOrNull();
        bindTenantSchema(null); // explícito: public = sem tenantSchema
        return new Scope(previousTenantSchema);
    }

    public static final class Scope implements AutoCloseable {
        private final String previousTenantSchema;
        private boolean closed = false;

        private Scope(String previousTenantSchema) {
            this.previousTenantSchema = previousTenantSchema;
        }

        @Override
        public void close() {
            if (!closed) {
                TenantContext.bindTenantSchema(previousTenantSchema); // restaura exatamente o anterior
                closed = true;
            }
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/contracts/AccountRef.java
============================================================
package brito.com.multitenancy001.shared.contracts;

public record AccountRef(
        Long id,
        String tenantSchema,
        String timezone,
        String locale
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/contracts/AccountSnapshot.java
============================================================
package brito.com.multitenancy001.shared.contracts;

public record AccountSnapshot(Long id, String tenantSchema, String slug) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/contracts/TenantUserOperations.java
============================================================
package brito.com.multitenancy001.shared.contracts;

import java.util.List;

/**
 * Contrato (porta) que define as operações que o Control Plane pode executar
 * sobre os usuários de um Tenant.
 *
 * Esta interface vive no módulo 'shared' e representa uma dependência invertida:
 * o Control Plane depende desta abstração, e não de uma implementação concreta do Tenant.
 *
 * A implementação concreta (adaptador) deve ser fornecida pelo módulo 'integration.tenant',
 * que conhece os detalhes de como executar as operações no contexto do Tenant,
 * incluindo a troca de schema via TenantExecutor.
 *
 * Regras de implementação:
 * - Os métodos devem ser idempotentes sempre que possível.
 * - As implementações devem lidar com a troca de schema (tenantSchema) internamente.
 * - Exceções devem ser do tipo ApiException com os códigos apropriados.
 *
 * @see brito.com.multitenancy001.integration.tenant.TenantProvisioningIntegrationService
 */
public interface TenantUserOperations {

    /**
     * Lista os usuários de um tenant.
     *
     * @param tenantSchema    O schema do tenant alvo (obrigatório).
     * @param accountId       O ID da conta (obrigatório).
     * @param onlyOperational Se true, retorna apenas usuários operacionais
     *                        (não deletados e não suspensos por account/admin).
     * @return Uma lista de resumos dos usuários (nunca null).
     * @throws brito.com.multitenancy001.shared.kernel.error.ApiException
     *         Se o tenantSchema for inválido, a conta não for encontrada,
     *         ou o schema do tenant não estiver pronto.
     */
    List<UserSummaryData> listUserSummaries(String tenantSchema, Long accountId, boolean onlyOperational);

    /**
     * Define o status de suspensão por admin de um usuário específico.
     *
     * @param tenantSchema O schema do tenant alvo (obrigatório).
     * @param accountId    O ID da conta (obrigatório).
     * @param userId       O ID do usuário alvo (obrigatório).
     * @param suspended    O novo status de suspensão (true = suspenso, false = reativado).
     * @throws brito.com.multitenancy001.shared.kernel.error.ApiException
     *         Se os parâmetros forem inválidos, o usuário não for encontrado,
     *         ou a operação violar regras de negócio (ex: suspender o último owner).
     */
    void setUserSuspendedByAdmin(String tenantSchema, Long accountId, Long userId, boolean suspended);

    /**
     * Suspende todos os usuários de uma conta, exceto o TENANT_OWNER.
     *
     * @param tenantSchema O schema do tenant alvo (obrigatório).
     * @param accountId    O ID da conta (obrigatório).
     * @return O número de usuários afetados pela operação.
     * @throws brito.com.multitenancy001.shared.kernel.error.ApiException
     *         Se a conta não existir ou se não houver pelo menos um TENANT_OWNER ativo.
     */
    int suspendAllUsersByAccount(String tenantSchema, Long accountId);

    /**
     * Reativa (remove suspensão por account) todos os usuários de uma conta.
     *
     * @param tenantSchema O schema do tenant alvo (obrigatório).
     * @param accountId    O ID da conta (obrigatório).
     * @return O número de usuários afetados pela operação.
     * @throws brito.com.multitenancy001.shared.kernel.error.ApiException
     *         Se a conta não for encontrada.
     */
    int unsuspendAllUsersByAccount(String tenantSchema, Long accountId);

    /**
     * Aplica soft delete em todos os usuários de uma conta, exceto o TENANT_OWNER.
     *
     * @param tenantSchema O schema do tenant alvo (obrigatório).
     * @param accountId    O ID da conta (obrigatório).
     * @return O número de usuários afetados pela operação.
     * @throws brito.com.multitenancy001.shared.kernel.error.ApiException
     *         Se a conta não existir ou se não houver pelo menos um TENANT_OWNER ativo.
     */
    int softDeleteAllUsersByAccount(String tenantSchema, Long accountId);

    /**
     * Restaura todos os usuários de uma conta que foram previamente deletados.
     *
     * @param tenantSchema O schema do tenant alvo (obrigatório).
     * @param accountId    O ID da conta (obrigatório).
     * @return O número de usuários afetados pela operação.
     * @throws brito.com.multitenancy001.shared.kernel.error.ApiException
     *         Se a conta não for encontrada.
     */
    int restoreAllUsersByAccount(String tenantSchema, Long accountId);
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/contracts/UserSummaryData.java
============================================================
package brito.com.multitenancy001.shared.contracts;

import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Snapshot compartilhado (contrato) para representar um usuário do Tenant
 * sem expor a entidade do Tenant (bounded context).
 */
public record UserSummaryData(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRoleName role,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/db/Schemas.java
============================================================
package brito.com.multitenancy001.shared.db;

public final class Schemas {

    /**
     * Schema do Control Plane (tabelas globais).
     * É o schema fallback (root) quando não há tenant bindado.
     */
    public static final String CONTROL_PLANE = "public";

    private Schemas() {}
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/DomainException.java
============================================================
package brito.com.multitenancy001.shared.domain;

public class DomainException extends RuntimeException {
    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public DomainException(String message) {
        super(message);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/EmailNormalizer.java
============================================================
package brito.com.multitenancy001.shared.domain;

public final class EmailNormalizer {

    private EmailNormalizer() { }

    public static String normalizeOrNull(String email) {
        if (email == null) return null;
        String e = email.trim();
        if (e.isEmpty()) return null;
        return e.toLowerCase();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditActor.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public record AuditActor(Long userId, String email) {

    public static AuditActor system() {
        return new AuditActor(null, "system");
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditInfo.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

import jakarta.persistence.Column;
import jakarta.persistence.Embeddable;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;

/**
 * AuditInfo (fonte única) — compatível com o DDL:
 * created_at/created_by/created_by_email
 * updated_at/updated_by/updated_by_email
 * deleted_at/deleted_by/deleted_by_email
 *
 * Semântica:
 * - createdAt/updatedAt/deletedAt: instantes reais (TIMESTAMPTZ)
 * - createdBy/updatedBy/deletedBy: userId (quando aplicável)
 * - createdByEmail/updatedByEmail/deletedByEmail: CITEXT
 */
@Embeddable
@Getter
@Setter
@NoArgsConstructor
public class AuditInfo {

    @Column(name = "created_at", columnDefinition = "timestamptz")
    private Instant createdAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "created_by_email")
    private String createdByEmail;

    @Column(name = "updated_at", columnDefinition = "timestamptz")
    private Instant updatedAt;

    @Column(name = "updated_by")
    private Long updatedBy;

    @Column(name = "updated_by_email")
    private String updatedByEmail;

    @Column(name = "deleted_at", columnDefinition = "timestamptz")
    private Instant deletedAt;

    // ✅ NOVOS CAMPOS: Adicionados para o AuditEntityListener poder preencher
    @Column(name = "deleted_by")
    private Long deletedBy;

    @Column(name = "deleted_by_email")
    private String deletedByEmail;

    // ---------------------------------------------------------------------
    // Lifecycle helpers (usados pelo AuditEntityListener)
    // ---------------------------------------------------------------------

    public void onCreate(AuditActor actor, Instant now) {
        if (now == null) return;

        if (this.createdAt == null) this.createdAt = now;
        if (actor != null) {
            if (this.createdBy == null) this.createdBy = actor.userId();
            if (this.createdByEmail == null) this.createdByEmail = actor.email();
        }

        // created também é update inicial
        this.updatedAt = now;
        if (actor != null) {
            this.updatedBy = actor.userId();
            this.updatedByEmail = actor.email();
        }
    }

    public void onUpdate(AuditActor actor, Instant now) {
        if (now == null) return;

        if (this.createdAt == null) {
            // fallback defensivo (não deveria acontecer em entidades normais)
            this.createdAt = now;
            if (actor != null) {
                this.createdBy = actor.userId();
                this.createdByEmail = actor.email();
            }
        }

        this.updatedAt = now;
        if (actor != null) {
            this.updatedBy = actor.userId();
            this.updatedByEmail = actor.email();
        }
    }

    public void onDelete(AuditActor actor, Instant now) {
        if (now == null) return;

        this.deletedAt = now;
        if (actor != null) {
            this.deletedBy = actor.userId();
            this.deletedByEmail = actor.email();
        }

        // deletar também conta como update
        if (this.createdAt == null) {
            this.createdAt = now;
            if (actor != null) {
                this.createdBy = actor.userId();
                this.createdByEmail = actor.email();
            }
        }

        this.updatedAt = now;
        if (actor != null) {
            this.updatedBy = actor.userId();
            this.updatedByEmail = actor.email();
        }
    }

    public void clearDeleted() {
        this.deletedAt = null;
        this.deletedBy = null;
        this.deletedByEmail = null;
    }

    public boolean isDeleted() {
        return deletedAt != null;
    }

    // ---------------------------------------------------------------------
    // Aliases de compatibilidade (código legado chama mark*)
    // ---------------------------------------------------------------------

    /**
     * Legado: entidades antigas chamam audit.markDeleted(now).
     * Mantemos para evitar quebrar domínio.
     */
    public void markDeleted(Instant now) {
        onDelete(null, now);
    }

    /**
     * Legado (opcional): se houver chamadas antigas.
     */
    public void markCreated(Instant now) {
        onCreate(null, now);
    }

    /**
     * Legado (opcional): se houver chamadas antigas.
     */
    public void markUpdated(Instant now) {
        onUpdate(null, now);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/AuditOutcome.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public enum AuditOutcome {
    ATTEMPT,
    SUCCESS,
    FAILURE,
    DENIED
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/Auditable.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public interface Auditable {
    AuditInfo getAudit();
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/AuthDomain.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

import java.util.Locale;

public enum AuthDomain {
    TENANT("tenant"),
    CONTROLPLANE("controlplane"),
    REFRESH("refresh"),
    PASSWORD_RESET("password_reset");

    private final String dbValue;

    AuthDomain(String dbValue) {
        this.dbValue = dbValue;
    }

    /**
     * Valor persistido no banco/audit (minúsculo, sem mudar DDL).
     */
    public String dbValue() {
        return dbValue;
    }

    /**
     * Valor canônico para JWT/claims (MAIÚSCULO), compatível com o que você já usa hoje:
     * TENANT, CONTROLPLANE, REFRESH, PASSWORD_RESET
     */
    public String tokenValue() {
        return name();
    }

    /**
     * Lê do banco/audit (minúsculo).
     */
    public static AuthDomain fromDbValueOrNull(String raw) {
        if (raw == null) return null;
        String v = raw.trim().toLowerCase(Locale.ROOT);
        for (AuthDomain d : values()) {
            if (d.dbValue.equals(v)) return d;
        }
        return null;
    }

    /**
     * Lê do JWT (MAIÚSCULO) e também aceita legado/minúsculo.
     * - "TENANT" -> TENANT
     * - "tenant" -> TENANT (compat)
     * - "PASSWORD_RESET" -> PASSWORD_RESET
     * - "password_reset" -> PASSWORD_RESET (compat)
     */
    public static AuthDomain fromTokenValueOrNull(String raw) {
        if (raw == null) return null;
        String t = raw.trim();
        if (t.isEmpty()) return null;

        // 1) tenta pelo nome do enum (MAIÚSCULO)
        try {
            return AuthDomain.valueOf(t.toUpperCase(Locale.ROOT));
        } catch (Exception ignore) {}

        // 2) tenta mapear pelo dbValue (minúsculo)
        return fromDbValueOrNull(t);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/AuthDomainConverter.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

@Converter(autoApply = false)
public class AuthDomainConverter implements AttributeConverter<AuthDomain, String> {

    @Override
    public String convertToDatabaseColumn(AuthDomain attribute) {
        return attribute == null ? null : attribute.dbValue();
    }

    @Override
    public AuthDomain convertToEntityAttribute(String dbData) {
        return AuthDomain.fromDbValueOrNull(dbData);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/AuthEventType.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

/**
 * Tipos de eventos de autenticação registrados em audit.
 *
 * IMPORTANTE:
 * - Mantém compatibilidade com os tipos já existentes
 * - Adiciona LOGOUT para logout forte (revogação server-side)
 */
public enum AuthEventType {
    LOGIN_INIT,
    TENANT_SELECTION_REQUIRED,
    LOGIN_CONFIRM,
    LOGIN_SUCCESS,
    LOGIN_FAILURE,
    LOGIN_DENIED,
    TOKEN_REFRESH,
    LOGOUT
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/SecurityAuditActionType.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

/**
 * Tipos de ações registradas na trilha append-only de segurança.
 *
 * Regras:
 * - NÃO remover/renomear valores (quebra histórico).
 * - SÓ adicionar novos valores, preferencialmente no final.
 *
 * Observação:
 * - Os tipos antigos permanecem válidos.
 * - Os novos tipos adicionados dão granularidade SOC2-like.
 */
public enum SecurityAuditActionType {

    // =========================================================
    // Password flows
    // =========================================================

    PASSWORD_RESET_REQUESTED,
    PASSWORD_RESET_COMPLETED,

    /**
     * Troca de senha autenticada (senha atual + nova senha).
     * (Não é reset via token.)
     */
    PASSWORD_CHANGED,

    // =========================================================
    // User administration (CP / Tenant)
    // =========================================================

    USER_CREATED,
    USER_UPDATED,
    USER_SUSPENDED,
    USER_RESTORED,
    ROLE_CHANGED,
    PERMISSIONS_CHANGED,

    // =========================================================
    // SOC2-like additions (append-only)
    // =========================================================

    /**
     * Usuário removido logicamente (soft delete).
     */
    USER_SOFT_DELETED,

    /**
     * Usuário restaurado após soft delete.
     * (Diferente de USER_RESTORED, que costuma ser "unsuspend/reenable".)
     */
    USER_SOFT_RESTORED,

    /**
     * Transferência de ownership (ex.: dono do tenant/conta).
     */
    OWNERSHIP_TRANSFERRED,

    /**
     * Mudança de status administrativa em Account/Tenant (suspend/resume).
     */
    ACCOUNT_STATUS_CHANGED,
    
    // =========================================================
    // Accounts (append-only)
    // =========================================================

    ACCOUNT_SUSPENDED,
    ACCOUNT_RESTORED,
    

    // =========================================================
    // Billing / Payments (append-only)
    // =========================================================

    /**
     * Pagamento criado (ex.: geração de cobrança).
     */
    PAYMENT_CREATED,

    /**
     * Status do pagamento alterado (ex.: PENDING -> PAID).
     */
    PAYMENT_STATUS_CHANGED,

    /**
     * Reembolso solicitado (futuro).
     */
    PAYMENT_REFUND_REQUESTED,

    /**
     * Reembolso concluído (futuro).
     */
    PAYMENT_REFUNDED
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/SoftDeletable.java
============================================================
package brito.com.multitenancy001.shared.domain.audit;

public interface SoftDeletable {
    boolean isDeleted();
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditActorProvider.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;
import brito.com.multitenancy001.shared.security.AuthenticatedPrincipal;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

@Component
public class AuditActorProvider {

    @PostConstruct
    void register() {
        AuditActorProviders.setProvider(this);
    }

    @PreDestroy
    void unregister() {
        AuditActorProviders.clear();
    }

    public AuditActor current() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();

        if (auth == null || !(auth.getPrincipal() instanceof AuthenticatedPrincipal p)) {
            return AuditActor.system();
        }

        return new AuditActor(p.getUserId(), p.getEmail());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditActorProviders.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;

/**
 * Holder estático para permitir que EntityListeners (instanciados pelo JPA)
 * acessem o AuditActorProvider (bean Spring) sem injeção direta.
 *
 * Nota: "SYSTEM" é válido quando não existe usuário autenticado.
 * Mas provider ausente é erro de wiring -> fail-fast quando necessário.
 */
public final class AuditActorProviders {

    private static volatile AuditActorProvider provider;

    private AuditActorProviders() {}

    static void setProvider(AuditActorProvider provider) {
        AuditActorProviders.provider = provider;
    }

    static void clear() {
        AuditActorProviders.provider = null;
    }

    /** Usado por wiring verifier / health-checks internos. */
    public static void requireRegistered() {
        if (provider == null) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditActorProvider NÃO está registrado no AuditActorProviders. " +
                "A auditoria pode registrar tudo como SYSTEM sem você perceber. " +
                "Verifique o bean AuditActorProvider e o @PostConstruct register()."
            );
        }
    }

    /** Fail-fast se provider não estiver registrado (wiring quebrado). */
    public static AuditActor currentOrFail() {
        AuditActorProvider p = provider;
        if (p == null) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditActorProvider ausente (AuditActorProviders.provider == null)."
            );
        }
        return p.current(); // aqui sim pode retornar SYSTEM legitimamente (sem auth)
    }

    /**
     * Mantido por compatibilidade: se provider estiver ausente, retorna SYSTEM.
     * Útil só como "último recurso".
     */
    public static AuditActor currentOrSystem() {
        AuditActorProvider p = provider;
        if (p == null) return AuditActor.system();
        return p.current();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditClockProvider.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import brito.com.multitenancy001.shared.time.AppClock;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import org.springframework.stereotype.Component;

import java.time.Instant;

/**
 * Bean Spring que "liga" AppClock no mundo JPA EntityListener via holder estático.
 */
@Component
public class AuditClockProvider {

    private final AppClock appClock;

    public AuditClockProvider(AppClock appClock) {
        this.appClock = appClock;
    }

    @PostConstruct
    void register() {
        AuditClockProviders.setProvider(this);
    }

    @PreDestroy
    void unregister() {
        AuditClockProviders.clear();
    }

    public Instant appNow() {
        return appClock.instant();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditClockProviders.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import java.time.Instant;

/**
 * Holder estático para permitir que EntityListeners (instanciados pelo JPA)
 * acessem o tempo via AppClock (bean Spring) sem injeção direta.
 *
 * Regra: FAIL-FAST sempre que o provider não estiver registrado.
 */
public final class AuditClockProviders {

    private static volatile AuditClockProvider provider;

    private AuditClockProviders() {}

    static void setProvider(AuditClockProvider provider) {
        AuditClockProviders.provider = provider;
    }

    static void clear() {
        AuditClockProviders.provider = null;
    }

    /** Usado por wiring verifier / health-checks internos. */
    public static void requireRegistered() {
        if (provider == null) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditClockProvider NÃO está registrado no AuditClockProviders. " +
                "Verifique o bean AuditClockProvider e o @PostConstruct register()."
            );
        }
    }

    /** Regra padrão: tempo SEMPRE vem do AppClock (fail-fast se wiring quebrou). */
    public static Instant nowOrFail() {
        AuditClockProvider p = provider;
        if (p == null) {
            throw new IllegalStateException(
                "AUDIT MISCONFIGURATION: AuditClockProvider ausente (AuditClockProviders.provider == null). " +
                "Isso indica que o @PostConstruct do AuditClockProvider não executou ou o bean não foi criado."
            );
        }
        return p.appNow();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditEntityListener.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import java.time.Instant;

import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;

import brito.com.multitenancy001.shared.domain.audit.AuditActor;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;

public class AuditEntityListener {

    @PrePersist
    public void prePersist(Object entity) {
        if (!(entity instanceof Auditable auditable)) return;

        // FAIL-FAST se wiring quebrou (provider ausente)
        AuditActor actor = AuditActorProviders.currentOrFail();
        Instant now = AuditClockProviders.nowOrFail();

        auditable.getAudit().onCreate(actor, now);

        if (entity instanceof SoftDeletable softDeletable
                && softDeletable.isDeleted()
                && auditable.getAudit().getDeletedAt() == null) {
            auditable.getAudit().onDelete(actor, now);
        }
    }

    @PreUpdate
    public void preUpdate(Object entity) {
        if (!(entity instanceof Auditable auditable)) return;

        AuditActor actor = AuditActorProviders.currentOrFail();
        Instant now = AuditClockProviders.nowOrFail();

        auditable.getAudit().onUpdate(actor, now);

        if (entity instanceof SoftDeletable softDeletable
                && softDeletable.isDeleted()
                && auditable.getAudit().getDeletedAt() == null) {
            auditable.getAudit().onDelete(actor, now);
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/audit/jpa/AuditWiringVerifier.java
============================================================
package brito.com.multitenancy001.shared.domain.audit.jpa;

import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import jakarta.annotation.PostConstruct;
import jakarta.persistence.EntityManager;
import jakarta.persistence.metamodel.EntityType;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * Verificador FAIL-FAST (ENFORCED) para auditoria.
 *
 * O que valida no startup:
 *
 * 1) Wiring obrigatório:
 *    - AuditActorProvider registrado
 *    - AuditClockProvider registrado
 *
 * 2) Modelo obrigatório (SaaS-grade):
 *    - toda @Entity do TENANT => implements {@link Auditable}
 *    - toda @Entity com assinatura de soft delete => implements {@link SoftDeletable}
 *
 * Resultado:
 * - Se houver violações, quebra o startup com "lista de violações" (estilo compliance verifier).
 *
 * Heurísticas (ajuste se necessário):
 * - "Tenant entity" = package contém ".tenant." e NÃO contém ".controlplane." e NÃO contém ".publicschema."
 * - "Soft delete signature" = campo deleted (boolean/Boolean) OU método isDeleted() OU métodos softDelete()/restore()
 */
@Component
@RequiredArgsConstructor
public class AuditWiringVerifier {

    private final EntityManager entityManager;

    @PostConstruct
    public void verifyAuditWiring() {
        /* Verifica wiring e enforcement de modelo (fail-fast). */

        // -------------------------------------------------
        // 1) Wiring obrigatório (como hoje)
        // -------------------------------------------------
        AuditActorProviders.requireRegistered();
        AuditClockProviders.requireRegistered();

        // -------------------------------------------------
        // 2) Enforced model checks
        // -------------------------------------------------
        List<String> violations = new ArrayList<>();

        for (EntityType<?> et : entityManager.getMetamodel().getEntities()) {
            Class<?> javaType = et.getJavaType();
            if (javaType == null) continue;

            if (!isTenantEntity(javaType)) continue;

            // tenant @Entity => Auditable
            if (!Auditable.class.isAssignableFrom(javaType)) {
                violations.add("[TENANT_ENTITY_NOT_AUDITABLE] " + javaType.getName()
                        + " => deve implementar Auditable");
            }

            // soft delete signature => SoftDeletable
            if (looksLikeSoftDelete(javaType) && !SoftDeletable.class.isAssignableFrom(javaType)) {
                violations.add("[SOFT_DELETE_WITHOUT_SOFTDELETABLE] " + javaType.getName()
                        + " => parece ter soft delete (deleted/isDeleted/softDelete/restore), mas não implementa SoftDeletable");
            }
        }

        if (!violations.isEmpty()) {
            violations.sort(Comparator.naturalOrder());
            throw new IllegalStateException(buildFailFastMessage(violations));
        }
    }

    private static boolean isTenantEntity(Class<?> type) {
        /* Decide por package se a entidade pertence ao bounded context TENANT. */
        Package p = type.getPackage();
        String name = (p == null) ? "" : p.getName();

        if (!name.contains(".tenant.")) return false;
        if (name.contains(".controlplane.")) return false;
        if (name.contains(".publicschema.")) return false;

        return true;
    }

    private static boolean looksLikeSoftDelete(Class<?> type) {
        /* Heurística para detectar assinatura típica de soft delete no domínio. */

        // Campo "deleted"
        Field deleted = findField(type, "deleted");
        if (deleted != null && (deleted.getType() == boolean.class || deleted.getType() == Boolean.class)) {
            return true;
        }

        // Método "isDeleted()"
        Method isDeleted = findNoArgMethod(type, "isDeleted");
        if (isDeleted != null && (isDeleted.getReturnType() == boolean.class || isDeleted.getReturnType() == Boolean.class)) {
            return true;
        }

        // Métodos comuns de domínio
        if (findNoArgMethod(type, "softDelete") != null) return true;
        if (findNoArgMethod(type, "restore") != null) return true;

        return false;
    }

    private static Field findField(Class<?> type, String fieldName) {
        /* Procura campo por nome subindo a hierarquia. */
        Class<?> c = type;
        while (c != null && c != Object.class) {
            try {
                return c.getDeclaredField(fieldName);
            } catch (NoSuchFieldException ignored) {
                c = c.getSuperclass();
            }
        }
        return null;
    }

    private static Method findNoArgMethod(Class<?> type, String methodName) {
        /* Procura método sem args por nome subindo a hierarquia. */
        Class<?> c = type;
        while (c != null && c != Object.class) {
            for (Method m : c.getDeclaredMethods()) {
                if (m.getName().equals(methodName) && m.getParameterCount() == 0) {
                    return m;
                }
            }
            c = c.getSuperclass();
        }
        return null;
    }

    private static String buildFailFastMessage(List<String> violations) {
        /* Monta mensagem estilo compliance verifier para troubleshooting rápido. */
        StringBuilder sb = new StringBuilder();
        sb.append("AUDIT_WIRING_VERIFIER_FAILED (ENFORCED)\n\n");
        sb.append("Foram encontradas violações de auditoria:\n\n");
        for (String v : violations) {
            sb.append(" - ").append(v).append("\n");
        }
        sb.append("\nRegras enforced:\n");
        sb.append(" - tenant @Entity => implements Auditable\n");
        sb.append(" - soft delete signature => implements SoftDeletable\n");
        return sb.toString();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentGateway.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentGateway {
    MERCADOPAGO, STRIPE, PAGSEGURO, MANUAL
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentMethod.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentMethod {
    PIX, BOLETO, CREDIT_CARD, DEBIT_CARD, TRANSFER, CASH
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/billing/PaymentStatus.java
============================================================
package brito.com.multitenancy001.shared.domain.billing;

public enum PaymentStatus {
    PENDING("Pendente"),
    COMPLETED("Concluído"),
    FAILED("Falhou"),
    REFUNDED("Reembolsado"),
    CANCELLED("Cancelado"),
    EXPIRED("Expirado");

    private final String description;

    PaymentStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    public boolean isSuccessful() {
        return this == COMPLETED;
    }

    public boolean isFinal() {
        return this != PENDING;
    }

    public static PaymentStatus fromString(String status) {
        if (status == null) return PENDING;
        try {
            return PaymentStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            return PENDING;
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/domain/common/EntityOrigin.java
============================================================
package brito.com.multitenancy001.shared.domain.common;

/**
 * Origem de criação de entidades administrativas (seed, painel, integrações).
 *
 * Mantida em shared para evitar duplicação e vazamento de boundary
 * (controlplane <-> tenant).
 */
public enum EntityOrigin {
    BUILT_IN,
    ADMIN,
    API
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/executor/PublicSchemaExecutor.java
============================================================
package brito.com.multitenancy001.shared.executor;

import java.util.function.Supplier;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.shared.context.TenantContext;


/**
 * Executor utilitário para forçar execução no schema PUBLIC (Control Plane).
 *
 * <p>Objetivo:</p>
 * <ul>
 *   <li>Garantir que operações de leitura/escrita do Control Plane ocorram no schema correto, independentemente do
 *       contexto atual do request (tenant vs public).</li>
 * </ul>
 *
 * <p>Uso recomendado:</p>
 * <ul>
 *   <li>Qualquer acesso a tabelas do Control Plane deve ser executado via {@code inPublic(...)}.</li>
 *   <li>Para operações com transação, preferir {@code PublicSchemaUnitOfWork.tx(...)}.</li>
 * </ul>
 *
 * <p>Observação:</p>
 * <ul>
 *   <li>Este executor não define transação; ele apenas aplica o escopo de schema via {@code TenantContext}.</li>
 * </ul>
 */
@Component
public class PublicSchemaExecutor {

    // ---------------------------------------------------------------------
    // ✅ PADRÃO CANÔNICO (preferido)
    // ---------------------------------------------------------------------

    /**
     * Executa a função no schema PUBLIC (Control Plane).
     * Preferir este método em todo código novo.
     */
    public <T> T inPublic(Supplier<T> supplier) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            return supplier.get();
        }
    }

    /**
     * Executa o runnable no schema PUBLIC (Control Plane).
     * Preferir este método em todo código novo.
     */
    public void inPublic(Runnable runnable) {
        try (TenantContext.Scope ignored = TenantContext.publicScope()) {
            runnable.run();
        }
    }

    public TenantContext.Scope publicSchemaScope() {
        return TenantContext.publicScope();
    }

  
   
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/executor/PublicSchemaUnitOfWork.java
============================================================
package brito.com.multitenancy001.shared.executor;

import java.util.Map;
import java.util.function.Supplier;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.transaction.support.TransactionSynchronizationManager;

import brito.com.multitenancy001.infrastructure.persistence.TxExecutor;
import lombok.RequiredArgsConstructor;

/**
 * Unidade de trabalho explícita para operações no Public Schema (Control Plane).
 *
 * <p><b>Responsabilidades:</b></p>
 * <ul>
 *   <li>Controlar fronteiras transacionais no PUBLIC.</li>
 *   <li>Diferenciar operações read-only vs comandos (write).</li>
 *   <li>Evitar vazamento de {@code @Transactional} espalhado na aplicação.</li>
 * </ul>
 *
 * <p><b>Regra crítica:</b></p>
 * <ul>
 *   <li>PUBLIC não deve ser iniciado dentro de um TX de outro TransactionManager.
 *       Isso tende a causar: "Pre-bound JDBC Connection found!".</li>
 * </ul>
 *
 * <p><b>Observabilidade:</b> adiciona logs quando é chamado com transação já ativa no thread.</p>
 */
@Component
@RequiredArgsConstructor
public class PublicSchemaUnitOfWork {

    private static final Logger log = LoggerFactory.getLogger(PublicSchemaUnitOfWork.class);

    private final PublicSchemaExecutor publicExecutor;
    private final TxExecutor transactionExecutor;

    // REQUIRED
    public <T> T tx(Supplier<T> fn) {
        warnIfCalledInsideExistingTx("tx(REQUIRED)");
        return publicExecutor.inPublic(() -> transactionExecutor.inPublicTx(fn));
    }

    public void tx(Runnable fn) {
        warnIfCalledInsideExistingTx("tx(REQUIRED)");
        publicExecutor.inPublic(() -> transactionExecutor.inPublicTx(fn));
    }

    // REQUIRES_NEW
    public <T> T requiresNew(Supplier<T> fn) {
        warnIfCalledInsideExistingTx("requiresNew(REQUIRES_NEW)");
        return publicExecutor.inPublic(() -> transactionExecutor.inPublicRequiresNew(fn));
    }

    public void requiresNew(Runnable fn) {
        warnIfCalledInsideExistingTx("requiresNew(REQUIRES_NEW)");
        publicExecutor.inPublic(() -> transactionExecutor.inPublicRequiresNew(fn));
    }

    // READ ONLY
    public <T> T readOnly(Supplier<T> fn) {
        warnIfCalledInsideExistingTx("readOnly(REQUIRED, readOnly=true)");
        return publicExecutor.inPublic(() -> transactionExecutor.inPublicReadOnlyTx(fn));
    }

    public void readOnly(Runnable fn) {
        warnIfCalledInsideExistingTx("readOnly(REQUIRED, readOnly=true)");
        publicExecutor.inPublic(() -> transactionExecutor.inPublicReadOnlyTx(fn));
    }

    // REQUIRES_NEW READ ONLY
    public <T> T requiresNewReadOnly(Supplier<T> fn) {
        warnIfCalledInsideExistingTx("requiresNewReadOnly(REQUIRES_NEW, readOnly=true)");
        return publicExecutor.inPublic(() -> transactionExecutor.inPublicRequiresNewReadOnly(fn));
    }

    public void requiresNewReadOnly(Runnable fn) {
        warnIfCalledInsideExistingTx("requiresNewReadOnly(REQUIRES_NEW, readOnly=true)");
        publicExecutor.inPublic(() -> transactionExecutor.inPublicRequiresNewReadOnly(fn));
    }

    private static void warnIfCalledInsideExistingTx(String op) {
        if (!TransactionSynchronizationManager.isActualTransactionActive()) return;

        Map<Object, Object> resources = TransactionSynchronizationManager.getResourceMap();
        log.warn("⚠️ PUBLIC UoW chamado com transação já ativa no thread | op={} | resources={}",
                op, summarizeResources(resources));
    }

    private static String summarizeResources(Map<Object, Object> resources) {
        if (resources == null || resources.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        boolean first = true;
        for (var e : resources.entrySet()) {
            if (!first) sb.append(", ");
            first = false;
            Object k = e.getKey();
            Object v = e.getValue();
            sb.append(k == null ? "null" : k.getClass().getName())
              .append("->")
              .append(v == null ? "null" : v.getClass().getName());
        }
        sb.append("]");
        return sb.toString();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/json/JsonDetailsMapper.java
============================================================
package brito.com.multitenancy001.shared.json;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.NullNode;
import com.fasterxml.jackson.databind.node.TextNode;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class JsonDetailsMapper {

    private final ObjectMapper objectMapper;

    public JsonNode toJsonNode(Object details) {
        if (details == null) return NullNode.getInstance();

        if (details instanceof JsonNode node) {
            return node;
        }

        if (details instanceof String s) {
            if (s.isBlank()) return NullNode.getInstance();
            try {
                return objectMapper.readTree(s); // se for JSON válido, vira JsonNode
            } catch (Exception ignored) {
                return TextNode.valueOf(s); // compat: texto puro vira JSON string
            }
        }

        // Map, DTO, record, etc.
        return objectMapper.valueToTree(details);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/kernel/error/ApiException.java
============================================================
package brito.com.multitenancy001.shared.kernel.error;

import brito.com.multitenancy001.shared.api.error.ApiErrorCategory;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import lombok.Getter;

import java.util.List;
import java.util.Objects;

/**
 * Exceção padrão de API (VERSÃO ENFORCED).
 *
 * Regras:
 * - O "error" do payload é sempre code.name().
 * - O status default vem de ApiErrorCode.httpStatus().
 * - Não existe construtor público que permita "inventar" status no call site.
 * - A mensagem default vem de ApiErrorCode.defaultMessage() quando não informada.
 */
@Getter
public class ApiException extends RuntimeException {

    private static final long serialVersionUID = 1L;

    /** Código exposto no payload (sempre enum.name()). */
    private final String error;

    /** Status HTTP a ser retornado (sempre derivado do enum). */
    private final int status;

    /** Campos adicionais (quando aplicável). */
    private final String field;
    private final String invalidValue;
    private final List<String> allowedValues;
    private final Object details;

    /** Metadados tipados. */
    private final ApiErrorCode code;
    private final ApiErrorCategory category;

    // =========================
    // Construtores (enforced)
    // =========================

    public ApiException(ApiErrorCode code) {
        this(code, null, null, null, null, null);
    }

    public ApiException(ApiErrorCode code, String message) {
        this(code, message, null, null, null, null);
    }

    public ApiException(ApiErrorCode code, String message, Object details) {
        this(code, message, null, null, null, details);
    }

    public ApiException(
            ApiErrorCode code,
            String message,
            String field,
            String invalidValue,
            List<String> allowedValues,
            Object details
    ) {
        super(resolveMessage(code, message));

        ApiErrorCode safeCode = (code != null ? code : ApiErrorCode.INTERNAL_SERVER_ERROR);

        this.code = safeCode;
        this.category = safeCode.category();

        this.error = safeCode.name();
        this.status = resolveStatus(safeCode);

        this.field = field;
        this.invalidValue = invalidValue;
        this.allowedValues = allowedValues;
        this.details = details;
    }

    // =========================
    // Helpers
    // =========================

    private static String resolveMessage(ApiErrorCode code, String message) {
        if (message != null && !message.isBlank()) return message;
        if (code != null && code.defaultMessage() != null && !code.defaultMessage().isBlank()) return code.defaultMessage();
        return "Erro";
    }

    private static int resolveStatus(ApiErrorCode code) {
        return Objects.requireNonNull(code, "code").httpStatus();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/net/IpAddressMapper.java
============================================================
package brito.com.multitenancy001.shared.net;

import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.net.InetAddress;

@Component
public class IpAddressMapper {

    public InetAddress toInetAddressOrNull(String raw) {
        if (!StringUtils.hasText(raw)) return null;

        // Tomcat às vezes entrega "0:0:0:0:0:0:0:1" (IPv6 localhost)
        String v = raw.trim();

        // Se vier com porta tipo "127.0.0.1:12345" (depende de proxy/header), remove porta.
        int colon = v.lastIndexOf(':');
        if (colon > -1 && v.indexOf('.') > -1) { // heurística simples p/ IPv4 com porta
            String maybePort = v.substring(colon + 1);
            if (maybePort.chars().allMatch(Character::isDigit)) {
                v = v.substring(0, colon);
            }
        }

        try {
            return InetAddress.getByName(v);
        } catch (Exception ignored) {
            return null; // não deixa auditoria derrubar login
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/PgColumnTypes.java
============================================================
package brito.com.multitenancy001.shared.persistence;

/**
 * Constantes de tipos Postgres para usar em @Column(columnDefinition = ...).
 * Evita typo e padroniza o projeto.
 */
public final class PgColumnTypes {

    public static final String TIMESTAMPTZ = "timestamptz";
    public static final String DATE = "date";
    public static final String JSONB = "jsonb";
    public static final String INET = "inet";
    public static final String TEXT = "TEXT";

    private PgColumnTypes() {
        // utility class
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsGuard.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsGuard {

    private final AccountRepository accountRepository;
    private final AccountEntitlementsService accountEntitlementsService;
    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;

    public void assertCanCreateUser(Long accountId, long currentUsers) {
        if (accountId == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "AccountId obrigatório", 400);
        }

        // ✅ PRECISA ser TX normal, porque pode provisionar entitlements
        publicSchemaUnitOfWork.tx(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404));

            accountEntitlementsService.assertCanCreateUser(account, currentUsers);
        });
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsService.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import brito.com.multitenancy001.controlplane.accounts.app.AccountEntitlementsProvisioningService;
import brito.com.multitenancy001.controlplane.accounts.domain.Account;
import brito.com.multitenancy001.controlplane.accounts.domain.AccountEntitlements;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountEntitlementsRepository;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AccountEntitlementsService {

    private final AccountEntitlementsRepository accountEntitlementsRepository;
    private final AccountEntitlementsProvisioningService provisioningService;
    private final AccountRepository accountRepository;
    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;

    /**
     * Resolve entitlements efetivos da conta.
     * ✅ TX normal porque pode provisionar default entitlements.
     */
    public AccountEntitlementsSnapshot resolveEffective(Account account) {
        return publicSchemaUnitOfWork.tx(() -> resolveEffectiveInternal(account));
    }

    /**
     * ✅ NOVO: usado na camada TENANT para expor entitlements (apenas para TENANT_OWNER)
     * Resolve entitlements efetivos por accountId.
     * ✅ TX normal porque pode provisionar default entitlements.
     */
    public AccountEntitlementsSnapshot resolveEffectiveByAccountId(Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);

        return publicSchemaUnitOfWork.tx(() -> {
            Account account = accountRepository.findByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404));

            return resolveEffectiveInternal(account);
        });
    }

    // =========================================================
    // QUOTAS / ASSERTS (compatível com AccountEntitlementsGuard)
    // =========================================================

    public boolean canCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        return currentUsers < eff.maxUsers();
    }

    public void assertCanCreateUser(Account account, long currentUsers) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        if (currentUsers >= eff.maxUsers()) {
            throw new ApiException(ApiErrorCode.QUOTA_MAX_USERS_REACHED, "Limite de usuários atingido para este plano", 403);
        }
    }

    public boolean canCreateProduct(Account account, long currentProducts) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        return currentProducts < eff.maxProducts();
    }

    public void assertCanCreateProduct(Account account, long currentProducts) {
        AccountEntitlementsSnapshot eff = resolveEffective(account);
        if (currentProducts >= eff.maxProducts()) {
            throw new ApiException(ApiErrorCode.QUOTA_MAX_PRODUCTS_REACHED, "Limite de produtos atingido para este plano", 403);
        }
    }

    public void assertCanConsumeStorage(Account account, long currentStorageMb, long deltaMb) {
        if (deltaMb < 0) {
            throw new ApiException(ApiErrorCode.INVALID_STORAGE_DELTA, "deltaMb não pode ser negativo", 400);
        }

        AccountEntitlementsSnapshot eff = resolveEffective(account);
        long after = currentStorageMb + deltaMb;

        if (after > eff.maxStorageMb()) {
            throw new ApiException(ApiErrorCode.QUOTA_MAX_STORAGE_REACHED, "Limite de armazenamento atingido para este plano", 403);
        }
    }

    // =========================================================
    // INTERNALS (sem tx aqui)
    // =========================================================

    private AccountEntitlementsSnapshot resolveEffectiveInternal(Account account) {
        if (account == null || account.getId() == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "Conta é obrigatória", 400);
        }

        // BUILT_IN/PLATFORM => ilimitado
        if (account.isBuiltInAccount()) {
            return AccountEntitlementsSnapshot.ofUnlimited();
        }

        AccountEntitlements ent = accountEntitlementsRepository
                .findByAccount_Id(account.getId())
                .orElse(null);

        if (ent == null) {
            // provisiona default (idempotente / race-safe)
            ent = provisioningService.ensureDefaultEntitlementsForTenant(account);
        }

        if (ent == null) {
            throw new ApiException(ApiErrorCode.ENTITLEMENTS_UNEXPECTED_NULL, "Entitlements inesperadamente nulos", 500);
        }

        Integer maxUsers = safePositive(ent.getMaxUsers(), "maxUsers");
        Integer maxProducts = safePositive(ent.getMaxProducts(), "maxProducts");
        Integer maxStorageMb = safePositive(ent.getMaxStorageMb(), "maxStorageMb");

        return AccountEntitlementsSnapshot.ofLimited(maxUsers, maxProducts, maxStorageMb);
    }

    private Integer safePositive(Integer value, String field) {
        if (value == null || value <= 0) {
            throw new ApiException(ApiErrorCode.INVALID_ENTITLEMENT, "Entitlement inválido: " + field, 500);
        }
        return value;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountEntitlementsSnapshot.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

public record AccountEntitlementsSnapshot(
        int maxUsers,
        int maxProducts,
        int maxStorageMb,
        boolean unlimited
) {

    public static AccountEntitlementsSnapshot ofUnlimited() {
        return new AccountEntitlementsSnapshot(
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                Integer.MAX_VALUE,
                true
        );
    }

    public static AccountEntitlementsSnapshot ofLimited(int maxUsers, int maxProducts, int maxStorageMb) {
        return new AccountEntitlementsSnapshot(maxUsers, maxProducts, maxStorageMb, false);
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountResolver.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import java.time.Instant;

import org.springframework.stereotype.Service;

import brito.com.multitenancy001.controlplane.accounts.persistence.AccountRepository;
import brito.com.multitenancy001.controlplane.accounts.persistence.AccountResolverProjection;
import brito.com.multitenancy001.shared.executor.PublicSchemaExecutor;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class AccountResolver {

    private final AccountRepository accountRepository;
    private final AppClock appClock;
    private final PublicSchemaExecutor publicExecutor;

    public AccountSnapshot resolveActiveAccountBySlug(String slug) {
        return publicExecutor.inPublic(() -> {
            Instant now = appClock.instant();

            AccountResolverProjection p = accountRepository.findProjectionBySlugAndDeletedFalseIgnoreCase(slug)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404));

            if (!isOperational(p, now)) {
                throw new ApiException(ApiErrorCode.ACCOUNT_INACTIVE, "Conta inativa", 403);
            }

            return new AccountSnapshot(p.getId(), p.getTenantSchema(), p.getSlug(), p.getDisplayName());
        });
    }

    public AccountSnapshot resolveActiveAccountById(Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.INVALID_ACCOUNT, "accountId inválido", 400);
        return resolveActiveAccountByIdInternal(accountId);
    }

    private AccountSnapshot resolveActiveAccountByIdInternal(Long accountId) {
        return publicExecutor.inPublic(() -> {
            Instant now = appClock.instant();

            AccountResolverProjection p = accountRepository.findProjectionByIdAndDeletedFalse(accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404));

            if (!isOperational(p, now)) {
                throw new ApiException(ApiErrorCode.ACCOUNT_INACTIVE, "Conta inativa", 403);
            }

            return new AccountSnapshot(p.getId(), p.getTenantSchema(), p.getSlug(), p.getDisplayName());
        });
    }

    private boolean isOperational(AccountResolverProjection p, Instant now) {
        if (p == null) return false;

        if ("BUILT_IN".equalsIgnoreCase(p.getOrigin())) return true;

        String status = p.getStatus();
        if ("ACTIVE".equalsIgnoreCase(status)) return true;

        if ("FREE_TRIAL".equalsIgnoreCase(status)) {
            return p.getTrialEndAt() != null && now != null && p.getTrialEndAt().isAfter(now);
        }

        return false;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/AccountSnapshot.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

public record AccountSnapshot(
        Long id,
        String tenantSchema,
        String slug,
        String displayName
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityProvisioningService.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.TransactionSynchronizationManager;

import java.util.Map;

/**
 * Provisionamento de Login Identities (schema PUBLIC).
 *
 * <p><b>Objetivo:</b></p>
 * <ul>
 *   <li>Garantir que fluxos de login (tenant e control-plane) consigam resolver "candidatos" por e-mail</li>
 *   <li>Evitar joins complexos/ambíguos em múltiplos schemas durante a autenticação</li>
 * </ul>
 *
 * <p><b>Importante (transação):</b></p>
 * <ul>
 *   <li>Este serviço <b>SEMPRE</b> opera no PUBLIC schema.</li>
 *   <li>Para evitar ambiguidades, usamos explicitamente {@code transactionManager="publicTransactionManager"}.</li>
 * </ul>
 *
 * <p><b>Diagnóstico:</b></p>
 * <ul>
 *   <li>Se for invocado com uma transação já ativa no thread, logamos warning com resources bindados.</li>
 *   <li>Isso ajuda a detectar cenários de “pre-bound JDBC connection” antes de abrir TX JPA.</li>
 * </ul>
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class LoginIdentityProvisioningService {

    private final JdbcTemplate jdbcTemplate;

    @Transactional(
            transactionManager = "publicTransactionManager",
            propagation = Propagation.REQUIRED
    )
    public void ensureTenantIdentity(String email, Long accountId) {
        if (accountId == null) return;

        String emailNorm = EmailNormalizer.normalizeOrNull(email);
        if (emailNorm == null) return;

        warnIfActiveTx("ensureTenantIdentity", emailNorm, accountId);

        String sql =
                "INSERT INTO public.login_identities (email, subject_type, subject_id, account_id)\n" +
                "VALUES (?, ?::text, ?, ?)\n" +
                "ON CONFLICT (email, account_id) WHERE subject_type = ?::text\n" +
                "DO NOTHING";

        int rows = jdbcTemplate.update(
                sql,
                emailNorm,
                LoginIdentitySubjectType.TENANT_ACCOUNT.name(),
                accountId,
                accountId,
                LoginIdentitySubjectType.TENANT_ACCOUNT.name()
        );

        if (log.isDebugEnabled()) {
            log.debug("🧩 login_identity ensured (tenant) | email={} | accountId={} | rows={}",
                    emailNorm, accountId, rows);
        }
    }

    @Transactional(
            transactionManager = "publicTransactionManager",
            propagation = Propagation.REQUIRED
    )
    public void deleteTenantIdentity(String email, Long accountId) {
        if (accountId == null) return;

        String emailNorm = EmailNormalizer.normalizeOrNull(email);
        if (emailNorm == null) return;

        warnIfActiveTx("deleteTenantIdentity", emailNorm, accountId);

        String sql =
                "DELETE FROM public.login_identities\n" +
                " WHERE subject_type = ?::text\n" +
                "   AND email = ?\n" +
                "   AND account_id = ?";

        int rows = jdbcTemplate.update(sql,
                LoginIdentitySubjectType.TENANT_ACCOUNT.name(),
                emailNorm,
                accountId
        );

        if (log.isDebugEnabled()) {
            log.debug("🧹 login_identity deleted (tenant) | email={} | accountId={} | rows={}",
                    emailNorm, accountId, rows);
        }
    }

    @Transactional(
            transactionManager = "publicTransactionManager",
            propagation = Propagation.REQUIRED
    )
    public void ensureControlPlaneIdentity(String email, Long controlPlaneUserId) {
        if (controlPlaneUserId == null) return;

        String emailNorm = EmailNormalizer.normalizeOrNull(email);
        if (emailNorm == null) return;

        warnIfActiveTx("ensureControlPlaneIdentity", emailNorm, null);

        String sql =
                "INSERT INTO public.login_identities (email, subject_type, subject_id, account_id)\n" +
                "VALUES (?, ?::text, ?, NULL)\n" +
                "ON CONFLICT (subject_type, subject_id) WHERE subject_type = ?::text\n" +
                "DO UPDATE SET email = EXCLUDED.email";

        int rows = jdbcTemplate.update(sql,
                emailNorm,
                LoginIdentitySubjectType.CONTROLPLANE_USER.name(),
                controlPlaneUserId,
                LoginIdentitySubjectType.CONTROLPLANE_USER.name()
        );

        if (log.isDebugEnabled()) {
            log.debug("🧩 login_identity ensured (cp) | email={} | controlPlaneUserId={} | rows={}",
                    emailNorm, controlPlaneUserId, rows);
        }
    }

    @Transactional(
            transactionManager = "publicTransactionManager",
            propagation = Propagation.REQUIRED
    )
    public void deleteControlPlaneIdentityByUserId(Long controlPlaneUserId) {
        if (controlPlaneUserId == null) return;

        warnIfActiveTx("deleteControlPlaneIdentityByUserId", null, null);

        String sql =
                "DELETE FROM public.login_identities\n" +
                " WHERE subject_type = ?::text\n" +
                "   AND subject_id = ?";

        int rows = jdbcTemplate.update(sql,
                LoginIdentitySubjectType.CONTROLPLANE_USER.name(),
                controlPlaneUserId
        );

        if (log.isDebugEnabled()) {
            log.debug("🧹 login_identity deleted (cp) | controlPlaneUserId={} | rows={}",
                    controlPlaneUserId, rows);
        }
    }

    @Transactional(
            transactionManager = "publicTransactionManager",
            propagation = Propagation.REQUIRED
    )
    public void moveControlPlaneIdentity(Long controlPlaneUserId, String newEmail) {
        if (controlPlaneUserId == null) return;

        String emailNorm = EmailNormalizer.normalizeOrNull(newEmail);
        if (emailNorm == null) return;

        warnIfActiveTx("moveControlPlaneIdentity", emailNorm, null);

        String updateSql =
                "UPDATE public.login_identities\n" +
                "   SET email = ?\n" +
                " WHERE subject_type = ?::text\n" +
                "   AND subject_id = ?";

        int updated = jdbcTemplate.update(updateSql,
                emailNorm,
                LoginIdentitySubjectType.CONTROLPLANE_USER.name(),
                controlPlaneUserId
        );

        if (updated == 0) {
            ensureControlPlaneIdentity(emailNorm, controlPlaneUserId);
        }

        if (log.isDebugEnabled()) {
            log.debug("🔁 login_identity moved (cp) | controlPlaneUserId={} | email={} | updated={}",
                    controlPlaneUserId, emailNorm, updated);
        }
    }

    private static void warnIfActiveTx(String op, String emailNorm, Long accountId) {
        if (!TransactionSynchronizationManager.isActualTransactionActive()) return;

        Map<Object, Object> resources = TransactionSynchronizationManager.getResourceMap();
        log.warn("⚠️ LoginIdentityProvisioningService chamado com TX já ativa | op={} | email={} | accountId={} | resourcesKeys={}",
                op,
                emailNorm,
                accountId,
                summarizeResourceKeys(resources));
    }

    private static String summarizeResourceKeys(Map<Object, Object> resources) {
        if (resources == null || resources.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        boolean first = true;
        for (Object k : resources.keySet()) {
            if (!first) sb.append(", ");
            first = false;
            sb.append(k == null ? "null" : k.getClass().getName());
        }
        sb.append("]");
        return sb.toString();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityResolver.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * Resolver de login identities no schema PUBLIC.
 *
 * <p><b>Responsabilidade:</b> executar consultas pequenas e determinísticas
 * para resolver identidades usadas no fluxo de login.</p>
 *
 * <p><b>Transação:</b>
 * as operações são read-only e rodam no PUBLIC; usamos {@code SUPPORTS} para:
 * <ul>
 *   <li>participar de TX existente (se houver)</li>
 *   <li>não “forçar” abertura de TX se o chamador não precisar</li>
 * </ul>
 * sempre com {@code transactionManager="publicTransactionManager"} para evitar ambiguidades.</p>
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class LoginIdentityResolver {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Transactional(
            transactionManager = "publicTransactionManager",
            readOnly = true,
            propagation = Propagation.SUPPORTS
    )
    public List<LoginIdentityRow> findTenantAccountsByEmail(String email) {
        String normalized = EmailNormalizer.normalizeOrNull(email);
        if (normalized == null) return List.of();

        String sql = """
            select li.account_id,
                   a.display_name,
                   a.slug
              from public.login_identities li
              join public.accounts a on a.id = li.account_id
             where li.email = :email
               and li.subject_type = 'TENANT_ACCOUNT'
               and a.deleted = false
        """;

        var params = new MapSqlParameterSource("email", normalized);

        List<LoginIdentityRow> out = jdbcTemplate.query(sql, params, (rs, rowNum) -> new LoginIdentityRow(
                rs.getLong("account_id"),
                rs.getString("display_name"),
                rs.getString("slug")
        ));

        if (log.isDebugEnabled()) {
            log.debug("🔎 findTenantAccountsByEmail | email={} | rows={}", normalized, out.size());
        }

        return out;
    }

    /**
     * Resolve o Control Plane user por e-mail via login_identities.
     *
     * <p>Retorna {@code null} se não existir.</p>
     */
    @Transactional(
            transactionManager = "publicTransactionManager",
            readOnly = true,
            propagation = Propagation.SUPPORTS
    )
    public Long resolveControlPlaneUserIdByEmail(String email) {
        String normalized = EmailNormalizer.normalizeOrNull(email);
        if (normalized == null) return null;

        String sql = """
            select li.subject_id
              from public.login_identities li
             where li.email = :email
               and li.subject_type = 'CONTROLPLANE_USER'
             limit 1
        """;

        var params = new MapSqlParameterSource("email", normalized);

        List<Long> rows = jdbcTemplate.query(sql, params, (rs, rowNum) -> rs.getLong("subject_id"));
        Long out = rows.isEmpty() ? null : rows.get(0);

        if (log.isDebugEnabled()) {
            log.debug("🔎 resolveControlPlaneUserIdByEmail | email={} | found={}", normalized, out != null);
        }

        return out;
    }

    @Transactional(
            transactionManager = "publicTransactionManager",
            readOnly = true,
            propagation = Propagation.SUPPORTS
    )
    public boolean existsControlPlaneIdentity(String email) {
        String normalized = EmailNormalizer.normalizeOrNull(email);
        if (normalized == null) return false;

        String sql = """
            select count(1)
              from public.login_identities li
             where li.email = :email
               and li.subject_type = 'CONTROLPLANE_USER'
        """;

        var params = new MapSqlParameterSource("email", normalized);

        Integer count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        boolean out = count != null && count > 0;

        if (log.isDebugEnabled()) {
            log.debug("🔎 existsControlPlaneIdentity | email={} | exists={}", normalized, out);
        }

        return out;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentityRow.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;





public record LoginIdentityRow(
        Long accountId,
        String displayName,
        String slug
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/persistence/publicschema/LoginIdentitySubjectType.java
============================================================
package brito.com.multitenancy001.shared.persistence.publicschema;

/**
 * Tipos de subject para a tabela login_identities.
 */
public enum LoginIdentitySubjectType {

    TENANT_ACCOUNT,
    CONTROLPLANE_USER;

    public String getDbValue() {
        return this.name();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/AuthenticatedPrincipal.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Contrato mínimo para Principal autenticado.
 *
 * Evita acoplamento do shared/persistence com classes de infraestrutura.
 */
public interface AuthenticatedPrincipal {
    Long getUserId();
    String getEmail();
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/PermissionAuthority.java
============================================================
package brito.com.multitenancy001.shared.security;

public interface PermissionAuthority {
    String asAuthority(); // ex: "CP_USER_READ" ou "TEN_USER_READ"
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/PermissionCode.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Contrato "shared" para permissões.
 *
 * - O shared pode depender deste contrato.
 * - ControlPlane e Tenant podem implementar este contrato nos seus enums.
 * - O shared NÃO deve importar classes/enums dos bounded contexts.
 *
 * Observação:
 * - Mantemos compatibilidade com o seu modelo atual (PermissionAuthority),
 *   já que o resto do projeto usa "asAuthority()" para gerar GrantedAuthority/JWT claims.
 */
public interface PermissionCode extends PermissionAuthority {
    // marker + compatibilidade (herda asAuthority())
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/PermissionScopeValidator.java
============================================================
package brito.com.multitenancy001.shared.security;

import brito.com.multitenancy001.shared.domain.DomainException;

import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * Validador de escopo de permissões (shared).
 *
 * Objetivo:
 * - Evitar "vazamento" de permissions entre bounded contexts (TEN_ vs CP_)
 * - FAIL-FAST: nunca aceitar permission sem prefixo
 * - DDD/layered: shared não conhece enums concretos (somente contratos via PermissionCode)
 *
 * Regras:
 * - Tenant: somente "TEN_*" é aceito (nunca CP_ e nunca sem prefixo)
 * - ControlPlane: somente "CP_*" é aceito (nunca TEN_ e nunca sem prefixo)
 */
public final class PermissionScopeValidator {

    private PermissionScopeValidator() {}

    // =========================================================
    // STRICT (String): exige prefixo correto SEMPRE
    // =========================================================

    public static LinkedHashSet<String> normalizeTenantStrict(Collection<String> perms) {
        return normalizeStringStrict(perms, "TEN_", "CP_", "Tenant", "Control Plane");
    }

    public static LinkedHashSet<String> normalizeControlPlaneStrict(Collection<String> perms) {
        return normalizeStringStrict(perms, "CP_", "TEN_", "Control Plane", "Tenant");
    }

    /** Aliases (continua STRICT). */
    public static LinkedHashSet<String> normalizeTenant(Collection<String> perms) {
        return normalizeTenantStrict(perms);
    }

    public static LinkedHashSet<String> normalizeControlPlane(Collection<String> perms) {
        return normalizeControlPlaneStrict(perms);
    }

    private static LinkedHashSet<String> normalizeStringStrict(
            Collection<String> perms,
            String expectedPrefix,
            String forbiddenPrefix,
            String expectedContextLabel,
            String forbiddenContextLabel
    ) {
        LinkedHashSet<String> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (String p : perms) {
            if (p == null) continue;

            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith(forbiddenPrefix)) {
                throw new DomainException("Permission de " + forbiddenContextLabel
                        + " não é permitida no " + expectedContextLabel + ": " + x);
            }

            // ✅ NUNCA aceita permissão sem prefixo
            if (!x.startsWith(expectedPrefix)) {
                throw new DomainException("Permission inválida (esperado prefixo " + expectedPrefix
                        + ") no " + expectedContextLabel + ": " + x);
            }

            out.add(x);
        }

        return out;
    }

    // =========================================================
    // STRICT (Tipado): enums implementando PermissionCode
    // =========================================================

    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> normalizeTenantPermissions(Collection<T> perms) {
        return normalizeTypedStrict(perms, "TEN_", "CP_", "Tenant", "Control Plane");
    }

    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> normalizeControlPlanePermissions(Collection<T> perms) {
        return normalizeTypedStrict(perms, "CP_", "TEN_", "Control Plane", "Tenant");
    }

    private static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> normalizeTypedStrict(
            Collection<T> perms,
            String expectedPrefix,
            String forbiddenPrefix,
            String expectedContextLabel,
            String forbiddenContextLabel
    ) {
        LinkedHashSet<T> out = new LinkedHashSet<>();
        if (perms == null) return out;

        for (T p : perms) {
            if (p == null) continue;

            String code = p.asAuthority(); // contrato shared
            if (code == null) continue;

            String x = code.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith(forbiddenPrefix)) {
                throw new DomainException("Permission de " + forbiddenContextLabel
                        + " não é permitida no " + expectedContextLabel + ": " + x);
            }

            // ✅ NUNCA aceita permissão sem prefixo
            if (!x.startsWith(expectedPrefix)) {
                throw new DomainException("Permission inválida (esperado prefixo " + expectedPrefix
                        + ") no " + expectedContextLabel + ": " + x);
            }

            out.add(p);
        }

        return out;
    }

    // =========================================================
    // COMPAT (métodos antigos) - agora STRICT (sem auto-prefix)
    // =========================================================

    /** Compat: valida lista string no contexto CP. */
    public static void assertNoTenantPermissionLeak(List<String> permissions) {
        if (permissions == null) return;

        for (String p : permissions) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("TEN_")) {
                throw new DomainException("Permission de Tenant não é permitida no Control Plane: " + x);
            }

            // ✅ também falha se vier sem prefixo
            if (!x.startsWith("CP_")) {
                throw new DomainException("Permission inválida no Control Plane (esperado prefixo CP_): " + x);
            }
        }
    }

    /** Compat: valida lista string no contexto Tenant. */
    public static void assertNoControlPlanePermissionLeak(List<String> permissions) {
        if (permissions == null) return;

        for (String p : permissions) {
            if (p == null) continue;
            String x = p.trim();
            if (x.isEmpty()) continue;

            if (x.startsWith("CP_")) {
                throw new DomainException("Permission de Control Plane não é permitida no Tenant: " + x);
            }

            // ✅ também falha se vier sem prefixo
            if (!x.startsWith("TEN_")) {
                throw new DomainException("Permission inválida no Tenant (esperado prefixo TEN_): " + x);
            }
        }
    }

    public static void assertAllTenantScoped(Collection<String> permissions) {
        assertNoControlPlanePermissionLeak(toList(permissions));
    }

    public static void assertAllControlPlaneScoped(Collection<String> permissions) {
        assertNoTenantPermissionLeak(toList(permissions));
    }

  

    /**
     * Valida permissões tipadas do Tenant (TEN_*), estritamente.
     * - Não aceita CP_*
     * - Não aceita sem prefixo
     */
    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> validateTenantPermissionsStrict(Set<T> perms) {
        return normalizeTenantPermissions(perms);
    }

    /**
     * Valida permissões tipadas do ControlPlane (CP_*), estritamente.
     * - Não aceita TEN_*
     * - Não aceita sem prefixo
     */
    public static <T extends Enum<T> & PermissionCode> LinkedHashSet<T> validateControlPlanePermissionsStrict(Set<T> perms) {
        return normalizeControlPlanePermissions(perms);
    }

    private static List<String> toList(Collection<String> c) {
        if (c == null) return List.of();
        return c.stream().filter(Objects::nonNull).toList();
    }
    
    
 // =========================================================
 // REQUIRE (fail-fast) - helpers para domínio tipado
 // =========================================================

 /**
  * Fail-fast: exige permissão TEN_*
  * (shared não importa enum do Tenant; usa PermissionCode/Enum/String)
  */
 public static void requireTenantPermission(Object permission) {
     requireScopedPermission(permission, "TEN_", "CP_", "Tenant", "Control Plane");
 }

 /**
  * Fail-fast: exige permissão CP_*
  * (shared não importa enum do ControlPlane; usa PermissionCode/Enum/String)
  */
 public static void requireControlPlanePermission(Object permission) {
     requireScopedPermission(permission, "CP_", "TEN_", "Control Plane", "Tenant");
 }

 private static void requireScopedPermission(
         Object permission,
         String expectedPrefix,
         String forbiddenPrefix,
         String expectedContextLabel,
         String forbiddenContextLabel
 ) {
     if (permission == null) {
         throw new DomainException("Permission é obrigatória no contexto " + expectedContextLabel);
     }

     final String code;
     if (permission instanceof PermissionCode pc) {
         code = pc.asAuthority(); // contrato shared
     } else if (permission instanceof Enum<?> e) {
         code = e.name(); // fallback (nome do enum)
     } else if (permission instanceof String s) {
         code = s;
     } else {
         throw new DomainException("Tipo inválido de permission (" + permission.getClass().getName()
                 + ") no contexto " + expectedContextLabel);
     }

     if (code == null || code.trim().isEmpty()) {
         throw new DomainException("Permission inválida/vazia no contexto " + expectedContextLabel);
     }

     String x = code.trim();

     if (x.startsWith(forbiddenPrefix)) {
         throw new DomainException("Permission de " + forbiddenContextLabel
                 + " não é permitida no " + expectedContextLabel + ": " + x);
     }

     if (!x.startsWith(expectedPrefix)) {
         throw new DomainException("Permission inválida (esperado prefixo " + expectedPrefix
                 + ") no " + expectedContextLabel + ": " + x);
     }
 }

}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/PreAuthorizePermissionReferenceParser.java
============================================================
package brito.com.multitenancy001.shared.security;

import org.springframework.util.StringUtils;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parser simples (fail-fast-friendly) para extrair referências de permissões em expressões SpEL de @PreAuthorize.
 *
 * Cobre os padrões mais comuns do projeto:
 *  1) hasAuthority(T(fqn.PermissionEnum).CONST.asAuthority())
 *  2) hasAuthority(T(fqn.PermissionEnum).CONST.name())
 *  3) hasAuthority(T(fqn.PermissionEnum).CONST)  (raro, mas suportado)
 *  4) hasAuthority('CP_USER_READ') / hasAnyAuthority('TEN_X', 'TEN_Y') (string literal)
 *
 * Não executa SpEL; apenas faz parsing de referências explícitas para validação fail-fast.
 */
public final class PreAuthorizePermissionReferenceParser {

    private PreAuthorizePermissionReferenceParser() {}

    /**
     * Captura: T(fully.qualified.Enum).CONST
     *
     * Exemplos que casam:
     *  - T(brito.com...TenantPermission).TEN_USER_READ.asAuthority()
     *  - T(brito.com...ControlPlanePermission).CP_USER_READ.name()
     */
    private static final Pattern T_ENUM_CONST =
            Pattern.compile("T\\(([^)]+)\\)\\.([A-Z0-9_]+)");

    /**
     * Captura: 'CP_...' ou 'TEN_...' como string literal
     *
     * Exemplos:
     *  - hasAuthority('CP_TENANT_READ')
     *  - hasAnyAuthority('TEN_USER_READ','TEN_PRODUCT_READ')
     */
    private static final Pattern STRING_LITERAL_PERMISSION =
            Pattern.compile("'((?:CP|TEN)_[A-Z0-9_]+)'");

    public static ParsedPermissions parse(String spelExpression) {
        if (!StringUtils.hasText(spelExpression)) {
            return ParsedPermissions.empty();
        }

        String expr = spelExpression.trim();

        LinkedHashSet<EnumConstantRef> enumRefs = new LinkedHashSet<>();
        LinkedHashSet<String> stringCodes = new LinkedHashSet<>();

        // 1) T(Enum).CONST
        Matcher m1 = T_ENUM_CONST.matcher(expr);
        while (m1.find()) {
            String enumFqn = safeTrim(m1.group(1));
            String constant = safeTrim(m1.group(2));
            if (StringUtils.hasText(enumFqn) && StringUtils.hasText(constant)) {
                enumRefs.add(new EnumConstantRef(enumFqn, constant));
            }
        }

        // 2) 'CP_xxx' / 'TEN_xxx'
        Matcher m2 = STRING_LITERAL_PERMISSION.matcher(expr);
        while (m2.find()) {
            String code = safeTrim(m2.group(1));
            if (StringUtils.hasText(code)) {
                stringCodes.add(code);
            }
        }

        return new ParsedPermissions(enumRefs, stringCodes);
    }

    private static String safeTrim(String s) {
        return (s == null) ? null : s.trim();
    }

    // =========================================================
    // DTOs
    // =========================================================

    public record EnumConstantRef(String enumFqn, String constantName) {}

    public record ParsedPermissions(Set<EnumConstantRef> enumConstantRefs,
                                    Set<String> stringLiteralCodes) {
        public static ParsedPermissions empty() {
            return new ParsedPermissions(Set.of(), Set.of());
        }

        public boolean isEmpty() {
            return (enumConstantRefs == null || enumConstantRefs.isEmpty())
                    && (stringLiteralCodes == null || stringLiteralCodes.isEmpty());
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/RoleAuthority.java
============================================================
package brito.com.multitenancy001.shared.security;

import java.io.Serializable;

public interface RoleAuthority extends Serializable {
    String asAuthority();
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/SystemRoleName.java
============================================================
package brito.com.multitenancy001.shared.security;

public enum SystemRoleName {

    // CONTROL PLANE
    CONTROLPLANE_OWNER,
    CONTROLPLANE_ADMIN,
    CONTROLPLANE_BILLING_MANAGER,
    CONTROLPLANE_SUPPORT,
    CONTROLPLANE_VIEWER,
    CONTROLPLANE_OPERATOR,

    // TENANT
    TENANT_OWNER,
    TENANT_ADMIN,
    TENANT_MANAGER,
    TENANT_SUPPORT,
    TENANT_USER,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    public boolean isControlPlane() { return name().startsWith("CONTROLPLANE_"); }
    public boolean isTenant() { return name().startsWith("TENANT_"); }

    public static SystemRoleName fromString(String value) {
        if (value == null || value.isBlank()) return null;
        return SystemRoleName.valueOf(value.trim().toUpperCase());
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/TenantRoleName.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Role do contexto Tenant exposta como "contrato" compartilhado.
 *
 * Motivo: permitir tipagem no ControlPlane (DTOs, contratos, integrações)
 * sem depender de tenant.security.TenantRole (bounded context Tenant).
 *
 * Regra: este enum não deve conter comportamento de segurança, apenas nomes.
 */
public enum TenantRoleName {

    TENANT_OWNER,
    TENANT_ADMIN,
    TENANT_MANAGER,
    TENANT_SUPPORT,
    TENANT_USER,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    public static TenantRoleName fromString(String value) {
        if (value == null || value.isBlank()) return null;
        return TenantRoleName.valueOf(value.trim().toUpperCase());
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/security/TenantSystemRoleMapper.java
============================================================
package brito.com.multitenancy001.shared.security;

/**
 * Mapper do contrato TenantRoleName -> SystemRoleName
 * (fica em shared porque TenantRoleName já está em shared).
 */
public final class TenantSystemRoleMapper {

    private TenantSystemRoleMapper() {}

    public static SystemRoleName toSystemRole(TenantRoleName role) {
        if (role == null) return null;
        // nomes são iguais
        return SystemRoleName.valueOf(role.name());
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/time/AppClock.java
============================================================
package brito.com.multitenancy001.shared.time;

import java.time.Clock;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;

/**
 * Regra do projeto:
 * - "Instante real" => Instant (UTC) via AppClock.instant()
 * - "Data civil"    => LocalDate via AppClock.today()
 *
 * Não expor Instant para evitar "meio termo perigoso" que vaza pro domínio.
 */
public interface AppClock {

    Clock clock();

    default Instant instant() {
        Clock c = clock();
        if (c == null) throw new IllegalStateException("AppClock.clock() não pode ser null");
        return Instant.now(c);
    }


    default ZoneId zone() {
        return clock().getZone();
    }

    /**
     * Data civil no fuso do clock (normalmente UTC, mas pode ser ZoneId do tenant
     * em cenários específicos de UX).
     */
    default LocalDate today() {
        return LocalDate.now(clock());
    }

    default long epochMillis() {
        return instant().toEpochMilli();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/time/SystemAppClock.java
============================================================
package brito.com.multitenancy001.shared.time;

import java.time.Clock;

import org.springframework.stereotype.Component;

@Component
public class SystemAppClock implements AppClock {

    private final Clock clock;

    public SystemAppClock(Clock clock) {
        this.clock = clock;
    }

    @Override
    public Clock clock() {
        return clock;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/shared/validation/ValidationPatterns.java
============================================================
package brito.com.multitenancy001.shared.validation;

/**
 * Padrões de validação reutilizáveis em todo o sistema
 */
public final class ValidationPatterns {

    // ⚠️ APENAS PARA TESTE/DEV - NUNCA EM PRODUÇÃO!
    // Password: mínimo 3 caracteres, letras/números
    public static final String PASSWORD_PATTERN = "^[a-zA-Z0-9]{3,}$";

    // Email
    public static final String EMAIL_PATTERN = "^[A-Za-z0-9+_.-]+@(.+)$";

    // Nome
    public static final String NAME_PATTERN = "^[a-zA-ZÀ-ÿ\\s'-]{2,100}$";

    // Telefone
    public static final String PHONE_PATTERN = "^(\\(?\\d{2}\\)?)?\\s?\\d{4,5}-?\\d{4}$";

    public static final String CNPJ_PATTERN = "^\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}$";
    public static final String CPF_PATTERN  = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$";
    public static final String CEP_PATTERN  = "^\\d{5}-\\d{3}$";

    public static final String URL_PATTERN = "^(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?$";

    public static final String TIMEZONE_PATTERN = "^[A-Za-z_]+/[A-Za-z_]+$";
    public static final String LOCALE_PATTERN   = "^[a-z]{2}_[A-Z]{2}$";
    public static final String CURRENCY_PATTERN = "^[A-Z]{3}$";
    public static final String COLOR_PATTERN    = "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$";
    public static final String IP_PATTERN       = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
    public static final String UUID_PATTERN     = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";

    public static final String PERMISSION_PATTERN = "^[A-Z_]+$";

    private ValidationPatterns() {
        throw new UnsupportedOperationException("Classe utilitária - não instanciável");
    }

    public static boolean isValid(String value, String pattern) {
        return value != null && value.matches(pattern);
    }

    public static void validatePassword(String password) {
        if (password == null || !password.matches(PASSWORD_PATTERN)) {
            throw new IllegalArgumentException("Senha inválida");
        }
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantAuthController.java
============================================================
// src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantAuthController.java
package brito.com.multitenancy001.tenant.auth.api;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.api.dto.auth.JwtResponse;
import brito.com.multitenancy001.shared.api.dto.auth.LogoutRequest;
import brito.com.multitenancy001.shared.auth.app.AuthRefreshSessionService;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.auth.api.dto.TenantLoginConfirmRequest;
import brito.com.multitenancy001.tenant.auth.api.dto.TenantLoginInitRequest;
import brito.com.multitenancy001.tenant.auth.api.dto.TenantRefreshRequest;
import brito.com.multitenancy001.tenant.auth.api.dto.TenantSelectionOption;
import brito.com.multitenancy001.tenant.auth.api.dto.TenantSelectionRequiredResponse;
import brito.com.multitenancy001.tenant.auth.app.TenantLoginConfirmService;
import brito.com.multitenancy001.tenant.auth.app.TenantLoginInitService;
import brito.com.multitenancy001.tenant.auth.app.TenantLogoutService;
import brito.com.multitenancy001.tenant.auth.app.TenantTokenRefreshService;
import brito.com.multitenancy001.tenant.auth.app.command.TenantLoginConfirmCommand;
import brito.com.multitenancy001.tenant.auth.app.command.TenantLoginInitCommand;
import brito.com.multitenancy001.tenant.auth.app.dto.TenantLoginResult;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * API de autenticação do Tenant.
 *
 * Regras:
 * - /login pode retornar JWT final (single-tenant) OU exigir seleção (409)
 * - /login/confirm emite JWT final quando houve seleção
 * - /refresh rotaciona refresh token (novo refresh)
 * - /logout faz logout forte (revoga sessão/refresh no servidor)
 *
 * Ajuste:
 * - registra sessão server-side tanto no /login (quando retornar JWT final)
 *   quanto no /login/confirm.
 */
@RestController
@RequestMapping("/api/tenant/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantAuthController {

    private final TenantLoginInitService tenantLoginInitService;
    private final TenantLoginConfirmService tenantLoginConfirmService;
    private final TenantTokenRefreshService tenantTokenRefreshService;

    private final TenantLogoutService tenantLogoutService;
    private final AuthRefreshSessionService refreshSessions;

    private static JwtResponse toHttp(JwtResult r) {
        if (r == null) return null;
        return new JwtResponse(
                r.accessToken(),
                r.refreshToken(),
                r.tokenType(),
                r.userId(),
                r.email(),
                r.role(),
                r.accountId(),
                r.tenantSchema()
        );
    }

    /**
     * POST /api/tenant/auth/login com email + password
     *
     * - Se só 1 tenant válido -> 200 + JWT FINAL
     * - Se >1 tenant válido -> 409 + TENANT_SELECTION_REQUIRED + challengeId + details[]
     */
    @PostMapping("/login")
    public ResponseEntity<?> loginTenant(@Valid @RequestBody TenantLoginInitRequest req) {

        /** comentário: inicia login tenant; pode emitir JWT final ou exigir seleção */
        TenantLoginInitCommand cmd = new TenantLoginInitCommand(req.email(), req.password());
        TenantLoginResult result = tenantLoginInitService.loginInit(cmd);

        if (result instanceof TenantLoginResult.LoginSuccess ok) {
            JwtResult jwt = ok.jwt();

            // ✅ /login pode retornar JWT final => registra sessão server-side
            refreshSessions.onRefreshIssued(
                    brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain.TENANT,
                    jwt.accountId(),
                    jwt.userId(),
                    jwt.tenantSchema(),
                    jwt.refreshToken()
            );

            return ResponseEntity.ok(toHttp(jwt));
        }

        if (result instanceof TenantLoginResult.TenantSelectionRequired sel) {
            List<TenantSelectionOption> details = sel.details().stream()
                    .map(o -> new TenantSelectionOption(o.accountId(), o.displayName(), o.slug()))
                    .toList();

            TenantSelectionRequiredResponse body = new TenantSelectionRequiredResponse(
                    ApiErrorCode.TENANT_SELECTION_REQUIRED.name(),
                    "Selecione a empresa/tenant para continuar",
                    sel.challengeId(),
                    details
            );

            return ResponseEntity.status(409).body(body);
        }

        throw new ApiException(ApiErrorCode.INTERNAL_ERROR, "Resposta inesperada do servidor", 500);
    }

    /**
     * POST /api/tenant/auth/login/confirm com challengeId + slug (ou accountId)
     * Autentica somente no tenant escolhido (JWT final).
     */
    @PostMapping("/login/confirm")
    public ResponseEntity<JwtResponse> confirmTenantLogin(@Valid @RequestBody TenantLoginConfirmRequest req) {

        /** comentário: confirma seleção e emite tokens definitivos */
        TenantLoginConfirmCommand cmd = new TenantLoginConfirmCommand(
                req.challengeId().toString(),
                req.accountId(),
                req.slug()
        );

        JwtResult jwt = tenantLoginConfirmService.loginConfirm(cmd);

        // ✅ registra sessão server-side (logout forte / rotação)
        refreshSessions.onRefreshIssued(
                brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain.TENANT,
                jwt.accountId(),
                jwt.userId(),
                jwt.tenantSchema(),
                jwt.refreshToken()
        );

        return ResponseEntity.ok(toHttp(jwt));
    }

    /**
     * refresh token -> novo accessToken + NOVO refreshToken (rotação)
     */
    @PostMapping("/refresh")
    public ResponseEntity<JwtResponse> refresh(@Valid @RequestBody TenantRefreshRequest req) {
        /** comentário: refresh com rotação server-side */
        JwtResult jwt = tenantTokenRefreshService.refresh(req.refreshToken());
        return ResponseEntity.ok(toHttp(jwt));
    }

    /**
     * Logout forte:
     * - revoga refreshToken no servidor
     * - allDevices=true revoga todas as sessões do usuário no domínio TENANT
     */
    @PostMapping("/logout")
    public ResponseEntity<Void> logout(@Valid @RequestBody LogoutRequest req) {
        /** comentário: executa logout forte */
        tenantLogoutService.logout(req.refreshToken(), req.allDevices());
        return ResponseEntity.noContent().build();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/TenantPasswordController.java
============================================================
package brito.com.multitenancy001.tenant.auth.api;

import brito.com.multitenancy001.shared.api.dto.GenericMessageResponse;
import brito.com.multitenancy001.tenant.auth.api.dto.ForgotPasswordRequest;
import brito.com.multitenancy001.tenant.auth.api.dto.ResetPasswordRequest;
import brito.com.multitenancy001.tenant.auth.app.TenantPasswordResetService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * Endpoints responsáveis pelo fluxo de recuperação e redefinição
 * de senha de usuários TENANT.
 *
 * Regras:
 * - Estes endpoints não exigem autenticação JWT.
 * - A segurança do fluxo é baseada em token temporário de reset de senha.
 * - Respostas são padronizadas via DTO (contrato consistente).
 */
@RestController
@RequestMapping("/api/tenant/password")
@CrossOrigin(origins = "*", maxAge = 3600)
@RequiredArgsConstructor
public class TenantPasswordController {

    private final TenantPasswordResetService tenantPasswordResetService;

    @PostMapping("/forgot")
    public ResponseEntity<GenericMessageResponse> forgotPassword(
            @Valid @RequestBody ForgotPasswordRequest forgotPasswordRequest
    ) {
        /* Gera token de reset e dispara o mecanismo associado (e-mail etc) via service. */
        tenantPasswordResetService.generatePasswordResetToken(
                forgotPasswordRequest.slug(),
                forgotPasswordRequest.email()
        );

        return ResponseEntity.ok(new GenericMessageResponse("Token gerado"));
    }

    @PostMapping("/reset")
    public ResponseEntity<GenericMessageResponse> resetPassword(
            @Valid @RequestBody ResetPasswordRequest resetPasswordRequest
    ) {
        /* Valida token e redefine a senha via service (nenhuma regra sensível fica no controller). */
        tenantPasswordResetService.resetPasswordWithToken(
                resetPasswordResetTokenSafe(resetPasswordRequest.token()),
                resetPasswordRequest.newPassword()
        );

        return ResponseEntity.ok(new GenericMessageResponse("Senha redefinida com sucesso"));
    }

    /**
     * Normalização defensiva do token para evitar edge-cases triviais de input.
     */
    private String resetPasswordResetTokenSafe(String token) {
        /* Normaliza input para evitar falhas por whitespace e manter consistência de auditoria. */
        return (token == null ? null : token.trim());
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/ForgotPasswordRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ForgotPasswordRequest(
        @NotBlank String slug,
        @NotBlank @Email String email
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/ResetPasswordRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;

public record ResetPasswordRequest(
        @NotBlank String token,
        @NotBlank
        @Pattern(
          regexp = ValidationPatterns.PASSWORD_PATTERN,
          message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais"
        )
        String newPassword
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantLoginConfirmRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.NotNull;

import java.util.UUID;

public record TenantLoginConfirmRequest(
        @NotNull(message = "challengeId é obrigatório")
        UUID challengeId,

        // Preferencial: usar slug
        String slug,

        // Compat opcional (se você quiser confirmar por id)
        Long accountId
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantLoginInitRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record TenantLoginInitRequest(
        @NotBlank(message = "email é obrigatório")
        @Email(message = "email inválido")
        String email,

        @NotBlank(message = "password é obrigatório")
        String password
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantRefreshRequest.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import jakarta.validation.constraints.NotBlank;

public record TenantRefreshRequest(
        @NotBlank(message = "refreshToken é obrigatório")
        String refreshToken
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantSelectionOption.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

public record TenantSelectionOption(
        Long accountId,
        String displayName,
        String slug
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/api/dto/TenantSelectionRequiredResponse.java
============================================================
package brito.com.multitenancy001.tenant.auth.api.dto;

import java.util.List;

public record TenantSelectionRequiredResponse(
        String code,
        String message,
        String challengeId,
        List<TenantSelectionOption> details
) { }

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginCandidateAccountService.java
============================================================
package brito.com.multitenancy001.tenant.auth.app;

import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityResolver;
import brito.com.multitenancy001.tenant.auth.app.dto.TenantLoginCandidateAccount;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TenantLoginCandidateAccountService {

    private final LoginIdentityResolver loginIdentityResolver;

    public List<TenantLoginCandidateAccount> findCandidateAccounts(String normalizedEmail) {
        if (!StringUtils.hasText(normalizedEmail)) return List.of();

        return loginIdentityResolver.findTenantAccountsByEmail(normalizedEmail)
                .stream()
                .map(r -> new TenantLoginCandidateAccount(r.accountId(), r.displayName(), r.slug()))
                .toList();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginChallengeService.java
============================================================
package brito.com.multitenancy001.tenant.auth.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantLoginChallengeStore;
import brito.com.multitenancy001.tenant.auth.domain.TenantLoginChallenge;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Instant;
import java.util.Set;
import java.util.UUID;

/**
 * Application Service responsável por criar e validar challenges de seleção de tenant no login.
 *
 * <p>Responsabilidade:</p>
 * <ul>
 *   <li>Criar um challenge temporário para {@code email} com um conjunto de {@code accountIds} candidatos.</li>
 *   <li>Validar challenge por id e verificar expiração/uso único.</li>
 *   <li>Marcar challenge como usado após confirmação bem-sucedida.</li>
 * </ul>
 *
 * <p>Regras de tempo:</p>
 * <ul>
 *   <li>{@code AppClock} deve ser a única fonte de tempo; esta classe não deve usar {@code Instant.now()}.</li>
 * </ul>
 *
 * <p>Persistência:</p>
 * <ul>
 *   <li>Não define tecnologia; persiste via {@code TenantLoginChallengeStore} (boundary).</li>
 * </ul>
 */
@Service
@RequiredArgsConstructor
public class TenantLoginChallengeService {

    private final TenantLoginChallengeStore store;
    private final AppClock appClock;

    private Instant now() {
        return appClock.instant();
    }

    public UUID createChallenge(String email, Set<Long> candidateAccountIds) {
        String normalizedEmail = EmailNormalizer.normalizeOrNull(email);

        if (!StringUtils.hasText(normalizedEmail)) {
            throw new ApiException(ApiErrorCode.INVALID_EMAIL);
        }

        if (candidateAccountIds == null || candidateAccountIds.isEmpty()) {
            throw new ApiException(ApiErrorCode.INVALID_CHALLENGE);
        }

        return store.create(now(), normalizedEmail, candidateAccountIds);
    }

    public TenantLoginChallenge requireValid(UUID challengeId) {
        if (challengeId == null) {
            throw new ApiException(ApiErrorCode.INVALID_CHALLENGE);
        }

        return store.findValid(challengeId, now())
                .orElseThrow(() ->
                        new ApiException(ApiErrorCode.CHALLENGE_NOT_FOUND)
                );
    }

    public void markUsed(UUID challengeId) {
        if (challengeId == null) {
            return;
        }
        store.markUsed(challengeId, now());
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginConfirmService.java
============================================================
package brito.com.multitenancy001.tenant.auth.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountResolver;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountSnapshot;
import brito.com.multitenancy001.tenant.auth.app.audit.TenantAuthAuditRecorder;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantAuthMechanics;
import brito.com.multitenancy001.tenant.auth.app.command.TenantLoginConfirmCommand;
import brito.com.multitenancy001.tenant.auth.domain.TenantLoginChallenge;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.Set;
import java.util.UUID;


/**
 * Application Service responsável por CONFIRMAR login de Tenant quando o INIT retornou ambiguidade.
 *
 * <p>Fluxo suportado:</p>
 * <ul>
 *   <li><b>INIT</b> (email+senha) retorna {@code 409 TENANT_SELECTION_REQUIRED} quando há mais de um tenant válido.</li>
 *   <li>O backend cria um {@code challengeId} (prova temporária) vinculando email + tenants permitidos.</li>
 *   <li><b>CONFIRM</b> recebe {@code challengeId} + {@code slug} (ou {@code accountId}) para selecionar o tenant.</li>
 *   <li>O backend valida o challenge e então emite JWT somente para o tenant escolhido.</li>
 * </ul>
 *
 * <p>Regras:</p>
 * <ul>
 *   <li>Nunca emite token no INIT quando houver ambiguidade.</li>
 *   <li>O CONFIRM não revalida senha; a validade do challenge prova que a senha já foi checada no INIT.</li>
 *   <li>Deve registrar auditoria de tentativa/sucesso/falha (auth audit) com detalhes do challenge.</li>
 * </ul>
 *
 * <p>Arquitetura:</p>
 * <ul>
 *   <li>Não deve conhecer detalhes de JWT/Spring Security diretamente; delega para {@code TenantAuthMechanics}.</li>
 *   <li>Resolução de conta (slug/accountId) usa camada de leitura do Control Plane (public schema).</li>
 * </ul>
 */
@Service
@RequiredArgsConstructor
public class TenantLoginConfirmService {

    private final TenantLoginChallengeService tenantLoginChallengeService;
    private final AccountResolver accountResolver;
    private final TenantAuthMechanics authMechanics;
    private final TenantAuthAuditRecorder audit;

    public JwtResult loginConfirm(TenantLoginConfirmCommand cmd) {

        if (cmd == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "Requisição inválida", 400);
        if (!StringUtils.hasText(cmd.challengeId())) throw new ApiException(ApiErrorCode.INVALID_CHALLENGE, "challengeId é obrigatório", 400);

        final UUID challengeId;
        try {
            challengeId = UUID.fromString(cmd.challengeId());
        } catch (Exception e) {
            throw new ApiException(ApiErrorCode.INVALID_CHALLENGE, "challengeId inválido", 400);
        }

        TenantLoginChallenge challenge = tenantLoginChallengeService.requireValid(challengeId);
        final String email = challenge.email();

        audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_CONFIRM, AuditOutcome.ATTEMPT, email, null, null, null,
                "{\"challengeId\":\"" + challengeId + "\"}");

        Long accountId = cmd.accountId();
        String slug = StringUtils.hasText(cmd.slug()) ? cmd.slug().trim() : null;

        if (accountId == null && slug == null) {
            audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_CONFIRM, AuditOutcome.FAILURE, email, null, null, null,
                    "{\"reason\":\"missing_selection\"}");
            throw new ApiException(ApiErrorCode.INVALID_SELECTION, "Informe accountId ou slug", 400);
        }

        AccountSnapshot account = (accountId != null)
                ? accountResolver.resolveActiveAccountById(accountId)
                : accountResolver.resolveActiveAccountBySlug(slug);

        if (account == null || account.id() == null) {
            audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_CONFIRM, AuditOutcome.FAILURE, email, null, null, null,
                    "{\"reason\":\"account_not_found\"}");
            throw new ApiException(ApiErrorCode.ACCOUNT_NOT_FOUND, "Conta não encontrada", 404);
        }

        Set<Long> allowedAccountIds = challenge.candidateAccountIds();
        if (allowedAccountIds == null || !allowedAccountIds.contains(account.id())) {
            audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_CONFIRM, AuditOutcome.FAILURE, email, null, account.id(), account.tenantSchema(),
                    "{\"reason\":\"account_not_in_challenge\"}");
            throw new ApiException(ApiErrorCode.INVALID_SELECTION, "Conta não pertence ao challenge", 400);
        }

        tenantLoginChallengeService.markUsed(challengeId);

        JwtResult jwt = authMechanics.issueJwtForAccountAndEmail(account, email);

        audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_SUCCESS, AuditOutcome.SUCCESS, email, jwt.userId(), account.id(), account.tenantSchema(),
                "{\"mode\":\"challenge_confirm\"}");

        return jwt;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginInitService.java
============================================================
// src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLoginInitService.java
package brito.com.multitenancy001.tenant.auth.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.executor.PublicSchemaExecutor;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountResolver;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountSnapshot;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityResolver;
import brito.com.multitenancy001.shared.persistence.publicschema.LoginIdentityRow;
import brito.com.multitenancy001.tenant.auth.app.audit.TenantAuthAuditRecorder;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantAuthMechanics;
import brito.com.multitenancy001.tenant.auth.app.command.TenantLoginInitCommand;
import brito.com.multitenancy001.tenant.auth.app.dto.TenantLoginResult;
import brito.com.multitenancy001.tenant.auth.app.dto.TenantSelectionOptionData;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Serviço de login INIT do Tenant.
 *
 * Regras:
 * - Resolve candidatos no PUBLIC (LoginIdentityResolver)
 * - Single-tenant: autentica direto e emite JWT
 * - Multi-tenant: valida password nos candidatos e:
 *     - se 1 passou -> autentica e emite JWT
 *     - se >1 passou -> cria challenge e exige seleção (409)
 *
 * Correção crítica pós-refactor multi-EMF:
 * - Tudo que acessa PUBLIC (LoginIdentityResolver e AccountResolver) deve rodar dentro do PublicSchemaExecutor.
 *   Caso contrário, pode cair no EntityManager/Tx errado e quebrar o contrato do login (401 “misterioso”).
 */
@Service
@RequiredArgsConstructor
public class TenantLoginInitService {

    private static final String INVALID_CREDENTIALS_MSG = "usuario ou senha invalidos";

    private final AccountResolver accountResolver;
    private final LoginIdentityResolver loginIdentityResolver;
    private final PublicSchemaExecutor publicExecutor;

    private final TenantLoginChallengeService tenantLoginChallengeService;
    private final TenantAuthMechanics authMechanics;

    private final TenantAuthAuditRecorder audit;

    public TenantLoginResult loginInit(TenantLoginInitCommand cmd) {

        /** comentário: valida request e inicia resolução de candidatos */
        if (cmd == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "Requisição inválida", 400);
        if (!StringUtils.hasText(cmd.email())) throw new ApiException(ApiErrorCode.INVALID_LOGIN, "email é obrigatório", 400);
        if (!StringUtils.hasText(cmd.password())) throw new ApiException(ApiErrorCode.INVALID_LOGIN, "password é obrigatório", 400);

        final String email = normalizeEmailRequired(cmd.email());
        final String password = cmd.password();

        audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_INIT, AuditOutcome.ATTEMPT, email, null, null, null,
                "{\"stage\":\"init\"}");

        try {
            /** comentário: resolve candidatos no PUBLIC */
            List<LoginIdentityRow> identities = publicExecutor.inPublic(() ->
                    loginIdentityResolver.findTenantAccountsByEmail(email)
            );

            if (identities == null || identities.isEmpty()) {
                audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_INIT, AuditOutcome.FAILURE, email, null, null, null,
                        "{\"reason\":\"no_candidates\"}");
                throw new BadCredentialsException(INVALID_CREDENTIALS_MSG);
            }

            LinkedHashSet<Long> candidateAccountIds = identities.stream()
                    .map(LoginIdentityRow::accountId)
                    .filter(Objects::nonNull)
                    .collect(Collectors.toCollection(LinkedHashSet::new));

            if (candidateAccountIds.isEmpty()) {
                audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_INIT, AuditOutcome.FAILURE, email, null, null, null,
                        "{\"reason\":\"empty_candidate_ids\"}");
                throw new BadCredentialsException(INVALID_CREDENTIALS_MSG);
            }

            /** comentário: se single-tenant, autentica diretamente */
            if (candidateAccountIds.size() == 1) {
                Long accountId = candidateAccountIds.iterator().next();

                // ✅ PUBLIC: resolve account snapshot dentro do executor
                AccountSnapshot account = publicExecutor.inPublic(() ->
                        accountResolver.resolveActiveAccountById(accountId)
                );

                var jwt = authMechanics.authenticateWithPassword(account, email, password);

                audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_INIT, AuditOutcome.SUCCESS, email, jwt.userId(), accountId, account.tenantSchema(),
                        "{\"mode\":\"single_tenant\"}");

                return new TenantLoginResult.LoginSuccess(jwt);
            }

            /** comentário: multi-tenant -> filtra candidatos que batem password */
            LinkedHashSet<Long> allowedAccountIds = new LinkedHashSet<>();

            for (Long accountId : candidateAccountIds) {
                // ✅ PUBLIC: resolve account snapshot dentro do executor
                AccountSnapshot account = publicExecutor.inPublic(() ->
                        accountResolver.resolveActiveAccountById(accountId)
                );

                boolean ok = authMechanics.verifyPasswordInTenant(account, email, password);
                if (ok) allowedAccountIds.add(accountId);
            }

            if (allowedAccountIds.isEmpty()) {
                audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_INIT, AuditOutcome.FAILURE, email, null, null, null,
                        "{\"reason\":\"no_password_match\"}");
                throw new BadCredentialsException(INVALID_CREDENTIALS_MSG);
            }

            /** comentário: se sobrou 1 candidato, autentica e emite JWT */
            if (allowedAccountIds.size() == 1) {
                Long accountId = allowedAccountIds.iterator().next();

                AccountSnapshot account = publicExecutor.inPublic(() ->
                        accountResolver.resolveActiveAccountById(accountId)
                );

                var jwt = authMechanics.authenticateWithPassword(account, email, password);

                audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_INIT, AuditOutcome.SUCCESS, email, jwt.userId(), accountId, account.tenantSchema(),
                        "{\"mode\":\"multi_resolved_single\"}");

                return new TenantLoginResult.LoginSuccess(jwt);
            }

            /** comentário: >1 candidato válido -> exige seleção via challenge */
            UUID challengeId = tenantLoginChallengeService.createChallenge(email, allowedAccountIds);

            List<TenantSelectionOptionData> details = identities.stream()
                    .filter(r -> r.accountId() != null && allowedAccountIds.contains(r.accountId()))
                    .map(r -> new TenantSelectionOptionData(r.accountId(), r.displayName(), r.slug()))
                    .toList();

            audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_INIT, AuditOutcome.SUCCESS, email, null, null, null,
                    "{\"mode\":\"tenant_selection_required\",\"challengeId\":\"" + challengeId + "\"}");

            return new TenantLoginResult.TenantSelectionRequired(challengeId.toString(), details);

        } catch (BadCredentialsException ex) {
            throw ex;
        } catch (ApiException ex) {
            throw ex;
        } catch (Exception ex) {
            audit.record(AuthDomain.TENANT, AuthEventType.LOGIN_INIT, AuditOutcome.FAILURE, email, null, null, null,
                    "{\"reason\":\"unexpected\"}");
            throw ex;
        }
    }

    private static String normalizeEmailRequired(String email) {
        /** comentário: normaliza e valida email */
        String normalized = EmailNormalizer.normalizeOrNull(email);
        if (!StringUtils.hasText(normalized)) {
            throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email inválido", 400);
        }
        return normalized;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantLogoutService.java
============================================================
package brito.com.multitenancy001.tenant.auth.app;

import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.auth.app.AuthRefreshSessionService;
import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.auth.app.audit.TenantAuthAuditRecorder;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantAuthMechanics;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantRefreshIdentity;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Logout forte do Tenant (opção B).
 *
 * Regras:
 * - Revoga refresh token no servidor (public schema).
 * - allDevices=true revoga todas as sessões do usuário no domínio TENANT.
 *
 * Nota:
 * - resolveRefreshIdentity(refreshToken) não faz query e pode retornar userId null.
 * - Para allDevices=true, precisamos resolver userId no schema do tenant.
 *
 * Regras de audit details:
 * - SEMPRE Map/record via JsonDetailsMapper
 * - Nunca montar JSON na mão (inclusive boolean concatenado).
 */
@Service
@RequiredArgsConstructor
public class TenantLogoutService {

    private final TenantAuthMechanics authMechanics;
    private final AuthRefreshSessionService refreshSessions;
    private final TenantAuthAuditRecorder audit;

    // ✅ necessários para resolver userId quando allDevices=true
    private final TenantExecutor tenantExecutor;
    private final TenantUserRepository tenantUserRepository;

    private final JsonDetailsMapper jsonDetailsMapper;

    public void logout(String refreshToken, boolean allDevices) {
        /** comentário: resolve identidade do refresh e revoga sessão(ões) */
        TenantRefreshIdentity id = authMechanics.resolveRefreshIdentity(refreshToken);

        audit.record(
                AuthDomain.TENANT,
                AuthEventType.LOGOUT,
                AuditOutcome.ATTEMPT,
                id.email(),
                id.userId(),
                id.accountId(),
                id.tenantSchema(),
                toJson(m("stage", "start", "allDevices", allDevices))
        );

        if (allDevices) {
            Long userId = resolveUserIdOrThrow(id);

            refreshSessions.revokeAllForUser(
                    AuthSessionDomain.TENANT,
                    id.accountId(),
                    userId,
                    toJson(m("reason", "logout_all_devices"))
            );
        } else {
            refreshSessions.revokeByRefreshTokenOrThrow(
                    refreshToken,
                    toJson(m("reason", "logout"))
            );
        }

        audit.record(
                AuthDomain.TENANT,
                AuthEventType.LOGOUT,
                AuditOutcome.SUCCESS,
                id.email(),
                id.userId(),
                id.accountId(),
                id.tenantSchema(),
                toJson(m("stage", "completed", "allDevices", allDevices))
        );
    }

    private Long resolveUserIdOrThrow(TenantRefreshIdentity id) {
        /** comentário: garante userId para revokeAllForUser (allDevices) */
        if (id.userId() != null) {
            return id.userId();
        }

        return tenantExecutor.runInTenantSchema(id.tenantSchema(), () ->
                tenantUserRepository
                        .findByEmailAndAccountIdAndDeletedFalse(id.email(), id.accountId())
                        .map(u -> u.getId())
                        .orElseThrow(() -> new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken inválido", 401))
        );
    }

    private String toJson(Object details) {
        /** comentário: converte details (Map/record/String) em JSON string compatível com jsonb */
        if (details == null) return null;
        return jsonDetailsMapper.toJsonNode(details).toString();
    }

    private static Map<String, Object> m(Object... kv) {
        /** comentário: cria LinkedHashMap em pares key/value com ordem estável */
        Map<String, Object> m = new LinkedHashMap<>();
        if (kv == null) return m;
        if (kv.length % 2 != 0) throw new IllegalArgumentException("m(kv): quantidade ímpar de argumentos");
        for (int i = 0; i < kv.length; i += 2) {
            Object k = kv[i];
            Object v = kv[i + 1];
            if (k == null) continue;
            m.put(String.valueOf(k), v);
        }
        return m;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantPasswordResetService.java
============================================================
package brito.com.multitenancy001.tenant.auth.app;

import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditService;
import brito.com.multitenancy001.infrastructure.security.jwt.JwtTokenProvider;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountResolver;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountSnapshot;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.users.app.command.TenantUserCommandService;
import brito.com.multitenancy001.tenant.users.app.query.TenantUserQueryService;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Duration;

/**
 * Application Service (Tenant): Password Reset.
 *
 * Regras:
 * - O token contém (email, tenantSchema, accountId).
 * - Reset com token executa no schema do tenant via TenantExecutor.
 * - Auditoria append-only (public schema) em ATTEMPT/SUCCESS/FAILURE.
 */
@Service
@RequiredArgsConstructor
public class TenantPasswordResetService {

    private final TenantUserQueryService tenantUserQueryService;
    private final TenantUserCommandService tenantUserCommandService;

    private final AccountResolver accountResolver;
    private final JwtTokenProvider jwtTokenProvider;
    private final TenantExecutor tenantExecutor;
    private final AppClock appClock;
    private final SecurityAuditService securityAuditService;

    public String generatePasswordResetToken(String slug, String email) {
        /* Gera token de reset (password reset request) para um usuário ativo. */
        if (!StringUtils.hasText(slug)) throw new ApiException(ApiErrorCode.INVALID_SLUG, "Slug é obrigatório", 400);
        if (!StringUtils.hasText(email)) throw new ApiException(ApiErrorCode.INVALID_LOGIN, "Email é obrigatório", 400);

        String normalizedEmail = email.trim().toLowerCase();

        securityAuditService.record(
                SecurityAuditActionType.PASSWORD_RESET_REQUESTED,
                AuditOutcome.ATTEMPT,
                null,
                null,
                normalizedEmail,
                null,
                null,
                null,
                "{\"slug\":\"" + slug + "\"}"
        );

        AccountSnapshot account = accountResolver.resolveActiveAccountBySlug(slug);

        String tenantSchemaRaw = account.tenantSchema();
        if (!StringUtils.hasText(tenantSchemaRaw)) {
            throw new ApiException(ApiErrorCode.ACCOUNT_NOT_READY, "Conta sem schema", 409);
        }

        final String tenantSchema = tenantSchemaRaw.trim();

        try {
            String token = tenantExecutor.runInTenantSchema(tenantSchema, () -> {
                TenantUser user = tenantUserQueryService.getUserByEmail(normalizedEmail, account.id());

                if (user.isDeleted() || user.isSuspendedByAccount() || user.isSuspendedByAdmin()) {
                    throw new ApiException(ApiErrorCode.USER_INACTIVE, "Usuário inativo", 403);
                }

                String passwordResetToken = jwtTokenProvider.generatePasswordResetToken(
                        user.getEmail(),
                        tenantSchema,
                        account.id()
                );

                user.setPasswordResetToken(passwordResetToken);
                user.setPasswordResetExpires(appClock.instant().plus(Duration.ofHours(1)));

                // ✅ assinatura nova: save(String tenantSchema, TenantUser user)
                tenantUserCommandService.save(tenantSchema, user);

                return passwordResetToken;
            });

            securityAuditService.record(
                    SecurityAuditActionType.PASSWORD_RESET_REQUESTED,
                    AuditOutcome.SUCCESS,
                    null,
                    null,
                    normalizedEmail,
                    null,
                    account.id(),
                    tenantSchema,
                    "{\"expiresHours\":1}"
            );

            return token;

        } catch (Exception e) {
            securityAuditService.record(
                    SecurityAuditActionType.PASSWORD_RESET_REQUESTED,
                    AuditOutcome.FAILURE,
                    null,
                    null,
                    normalizedEmail,
                    null,
                    account.id(),
                    tenantSchema,
                    "{\"reason\":\"error\"}"
            );
            throw e;
        }
    }

    public void resetPasswordWithToken(String token, String newPassword) {
        /* Executa reset com token (valida token e troca senha). */
        if (!StringUtils.hasText(token)) throw new ApiException(ApiErrorCode.INVALID_TOKEN, "Token inválido", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Nova senha é obrigatória", 400);

        String tenantSchema = jwtTokenProvider.getTenantSchemaFromToken(token);
        Long accountId = jwtTokenProvider.getAccountIdFromToken(token);
        String email = jwtTokenProvider.getEmailFromToken(token);

        securityAuditService.record(
                SecurityAuditActionType.PASSWORD_RESET_COMPLETED,
                AuditOutcome.ATTEMPT,
                null,
                null,
                email,
                null,
                accountId,
                tenantSchema,
                "{\"stage\":\"start\"}"
        );

        try {
            tenantExecutor.runInTenantSchema(tenantSchema, () -> {
                // ✅ assinatura correta (accountId, tenantSchema, email, token, newPassword)
                tenantUserCommandService.resetPasswordWithToken(accountId, tenantSchema, email, token, newPassword);
                return null;
            });

            securityAuditService.record(
                    SecurityAuditActionType.PASSWORD_RESET_COMPLETED,
                    AuditOutcome.SUCCESS,
                    null,
                    null,
                    email,
                    null,
                    accountId,
                    tenantSchema,
                    "{\"stage\":\"done\"}"
            );
        } catch (Exception e) {
            securityAuditService.record(
                    SecurityAuditActionType.PASSWORD_RESET_COMPLETED,
                    AuditOutcome.FAILURE,
                    null,
                    null,
                    email,
                    null,
                    accountId,
                    tenantSchema,
                    "{\"reason\":\"error\"}"
            );
            throw e;
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/TenantTokenRefreshService.java
============================================================
package brito.com.multitenancy001.tenant.auth.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.auth.app.AuthRefreshSessionService;
import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.auth.domain.AuthSessionDomain;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.auth.app.audit.TenantAuthAuditRecorder;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantAuthMechanics;
import brito.com.multitenancy001.tenant.auth.app.boundary.TenantRefreshIdentity;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Serviço de refresh token do Tenant.
 *
 * Regras:
 * - refresh rotaciona o refresh token no servidor (logout forte depende disso).
 * - Auditoria SEMPRE com details estruturado (Map/record) serializado via JsonDetailsMapper.
 * - Nunca montar JSON na mão.
 *
 * Otimização:
 * - resolveRefreshIdentity não faz query; a query ocorre só dentro do refreshTenantJwt.
 */
@Service
@RequiredArgsConstructor
public class TenantTokenRefreshService {

    private final TenantAuthMechanics authMechanics;
    private final TenantAuthAuditRecorder audit;
    private final AuthRefreshSessionService refreshSessions;
    private final JsonDetailsMapper jsonDetailsMapper;

    public JwtResult refresh(String refreshToken) {

        /** comentário: valida request, executa refresh e rotaciona sessão server-side */
        if (!StringUtils.hasText(refreshToken)) {
            throw new ApiException(ApiErrorCode.INVALID_REFRESH, "refreshToken é obrigatório", 400);
        }

        audit.record(
                AuthDomain.TENANT,
                AuthEventType.TOKEN_REFRESH,
                AuditOutcome.ATTEMPT,
                null,
                null,
                null,
                null,
                toJson(m("stage", "start"))
        );

        TenantRefreshIdentity id = authMechanics.resolveRefreshIdentity(refreshToken);

        JwtResult result = authMechanics.refreshTenantJwt(refreshToken);

        refreshSessions.rotateOrThrow(
                AuthSessionDomain.TENANT,
                refreshToken,
                result.refreshToken(),
                id.accountId(),
                result.userId(),
                id.tenantSchema()
        );

        audit.record(
                AuthDomain.TENANT,
                AuthEventType.TOKEN_REFRESH,
                AuditOutcome.SUCCESS,
                result.email(),
                result.userId(),
                result.accountId(),
                result.tenantSchema(),
                toJson(m("stage", "completed", "rotated", true))
        );

        return result;
    }

    private String toJson(Object details) {
        /** comentário: converte details (Map/record/String) em JSON string compatível com jsonb */
        if (details == null) return null;
        return jsonDetailsMapper.toJsonNode(details).toString();
    }

    private static Map<String, Object> m(Object... kv) {
        /** comentário: cria LinkedHashMap em pares key/value com ordem estável */
        Map<String, Object> m = new LinkedHashMap<>();
        if (kv == null) return m;
        if (kv.length % 2 != 0) throw new IllegalArgumentException("m(kv): quantidade ímpar de argumentos");
        for (int i = 0; i < kv.length; i += 2) {
            Object k = kv[i];
            Object v = kv[i + 1];
            if (k == null) continue;
            m.put(String.valueOf(k), v);
        }
        return m;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/audit/TenantAuthAuditRecorder.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.audit;

import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.AuthDomain;
import brito.com.multitenancy001.shared.domain.audit.AuthEventType;

public interface TenantAuthAuditRecorder {

    void record(
            AuthDomain domain,
            AuthEventType type,
            AuditOutcome outcome,
            String email,
            Long userId,
            Long accountId,
            String tenantSchema,
            String detailsJson
    );
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/boundary/TenantAuthMechanics.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.boundary;

import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountSnapshot;

/**
 * Boundary de mecânica de autenticação do Tenant.
 *
 * Responsabilidades:
 * - Definir contratos técnicos para login, refresh e logout no contexto Tenant.
 * - Isolar a camada de aplicação dos detalhes de JWT, Spring Security ou filtros.
 *
 * Papel arquitetural:
 * - Boundary (porta interna) entre Application Layer e Infrastructure Layer.
 * - Permite testar serviços de autenticação sem dependência de SecurityContext.
 *
 * Regras:
 * - NÃO contém lógica de persistência.
 * - NÃO depende de HTTP, filtros ou controllers.
 * - Implementações concretas vivem na camada infrastructure.
 *
 * Observação:
 * - Este contrato existe para manter o domínio e a aplicação desacoplados
 *   de frameworks de segurança.
 */
public interface TenantAuthMechanics {

    boolean verifyPasswordInTenant(AccountSnapshot account, String normalizedEmail, String rawPassword);

    JwtResult authenticateWithPassword(AccountSnapshot account, String normalizedEmail, String rawPassword);

    /**
     * Emite tokens para (account,email) sem pedir senha novamente.
     * Usado no CONFIRM (challenge já prova que senha foi validada no INIT).
     */
    JwtResult issueJwtForAccountAndEmail(AccountSnapshot account, String normalizedEmail);

    /**
     * Parse/validação do refresh token e extração de identidade mínima (SEM query).
     */
    TenantRefreshIdentity resolveRefreshIdentity(String refreshToken);

    /**
     * Refresh do JWT do Tenant:
     * - emite NOVO accessToken
     * - emite NOVO refreshToken (rotação)
     */
    JwtResult refreshTenantJwt(String refreshToken);
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/boundary/TenantLoginChallengeStore.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.boundary;

import brito.com.multitenancy001.tenant.auth.domain.TenantLoginChallenge;

import java.time.Instant;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

public interface TenantLoginChallengeStore {

    UUID create(Instant now, String normalizedEmail, Set<Long> candidateAccountIds);

    Optional<TenantLoginChallenge> findValid(UUID id, Instant now);

    void markUsed(UUID id, Instant now);
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/boundary/TenantRefreshIdentity.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.boundary;

/**
 * Identidade derivada do refresh token do Tenant.
 *
 * Campos:
 * - email: subject do token
 * - accountId: account do token
 * - tenantSchema: schema do token
 * - userId: opcional (pode ser resolvido via query no schema do tenant)
 *
 * Semântica atual do projeto:
 * - resolveRefreshIdentity(refreshToken) NÃO faz query => userId normalmente null
 * - refreshTenantJwt(refreshToken) faz query no tenant => pode preencher userId se quiser
 */
public record TenantRefreshIdentity(
        String email,
        Long accountId,
        String tenantSchema,
        Long userId
) {
    /**
     * Construtor “mínimo” (sem query). Mantém compatibilidade com chamadas:
     * new TenantRefreshIdentity(email, accountId, tenantSchema)
     */
    public TenantRefreshIdentity(String email, Long accountId, String tenantSchema) {
        this(email, accountId, tenantSchema, null);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/command/TenantLoginConfirmCommand.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.command;

public record TenantLoginConfirmCommand(
        String challengeId,
        Long accountId,
        String slug
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/command/TenantLoginInitCommand.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.command;

public record TenantLoginInitCommand(
        String email,
        String password
) { }


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/TenantLoginCandidateAccount.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.dto;

/**
 * Conta candidata no login do TENANT (multi-tenant selection).
 * Vem do public.login_identities + public.accounts.
 */
public record TenantLoginCandidateAccount(
        Long accountId,
        String displayName,
        String slug
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/TenantLoginResult.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.dto;

import brito.com.multitenancy001.shared.auth.app.dto.JwtResult;

import java.util.List;

public sealed interface TenantLoginResult {

    record LoginSuccess(JwtResult jwt) implements TenantLoginResult {}

    /**
     * NOVO (semântico): quando email+senha validam para mais de um tenant
     */
    record TenantSelectionRequired(
            String challengeId,
            List<TenantSelectionOptionData> details
    ) implements TenantLoginResult {}
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/app/dto/TenantSelectionOptionData.java
============================================================
package brito.com.multitenancy001.tenant.auth.app.dto;

public record TenantSelectionOptionData(
        Long accountId,
        String displayName,
        String slug
) { }

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/auth/domain/TenantLoginChallenge.java
============================================================
package brito.com.multitenancy001.tenant.auth.domain;

import java.time.Instant;
import java.util.Set;
import java.util.UUID;

public record TenantLoginChallenge(
        UUID id,
        String email,
        Set<Long> candidateAccountIds,
        Instant createdAt,
        Instant expiresAt,
        Instant usedAt
) {
    public boolean isUsed() {
        return usedAt != null;
    }

    public boolean isExpired(Instant now) {
        if (now == null) throw new IllegalArgumentException("now é obrigatório");
        if (expiresAt == null) return true;
        return now.isAfter(expiresAt);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/billing/api/TenantPaymentController.java
============================================================
package brito.com.multitenancy001.tenant.billing.api;

import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.tenant.billing.app.TenantPaymentService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/tenant/billing/payments")
@RequiredArgsConstructor
public class TenantPaymentController {

    private final TenantPaymentService tenantPaymentService;

    @GetMapping("/account/{accountId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_BILLING_READ.asAuthority())")
    public ResponseEntity<List<PaymentResponse>> listPayments(@PathVariable Long accountId) {
        return ResponseEntity.ok(tenantPaymentService.listPaymentsForAccount(accountId));
    }

    @GetMapping("/account/{accountId}/{paymentId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_BILLING_READ.asAuthority())")
    public ResponseEntity<PaymentResponse> getPayment(@PathVariable Long accountId, @PathVariable Long paymentId) {
        return ResponseEntity.ok(tenantPaymentService.getPaymentForAccount(accountId, paymentId));
    }

    @GetMapping("/account/{accountId}/has-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_BILLING_READ.asAuthority())")
    public ResponseEntity<Boolean> hasActive(@PathVariable Long accountId) {
        return ResponseEntity.ok(tenantPaymentService.hasActivePayment(accountId));
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/billing/app/TenantPaymentService.java
============================================================
package brito.com.multitenancy001.tenant.billing.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import brito.com.multitenancy001.shared.api.dto.billing.PaymentResponse;
import brito.com.multitenancy001.shared.billing.PaymentQueryService;
import brito.com.multitenancy001.shared.executor.PublicSchemaUnitOfWork;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantPaymentService {

    private final PublicSchemaUnitOfWork publicSchemaUnitOfWork;
    private final PaymentQueryService paymentQueryService;

    /**
     * ✅ Tenant service chamando PUBLIC de forma explícita, sem @Transactional meta-annotation aqui.
     * Semântica: cross-context => boundary é UnitOfWork.
     */
    public List<PaymentResponse> listPaymentsForAccount(Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);

        return publicSchemaUnitOfWork.readOnly(() -> paymentQueryService.listByAccount(accountId));
    }

    public PaymentResponse getPaymentForAccount(Long accountId, Long paymentId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        if (paymentId == null) throw new ApiException(ApiErrorCode.PAYMENT_ID_REQUIRED, "paymentId é obrigatório", 400);

        return publicSchemaUnitOfWork.readOnly(() -> paymentQueryService.getByAccount(accountId, paymentId));
    }

    public boolean hasActivePayment(Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);

        return publicSchemaUnitOfWork.readOnly(() -> paymentQueryService.hasActivePayment(accountId));
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/TenantCategoryController.java
============================================================
package brito.com.multitenancy001.tenant.categories.api;

import brito.com.multitenancy001.tenant.categories.api.dto.CategoryCreateRequest;
import brito.com.multitenancy001.tenant.categories.api.dto.CategoryResponse;
import brito.com.multitenancy001.tenant.categories.api.dto.CategoryUpdateRequest;
import brito.com.multitenancy001.tenant.categories.api.mapper.CategoryApiMapper;
import brito.com.multitenancy001.tenant.categories.app.TenantCategoryService;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Endpoints de Categories do Tenant.
 *
 * Padrão definitivo (DDD / layered simples):
 * - Controller: somente HTTP (DTO + mapper)
 * - Service: Commands + regras de negócio
 * - Domain: entidades + invariantes simples
 */
@RestController
@RequestMapping("/api/tenant/categories")
@RequiredArgsConstructor
public class TenantCategoryController {

    private final TenantCategoryService tenantCategoryService;
    private final CategoryApiMapper categoryApiMapper;

    /**
     * Lista categorias (NOT deleted).
     */
    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.asAuthority())")
    public ResponseEntity<List<CategoryResponse>> listAll() {
        // Comentário do método: contrato retorna DTO, não Entity.
        return ResponseEntity.ok(categoryApiMapper.toResponseList(tenantCategoryService.findAll()));
    }

    /**
     * Lista categorias ativas (NOT deleted, active=true).
     */
    @GetMapping("/active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.asAuthority())")
    public ResponseEntity<List<CategoryResponse>> listActive() {
        // Comentário do método: retorna apenas ativas (padrão atual do service).
        return ResponseEntity.ok(categoryApiMapper.toResponseList(tenantCategoryService.findActive()));
    }

    /**
     * Busca categoria por id (deleted => 404).
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.asAuthority())")
    public ResponseEntity<CategoryResponse> getById(@PathVariable Long id) {
        // Comentário do método: service garante 404 quando deleted.
        Category c = tenantCategoryService.findById(id);
        return ResponseEntity.ok(categoryApiMapper.toResponse(c));
    }

    /**
     * Pesquisa categorias por nome (NOT deleted).
     */
    @GetMapping("/search")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.asAuthority())")
    public ResponseEntity<List<CategoryResponse>> search(@RequestParam("name") String name) {
        // Comentário do método: service valida required/blank.
        return ResponseEntity.ok(categoryApiMapper.toResponseList(tenantCategoryService.searchByName(name)));
    }

    /**
     * Lista categorias com flags administrativas (opcionalmente incluindo deletadas/inativas).
     */
    @GetMapping("/admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.asAuthority())")
    public ResponseEntity<List<CategoryResponse>> listAdmin(
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        // Comentário do método: expõe deleted/active no DTO para suportar visão admin.
        return ResponseEntity.ok(
                categoryApiMapper.toResponseList(tenantCategoryService.findWithFlags(includeDeleted, includeInactive))
        );
    }

    /**
     * Cria categoria no tenant.
     */
    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<CategoryResponse> create(@Valid @RequestBody CategoryCreateRequest req) {
        // Comentário do método: DTO -> Command -> Service.
        Category saved = tenantCategoryService.create(categoryApiMapper.toCreateCommand(req));
        return ResponseEntity.status(HttpStatus.CREATED).body(categoryApiMapper.toResponse(saved));
    }

    /**
     * Atualiza categoria do tenant (PUT semântico).
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<CategoryResponse> update(@PathVariable Long id, @Valid @RequestBody CategoryUpdateRequest req) {
        // Comentário do método: service decide 404/409 conforme regras (deleted etc).
        Category updated = tenantCategoryService.update(id, categoryApiMapper.toUpdateCommand(req));
        return ResponseEntity.ok(categoryApiMapper.toResponse(updated));
    }

    /**
     * Alterna status ativo/inativo da categoria.
     */
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<CategoryResponse> toggleActive(@PathVariable Long id) {
        // Comentário do método: mantém endpoint existente, apenas troca retorno para DTO.
        return ResponseEntity.ok(categoryApiMapper.toResponse(tenantCategoryService.toggleActive(id)));
    }

    /**
     * Soft-delete idempotente: sempre 204 (mesmo se não existir / já estiver deletada).
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<Void> softDelete(@PathVariable Long id) {
        // Comentário do método: service implementa idempotência.
        tenantCategoryService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Restaura categoria previamente deletada (200 com body).
     */
    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<CategoryResponse> restore(@PathVariable Long id) {
        // Comentário do método: 404 se não existir; 200 com DTO se restaurar.
        return ResponseEntity.ok(categoryApiMapper.toResponse(tenantCategoryService.restore(id)));
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/TenantSubcategoryController.java
============================================================
package brito.com.multitenancy001.tenant.categories.api;

import brito.com.multitenancy001.tenant.categories.api.dto.SubcategoryCreateRequest;
import brito.com.multitenancy001.tenant.categories.api.dto.SubcategoryResponse;
import brito.com.multitenancy001.tenant.categories.api.dto.SubcategoryUpdateRequest;
import brito.com.multitenancy001.tenant.categories.api.mapper.SubcategoryApiMapper;
import brito.com.multitenancy001.tenant.categories.app.TenantSubcategoryService;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Endpoints de Subcategories do Tenant.
 *
 * Padrão definitivo:
 * - Controller só HTTP (DTO/mapper)
 * - Service com Commands/regras
 */
@RestController
@RequestMapping("/api/tenant/subcategories")
@RequiredArgsConstructor
public class TenantSubcategoryController {

    private final TenantSubcategoryService tenantSubcategoryService;
    private final SubcategoryApiMapper subcategoryApiMapper;

    /**
     * Busca subcategoria por id (deleted => 404).
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.asAuthority())")
    public ResponseEntity<SubcategoryResponse> getById(@PathVariable Long id) {
        // Comentário do método: service garante 404 quando deleted.
        Subcategory s = tenantSubcategoryService.findById(id);
        return ResponseEntity.ok(subcategoryApiMapper.toResponse(s));
    }

    /**
     * Lista subcategorias por categoria (admin flags).
     */
    @GetMapping("/category/{categoryId}/admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.asAuthority())")
    public ResponseEntity<List<SubcategoryResponse>> listByCategoryAdmin(
            @PathVariable Long categoryId,
            @RequestParam(defaultValue = "false") boolean includeDeleted,
            @RequestParam(defaultValue = "false") boolean includeInactive
    ) {
        // Comentário do método: retorna DTO, não entity.
        return ResponseEntity.ok(
                subcategoryApiMapper.toResponseList(
                        tenantSubcategoryService.findByCategoryIdAdmin(categoryId, includeDeleted, includeInactive)
                )
        );
    }

    /**
     * Lista subcategorias por categoria (NOT deleted, inclui inativas).
     */
    @GetMapping("/category/{categoryId}/not-deleted")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_READ.asAuthority())")
    public ResponseEntity<List<SubcategoryResponse>> listByCategoryNotDeleted(@PathVariable Long categoryId) {
        // Comentário do método: mantém endpoint existente, só muda retorno.
        return ResponseEntity.ok(
                subcategoryApiMapper.toResponseList(tenantSubcategoryService.findByCategoryIdNotDeleted(categoryId))
        );
    }

    /**
     * Cria subcategoria dentro de uma categoria.
     */
    @PostMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<SubcategoryResponse> create(
            @PathVariable Long categoryId,
            @Valid @RequestBody SubcategoryCreateRequest req
    ) {
        // Comentário do método: DTO + path -> Command -> Service.
        Subcategory saved = tenantSubcategoryService.create(subcategoryApiMapper.toCreateCommand(categoryId, req));
        return ResponseEntity.status(HttpStatus.CREATED).body(subcategoryApiMapper.toResponse(saved));
    }

    /**
     * Atualiza subcategoria (PUT semântico).
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<SubcategoryResponse> update(@PathVariable Long id, @Valid @RequestBody SubcategoryUpdateRequest req) {
        // Comentário do método: service aplica regras (409 se deletada etc).
        Subcategory updated = tenantSubcategoryService.update(id, subcategoryApiMapper.toUpdateCommand(req));
        return ResponseEntity.ok(subcategoryApiMapper.toResponse(updated));
    }

    /**
     * Alterna status ativo/inativo.
     */
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<SubcategoryResponse> toggleActive(@PathVariable Long id) {
        // Comentário do método: mantém comportamento, retorna DTO.
        return ResponseEntity.ok(subcategoryApiMapper.toResponse(tenantSubcategoryService.toggleActive(id)));
    }

    /**
     * Soft-delete idempotente: sempre 204.
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<Void> softDelete(@PathVariable Long id) {
        // Comentário do método: idempotência é no service.
        tenantSubcategoryService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Restore: 200 com body.
     */
    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_CATEGORY_WRITE.asAuthority())")
    public ResponseEntity<SubcategoryResponse> restore(@PathVariable Long id) {
        // Comentário do método: 404 se não existe; 200 com DTO.
        return ResponseEntity.ok(subcategoryApiMapper.toResponse(tenantSubcategoryService.restore(id)));
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/CategoryCreateRequest.java
============================================================
package brito.com.multitenancy001.tenant.categories.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/**
 * Request HTTP para criação de Category no contexto do Tenant.
 *
 * Regras:
 * - Controller recebe DTO (nunca Entity)
 * - Validações básicas ficam no DTO; regras de negócio ficam no Service/Domain
 */
public record CategoryCreateRequest(
        @NotBlank(message = "name é obrigatório")
        @Size(max = 100, message = "name deve ter no máximo 100 caracteres")
        String name
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/CategoryResponse.java
============================================================
package brito.com.multitenancy001.tenant.categories.api.dto;

/**
 * Response HTTP de Category (contrato da API do Tenant).
 */
public record CategoryResponse(
        Long id,
        String name,
        boolean active,
        boolean deleted
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/CategoryUpdateRequest.java
============================================================
package brito.com.multitenancy001.tenant.categories.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/**
 * Request HTTP para atualização de Category no contexto do Tenant.
 *
 * Observação:
 * - Aqui escolhi exigir "name" (PUT semântico = substituição completa).
 * - Se você preferir PATCH parcial, trocamos NotBlank por @Size e aceitamos null.
 */
public record CategoryUpdateRequest(
        @NotBlank(message = "name é obrigatório")
        @Size(max = 100, message = "name deve ter no máximo 100 caracteres")
        String name
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/SubcategoryCreateRequest.java
============================================================
package brito.com.multitenancy001.tenant.categories.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/**
 * Request HTTP para criação de Subcategory no contexto do Tenant.
 */
public record SubcategoryCreateRequest(
        @NotBlank(message = "name é obrigatório")
        @Size(max = 100, message = "name deve ter no máximo 100 caracteres")
        String name
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/SubcategoryResponse.java
============================================================
package brito.com.multitenancy001.tenant.categories.api.dto;

/**
 * Response HTTP de Subcategory (contrato da API do Tenant).
 */
public record SubcategoryResponse(
        Long id,
        Long categoryId,
        String name,
        boolean active,
        boolean deleted
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/dto/SubcategoryUpdateRequest.java
============================================================
package brito.com.multitenancy001.tenant.categories.api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/**
 * Request HTTP para atualização de Subcategory (PUT semântico).
 */
public record SubcategoryUpdateRequest(
        @NotBlank(message = "name é obrigatório")
        @Size(max = 100, message = "name deve ter no máximo 100 caracteres")
        String name
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/mapper/CategoryApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.categories.api.mapper;

import brito.com.multitenancy001.tenant.categories.api.dto.CategoryCreateRequest;
import brito.com.multitenancy001.tenant.categories.api.dto.CategoryResponse;
import brito.com.multitenancy001.tenant.categories.api.dto.CategoryUpdateRequest;
import brito.com.multitenancy001.tenant.categories.app.command.CreateCategoryCommand;
import brito.com.multitenancy001.tenant.categories.app.command.UpdateCategoryCommand;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Mapper HTTP <-> Application <-> Domain para Category.
 *
 * Regras:
 * - Controller só usa DTO + Mapper
 * - Service só usa Command + Domain
 */
@Component
public class CategoryApiMapper {

    /**
     * Mapeia request HTTP para Command de criação.
     */
    public CreateCategoryCommand toCreateCommand(CategoryCreateRequest req) {
        // Comentário do método: normalização final acontece no Service (trim/uniqueness).
        return new CreateCategoryCommand(req.name());
    }

    /**
     * Mapeia request HTTP para Command de atualização.
     */
    public UpdateCategoryCommand toUpdateCommand(CategoryUpdateRequest req) {
        // Comentário do método: PUT exige name; regra de unicidade é no Service.
        return new UpdateCategoryCommand(req.name());
    }

    /**
     * Mapeia Domain para Response HTTP.
     */
    public CategoryResponse toResponse(Category c) {
        // Comentário do método: expõe deleted para suportar endpoints admin sem trocar DTO.
        return new CategoryResponse(
                c.getId(),
                c.getName(),
                c.isActive(),
                c.isDeleted()
        );
    }

    /**
     * Mapeia lista Domain para lista Response.
     */
    public List<CategoryResponse> toResponseList(List<Category> list) {
        // Comentário do método: stream simples, sem regras.
        return list.stream().map(this::toResponse).toList();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/api/mapper/SubcategoryApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.categories.api.mapper;

import brito.com.multitenancy001.tenant.categories.api.dto.SubcategoryCreateRequest;
import brito.com.multitenancy001.tenant.categories.api.dto.SubcategoryResponse;
import brito.com.multitenancy001.tenant.categories.api.dto.SubcategoryUpdateRequest;
import brito.com.multitenancy001.tenant.categories.app.command.CreateSubcategoryCommand;
import brito.com.multitenancy001.tenant.categories.app.command.UpdateSubcategoryCommand;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Mapper HTTP <-> Application <-> Domain para Subcategory.
 */
@Component
public class SubcategoryApiMapper {

    /**
     * DTO + path param -> Command.
     */
    public CreateSubcategoryCommand toCreateCommand(Long categoryId, SubcategoryCreateRequest req) {
        // Comentário do método: Service valida e normaliza.
        return new CreateSubcategoryCommand(categoryId, req.name());
    }

    /**
     * DTO -> Command.
     */
    public UpdateSubcategoryCommand toUpdateCommand(SubcategoryUpdateRequest req) {
        // Comentário do método: PUT exige name.
        return new UpdateSubcategoryCommand(req.name());
    }

    /**
     * Domain -> Response.
     */
    public SubcategoryResponse toResponse(Subcategory s) {
        // Comentário do método: categoryId é derivado do relacionamento.
        Long categoryId = (s.getCategory() != null ? s.getCategory().getId() : null);

        return new SubcategoryResponse(
                s.getId(),
                categoryId,
                s.getName(),
                s.isActive(),
                s.isDeleted()
        );
    }

    /**
     * Lista Domain -> Lista Response.
     */
    public List<SubcategoryResponse> toResponseList(List<Subcategory> list) {
        // Comentário do método: map simples.
        return list.stream().map(this::toResponse).toList();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/app/TenantCategoryService.java
============================================================
package brito.com.multitenancy001.tenant.categories.app;

import brito.com.multitenancy001.infrastructure.persistence.tx.TenantReadOnlyTx;
import brito.com.multitenancy001.infrastructure.persistence.tx.TenantTx;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.categories.app.command.CreateCategoryCommand;
import brito.com.multitenancy001.tenant.categories.app.command.UpdateCategoryCommand;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.persistence.TenantCategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.List;

/**
 * Application Service de Categories (Tenant).
 *
 * Padrão definitivo:
 * - Recebe Commands (não DTO HTTP)
 * - Aplica regras de negócio (unicidade, soft-delete, etc.)
 * - Repositório fica somente com queries/persistência
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class TenantCategoryService {

    private final TenantCategoryRepository tenantCategoryRepository;

    // =========================================================
    // READ
    // =========================================================

    @TenantReadOnlyTx
    public Category findById(Long id) {
        // Comentário do método: contrato exige 400 para id null e 404 para deleted.
        if (id == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "id é obrigatório", 400);

        Category c = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.CATEGORY_NOT_FOUND, "Categoria não encontrada: " + id, 404));

        if (c.isDeleted()) {
            // Padrão escolhido: deleted => 404 (esconde recurso removido)
            throw new ApiException(ApiErrorCode.CATEGORY_DELETED, "Categoria deletada não pode ser consultada", 404);
        }

        return c;
    }

    @TenantReadOnlyTx
    public List<Category> findAll() {
        // Comentário do método: NOT deleted.
        return tenantCategoryRepository.findNotDeleted();
    }

    @TenantReadOnlyTx
    public List<Category> findActive() {
        // Comentário do método: NOT deleted e active=true.
        return tenantCategoryRepository.findNotDeletedActive();
    }

    @TenantReadOnlyTx
    public List<Category> searchByName(String name) {
        // Comentário do método: valida input e retorna NOT deleted.
        if (!StringUtils.hasText(name)) {
            throw new ApiException(ApiErrorCode.CATEGORY_NAME_REQUIRED, "name é obrigatório", 400);
        }
        return tenantCategoryRepository.findNotDeletedByNameContainingIgnoreCase(name.trim());
    }

    @TenantReadOnlyTx
    public List<Category> findWithFlags(boolean includeDeleted, boolean includeInactive) {
        // Comentário do método: endpoint admin (pode trazer deleted/inactive conforme flags).
        return tenantCategoryRepository.findWithFlags(includeDeleted, includeInactive);
    }

    // =========================================================
    // WRITE
    // =========================================================

    @TenantTx
    public Category create(CreateCategoryCommand cmd) {
        // Comentário do método: Command -> Domain (cria entidade aqui).
        if (cmd == null) throw new ApiException(ApiErrorCode.CATEGORY_REQUIRED, "payload é obrigatório", 400);
        if (!StringUtils.hasText(cmd.name())) {
            throw new ApiException(ApiErrorCode.CATEGORY_NAME_REQUIRED, "name é obrigatório", 400);
        }

        String name = cmd.name().trim();

        tenantCategoryRepository.findNotDeletedByNameIgnoreCase(name)
                .ifPresent(existing -> {
                    throw new ApiException(ApiErrorCode.CATEGORY_NAME_ALREADY_EXISTS, "Categoria já existe: " + name, 409);
                });

        Category category = new Category();
        category.setName(name);
        category.setDeleted(false);
        category.setActive(true);

        return tenantCategoryRepository.save(category);
    }

    @TenantTx
    public Category update(Long id, UpdateCategoryCommand cmd) {
        // Comentário do método: validações e regra de "não atualizar deletado".
        if (id == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "id é obrigatório", 400);
        if (cmd == null) throw new ApiException(ApiErrorCode.CATEGORY_REQUIRED, "payload é obrigatório", 400);

        Category existing = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.CATEGORY_NOT_FOUND, "Categoria não encontrada: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException(ApiErrorCode.CATEGORY_DELETED, "Não é permitido alterar categoria deletada", 409);
        }

        if (!StringUtils.hasText(cmd.name())) {
            throw new ApiException(ApiErrorCode.CATEGORY_NAME_REQUIRED, "name é obrigatório", 400);
        }

        String newName = cmd.name().trim();

        tenantCategoryRepository.findNotDeletedByNameIgnoreCase(newName)
                .ifPresent(other -> {
                    if (!other.getId().equals(id)) {
                        throw new ApiException(ApiErrorCode.CATEGORY_NAME_ALREADY_EXISTS, "Categoria já existe: " + newName, 409);
                    }
                });

        existing.setName(newName);

        return tenantCategoryRepository.save(existing);
    }

    @TenantTx
    public Category toggleActive(Long id) {
        // Comentário do método: mantém comportamento atual, apenas centraliza validações.
        if (id == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "id é obrigatório", 400);

        Category category = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.CATEGORY_NOT_FOUND, "Categoria não encontrada: " + id, 404));

        if (category.isDeleted()) {
            throw new ApiException(ApiErrorCode.CATEGORY_DELETED, "Não é permitido alterar categoria deletada", 409);
        }

        category.setActive(!category.isActive());
        return tenantCategoryRepository.save(category);
    }

    @TenantTx
    public void softDelete(Long id) {
        // Comentário do método: CONTRATO IDÊMPOTENTE => sempre "ok" (controller retorna 204).
        if (id == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "id é obrigatório", 400);

        tenantCategoryRepository.findById(id).ifPresent(category -> {
            if (category.isDeleted()) return;
            category.softDelete();
            tenantCategoryRepository.save(category);
        });
    }

    @TenantTx
    public Category restore(Long id) {
        // Comentário do método: restauração mantém 404 se não existir (padrão atual).
        if (id == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "id é obrigatório", 400);

        Category category = tenantCategoryRepository.findById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.CATEGORY_NOT_FOUND, "Categoria não encontrada: " + id, 404));

        category.restore();
        return tenantCategoryRepository.save(category);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/app/TenantSubcategoryService.java
============================================================
package brito.com.multitenancy001.tenant.categories.app;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;

import brito.com.multitenancy001.infrastructure.persistence.tx.TenantReadOnlyTx;
import brito.com.multitenancy001.infrastructure.persistence.tx.TenantTx;
import brito.com.multitenancy001.infrastructure.tenant.TenantSchemaUnitOfWork;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.categories.app.command.CreateSubcategoryCommand;
import brito.com.multitenancy001.tenant.categories.app.command.UpdateSubcategoryCommand;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import brito.com.multitenancy001.tenant.categories.persistence.TenantCategoryRepository;
import brito.com.multitenancy001.tenant.categories.persistence.TenantSubcategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantSubcategoryService {

    private final TenantSchemaUnitOfWork tenantSchemaUnitOfWork;

    private final TenantSubcategoryRepository tenantSubcategoryRepository;
    private final TenantCategoryRepository tenantCategoryRepository;

    // =========================================================
    // READ
    // =========================================================

    @TenantReadOnlyTx
    public Subcategory findById(Long id) {
        if (id == null) throw new ApiException(ApiErrorCode.SUBCATEGORY_ID_REQUIRED, "id é obrigatório", 400);

        Subcategory s = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.SUBCATEGORY_NOT_FOUND, "Subcategoria não encontrada: " + id, 404));

        if (s.isDeleted()) {
            throw new ApiException(ApiErrorCode.SUBCATEGORY_DELETED, "Subcategoria deletada não pode ser consultada", 404);
        }

        return s;
    }

    @TenantReadOnlyTx
    public List<Subcategory> findAll() {
        return tenantSubcategoryRepository.findNotDeleted();
    }

    @TenantReadOnlyTx
    public List<Subcategory> findActive() {
        return tenantSubcategoryRepository.findActiveNotDeleted();
    }

    @TenantReadOnlyTx
    public List<Subcategory> findByCategoryId(Long categoryId) {
        if (categoryId == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findActiveNotDeletedByCategoryId(categoryId);
    }

    @TenantReadOnlyTx
    public List<Subcategory> findByCategoryIdAdmin(Long categoryId, boolean includeDeleted, boolean includeInactive) {
        if (categoryId == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findByCategoryWithFlags(categoryId, includeDeleted, includeInactive);
    }

    @TenantReadOnlyTx
    public List<Subcategory> findByCategoryIdNotDeleted(Long categoryId) {
        if (categoryId == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "categoryId é obrigatório", 400);
        return tenantSubcategoryRepository.findNotDeletedByCategoryId(categoryId);
    }

    // =========================================================
    // WRITE (multi-step/multi-repo => TenantSchemaUnitOfWork)
    // =========================================================

       /**
     * Cria Subcategory dentro de uma Category.
     */
    public Subcategory create(CreateSubcategoryCommand cmd) {
        // Comentário do método: validações de negócio + multirepo dentro de tenantSchemaUnitOfWork.
        if (cmd == null) throw new ApiException(ApiErrorCode.SUBCATEGORY_REQUIRED, "payload é obrigatório", 400);
        if (cmd.categoryId() == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "categoryId é obrigatório", 400);
        if (!StringUtils.hasText(cmd.name())) {
            throw new ApiException(ApiErrorCode.SUBCATEGORY_NAME_REQUIRED, "name é obrigatório", 400);
        }

        Long categoryId = cmd.categoryId();
        String tenantSchema = requireBoundTenantSchema();

        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Category category = tenantCategoryRepository.findById(categoryId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.CATEGORY_NOT_FOUND, "Categoria não encontrada: " + categoryId, 404));

            if (category.isDeleted()) {
                throw new ApiException(ApiErrorCode.CATEGORY_DELETED, "Não é permitido criar subcategoria em categoria deletada", 409);
            }

            String name = cmd.name().trim();

            tenantSubcategoryRepository.findNotDeletedByCategoryIdAndNameIgnoreCase(categoryId, name)
                    .ifPresent(existing -> {
                        throw new ApiException(
                                ApiErrorCode.SUBCATEGORY_ALREADY_EXISTS,
                                "Subcategoria já existe na categoria " + categoryId + ": " + name,
                                409
                        );
                    });

            Subcategory sub = new Subcategory();
            sub.setCategory(category);
            sub.setName(name);
            sub.setDeleted(false);
            sub.setActive(true);

            return tenantSubcategoryRepository.save(sub);
        });
    }

       /**
     * Atualiza Subcategory.
     */
    public Subcategory update(Long id, UpdateSubcategoryCommand cmd) {
        // Comentário do método: proíbe atualizar deletada; valida unicidade por categoria.
        if (id == null) throw new ApiException(ApiErrorCode.SUBCATEGORY_ID_REQUIRED, "id é obrigatório", 400);
        if (cmd == null) throw new ApiException(ApiErrorCode.SUBCATEGORY_REQUIRED, "payload é obrigatório", 400);
        if (!StringUtils.hasText(cmd.name())) {
            throw new ApiException(ApiErrorCode.SUBCATEGORY_NAME_REQUIRED, "name é obrigatório", 400);
        }

        String tenantSchema = requireBoundTenantSchema();

        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Subcategory existing = tenantSubcategoryRepository.findByIdWithCategory(id)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.SUBCATEGORY_NOT_FOUND, "Subcategoria não encontrada: " + id, 404));

            if (existing.isDeleted()) {
                throw new ApiException(ApiErrorCode.SUBCATEGORY_DELETED, "Não é permitido alterar subcategoria deletada", 409);
            }

            String newName = cmd.name().trim();
            Long categoryId = existing.getCategory().getId();

            tenantSubcategoryRepository.findNotDeletedByCategoryIdAndNameIgnoreCase(categoryId, newName)
                    .ifPresent(other -> {
                        if (!other.getId().equals(id)) {
                            throw new ApiException(
                                    ApiErrorCode.SUBCATEGORY_ALREADY_EXISTS,
                                    "Subcategoria já existe na categoria " + categoryId + ": " + newName,
                                    409
                            );
                        }
                    });

            existing.setName(newName);
            return tenantSubcategoryRepository.save(existing);
        });
    }

    // =========================================================
    // WRITE (single-repo / simples => mantém @TenantTx)
    // =========================================================

    @TenantTx
    public Subcategory toggleActive(Long id) {
        Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.SUBCATEGORY_NOT_FOUND, "Subcategoria não encontrada: " + id, 404));

        if (sub.isDeleted()) {
            throw new ApiException(ApiErrorCode.SUBCATEGORY_DELETED, "Não é permitido alterar subcategoria deletada", 409);
        }

        sub.setActive(!sub.isActive());
        return tenantSubcategoryRepository.save(sub);
    }

       /**
     * Soft-delete idempotente: não falha se não existir / já estiver deletada.
     */
    @TenantTx
    public void softDelete(Long id) {
        // Comentário do método: contrato HTTP pede sempre 204.
        if (id == null) throw new ApiException(ApiErrorCode.SUBCATEGORY_ID_REQUIRED, "id é obrigatório", 400);

        tenantSubcategoryRepository.findByIdWithCategory(id).ifPresent(sub -> {
            if (sub.isDeleted()) return;
            sub.softDelete();
            tenantSubcategoryRepository.save(sub);
        });
    }

    @TenantTx
    public Subcategory restore(Long id) {
        Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.SUBCATEGORY_NOT_FOUND, "Subcategoria não encontrada: " + id, 404));

        sub.restore();
        return tenantSubcategoryRepository.save(sub);
    }

    // =========================================================
    // Helpers
    // =========================================================

    private String requireBoundTenantSchema() {
        String tenantSchema = TenantContext.getOrNull();
        if (tenantSchema == null) {
            throw new ApiException(
                    ApiErrorCode.TENANT_CONTEXT_REQUIRED,
                    "TenantContext não está bindado (tenantSchema=null). Operação requer contexto TENANT.",
                    500
            );
        }
        return tenantSchema;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/app/command/CreateCategoryCommand.java
============================================================
package brito.com.multitenancy001.tenant.categories.app.command;

/**
 * Command de Application Layer para criação de Category.
 *
 * Regras:
 * - Commands são objetos "puros" (sem annotations HTTP)
 * - Service trabalha com Commands, não com DTOs HTTP
 */
public record CreateCategoryCommand(
        String name
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/app/command/CreateSubcategoryCommand.java
============================================================
package brito.com.multitenancy001.tenant.categories.app.command;

/**
 * Command de criação de Subcategory.
 *
 * Observação:
 * - categoryId vem do path (controller), mas vira dado do Command para o Service.
 */
public record CreateSubcategoryCommand(
        Long categoryId,
        String name
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/app/command/UpdateCategoryCommand.java
============================================================
package brito.com.multitenancy001.tenant.categories.app.command;

/**
 * Command de Application Layer para atualização de Category.
 */
public record UpdateCategoryCommand(
        String name
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/app/command/UpdateSubcategoryCommand.java
============================================================
package brito.com.multitenancy001.tenant.categories.app.command;

/**
 * Command de atualização de Subcategory.
 */
public record UpdateSubcategoryCommand(
        String name
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/domain/Category.java
============================================================
package brito.com.multitenancy001.tenant.categories.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
        name = "categories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_categories_name",
                columnNames = "name"
        )
)
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
public class Category implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Embedded
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        this.active = false;
        // deletedAt será setado pelo AuditEntityListener (audit.deletedAt)
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        this.active = true;
        // deletedAt será limpo pelo AuditEntityListener se você quiser (opcional).
        // Se sua política for manter histórico, NÃO limpe. Se for "restore limpa", ajuste listener.
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/domain/Subcategory.java
============================================================
package brito.com.multitenancy001.tenant.categories.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(
        name = "subcategories",
        uniqueConstraints = @UniqueConstraint(
                name = "uk_subcategories_name_category",
                columnNames = {"category_id", "name"}
        )
)
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
public class Subcategory implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_subcategories_category")
    )
    private Category category;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false)
    private boolean active = true;

    @Column(nullable = false)
    private boolean deleted = false;

    @Embedded
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        this.active = false;
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        this.active = true;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/persistence/TenantCategoryRepository.java
============================================================
package brito.com.multitenancy001.tenant.categories.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.categories.domain.Category;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantCategoryRepository extends JpaRepository<Category, Long> {

    // =========
    // Normal (default): NÃO retorna deletados
    // =========

    @Query("select c from Category c where c.deleted = false order by c.name asc")
    List<Category> findNotDeleted();

    @Query("select c from Category c where c.deleted = false and c.active = true order by c.name asc")
    List<Category> findNotDeletedActive();

    @Query("select c from Category c where c.deleted = false and lower(c.name) = lower(:name)")
    Optional<Category> findNotDeletedByNameIgnoreCase(@Param("name") String name);

    @Query("select c from Category c where c.deleted = false and lower(c.name) like lower(concat('%', :name, '%')) order by c.name asc")
    List<Category> findNotDeletedByNameContainingIgnoreCase(@Param("name") String name);

    // =========
    // Admin: flags (includeDeleted / includeInactive)
    // =========

    @Query("""
           select c from Category c
           where (:includeDeleted = true or c.deleted = false)
             and (:includeInactive = true or c.active = true)
           order by c.name asc
           """)
    List<Category> findWithFlags(@Param("includeDeleted") boolean includeDeleted,
                                 @Param("includeInactive") boolean includeInactive);
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/categories/persistence/TenantSubcategoryRepository.java
============================================================
package brito.com.multitenancy001.tenant.categories.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.tenant.categories.domain.Subcategory;

import java.util.List;
import java.util.Optional;

@Repository
public interface TenantSubcategoryRepository extends JpaRepository<Subcategory, Long> {

    @Query("select s from Subcategory s join fetch s.category where s.id = :id")
    Optional<Subcategory> findByIdWithCategory(@Param("id") Long id);

    // =========
    // Default: NÃO retorna deletados
    // =========

    @Query("""
           select s from Subcategory s
           where s.deleted = false
           order by s.name asc
           """)
    List<Subcategory> findNotDeleted();

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.active = true
           order by s.name asc
           """)
    List<Subcategory> findActiveNotDeleted();

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.category.id = :categoryId
           order by s.name asc
           """)
    List<Subcategory> findNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
           select s from Subcategory s
           where s.deleted = false and s.active = true and s.category.id = :categoryId
           order by s.name asc
           """)
    List<Subcategory> findActiveNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
           select s from Subcategory s
           where s.deleted = false
             and s.category.id = :categoryId
             and lower(s.name) = lower(:name)
           """)
    Optional<Subcategory> findNotDeletedByCategoryIdAndNameIgnoreCase(@Param("categoryId") Long categoryId,
                                                                      @Param("name") String name);

    // =========
    // Admin: flags (includeDeleted / includeInactive)
    // =========

    @Query("""
           select s from Subcategory s
           where s.category.id = :categoryId
             and (:includeDeleted = true or s.deleted = false)
             and (:includeInactive = true or s.active = true)
           order by s.name asc
           """)
    List<Subcategory> findByCategoryWithFlags(@Param("categoryId") Long categoryId,
                                              @Param("includeDeleted") boolean includeDeleted,
                                              @Param("includeInactive") boolean includeInactive);
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/debug/api/TenantDebugController.java
============================================================
package brito.com.multitenancy001.tenant.debug.api;

import brito.com.multitenancy001.tenant.debug.api.dto.TenantSchemaDebugResponse;
import brito.com.multitenancy001.tenant.debug.app.TenantDebugQueryService;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Profile;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

/**
 * Endpoints DEV-only para depuração do multi-tenant.
 *
 * Regras:
 * - Somente no profile "dev".
 * - Controller NÃO injeta JdbcTemplate (ControllerComplianceVerifier).
 * - Delegar para Application Service.
 */
@RestController
@RequiredArgsConstructor
@Profile("dev")
public class TenantDebugController {

    private final TenantDebugQueryService tenantDebugQueryService;

    /**
     * DEBUG/DEV:
     * Força o tenant via header X-Tenant para validar o multi-tenant SEM depender de JWT.
     *
     * Exemplo:
     * GET /api/tenant/_debug/schema
     * Header: X-Tenant: t_foton_devices_6d79df
     */
    @GetMapping("/api/tenant/_debug/schema")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SETTINGS_READ.asAuthority())")
    public ResponseEntity<TenantSchemaDebugResponse> schema(
            /* Header opcional de tenant para bind do schema. */
            @RequestHeader(name = "X-Tenant", required = false) String tenantHeaderRaw
    ) {
        TenantSchemaDebugResponse response = tenantDebugQueryService.getSchemaDebug(tenantHeaderRaw);
        return ResponseEntity.ok(response);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/debug/api/dto/TenantSchemaDebugResponse.java
============================================================
package brito.com.multitenancy001.tenant.debug.api.dto;

/**
 * DTO de resposta para diagnóstico do schema do Tenant.
 *
 * Campos:
 * - tenantHeader: valor do header recebido (se houver)
 * - currentSchema: resultado de current_schema()
 * - searchPath: resultado do SHOW search_path
 * - valid: sanity-check simples do contexto
 */
public record TenantSchemaDebugResponse(
        String tenantHeader,
        String currentSchema,
        String searchPath,
        boolean valid
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/debug/app/TenantDebugQueryService.java
============================================================
package brito.com.multitenancy001.tenant.debug.app;

import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.tenant.debug.api.dto.TenantSchemaDebugResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

/**
 * Application Service (Tenant) para diagnóstico do contexto de schema/tenant.
 *
 * <p><b>Regras do projeto:</b></p>
 * <ul>
 *   <li>Controller não injeta {@code JdbcTemplate} diretamente (ControllerComplianceVerifier).</li>
 *   <li>Em TENANT, evitar {@code @Transactional} direto. Este serviço não declara transação.</li>
 * </ul>
 *
 * <p><b>Uso:</b> endpoint de debug para inspecionar {@code current_schema()} e {@code search_path},
 * e checar se o bind de {@link TenantContext} está sendo aplicado.</p>
 *
 * <p><b>Segurança:</b> não retorna dados sensíveis, apenas metadados do DB.</p>
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class TenantDebugQueryService {

    private final JdbcTemplate jdbcTemplate;

    /**
     * Coleta informações úteis para diagnosticar:
     * <ul>
     *   <li>schema efetivo ({@code current_schema()})</li>
     *   <li>search_path ({@code show search_path})</li>
     *   <li>se o header/valor recebido é válido para bind de schema</li>
     * </ul>
     *
     * @param tenantHeaderRaw valor bruto recebido (ex.: header X-Tenant-Schema)
     * @return resposta com informações de debug do contexto
     */
    public TenantSchemaDebugResponse getSchemaDebug(String tenantHeaderRaw) {
        String tenantHeader = (tenantHeaderRaw == null ? null : tenantHeaderRaw.trim());
        String tenantNormalized = StringUtils.hasText(tenantHeader) ? tenantHeader : null;

        boolean valid = isValidSchemaIdentifierOrNull(tenantNormalized);

        // se inválido, não bindamos tenant (fica PUBLIC)
        String tenantToBind = valid ? tenantNormalized : null;

        if (log.isDebugEnabled()) {
            log.debug("🧪 TenantDebugQueryService.getSchemaDebug | raw='{}' | normalized='{}' | valid={} | bind='{}'",
                    tenantHeaderRaw, tenantNormalized, valid, tenantToBind);
        }

        try (TenantContext.Scope ignored = TenantContext.scope(tenantToBind)) {
            String currentSchema = jdbcTemplate.queryForObject("select current_schema()", String.class);
            String searchPath = jdbcTemplate.queryForObject("show search_path", String.class);

            if (log.isDebugEnabled()) {
                log.debug("🧪 TenantDebug result | bind='{}' | current_schema='{}' | search_path='{}'",
                        tenantToBind, currentSchema, searchPath);
            }

            return new TenantSchemaDebugResponse(
                    tenantNormalized,
                    currentSchema,
                    searchPath,
                    valid
            );
        }
    }

    /**
     * Valida se o schema pode ser bindado com segurança.
     *
     * <p>Regra: identificador SQL simples (sem aspas), estilo Postgres:
     * começa com letra/underscore, seguido de letras/números/underscore.</p>
     */
    private static boolean isValidSchemaIdentifierOrNull(String tenantSchema) {
        if (tenantSchema == null) return true; // null significa PUBLIC
        return tenantSchema.matches("^[a-zA-Z_][a-zA-Z0-9_]*$");
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/api/TenantMeController.java
============================================================
package brito.com.multitenancy001.tenant.me.api;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import brito.com.multitenancy001.tenant.me.api.dto.TenantChangeMyPasswordRequest;
import brito.com.multitenancy001.tenant.me.api.dto.TenantMeResponse;
import brito.com.multitenancy001.tenant.me.api.dto.UpdateMyProfileRequest;
import brito.com.multitenancy001.tenant.me.api.mapper.TenantMeApiMapper;
import brito.com.multitenancy001.tenant.me.app.TenantMeService;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;


/**
 * Controller do Tenant para operações do "usuário logado" (perfil e credenciais).
 *
 * Responsabilidade:
 * - Expor endpoints HTTP para consultar/alterar dados do usuário autenticado.
 *
 * Regras:
 * - Controller não acessa repository/JPA diretamente (somente Application Service).
 * - RequestBody deve ser DTO e validado com @Valid.
 * - Respostas devem ser DTO (nunca Entity).
 * - Autorização deve ser feita via permissions (hasAuthority(...asAuthority())).
 *
 * Observação:
 * - Alterações sensíveis (ex.: troca de senha) devem gerar auditoria no serviço de aplicação.
 */

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/tenant/me")
public class TenantMeController {

    private final TenantMeService tenantMeService;
    private final TenantMeApiMapper tenantMeApiMapper;

    // ✅ Perfil do usuário logado
    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.asAuthority())")
    public ResponseEntity<TenantMeResponse> me() {
        TenantUser tenantUser = tenantMeService.getMyProfile();
        return ResponseEntity.ok(tenantMeApiMapper.toMe(tenantUser));
    }

    // ✅ Atualiza perfil do usuário logado (SAFE whitelist)
    @PutMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_UPDATE.asAuthority())")
    public ResponseEntity<TenantMeResponse> update(@Valid @RequestBody UpdateMyProfileRequest req) {
        TenantUser tenantUser = tenantMeService.updateMyProfile(req);
        return ResponseEntity.ok(tenantMeApiMapper.toMe(tenantUser));
    }

    // ✅ Troca minha senha (JWT) - destrava mustChangePassword
    @PatchMapping("/password")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_UPDATE.asAuthority())")
    public ResponseEntity<Void> changeMyPassword(@Valid @RequestBody TenantChangeMyPasswordRequest req) {
        tenantMeService.changeMyPassword(req);
        return ResponseEntity.noContent().build();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/api/dto/TenantChangeMyPasswordRequest.java
============================================================
package brito.com.multitenancy001.tenant.me.api.dto;

import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public record TenantChangeMyPasswordRequest(

        @NotBlank(message = "Senha atual é obrigatória")
        @Size(min = 8, max = 72, message = "Senha atual deve ter entre 8 e 72 caracteres")
        String currentPassword,

        @NotBlank(message = "Nova senha é obrigatória")
        @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, message = "Senha fraca / inválida")
        @Size(min = 8, max = 72, message = "Nova senha deve ter entre 8 e 72 caracteres")
        String newPassword,

        @NotBlank(message = "Confirmar nova senha é obrigatório")
        @Pattern(regexp = ValidationPatterns.PASSWORD_PATTERN, message = "Senha fraca / inválida")
        @Size(min = 8, max = 72, message = "Confirmar nova senha deve ter entre 8 e 72 caracteres")
        String confirmNewPassword
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/api/dto/TenantMeResponse.java
============================================================
package brito.com.multitenancy001.tenant.me.api.dto;

import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.tenant.security.TenantRole;

public record TenantMeResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRole role,
        String phone,
        String avatarUrl,
        String timezone,
        String locale,
        boolean mustChangePassword,
        EntityOrigin origin,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/api/dto/UpdateMyProfileRequest.java
============================================================
package brito.com.multitenancy001.tenant.me.api.dto;

import jakarta.validation.constraints.Size;
import org.hibernate.validator.constraints.URL;

public record UpdateMyProfileRequest(
        @Size(min = 2, max = 100, message = "name deve ter entre 2 e 100 caracteres")
        String name,

        @Size(max = 20, message = "phone deve ter no máximo 20 caracteres")
        String phone,

        @Size(max = 500, message = "avatarUrl deve ter no máximo 500 caracteres")
        @URL(protocol = "https", message = "avatarUrl deve ser uma URL https válida")
        String avatarUrl,

        @Size(max = 20, message = "locale deve ter no máximo 20 caracteres")
        String locale,

        @Size(max = 60, message = "timezone deve ter no máximo 60 caracteres")
        String timezone
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/api/mapper/TenantMeApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.me.api.mapper;

import brito.com.multitenancy001.tenant.me.api.dto.TenantMeResponse;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import org.springframework.stereotype.Component;

@Component
public class TenantMeApiMapper {

    public TenantMeResponse toMe(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantMeResponse(
                tenantUser.getId(),
                tenantUser.getAccountId(),
                tenantUser.getName(),
                tenantUser.getEmail(),
                tenantUser.getRole(),
                tenantUser.getPhone(),
                tenantUser.getAvatarUrl(),
                tenantUser.getTimezone(),
                tenantUser.getLocale(),
                tenantUser.isMustChangePassword(),
                tenantUser.getOrigin(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                tenantUser.isDeleted(),
                enabled
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/me/app/TenantMeService.java
============================================================
package brito.com.multitenancy001.tenant.me.app;

import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.integration.security.TenantRequestIdentityService;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.me.api.dto.TenantChangeMyPasswordRequest;
import brito.com.multitenancy001.tenant.me.api.dto.UpdateMyProfileRequest;
import brito.com.multitenancy001.tenant.users.app.command.TenantUserCommandService;
import brito.com.multitenancy001.tenant.users.app.query.TenantUserQueryService;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

/**
 * Application Service (Tenant): Me.
 *
 * Regras:
 * - Resolve accountId/userId/tenantSchema da identidade do request.
 * - Executa tudo dentro do schema via TenantExecutor.
 * - Não acessa repository direto (só services).
 */
@Service
@RequiredArgsConstructor
public class TenantMeService {

    private final TenantUserQueryService tenantUserQueryService;
    private final TenantUserCommandService tenantUserCommandService;

    private final TenantExecutor tenantExecutor;
    private final TenantRequestIdentityService requestIdentity;
    private final AppClock appClock;

    public TenantUser getMyProfile() {
        /* Retorna perfil do usuário autenticado no tenant. */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();
        Long userId = requestIdentity.getCurrentUserId();

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                tenantUserQueryService.getUser(userId, accountId)
        );
    }

    public TenantUser updateMyProfile(UpdateMyProfileRequest req) {
        /* Atualiza dados de perfil do usuário autenticado (sem alterar role/perms). */
        if (req == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "request é obrigatório", 400);

        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();
        Long userId = requestIdentity.getCurrentUserId();

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                // ✅ FIX: assinatura correta: (userId, accountId, tenantSchema, name, phone, avatarUrl, locale, timezone, now)
                tenantUserCommandService.updateProfile(
                        userId,
                        accountId,
                        tenantSchema,
                        req.name(),
                        req.phone(),
                        req.avatarUrl(),
                        req.locale(),
                        req.timezone(),
                        appClock.instant()
                )
        );
    }

    public void changeMyPassword(TenantChangeMyPasswordRequest req) {
        /* Troca autenticada de senha (self). */
        if (req == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "request é obrigatório", 400);

        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();
        Long userId = requestIdentity.getCurrentUserId();

        tenantExecutor.runInTenantSchema(tenantSchema, () -> {
            // ✅ FIX: assinatura correta: (userId, accountId, tenantSchema, currentPassword, newPassword, confirmNewPassword)
            tenantUserCommandService.changeMyPassword(
                    userId,
                    accountId,
                    tenantSchema,
                    req.currentPassword(),
                    req.newPassword(),
                    req.confirmNewPassword()
            );
            return null;
        });
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/payments/app/audit/TenantBillingSecurityAuditRecorder.java
============================================================
package brito.com.multitenancy001.tenant.payments.app.audit;

import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditService;
import brito.com.multitenancy001.integration.security.TenantRequestIdentityService;
import brito.com.multitenancy001.shared.audit.AuditDetails;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Recorder de auditoria de segurança para Billing/Payments (TENANT).
 *
 * Objetivo:
 * - Auditar eventos relevantes de billing (criação e mudança de status).
 * - Padronizar details via Map + JsonDetailsMapper.
 *
 * Regras:
 * - Não registrar PAN/cartão, tokens de PSP, payloads sensíveis.
 * - Preferir IDs e status, valores agregados e referências.
 */
@Service
@RequiredArgsConstructor
public class TenantBillingSecurityAuditRecorder {

    private static final String SCOPE = "tenant.billing";

    private final TenantRequestIdentityService requestIdentity;
    private final SecurityAuditService securityAuditService;
    private final JsonDetailsMapper jsonDetailsMapper;

    public void paymentCreatedAttempt(Long paymentId, String providerRef, Map<String, Object> extra) {
        /* Registra ATTEMPT de criação de pagamento. */
        record(SecurityAuditActionType.PAYMENT_CREATED, AuditOutcome.ATTEMPT, details("payment_created", paymentId, providerRef, extra));
    }

    public void paymentCreatedSuccess(Long paymentId, String providerRef, Map<String, Object> extra) {
        /* Registra SUCCESS de criação de pagamento. */
        record(SecurityAuditActionType.PAYMENT_CREATED, AuditOutcome.SUCCESS, details("payment_created", paymentId, providerRef, extra));
    }

    public void paymentCreatedDenied(Long paymentId, String providerRef, Map<String, Object> extra) {
        /* Registra DENIED de criação de pagamento. */
        record(SecurityAuditActionType.PAYMENT_CREATED, AuditOutcome.DENIED, details("payment_created", paymentId, providerRef, extra));
    }

    public void paymentCreatedFailure(Long paymentId, String providerRef, Map<String, Object> extra) {
        /* Registra FAILURE de criação de pagamento. */
        record(SecurityAuditActionType.PAYMENT_CREATED, AuditOutcome.FAILURE, details("payment_created", paymentId, providerRef, extra));
    }

    public void paymentStatusChangedAttempt(Long paymentId, String fromStatus, String toStatus, Map<String, Object> extra) {
        /* Registra ATTEMPT de mudança de status do pagamento. */
        Map<String, Object> d = details("payment_status_changed", paymentId, null, extra);
        d.put("fromStatus", fromStatus);
        d.put("toStatus", toStatus);
        record(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, AuditOutcome.ATTEMPT, d);
    }

    public void paymentStatusChangedSuccess(Long paymentId, String fromStatus, String toStatus, Map<String, Object> extra) {
        /* Registra SUCCESS de mudança de status do pagamento. */
        Map<String, Object> d = details("payment_status_changed", paymentId, null, extra);
        d.put("fromStatus", fromStatus);
        d.put("toStatus", toStatus);
        record(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, AuditOutcome.SUCCESS, d);
    }

    public void paymentStatusChangedDenied(Long paymentId, String fromStatus, String toStatus, Map<String, Object> extra) {
        /* Registra DENIED de mudança de status do pagamento. */
        Map<String, Object> d = details("payment_status_changed", paymentId, null, extra);
        d.put("fromStatus", fromStatus);
        d.put("toStatus", toStatus);
        record(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, AuditOutcome.DENIED, d);
    }

    public void paymentStatusChangedFailure(Long paymentId, String fromStatus, String toStatus, Map<String, Object> extra) {
        /* Registra FAILURE de mudança de status do pagamento. */
        Map<String, Object> d = details("payment_status_changed", paymentId, null, extra);
        d.put("fromStatus", fromStatus);
        d.put("toStatus", toStatus);
        record(SecurityAuditActionType.PAYMENT_STATUS_CHANGED, AuditOutcome.FAILURE, d);
    }

    private void record(SecurityAuditActionType actionType, AuditOutcome outcome, Map<String, Object> details) {
        /* Grava evento append-only no public schema via SecurityAuditService. */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        Long actorUserId = requestIdentity.getCurrentUserId();
        String actorEmail = requestIdentity.getCurrentEmail();

        String detailsJson = toJson(details);

        securityAuditService.record(
                actionType,
                outcome,
                actorEmail,
                actorUserId,
                null,
                null,
                accountId,
                tenantSchema,
                detailsJson
        );
    }

    private Map<String, Object> details(String event, Long paymentId, String providerRef, Map<String, Object> extra) {
        /* Monta details base de billing com campos seguros. */
        Map<String, Object> d = AuditDetails.base(SCOPE, event);
        if (paymentId != null) d.put("paymentId", paymentId);
        if (providerRef != null) d.put("providerRef", providerRef);
        if (extra != null && !extra.isEmpty()) d.put("extra", new LinkedHashMap<>(extra));
        return d;
    }

    private String toJson(Object details) {
        /* Converte details (Map/record/String) em JSON string compatível com jsonb. */
        if (details == null) return null;
        return jsonDetailsMapper.toJsonNode(details).toString();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/TenantProductController.java
============================================================
package brito.com.multitenancy001.tenant.products.api;

import brito.com.multitenancy001.tenant.products.api.dto.ProductResponse;
import brito.com.multitenancy001.tenant.products.api.dto.ProductUpsertRequest;
import brito.com.multitenancy001.tenant.products.api.dto.SupplierProductCountResponse;
import brito.com.multitenancy001.tenant.products.api.mapper.ProductApiMapper;
import brito.com.multitenancy001.tenant.products.app.TenantProductService;
import brito.com.multitenancy001.tenant.products.app.command.CreateProductCommand;
import brito.com.multitenancy001.tenant.products.domain.Product;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;

/**
 * Tenant API: Products.
 *
 * Padrão definitivo:
 * - Controller só HTTP (DTO Request/Response)
 * - Controller NÃO cria/manipula Entity
 * - Controller chama Application Service via Command (APP)
 * - Mapper converte Domain -> Response DTO
 */
@RestController
@RequestMapping("/api/tenant/products")
@RequiredArgsConstructor
public class TenantProductController {

    private final ProductApiMapper productApiMapper;
    private final TenantProductService tenantProductService;

    /**
     * Busca produto por id (escopo: tenant).
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<ProductResponse> getById(@PathVariable UUID id) {
        // método: delega ao service e mapeia para response DTO
        Product product = tenantProductService.findById(id);
        return ResponseEntity.ok(productApiMapper.toResponse(product));
    }

    /**
     * Lista paginada de produtos (default: conforme regras do service).
     */
    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<Page<ProductResponse>> list(Pageable pageable) {
        // método: paginação e mapeamento
        Page<ProductResponse> page = tenantProductService.findAll(pageable).map(productApiMapper::toResponse);
        return ResponseEntity.ok(page);
    }

    /**
     * Lista produtos por categoria (default: somente não-deletados/ativos conforme service).
     */
    @GetMapping("/category/{categoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<List<ProductResponse>> listByCategory(@PathVariable Long categoryId) {
        // método: consulta e mapeamento
        List<ProductResponse> out = tenantProductService.findByCategoryId(categoryId).stream()
                .map(productApiMapper::toResponse)
                .toList();
        return ResponseEntity.ok(out);
    }

    /**
     * Lista produtos por subcategoria (default: conforme regras do service).
     */
    @GetMapping("/subcategory/{subcategoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<List<ProductResponse>> listBySubcategory(@PathVariable Long subcategoryId) {
        // método: consulta e mapeamento
        List<ProductResponse> out = tenantProductService.findBySubcategoryId(subcategoryId).stream()
                .map(productApiMapper::toResponse)
                .toList();
        return ResponseEntity.ok(out);
    }

    /**
     * Lista produtos por supplier (default: conforme regras do service).
     */
    @GetMapping("/supplier/{supplierId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<List<ProductResponse>> listBySupplier(@PathVariable UUID supplierId) {
        // método: consulta e mapeamento
        List<ProductResponse> out = tenantProductService.findBySupplierId(supplierId).stream()
                .map(productApiMapper::toResponse)
                .toList();
        return ResponseEntity.ok(out);
    }

    /**
     * Query: contagem de produtos por supplier (agregado).
     */
    @GetMapping("/count-by-supplier")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<List<SupplierProductCountResponse>> countBySupplier() {
        // método: service retorna app.dto e controller mapeia para response DTO
        var rows = tenantProductService.countProductsBySupplier();
        var out = rows.stream()
                .map(r -> new SupplierProductCountResponse(r.supplierId(), r.productCount()))
                .toList();
        return ResponseEntity.ok(out);
    }

    /**
     * Retorna o valor total do inventário (estoque * custo) do tenant.
     */
    @GetMapping("/inventory-value")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_INVENTORY_READ.asAuthority())")
    public ResponseEntity<BigDecimal> getTotalInventoryValue() {
        // método: delega cálculo ao service
        BigDecimal value = tenantProductService.calculateTotalInventoryValue();
        return ResponseEntity.ok(value != null ? value : BigDecimal.ZERO);
    }

    /**
     * Retorna a contagem de produtos com estoque baixo.
     */
    @GetMapping("/low-stock/count")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_INVENTORY_READ.asAuthority())")
    public ResponseEntity<Long> countLowStock(@RequestParam(name = "threshold", defaultValue = "5") Integer threshold) {
        // método: delega cálculo ao service
        Long count = tenantProductService.countLowStockProducts(threshold);
        return ResponseEntity.ok(count != null ? count : 0L);
    }

    /**
     * Alterna status ativo/inativo do produto.
     */
    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_WRITE.asAuthority())")
    public ResponseEntity<ProductResponse> toggleActive(@PathVariable UUID id) {
        // método: delega ao service e mapeia response
        Product updated = tenantProductService.toggleActive(id);
        return ResponseEntity.ok(productApiMapper.toResponse(updated));
    }

    /**
     * Atualiza o custo do produto (costPrice).
     */
    @PatchMapping("/{id}/cost-price")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_WRITE.asAuthority())")
    public ResponseEntity<ProductResponse> updateCostPrice(@PathVariable UUID id, @RequestParam BigDecimal costPrice) {
        // método: delega ao service e mapeia response
        Product updatedProduct = tenantProductService.updateCostPrice(id, costPrice);
        return ResponseEntity.ok(productApiMapper.toResponse(updatedProduct));
    }

    /**
     * Cria produto detalhado a partir de um request DTO (upsert).
     *
     * Importante:
     * - Controller NÃO cria entities (Product/Category/Subcategory/Supplier)
     * - Controller transforma DTO -> Command e chama o service
     */
    @PostMapping("/detailed")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_WRITE.asAuthority())")
    public ResponseEntity<ProductResponse> createDetailedProduct(@Valid @RequestBody ProductUpsertRequest req) {
        // método: transforma request em command e delega ao service
        CreateProductCommand cmd = new CreateProductCommand(
                req.name(),
                req.description(),
                req.sku(),
                req.price(),
                req.stockQuantity(),
                req.minStock(),
                req.maxStock(),
                req.costPrice(),
                req.categoryId(),
                req.subcategoryId(),
                req.brand(),
                req.weightKg(),
                req.dimensions(),
                req.barcode(),
                req.active(),
                req.supplierId()
        );

        Product savedProduct = tenantProductService.create(cmd);
        return ResponseEntity.status(HttpStatus.CREATED).body(productApiMapper.toResponse(savedProduct));
    }

    /**
     * "Any" por categoria: pode incluir deleted/inactive conforme regra do service.
     */
    @GetMapping("/any/category/{categoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<List<ProductResponse>> findAnyByCategory(@PathVariable Long categoryId) {
        // método: consulta "any" e mapeia
        List<ProductResponse> out = tenantProductService.findAnyByCategoryId(categoryId).stream()
                .map(productApiMapper::toResponse)
                .toList();
        return ResponseEntity.ok(out);
    }

    /**
     * "Any" por subcategoria: pode incluir deleted/inactive conforme regra do service.
     */
    @GetMapping("/any/subcategory/{subcategoryId}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<List<ProductResponse>> findAnyBySubcategory(@PathVariable Long subcategoryId) {
        // método: consulta "any" e mapeia
        List<ProductResponse> out = tenantProductService.findAnyBySubcategoryId(subcategoryId).stream()
                .map(productApiMapper::toResponse)
                .toList();
        return ResponseEntity.ok(out);
    }

    /**
     * "Any" por marca: pode incluir deleted/inactive conforme regra do service.
     */
    @GetMapping("/any/brand")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<List<ProductResponse>> findAnyByBrand(@RequestParam("brand") String brand) {
        // método: consulta "any" e mapeia
        List<ProductResponse> out = tenantProductService.findAnyByBrandIgnoreCase(brand).stream()
                .map(productApiMapper::toResponse)
                .toList();
        return ResponseEntity.ok(out);
    }

    /**
     * Busca por nome (lista simples).
     */
    @GetMapping("/search")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_PRODUCT_READ.asAuthority())")
    public ResponseEntity<List<ProductResponse>> searchByName(
            @RequestParam("name") String name,
            @RequestParam(name = "minPrice", required = false) BigDecimal minPrice,
            @RequestParam(name = "maxPrice", required = false) BigDecimal maxPrice,
            @RequestParam(name = "minStock", required = false) Integer minStock,
            @RequestParam(name = "maxStock", required = false) Integer maxStock
    ) {
        // método: delega filtro ao service e mapeia
        List<ProductResponse> out = tenantProductService.searchProducts(name, minPrice, maxPrice, minStock, maxStock).stream()
                .map(productApiMapper::toResponse)
                .toList();
        return ResponseEntity.ok(out);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/dto/ProductResponse.java
============================================================
package brito.com.multitenancy001.tenant.products.api.dto;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.UUID;

public record ProductResponse(
        UUID id,
        String name,
        String description,
        String sku,
        BigDecimal price,
        Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        BigDecimal profitMargin,

        Long categoryId,
        String categoryName,
        Long subcategoryId,
        String subcategoryName,

        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,

        UUID supplierId,
        String supplierName,

        // ✅ Instantes reais na borda HTTP (JSON com "Z")
        Instant createdAt,
        Instant updatedAt
) {
    public ProductResponse {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/dto/ProductUpsertRequest.java
============================================================
package brito.com.multitenancy001.tenant.products.api.dto;

import java.math.BigDecimal;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;

// Record para criação/atualização expandido (com Category/Subcategory por ID)
public record ProductUpsertRequest(
     @NotBlank String name,
     String description,
     String sku,
     @NotNull @PositiveOrZero BigDecimal price,
     @PositiveOrZero Integer stockQuantity,
     Integer minStock,
     Integer maxStock,
     BigDecimal costPrice,

     @NotNull Long categoryId,     // ✅ obrigatório
     Long subcategoryId,           // ✅ opcional

     String brand,
     BigDecimal weightKg,
     String dimensions,
     String barcode,
     Boolean active,
     UUID supplierId
) {
    public ProductUpsertRequest {
        if (stockQuantity == null) stockQuantity = 0;
        if (active == null) active = true;
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/dto/SupplierProductCountResponse.java
============================================================
package brito.com.multitenancy001.tenant.products.api.dto;

import java.util.UUID;

public record SupplierProductCountResponse(UUID supplierId, long count) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/api/mapper/ProductApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.products.api.mapper;

import org.springframework.stereotype.Component;

import brito.com.multitenancy001.tenant.products.api.dto.ProductResponse;
import brito.com.multitenancy001.tenant.products.domain.Product;

@Component
public class ProductApiMapper {

    public ProductResponse toResponse(Product product) {
        return new ProductResponse(
                product.getId(),
                product.getName(),
                product.getDescription(),
                product.getSku(),
                product.getPrice(),
                product.getStockQuantity(),
                product.getMinStock(),
                product.getMaxStock(),
                product.getCostPrice(),
                product.getProfitMargin(),

                product.getCategory() != null ? product.getCategory().getId() : null,
                product.getCategory() != null ? product.getCategory().getName() : null,
                product.getSubcategory() != null ? product.getSubcategory().getId() : null,
                product.getSubcategory() != null ? product.getSubcategory().getName() : null,

                product.getBrand(),
                product.getWeightKg(),
                product.getDimensions(),
                product.getBarcode(),
                product.getActive(),

                product.getSupplier() != null ? product.getSupplier().getId() : null,
                product.getSupplier() != null ? product.getSupplier().getName() : null,

                // ✅ Auditoria única: vem do AuditInfo (Instant)
                product.getAudit() != null ? product.getAudit().getCreatedAt() : null,
                product.getAudit() != null ? product.getAudit().getUpdatedAt() : null
        );
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/app/TenantProductService.java
============================================================
package brito.com.multitenancy001.tenant.products.app;

import brito.com.multitenancy001.infrastructure.persistence.tx.TenantReadOnlyTx;
import brito.com.multitenancy001.infrastructure.persistence.tx.TenantTx;
import brito.com.multitenancy001.infrastructure.tenant.TenantSchemaUnitOfWork;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.context.TenantContext;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import brito.com.multitenancy001.tenant.categories.persistence.TenantCategoryRepository;
import brito.com.multitenancy001.tenant.categories.persistence.TenantSubcategoryRepository;
import brito.com.multitenancy001.tenant.products.app.command.CreateProductCommand;
import brito.com.multitenancy001.tenant.products.app.command.UpdateProductCommand;
import brito.com.multitenancy001.tenant.products.app.dto.SupplierProductCountData;
import brito.com.multitenancy001.tenant.products.domain.Product;
import brito.com.multitenancy001.tenant.products.persistence.TenantProductRepository;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import brito.com.multitenancy001.tenant.suppliers.persistence.TenantSupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Application Service (Tenant): Products.
 *
 * Nota importante (regra definitiva):
 * - A API mapeia Product -> DTO fora da transação (sem OpenSessionInView).
 * - Portanto, métodos de READ usados pela API precisam retornar entidades com relações inicializadas
 *   (category/subcategory/supplier), evitando LazyInitializationException.
 *
 * Estratégia:
 * - Repository expõe "read-safe" (EntityGraph / fetch join).
 * - Writes (create/update/toggle/cost) fazem save e retornam "re-fetch read-safe" por ID.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class TenantProductService {

    private final TenantSchemaUnitOfWork tenantSchemaUnitOfWork;

    private final TenantProductRepository tenantProductRepository;
    private final TenantSupplierRepository tenantSupplierRepository;
    private final TenantCategoryRepository tenantCategoryRepository;
    private final TenantSubcategoryRepository tenantSubcategoryRepository;

    /**
     * Lista paginada (read-safe: relações carregadas via EntityGraph no repository).
     */
    @TenantReadOnlyTx
    public Page<Product> findAll(Pageable pageable) {
        // método: delega paginação ao repository (read-safe)
        return tenantProductRepository.findAll(pageable);
    }

    /**
     * Busca por id (read-safe: relações carregadas).
     */
    @TenantReadOnlyTx
    public Product findById(UUID id) {
        // método: valida input e busca com relações inicializadas
        if (id == null) throw new ApiException(ApiErrorCode.PRODUCT_ID_REQUIRED, "id é obrigatório", 400);

        return tenantProductRepository.findWithRelationsById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.PRODUCT_NOT_FOUND,
                        "Produto não encontrado com ID: " + id, 404));
    }

    /**
     * Cria um Product via Command.
     *
     * Importante:
     * - Controller não cria entity
     * - Service monta o Product e resolve relacionamentos
     * - Retorno é read-safe (re-fetch com relações) para o mapper não quebrar fora da transação.
     */
    @TenantTx
    public Product create(CreateProductCommand cmd) {
        // método: valida command, monta entity, resolve relacionamentos e persiste
        if (cmd == null) throw new ApiException(ApiErrorCode.PRODUCT_REQUIRED, "payload é obrigatório", 400);

        Product product = fromCreateCommand(cmd);
        validateProductForCreate(product);

        String tenantSchema = requireBoundTenantSchema();

        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            resolveCategoryAndSubcategory(product);
            resolveSupplier(product);
            validateSubcategoryBelongsToCategory(product);

            Product saved = tenantProductRepository.save(product);

            // ✅ retorno read-safe (evita LazyInitialization no mapper)
            return tenantProductRepository.findWithRelationsById(saved.getId())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.PRODUCT_NOT_FOUND,
                            "Produto não encontrado após criação (ID: " + saved.getId() + ")", 500));
        });
    }

    /**
     * Update via Command.
     *
     * Retorno é read-safe (re-fetch).
     */
    @TenantTx
    public Product update(UUID id, UpdateProductCommand cmd) {
        // método: valida input, aplica alterações e persiste
        if (id == null) throw new ApiException(ApiErrorCode.PRODUCT_ID_REQUIRED, "id é obrigatório", 400);
        if (cmd == null) throw new ApiException(ApiErrorCode.PRODUCT_REQUIRED, "payload é obrigatório", 400);

        String tenantSchema = requireBoundTenantSchema();

        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Product existing = tenantProductRepository.findById(id)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.PRODUCT_NOT_FOUND,
                            "Produto não encontrado com ID: " + id, 404));

            if (StringUtils.hasText(cmd.name())) existing.setName(cmd.name().trim());
            if (cmd.description() != null) existing.setDescription(cmd.description());

            if (StringUtils.hasText(cmd.sku())) {
                String sku = cmd.sku().trim();
                Optional<Product> withSku = tenantProductRepository.findBySku(sku);
                if (withSku.isPresent() && !withSku.get().getId().equals(id)) {
                    throw new ApiException(ApiErrorCode.SKU_ALREADY_EXISTS, "SKU já cadastrado: " + sku, 409);
                }
                existing.setSku(sku);
            }

            if (cmd.price() != null) {
                validatePrice(cmd.price());
                existing.updatePrice(cmd.price());
            }

            if (cmd.stockQuantity() != null) existing.setStockQuantity(cmd.stockQuantity());
            if (cmd.minStock() != null) existing.setMinStock(cmd.minStock());
            if (cmd.maxStock() != null) existing.setMaxStock(cmd.maxStock());

            if (cmd.costPrice() != null) existing.updateCostPrice(cmd.costPrice());
            if (cmd.brand() != null) existing.setBrand(cmd.brand());
            if (cmd.weightKg() != null) existing.setWeightKg(cmd.weightKg());
            if (cmd.dimensions() != null) existing.setDimensions(cmd.dimensions());
            if (cmd.barcode() != null) existing.setBarcode(cmd.barcode());
            if (cmd.active() != null) existing.setActive(cmd.active());

            if (cmd.categoryId() != null) {
                Category category = tenantCategoryRepository.findById(cmd.categoryId())
                        .orElseThrow(() -> new ApiException(ApiErrorCode.CATEGORY_NOT_FOUND, "Categoria não encontrada", 404));
                existing.setCategory(category);
            }

            if (cmd.clearSubcategory()) {
                existing.setSubcategory(null);
            } else if (cmd.subcategoryId() != null) {
                Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(cmd.subcategoryId())
                        .orElseThrow(() -> new ApiException(ApiErrorCode.SUBCATEGORY_NOT_FOUND, "Subcategoria não encontrada", 404));
                existing.setSubcategory(sub);
            }

            if (cmd.supplierId() != null) {
                Supplier supplier = tenantSupplierRepository.findById(cmd.supplierId())
                        .orElseThrow(() -> new ApiException(ApiErrorCode.SUPPLIER_NOT_FOUND, "Fornecedor não encontrado", 404));
                existing.setSupplier(supplier);
            }

            validateSubcategoryBelongsToCategory(existing);

            tenantProductRepository.save(existing);

            // ✅ retorno read-safe
            return tenantProductRepository.findWithRelationsById(id)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.PRODUCT_NOT_FOUND,
                            "Produto não encontrado após update (ID: " + id + ")", 500));
        });
    }

    /**
     * Alterna status ativo/inativo do produto.
     *
     * ✅ EXISTE para o controller compilar
     * ✅ Retorna read-safe para o mapper não estourar lazy.
     */
    @TenantTx
    public Product toggleActive(UUID id) {
        // método: alterna flag active e persiste
        if (id == null) throw new ApiException(ApiErrorCode.PRODUCT_ID_REQUIRED, "id é obrigatório", 400);

        String tenantSchema = requireBoundTenantSchema();

        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Product product = tenantProductRepository.findById(id)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.PRODUCT_NOT_FOUND,
                            "Produto não encontrado com ID: " + id, 404));

            product.setActive(!Boolean.TRUE.equals(product.getActive()));
            tenantProductRepository.save(product);

            return tenantProductRepository.findWithRelationsById(id)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.PRODUCT_NOT_FOUND,
                            "Produto não encontrado após toggleActive (ID: " + id + ")", 500));
        });
    }

   /**
 * Atualiza o custo do produto (costPrice).
 *
 * ✅ EXISTE para o controller compilar
 * ✅ Retorna read-safe para o mapper não estourar lazy.
 */
@TenantTx
public Product updateCostPrice(UUID id, BigDecimal costPrice) {
    // método: valida input e persiste
    if (id == null) throw new ApiException(ApiErrorCode.PRODUCT_ID_REQUIRED, "id é obrigatório", 400);

    // ✅ você NÃO tem COST_PRICE_REQUIRED no enum -> reutiliza PRICE_REQUIRED
    if (costPrice == null) {
        throw new ApiException(ApiErrorCode.PRICE_REQUIRED, "costPrice é obrigatório", 400);
    }

    // ✅ você NÃO tem INVALID_COST_PRICE no enum -> reutiliza INVALID_AMOUNT (genérico)
    if (costPrice.compareTo(BigDecimal.ZERO) < 0) {
        throw new ApiException(ApiErrorCode.INVALID_AMOUNT, "costPrice não pode ser negativo", 400);
    }

    String tenantSchema = requireBoundTenantSchema();

    return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
        Product product = tenantProductRepository.findById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.PRODUCT_NOT_FOUND,
                        "Produto não encontrado com ID: " + id, 404));

        product.updateCostPrice(costPrice);
        tenantProductRepository.save(product);

        return tenantProductRepository.findWithRelationsById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.PRODUCT_NOT_FOUND,
                        "Produto não encontrado após updateCostPrice (ID: " + id + ")", 500));
    });
}

    // =========================
    // READ endpoints da API
    // =========================

    @TenantReadOnlyTx
    public List<SupplierProductCountData> countProductsBySupplier() {
        // método: mapeia resultado cru do repository para DTO de APP
        List<Object[]> rows = tenantProductRepository.countProductsBySupplier();
        return rows.stream()
                .map(row -> new SupplierProductCountData((UUID) row[0], ((Number) row[1]).longValue()))
                .toList();
    }

    @TenantReadOnlyTx
    public List<Product> findByCategoryId(Long categoryId) {
        // método: valida input e consulta read-safe no repository
        if (categoryId == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "categoryId é obrigatório", 400);
        return tenantProductRepository.findByCategoryId(categoryId);
    }

    @TenantReadOnlyTx
    public List<Product> findBySubcategoryId(Long subcategoryId) {
        // método: valida input e consulta read-safe no repository
        if (subcategoryId == null) throw new ApiException(ApiErrorCode.SUBCATEGORY_ID_REQUIRED, "subcategoryId é obrigatório", 400);
        return tenantProductRepository.findBySubcategoryId(subcategoryId);
    }

    @TenantReadOnlyTx
    public List<Product> findBySupplierId(UUID supplierId) {
        // método: valida input e consulta read-safe no repository
        if (supplierId == null) throw new ApiException(ApiErrorCode.SUPPLIER_ID_REQUIRED, "supplierId é obrigatório", 400);
        return tenantProductRepository.findBySupplierId(supplierId);
    }

    @TenantReadOnlyTx
    public List<Product> findAnyByCategoryId(Long categoryId) {
        // método: valida input e consulta read-safe
        if (categoryId == null) throw new ApiException(ApiErrorCode.CATEGORY_ID_REQUIRED, "categoryId é obrigatório", 400);
        return tenantProductRepository.findAnyByCategoryId(categoryId);
    }

    @TenantReadOnlyTx
    public List<Product> findAnyBySubcategoryId(Long subcategoryId) {
        // método: valida input e consulta read-safe
        if (subcategoryId == null) throw new ApiException(ApiErrorCode.SUBCATEGORY_ID_REQUIRED, "subcategoryId é obrigatório", 400);
        return tenantProductRepository.findAnyBySubcategoryId(subcategoryId);
    }

    @TenantReadOnlyTx
    public List<Product> findAnyByBrandIgnoreCase(String brand) {
        // método: valida input e consulta read-safe
        if (!StringUtils.hasText(brand)) throw new ApiException(ApiErrorCode.BRAND_REQUIRED, "brand é obrigatório", 400);
        return tenantProductRepository.findAnyByBrandIgnoreCase(brand.trim());
    }

    @TenantReadOnlyTx
    public BigDecimal calculateTotalInventoryValue() {
        // método: delega cálculo ao repository
        return tenantProductRepository.calculateTotalInventoryValue();
    }

    @TenantReadOnlyTx
    public Long countLowStockProducts(Integer threshold) {
        // método: delega cálculo ao repository
        return tenantProductRepository.countLowStockProducts(threshold);
    }

    @TenantReadOnlyTx
    public List<Product> searchProducts(String name, BigDecimal minPrice, BigDecimal maxPrice, Integer minStock, Integer maxStock) {
        // método: delega filtro ao repository (read-safe)
        return tenantProductRepository.searchProducts(name, minPrice, maxPrice, minStock, maxStock);
    }

    // =========================================================
    // Helpers (resolvers/validators)
    // =========================================================

    private void resolveSupplier(Product product) {
        // método: resolve supplier por id (se informado)
        if (product.getSupplier() != null && product.getSupplier().getId() != null) {
            UUID supplierId = product.getSupplier().getId();
            Supplier supplier = tenantSupplierRepository.findById(supplierId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.SUPPLIER_NOT_FOUND,
                            "Fornecedor não encontrado com ID: " + supplierId, 404));
            product.setSupplier(supplier);
        }
    }

    private void resolveCategoryAndSubcategory(Product product) {
        // método: resolve category obrigatória e subcategory opcional
        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException(ApiErrorCode.CATEGORY_REQUIRED, "Categoria é obrigatória", 400);
        }

        Category category = tenantCategoryRepository.findById(product.getCategory().getId())
                .orElseThrow(() -> new ApiException(ApiErrorCode.CATEGORY_NOT_FOUND, "Categoria não encontrada", 404));
        product.setCategory(category);

        if (product.getSubcategory() != null && product.getSubcategory().getId() != null) {
            Subcategory sub = tenantSubcategoryRepository.findByIdWithCategory(product.getSubcategory().getId())
                    .orElseThrow(() -> new ApiException(ApiErrorCode.SUBCATEGORY_NOT_FOUND, "Subcategoria não encontrada", 404));
            product.setSubcategory(sub);
        } else {
            product.setSubcategory(null);
        }
    }

    private void validateSubcategoryBelongsToCategory(Product product) {
        // método: valida consistência category/subcategory
        if (product.getSubcategory() == null) return;

        if (product.getCategory() == null || product.getCategory().getId() == null) {
            throw new ApiException(ApiErrorCode.CATEGORY_REQUIRED, "Categoria é obrigatória", 400);
        }

        if (product.getSubcategory().getCategory() == null || product.getSubcategory().getCategory().getId() == null) {
            throw new ApiException(ApiErrorCode.INVALID_SUBCATEGORY,
                    "Subcategoria sem categoria associada (cadastro inconsistente)", 409);
        }

        Long subCatCategoryId = product.getSubcategory().getCategory().getId();
        Long productCategoryId = product.getCategory().getId();

        if (!subCatCategoryId.equals(productCategoryId)) {
            throw new ApiException(ApiErrorCode.INVALID_SUBCATEGORY, "Subcategoria não pertence à categoria informada", 409);
        }
    }

    private void validateProductForCreate(Product product) {
        // método: validações mínimas para create
        if (product == null) throw new ApiException(ApiErrorCode.PRODUCT_REQUIRED, "payload é obrigatório", 400);

        if (!StringUtils.hasText(product.getName())) {
            throw new ApiException(ApiErrorCode.PRODUCT_NAME_REQUIRED, "name é obrigatório", 400);
        }

        if (!StringUtils.hasText(product.getSku())) {
            throw new ApiException(ApiErrorCode.SKU_REQUIRED, "sku é obrigatório", 400);
        }

        if (product.getPrice() == null) {
            throw new ApiException(ApiErrorCode.PRICE_REQUIRED, "price é obrigatório", 400);
        }

        validatePrice(product.getPrice());

        // SKU único
        String sku = product.getSku().trim();
        Optional<Product> existing = tenantProductRepository.findBySku(sku);
        if (existing.isPresent()) {
            throw new ApiException(ApiErrorCode.SKU_ALREADY_EXISTS, "SKU já cadastrado: " + sku, 409);
        }

        // normalizações
        product.setName(product.getName().trim());
        product.setSku(sku);

        if (product.getStockQuantity() == null) product.setStockQuantity(0);
        if (product.getActive() == null) product.setActive(true);
        if (product.getDeleted() == null) product.setDeleted(false);
    }

    private void validatePrice(BigDecimal price) {
        // método: valida preço não-negativo
        if (price == null) throw new ApiException(ApiErrorCode.PRICE_REQUIRED, "price é obrigatório", 400);
        if (price.compareTo(BigDecimal.ZERO) < 0) {
            throw new ApiException(ApiErrorCode.INVALID_PRICE, "price não pode ser negativo", 400);
        }
    }

    private String requireBoundTenantSchema() {
        // método: garante TenantContext bindado
        String tenantSchema = TenantContext.getOrNull();
        if (tenantSchema == null) {
            throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED,
                    "TenantContext não está bindado (tenantSchema=null). Operação requer contexto TENANT.", 500);
        }
        return tenantSchema;
    }

    private Product fromCreateCommand(CreateProductCommand cmd) {
        // método: monta entity Product a partir do command, sem resolver relacionamentos
        Product product = new Product();
        product.setName(cmd.name());
        product.setDescription(cmd.description());
        product.setSku(cmd.sku());
        product.setPrice(cmd.price());
        product.setStockQuantity(cmd.stockQuantity());
        product.setMinStock(cmd.minStock());
        product.setMaxStock(cmd.maxStock());
        product.setCostPrice(cmd.costPrice());
        product.setBrand(cmd.brand());
        product.setWeightKg(cmd.weightKg());
        product.setDimensions(cmd.dimensions());
        product.setBarcode(cmd.barcode());
        product.setActive(cmd.active());

        // category é obrigatória (resolvida depois)
        Category category = new Category();
        category.setId(cmd.categoryId());
        product.setCategory(category);

        // subcategory opcional
        if (cmd.subcategoryId() != null) {
            Subcategory sub = new Subcategory();
            sub.setId(cmd.subcategoryId());
            product.setSubcategory(sub);
        } else {
            product.setSubcategory(null);
        }

        // supplier opcional
        if (cmd.supplierId() != null) {
            Supplier supplier = new Supplier();
            supplier.setId(cmd.supplierId());
            product.setSupplier(supplier);
        } else {
            product.setSupplier(null);
        }

        // defaults explícitos
        product.setDeleted(false);
        if (product.getStockQuantity() == null) product.setStockQuantity(0);
        if (product.getActive() == null) product.setActive(true);

        return product;
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/app/command/CreateProductCommand.java
============================================================
package brito.com.multitenancy001.tenant.products.app.command;

import java.math.BigDecimal;
import java.util.UUID;

/**
 * Command de criação de Product (Tenant).
 *
 * Regras de camada:
 * - Command pertence à Application Layer (APP)
 * - Carrega apenas dados primitivos/ids necessários ao use-case
 * - Nunca carrega Entities do domínio
 */
public record CreateProductCommand(
        String name,
        String description,
        String sku,
        BigDecimal price,
        Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        Long categoryId,
        Long subcategoryId,
        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,
        UUID supplierId
) {
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/app/command/UpdateProductCommand.java
============================================================
package brito.com.multitenancy001.tenant.products.app.command;

import java.math.BigDecimal;
import java.util.UUID;

/**
 * Command de update de Product (Tenant).
 *
 * Semântica (para evitar "tri-state" com Entities):
 * - Campos nulos => não alteram (patch-like)
 * - categoryId se não-nulo => troca categoria
 * - subcategory:
 *     - clearSubcategory=true => remove subcategory
 *     - subcategoryId != null => define subcategory
 *     - ambos nulos/false => não altera subcategory
 * - supplierId se não-nulo => troca supplier (não há clear explícito aqui)
 */
public record UpdateProductCommand(
        String name,
        String description,
        String sku,
        BigDecimal price,
        Integer stockQuantity,
        Integer minStock,
        Integer maxStock,
        BigDecimal costPrice,
        Long categoryId,
        Long subcategoryId,
        boolean clearSubcategory,
        String brand,
        BigDecimal weightKg,
        String dimensions,
        String barcode,
        Boolean active,
        UUID supplierId
) {
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/app/dto/SupplierProductCountData.java
============================================================
package brito.com.multitenancy001.tenant.products.app.dto;

import java.util.UUID;

/**
 * DTO de Application Layer para dados agregados (query).
 *
 * Motivo:
 * - Evitar que a camada APP retorne DTOs da API
 * - Controller mapeia este DTO para o Response DTO HTTP
 */
public record SupplierProductCountData(
        UUID supplierId,
        long productCount
) {
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/domain/Product.java
============================================================
package brito.com.multitenancy001.tenant.products.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.tenant.categories.domain.Category;
import brito.com.multitenancy001.tenant.categories.domain.Subcategory;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.Instant;
import java.util.UUID;

/**
 * Aggregate Root (Tenant): Product.
 *
 * Regra única de margem (definitiva):
 * - profitMargin = "MARGEM %" (margin), não "markup".
 * - Fórmula: margin% = ((price - costPrice) / price) * 100
 *
 * Persistência / consistência:
 * - Para garantir que o retorno da API sempre traga profitMargin atualizado,
 *   esta entidade recalcula automaticamente a margem em @PrePersist/@PreUpdate
 *   (mesmo se alguém usar setters direto).
 */
@Entity
@Table(name = "products")
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"supplier", "category", "subcategory"})
public class Product implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(length = 100, nullable = false)
    private String sku;

    @Column(precision = 10, scale = 2, nullable = false)
    private BigDecimal price;

    @Column(name = "stock_quantity", nullable = false)
    @Builder.Default
    private Integer stockQuantity = 0;

    @Column(name = "min_stock")
    private Integer minStock;

    @Column(name = "max_stock")
    private Integer maxStock;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    /**
     * Percentual de margem (0..100..), scale(2).
     * Ex.: 25.00 significa 25% de margem sobre o preço.
     *
     * DDL atual: NUMERIC(12,2) está ótimo.
     */
    @Column(name = "profit_margin", precision = 12, scale = 2)
    private BigDecimal profitMargin;

    @Column(length = 100)
    private String brand;

    @Column(name = "weight_kg", precision = 10, scale = 3)
    private BigDecimal weightKg;

    @Column(length = 100)
    private String dimensions;

    @Column(length = 100)
    private String barcode;

    @Column(nullable = false)
    @Builder.Default
    private Boolean active = true;

    // =========================
    // SOFT DELETE + AUDIT ÚNICO
    // =========================

    @Column(nullable = false)
    @Builder.Default
    private Boolean deleted = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    // =========================
    // RELACIONAMENTOS
    // =========================

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
            name = "supplier_id",
            foreignKey = @ForeignKey(name = "fk_products_supplier")
    )
    private Supplier supplier;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "category_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_products_category")
    )
    private Category category;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(
            name = "subcategory_id",
            foreignKey = @ForeignKey(name = "fk_products_subcategory")
    )
    private Subcategory subcategory;

    // =========================
    // CONTRACTS
    // =========================

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return Boolean.TRUE.equals(deleted);
    }

    // =========================
    // JPA LIFECYCLE (garantia)
    // =========================

    @PrePersist
    @PreUpdate
    private void onPersistOrUpdate() {
        // método: garante consistência do campo derivado
        recomputeProfitMargin();
    }

    // =========================
    // DOMAIN METHODS (estoque)
    // =========================

    public void addToStock(Integer qty) {
        // método: adiciona ao estoque de forma segura
        if (qty == null || qty <= 0) return;
        if (this.stockQuantity == null) this.stockQuantity = 0;
        this.stockQuantity = this.stockQuantity + qty;
    }

    public void removeFromStock(int qty) {
        // método: remove do estoque garantindo não-negativo
        if (qty <= 0) return;
        if (this.stockQuantity == null) this.stockQuantity = 0;

        int next = this.stockQuantity - qty;
        if (next < 0) throw new IllegalStateException("Stock cannot be negative");
        this.stockQuantity = next;
    }

    // =========================
    // DOMAIN METHODS (preço/custo/margem)
    // =========================

    public void updatePrice(BigDecimal newPrice) {
        // método: valida, aplica preço e recalcula margem
        if (newPrice == null) throw new IllegalArgumentException("newPrice is required");
        if (newPrice.compareTo(BigDecimal.ZERO) < 0) throw new IllegalArgumentException("newPrice cannot be negative");

        this.price = newPrice;
        recomputeProfitMargin();
    }

    public void updateCostPrice(BigDecimal newCostPrice) {
        // método: valida, aplica custo e recalcula margem
        if (newCostPrice == null) throw new IllegalArgumentException("newCostPrice is required");
        if (newCostPrice.compareTo(BigDecimal.ZERO) < 0) throw new IllegalArgumentException("newCostPrice cannot be negative");

        this.costPrice = newCostPrice;
        recomputeProfitMargin();
    }

    /**
     * Regra única (MARGEM %):
     * margin% = ((price - costPrice) / price) * 100
     *
     * - Se price == null ou price <= 0 => profitMargin = null
     * - Se costPrice == null => profitMargin = null
     * - Se costPrice > price => margem negativa (aceito para sinalizar prejuízo)
     */
    public void recomputeProfitMargin() {
        // método: recalcula profitMargin de forma determinística
        if (this.price == null || this.price.compareTo(BigDecimal.ZERO) <= 0) {
            this.profitMargin = null;
            return;
        }
        if (this.costPrice == null) {
            this.profitMargin = null;
            return;
        }

        BigDecimal profit = this.price.subtract(this.costPrice);

        BigDecimal margin = profit
                .divide(this.price, 10, RoundingMode.HALF_UP) // precisão interna
                .multiply(new BigDecimal("100"))
                .setScale(2, RoundingMode.HALF_UP);

        this.profitMargin = margin;
    }

    // =========================
    // DOMAIN METHODS (soft delete / restore)
    // =========================

    public void softDelete() {
        // método: marca como deletado (idempotente)
        if (Boolean.TRUE.equals(this.deleted)) return;
        this.deleted = true;
        this.active = false;
    }

    public void softDelete(Instant now) {
        // método: marca como deletado e registra deletedAt (quando possível)
        if (Boolean.TRUE.equals(this.deleted)) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        this.active = false;

        if (this.audit != null) this.audit.markDeleted(now);
    }

    public void restore() {
        // método: restaura soft-delete (idempotente)
        if (!Boolean.TRUE.equals(this.deleted)) return;

        this.deleted = false;
        this.active = true;

        if (this.audit != null) this.audit.clearDeleted();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/products/persistence/TenantProductRepository.java
============================================================
package brito.com.multitenancy001.tenant.products.persistence;

import brito.com.multitenancy001.tenant.products.domain.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository JPA (Tenant): Products.
 *
 * Objetivo:
 * - Evitar LazyInitializationException quando a API mapeia Product -> ProductResponse fora da transação.
 * - Métodos "read" usados pela API DEVEM trazer relações inicializadas: category, subcategory, supplier.
 *
 * Convenções:
 * - "CATÁLOGO" => deleted=false AND active=true
 * - "ANY" => pode incluir deleted/inactive (admin/relatórios)
 */
@Repository
public interface TenantProductRepository extends JpaRepository<Product, UUID> {

    // =========================================================
    // READ SAFE (para controller mapear fora da transação)
    // =========================================================

    /**
     * Busca por id com relações carregadas (category/subcategory/supplier).
     */
    @EntityGraph(attributePaths = {"category", "subcategory", "supplier"})
    Optional<Product> findWithRelationsById(UUID id);

    /**
     * Lista paginada com relações carregadas.
     */
    @Override
    @EntityGraph(attributePaths = {"category", "subcategory", "supplier"})
    Page<Product> findAll(Pageable pageable);

    // =========================================================
    // CATÁLOGO: SOMENTE ATIVOS E NÃO DELETADOS (read-safe)
    // =========================================================

    @Query("""
        SELECT p FROM Product p
        LEFT JOIN FETCH p.category
        LEFT JOIN FETCH p.subcategory
        LEFT JOIN FETCH p.supplier
        WHERE p.deleted = false
          AND p.active = true
          AND LOWER(p.brand) = LOWER(:brand)
        """)
    List<Product> findActiveNotDeletedByBrandIgnoreCase(@Param("brand") String brand);

    @Query("""
        SELECT p FROM Product p
        LEFT JOIN FETCH p.category
        LEFT JOIN FETCH p.subcategory
        LEFT JOIN FETCH p.supplier
        WHERE p.deleted = false
          AND p.active = true
          AND p.category.id = :categoryId
        """)
    List<Product> findActiveNotDeletedByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
        SELECT p FROM Product p
        LEFT JOIN FETCH p.category
        LEFT JOIN FETCH p.subcategory
        LEFT JOIN FETCH p.supplier
        WHERE p.deleted = false
          AND p.active = true
          AND p.subcategory.id = :subcategoryId
        """)
    List<Product> findActiveNotDeletedBySubcategoryId(@Param("subcategoryId") Long subcategoryId);

    @Query("""
        SELECT p FROM Product p
        LEFT JOIN FETCH p.category
        LEFT JOIN FETCH p.subcategory
        LEFT JOIN FETCH p.supplier
        WHERE p.deleted = false
          AND p.active = true
          AND p.supplier.id = :supplierId
        """)
    List<Product> findActiveNotDeletedBySupplierId(@Param("supplierId") UUID supplierId);

    // =========================================================
    // SEARCH (read-safe)
    // =========================================================

    @Query("""
        SELECT p FROM Product p
        LEFT JOIN FETCH p.category
        LEFT JOIN FETCH p.subcategory
        LEFT JOIN FETCH p.supplier
        WHERE (:name IS NULL OR LOWER(p.name) LIKE LOWER(CONCAT('%', :name, '%')))
          AND (:minPrice IS NULL OR p.price >= :minPrice)
          AND (:maxPrice IS NULL OR p.price <= :maxPrice)
          AND (:minStock IS NULL OR p.stockQuantity >= :minStock)
          AND (:maxStock IS NULL OR p.stockQuantity <= :maxStock)
        """)
    List<Product> searchProducts(@Param("name") String name,
                                 @Param("minPrice") BigDecimal minPrice,
                                 @Param("maxPrice") BigDecimal maxPrice,
                                 @Param("minStock") Integer minStock,
                                 @Param("maxStock") Integer maxStock);

    // =========================================================
    // Outros métodos "de apoio" (mantidos)
    // =========================================================

    Optional<Product> findBySku(String sku);

    List<Product> findByStockQuantityLessThan(Integer quantity);

    List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

    @Query("SELECT COUNT(p) FROM Product p WHERE p.stockQuantity <= :threshold")
    Long countLowStock(@Param("threshold") Integer threshold);

    @Query("SELECT SUM(p.stockQuantity * p.price) FROM Product p")
    BigDecimal calculateTotalInventoryValue();

    @Query("SELECT p.supplier.id, COUNT(p) FROM Product p GROUP BY p.supplier.id")
    List<Object[]> countProductsBySupplier();

    // =========================================================
    // ANY (admin/relatórios) - read-safe
    // =========================================================

    @Query("""
        SELECT p FROM Product p
        LEFT JOIN FETCH p.category
        LEFT JOIN FETCH p.subcategory
        LEFT JOIN FETCH p.supplier
        WHERE LOWER(p.brand) = LOWER(:brand)
        """)
    List<Product> findAnyByBrandIgnoreCase(@Param("brand") String brand);

    @Query("""
        SELECT p FROM Product p
        LEFT JOIN FETCH p.category
        LEFT JOIN FETCH p.subcategory
        LEFT JOIN FETCH p.supplier
        WHERE p.category.id = :categoryId
        """)
    List<Product> findAnyByCategoryId(@Param("categoryId") Long categoryId);

    @Query("""
        SELECT p FROM Product p
        LEFT JOIN FETCH p.category
        LEFT JOIN FETCH p.subcategory
        LEFT JOIN FETCH p.supplier
        WHERE p.subcategory.id = :subcategoryId
        """)
    List<Product> findAnyBySubcategoryId(@Param("subcategoryId") Long subcategoryId);

    // =========================================================
    // Aliases semânticos (o service chama esses)
    // =========================================================

    /**
     * Padrão: catálogo (active + notDeleted) e read-safe.
     */
    default List<Product> findByCategoryId(Long categoryId) {
        return findActiveNotDeletedByCategoryId(categoryId);
    }

    /**
     * Padrão: catálogo (active + notDeleted) e read-safe.
     */
    default List<Product> findBySubcategoryId(Long subcategoryId) {
        return findActiveNotDeletedBySubcategoryId(subcategoryId);
    }

    /**
     * Padrão: catálogo (active + notDeleted) e read-safe.
     */
    default List<Product> findBySupplierId(UUID supplierId) {
        return findActiveNotDeletedBySupplierId(supplierId);
    }

    /**
     * Padrão: catálogo (active + notDeleted) e read-safe.
     */
    default List<Product> findByBrandIgnoreCase(String brand) {
        return findActiveNotDeletedByBrandIgnoreCase(brand);
    }

    default Long countLowStockProducts(Integer threshold) {
        return countLowStock(threshold);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/provisioning/app/TenantUserProvisioningService.java
============================================================
package brito.com.multitenancy001.tenant.provisioning.app;

import brito.com.multitenancy001.infrastructure.persistence.TxExecutor;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.TenantRoleName;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Instant;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class TenantUserProvisioningService {

    private static final String REQUIRED_TABLE = "tenant_users";
    private static final String OWNER_NAME_FALLBACK = "Owner";

    private final TenantExecutor tenantExecutor;
    private final TxExecutor transactionExecutor;

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;

    private final AppClock appClock;

    public List<UserSummaryData> listUserSummaries(String tenantSchema, Long accountId, boolean onlyOperational) {
        tenantExecutor.assertTenantSchemaReadyOrThrow(tenantSchema, REQUIRED_TABLE);

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                transactionExecutor.inTenantReadOnlyTx(() -> {

                    var users = onlyOperational
                            ? tenantUserRepository.findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId)
                            : tenantUserRepository.findByAccountId(accountId);

                    return users.stream()
                            .map(u -> new UserSummaryData(
                                    u.getId(),
                                    u.getAccountId(),
                                    u.getName(),
                                    u.getEmail(),
                                    u.getRole() == null ? null : TenantRoleName.valueOf(u.getRole().name()),
                                    u.isSuspendedByAccount(),
                                    u.isSuspendedByAdmin(),
                                    u.isDeleted()
                            ))
                            .toList();
                })
        );
    }

    /**
     * Cria o usuário dono (TENANT_OWNER) no schema do Tenant.
     */
    public UserSummaryData createTenantOwner(
            String tenantSchema,
            Long accountId,
            String ownerDisplayName,
            String email,
            String rawPassword
    ) {
        tenantExecutor.assertTenantSchemaReadyOrThrow(tenantSchema, REQUIRED_TABLE);

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                transactionExecutor.inTenantTx(() -> {

                    if (accountId == null) {
                        throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "AccountId obrigatório", 400);
                    }

                    String emailNorm = EmailNormalizer.normalizeOrNull(email);
                    if (!StringUtils.hasText(emailNorm)) {
                        throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email é obrigatório", 400);
                    }

                    if (!StringUtils.hasText(rawPassword)) {
                        throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Senha é obrigatória", 400);
                    }

                    boolean emailExists = tenantUserRepository.existsByEmailAndAccountId(emailNorm, accountId);
                    if (emailExists) {
                        throw new ApiException(ApiErrorCode.EMAIL_ALREADY_EXISTS, "Email já cadastrado nesta conta", 409);
                    }

                    String name = StringUtils.hasText(ownerDisplayName)
                            ? ownerDisplayName.trim()
                            : OWNER_NAME_FALLBACK;

                    Instant now = appNow();

                    TenantUser tenantUser = new TenantUser();
                    tenantUser.setAccountId(accountId);

                    // ✅ padronização: rename() (trim interno)
                    tenantUser.rename(name);

                    // ✅ padronização: changeEmail() (normaliza via EmailNormalizer)
                    tenantUser.changeEmail(emailNorm);

                    tenantUser.setPassword(passwordEncoder.encode(rawPassword));
                    tenantUser.setRole(TenantRole.TENANT_OWNER);

                    tenantUser.setSuspendedByAccount(false);
                    tenantUser.setSuspendedByAdmin(false);

                    tenantUser.setTimezone("America/Sao_Paulo");
                    tenantUser.setLocale("pt_BR");

                    tenantUser.setMustChangePassword(false);
                    tenantUser.setPasswordChangedAt(now);

                    TenantUser saved = tenantUserRepository.save(tenantUser);

                    return new UserSummaryData(
                            saved.getId(),
                            saved.getAccountId(),
                            saved.getName(),
                            saved.getEmail(),
                            saved.getRole() == null ? null : TenantRoleName.valueOf(saved.getRole().name()),
                            saved.isSuspendedByAccount(),
                            saved.isSuspendedByAdmin(),
                            saved.isDeleted()
                    );
                })
        );
    }

    /**
     * ✅ (SAFE) Admin bulk: suspende todos MENOS TENANT_OWNER.
     */
    public int suspendAllUsersByAccount(String tenantSchema, Long accountId) {
        tenantExecutor.assertTenantSchemaReadyOrThrow(tenantSchema, REQUIRED_TABLE);

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                transactionExecutor.inTenantRequiresNew(() -> {

                    if (accountId == null) {
                        throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "AccountId obrigatório", 400);
                    }

                    long ownersNotDeleted = tenantUserRepository.countNotDeletedByAccountIdAndRole(accountId, TenantRole.TENANT_OWNER);
                    if (ownersNotDeleted <= 0) {
                        throw new ApiException(
                                ApiErrorCode.TENANT_OWNER_REQUIRED,
                                "Não é possível suspender usuários: não existe TENANT_OWNER não deletado para esta conta (estado inválido).",
                                409
                        );
                    }

                    return tenantUserRepository.suspendAllByAccountExceptRole(accountId, TenantRole.TENANT_OWNER);
                })
        );
    }

    /**
     * ✅ Reativa todos (inclusive owners).
     */
    public int unsuspendAllUsersByAccount(String tenantSchema, Long accountId) {
        return tenantExecutor.runInTenantSchemaIfReady(
                tenantSchema,
                REQUIRED_TABLE,
                () -> transactionExecutor.inTenantRequiresNew(() -> tenantUserRepository.unsuspendAllByAccount(accountId)),
                0
        );
    }

    /**
     * ✅ (SAFE) Cancelamento / exclusão da conta:
     * soft-delete de todos os usuários MENOS TENANT_OWNER.
     */
    public int softDeleteAllUsersByAccount(String tenantSchema, Long accountId) {
        return tenantExecutor.runInTenantSchemaIfReady(
                tenantSchema,
                REQUIRED_TABLE,
                () -> transactionExecutor.inTenantRequiresNew(() -> {

                    if (accountId == null) {
                        throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "AccountId obrigatório", 400);
                    }

                    long ownersNotDeleted = tenantUserRepository.countNotDeletedByAccountIdAndRole(accountId, TenantRole.TENANT_OWNER);
                    if (ownersNotDeleted <= 0) {
                        throw new ApiException(
                                ApiErrorCode.TENANT_OWNER_REQUIRED,
                                "Não é possível remover usuários: não existe TENANT_OWNER não deletado para esta conta (estado inválido).",
                                409
                        );
                    }

                    Instant now = appClock.instant();
                    return tenantUserRepository.softDeleteAllByAccountExceptRole(accountId, TenantRole.TENANT_OWNER, now);
                }),
                0
        );
    }

    public int restoreAllUsersByAccount(String tenantSchema, Long accountId) {
        return tenantExecutor.runInTenantSchemaIfReady(
                tenantSchema,
                REQUIRED_TABLE,
                () -> transactionExecutor.inTenantRequiresNew(() -> tenantUserRepository.restoreAllByAccount(accountId)),
                0
        );
    }

    public void setSuspendedByAdmin(String tenantSchema, Long accountId, Long userId, boolean suspended) {
        tenantExecutor.assertTenantSchemaReadyOrThrow(tenantSchema, REQUIRED_TABLE);

        tenantExecutor.runInTenantSchema(tenantSchema, () ->
                transactionExecutor.inTenantTx(() -> {

                    if (accountId == null) {
                        throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "AccountId obrigatório", 400);
                    }
                    if (userId == null) {
                        throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId obrigatório", 400);
                    }

                    if (suspended) {
                        TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                                .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado ou removido", 404));

                        if (isActiveOwner(user)) {
                            long activeOwners = tenantUserRepository.countActiveOwnersByAccountId(accountId, TenantRole.TENANT_OWNER);
                            if (activeOwners <= 1) {
                                throw new ApiException(
                                        ApiErrorCode.TENANT_OWNER_REQUIRED,
                                        "Não é permitido suspender o último TENANT_OWNER ativo.",
                                        409
                                );
                            }
                        }
                    }

                    int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
                    if (updated == 0) {
                        throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado ou removido", 404);
                    }
                    return null;
                })
        );
    }

    public void setPasswordResetToken(String tenantSchema, Long accountId, Long userId, String token, Instant expiresAt) {
        tenantExecutor.runInTenantSchemaIfReady(tenantSchema, REQUIRED_TABLE, () ->
                transactionExecutor.inTenantTx(() -> {
                    TenantUser user = tenantUserRepository.findEnabledByIdAndAccountId(userId, accountId)
                            .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

                    user.setPasswordResetToken(token);
                    user.setPasswordResetExpiresAt(expiresAt);

                    tenantUserRepository.save(user);
                    return null;
                })
        );
    }

    public TenantUser findByPasswordResetToken(String tenantSchema, Long accountId, String token) {
        tenantExecutor.assertTenantSchemaReadyOrThrow(tenantSchema, REQUIRED_TABLE);

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                transactionExecutor.inTenantReadOnlyTx(() ->
                        tenantUserRepository.findByPasswordResetTokenAndAccountId(token, accountId)
                                .orElseThrow(() -> new ApiException(ApiErrorCode.TOKEN_INVALID, "Token inválido", 400))
                )
        );
    }

    // =========================================================
    // helpers
    // =========================================================

    private boolean isActiveOwner(TenantUser user) {
        if (user == null) return false;
        if (user.isDeleted()) return false;
        if (user.isSuspendedByAccount()) return false;
        if (user.isSuspendedByAdmin()) return false;
        return user.getRole() != null && user.getRole().isTenantOwner();
    }

    private Instant appNow() {
        return appClock.instant();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/provisioning/infra/TenantFlywayMigrator.java
============================================================
package brito.com.multitenancy001.tenant.provisioning.infra;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;

/**
 * Flyway para TENANT schemas.
 *
 * ✅ NÃO se chama "flyway" -> não roda no bootstrap
 * ✅ você chama migrate(tenantSchema) quando provisionar o tenant
 * ✅ cada tenant tem seu schema history dentro do schema do tenant
 *
 * BLINDAGEM EXTRA (recomendado):
 * - table("tenant_flyway_schema_history") separa o histórico do PUBLIC
 *
 * Linguagem ubíqua:
 * - tenantSchema = contexto de execução na infraestrutura
 */
@Component
@RequiredArgsConstructor
public class TenantFlywayMigrator {

    private static final String TENANT_HISTORY_TABLE = "tenant_flyway_schema_history";

    private final DataSource dataSource;

    public void migrate(String tenantSchema) {
        migrate(this.dataSource, tenantSchema);
    }

    /**
     * Executa Flyway usando o DataSource fornecido (pode ser SingleConnectionDataSource).
     * tenantSchema é o schema do tenant no contexto de execução.
     */
    public static void migrate(DataSource dataSource, String tenantSchema) {
        Flyway.configure()
                .dataSource(dataSource)
                .schemas(tenantSchema)
                .defaultSchema(tenantSchema)

                // ✅ sua pasta real (pela sua lista)
                .locations("classpath:db/migration/tenants")

                // ✅ blindagem (opcional mas recomendado)
                .table(TENANT_HISTORY_TABLE)

                .baselineOnMigrate(false)
                .validateOnMigrate(true)
                .cleanDisabled(true)
                .load()
                .migrate();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/sales/domain/Sale.java
============================================================
package brito.com.multitenancy001.tenant.sales.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "sales", indexes = {
        @Index(name = "idx_sales_sale_date", columnList = "sale_date"),
        @Index(name = "idx_sales_status", columnList = "status")
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "items")
public class Sale implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    /**
     * Instante real: quando a venda ocorreu.
     * (DB: TIMESTAMPTZ)
     */
    @Column(name = "sale_date", nullable = false, columnDefinition = "timestamptz")
    private Instant saleDate;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    @Builder.Default
    private BigDecimal totalAmount = BigDecimal.ZERO;

    @Column(name = "customer_name", length = 200)
    private String customerName;

    @Column(name = "customer_document", length = 20)
    private String customerDocument;

    @Column(name = "customer_email", length = 150)
    private String customerEmail;

    @Column(name = "customer_phone", length = 20)
    private String customerPhone;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private SaleStatus status;

    @OneToMany(
            mappedBy = "sale",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            orphanRemoval = true,
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<SaleItem> items = new ArrayList<>();

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // =========================
    // Soft delete (padrão do projeto)
    // - NÃO passa Instant para domínio
    // - AuditEntityListener seta audit.deletedAt com AppClock
    // =========================
    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        // deletedAt/deletedBy serão setados pelo AuditEntityListener ao atualizar
    }

    /**
     * Compat com código antigo que chamava softDelete(Instant).
     * A auditoria é responsabilidade do listener, então o parâmetro é ignorado.
     */
    public void softDelete(Instant ignoredNow) {
        softDelete();
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;

        // política: restore limpa deletedAt/deletedBy
        // (se você preferir manter histórico de deleção, remova essa linha)
        this.audit.clearDeleted();
    }

    // =========================
    // Itens / total
    // =========================
    public void addItem(SaleItem item) {
        if (item == null) return;
        item.setSale(this);
        this.items.add(item);
        recalcTotal();
    }

    public void removeItem(SaleItem item) {
        if (item == null) return;
        this.items.remove(item);
        item.setSale(null);
        recalcTotal();
    }

    public void recalcTotal() {
        BigDecimal sum = BigDecimal.ZERO;
        if (items != null) {
            for (SaleItem it : items) {
                if (it != null && it.getTotalPrice() != null) {
                    sum = sum.add(it.getTotalPrice());
                }
            }
        }
        this.totalAmount = sum;
    }

    public void cancel() {
        this.status = SaleStatus.CANCELLED;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/sales/domain/SaleItem.java
============================================================
package brito.com.multitenancy001.tenant.sales.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "sale_items", indexes = {
        @Index(name = "idx_sale_items_sale_id", columnList = "sale_id"),
        @Index(name = "idx_sale_items_product_id", columnList = "product_id")
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = "sale")
public class SaleItem implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", nullable = false, updatable = false)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
            name = "sale_id",
            nullable = false,
            foreignKey = @ForeignKey(name = "fk_sale_items_sale")
    )
    private Sale sale;

    // Sem FK para products. Referência fraca (histórico)
    @Column(name = "product_id")
    private UUID productId;

    // Snapshot obrigatório do produto no momento da venda
    @Column(name = "product_name", nullable = false, length = 255)
    private String productName;

    @Column(name = "quantity", nullable = false, precision = 12, scale = 3)
    private BigDecimal quantity;

    @Column(name = "unit_price", nullable = false, precision = 12, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_price", nullable = false, precision = 12, scale = 2)
    @Builder.Default
    private BigDecimal totalPrice = BigDecimal.ZERO;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // =========================
    // Soft delete (padrão do projeto)
    // =========================
    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        // audit.deletedAt será setado pelo listener
    }

    /** Compat com código antigo que chamava softDelete(Instant). */
    public void softDelete(Instant ignoredNow) {
        softDelete();
    }

    public void restore() {
        if (!this.deleted) return;
        this.deleted = false;
        this.audit.clearDeleted();
    }

    public void recalcTotal() {
        if (quantity == null || unitPrice == null) {
            this.totalPrice = BigDecimal.ZERO;
            return;
        }
        this.totalPrice = unitPrice.multiply(quantity);
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/sales/domain/SaleStatus.java
============================================================
package brito.com.multitenancy001.tenant.sales.domain;


public enum SaleStatus {
    DRAFT,
    OPEN,
    CONFIRMED,
    PAID,
    CANCELLED
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantEndpointPreAuthorizeVerifier.java
============================================================
package brito.com.multitenancy001.tenant.security;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

import java.lang.reflect.Method;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Fail-fast: garante que endpoints do TENANT tenham @PreAuthorize,
 * exceto os explicitamente allowlisted (login/refresh/reset etc.).
 *
 * Desative em testes/local se quiser:
 *   app.security.tenant.enforce-preauthorize=false
 */
@Component
public class TenantEndpointPreAuthorizeVerifier implements ApplicationRunner {

    private final RequestMappingHandlerMapping mapping;

    @Value("${app.security.tenant.enforce-preauthorize:true}")
    private boolean enabled;

    public TenantEndpointPreAuthorizeVerifier(
            @Qualifier("requestMappingHandlerMapping") RequestMappingHandlerMapping mapping
    ) {
        this.mapping = mapping;
    }

    @Override
    public void run(ApplicationArguments args) {
        if (!enabled) return;

        List<String> missing = new ArrayList<>();

        for (Map.Entry<RequestMappingInfo, HandlerMethod> e : mapping.getHandlerMethods().entrySet()) {
            RequestMappingInfo info = e.getKey();
            HandlerMethod hm = e.getValue();

            Class<?> beanType = hm.getBeanType();
            String pkg = beanType.getPackageName();

            // só TENANT
            if (!pkg.startsWith("brito.com.multitenancy001.tenant")) continue;

            Set<String> patterns = extractPatterns(info);
            if (patterns.isEmpty()) continue;

            // allowlist de endpoints públicos / especiais
            if (isAllowlisted(patterns)) continue;

            Method m = hm.getMethod();
            boolean has = hasPreAuthorize(beanType) || hasPreAuthorize(m);

            if (!has) {
                String methods = (info.getMethodsCondition() != null && !info.getMethodsCondition().getMethods().isEmpty())
                        ? info.getMethodsCondition().getMethods().toString()
                        : "[ANY]";

                String line = methods + " " + patterns + " -> " + beanType.getSimpleName() + "#" + m.getName();
                missing.add(line);
            }
        }

        if (!missing.isEmpty()) {
            String msg = "Endpoints do TENANT sem @PreAuthorize (fail-fast):\n"
                    + missing.stream().sorted().collect(Collectors.joining("\n"));
            throw new IllegalStateException(msg);
        }
    }

    private boolean hasPreAuthorize(Class<?> type) {
        return AnnotatedElementUtils.hasAnnotation(type, PreAuthorize.class);
    }

    private boolean hasPreAuthorize(Method m) {
        return AnnotatedElementUtils.hasAnnotation(m, PreAuthorize.class);
    }

    private boolean isAllowlisted(Set<String> patterns) {
        for (String p : patterns) {
            if (!StringUtils.hasText(p)) continue;

            // auth do tenant (login init/confirm/refresh)
            if (p.startsWith("/api/tenant/auth")) return true;

            // reset/forgot password
            if (p.startsWith("/api/tenant/password")) return true;

            // debug em dev (seu controller está @Profile("dev"))
            if (p.startsWith("/api/tenant/debug")) return true;
        }
        return false;
    }

    private Set<String> extractPatterns(RequestMappingInfo info) {
        try {
            // Boot 3 com PathPatterns
            if (info.getPathPatternsCondition() != null) {
                return new LinkedHashSet<>(info.getPathPatternsCondition().getPatternValues());
            }
        } catch (Throwable ignored) {}

        try {
            // fallback (ant style)
            if (info.getPatternsCondition() != null) {
                return new LinkedHashSet<>(info.getPatternsCondition().getPatterns());
            }
        } catch (Throwable ignored) {}

        return Set.of();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantPermission.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.PermissionCode;

/**
 * Padrão: TODA permissão de tenant deve iniciar com TEN_
 */
public enum TenantPermission implements PermissionCode {

    TEN_USER_READ,
    TEN_USER_CREATE,
    TEN_USER_UPDATE,
    TEN_USER_SUSPEND,
    TEN_USER_RESTORE,
    TEN_USER_DELETE,

    TEN_ROLE_TRANSFER,

    TEN_PRODUCT_READ,
    TEN_PRODUCT_WRITE,

    TEN_CATEGORY_READ,
    TEN_CATEGORY_WRITE,

    TEN_SUPPLIER_READ,
    TEN_SUPPLIER_WRITE,

    TEN_SALE_READ,
    TEN_SALE_WRITE,
    TEN_SALE_ISSUES_READ,
    TEN_SALE_ISSUES_WRITE,

    TEN_REPORT_SALES_READ,

    TEN_BILLING_READ,
    TEN_BILLING_WRITE,

    TEN_SETTINGS_READ,
    TEN_SETTINGS_WRITE,

    TEN_INVENTORY_READ,
    TEN_INVENTORY_WRITE;

    @Override
    public String asAuthority() {
        return name();
    }
}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantRole.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.RoleAuthority;

public enum TenantRole implements RoleAuthority {

    TENANT_OWNER,
    TENANT_ADMIN,

    /**
     * Admin operacional do dia a dia (sem poderes sensíveis / destrutivos).
     * Recomendado para separar "admin total" (TENANT_ADMIN) do "gerente" (TENANT_MANAGER).
     */
    TENANT_MANAGER,

    TENANT_SUPPORT,
    TENANT_USER,
    TENANT_PRODUCT_MANAGER,
    TENANT_SALES_MANAGER,
    TENANT_BILLING_MANAGER,
    TENANT_READ_ONLY,
    TENANT_OPERATOR;

    @Override
    public String asAuthority() {
        return "ROLE_" + name();
    }

    public boolean isTenantOwner() {
        return this == TENANT_OWNER;
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantRoleMapper.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.SystemRoleName;
import brito.com.multitenancy001.shared.security.TenantRoleName;

/**
 * Mapper local do contexto Tenant.
 * Aqui o Tenant conhece o shared contract, mas o shared não conhece o Tenant.
 */
public final class TenantRoleMapper {

    private TenantRoleMapper() {}

    public static TenantRole toTenantRole(TenantRoleName roleName) {
        if (roleName == null) return null;
        return TenantRole.valueOf(roleName.name());
    }

    public static TenantRoleName toRoleName(TenantRole role) {
        if (role == null) return null;
        return TenantRoleName.valueOf(role.name());
    }

    public static SystemRoleName toSystemRoleOrNull(TenantRole tenantRole) {
        if (tenantRole == null) return null;

        return switch (tenantRole) {
            case TENANT_OWNER -> SystemRoleName.TENANT_OWNER;
            case TENANT_ADMIN -> SystemRoleName.TENANT_ADMIN;
            case TENANT_MANAGER -> SystemRoleName.TENANT_MANAGER;
            case TENANT_SUPPORT -> SystemRoleName.TENANT_SUPPORT;
            case TENANT_USER -> SystemRoleName.TENANT_USER;
            case TENANT_PRODUCT_MANAGER -> SystemRoleName.TENANT_PRODUCT_MANAGER;
            case TENANT_SALES_MANAGER -> SystemRoleName.TENANT_SALES_MANAGER;
            case TENANT_BILLING_MANAGER -> SystemRoleName.TENANT_BILLING_MANAGER;
            case TENANT_READ_ONLY -> SystemRoleName.TENANT_READ_ONLY;
            case TENANT_OPERATOR -> SystemRoleName.TENANT_OPERATOR;
        };
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantRolePermissions.java
============================================================
package brito.com.multitenancy001.tenant.security;

import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Set;

import static brito.com.multitenancy001.tenant.security.TenantPermission.*;

/**
 * Centraliza a matriz Role -> Permissions do Tenant.
 *
 * Regras:
 * - sempre devolve Set imutável
 * - toda role deve estar mapeada explicitamente
 * - FAIL-FAST: role sem mapeamento explode na inicialização e/ou no uso
 * - FAIL-FAST: role decorativa (set vazio) é bug
 * - FAIL-FAST: permissão duplicada no mapeamento é bug (evita erro humano escondido por Set)
 */
public final class TenantRolePermissions {

    private static final EnumMap<TenantRole, Set<TenantPermission>> MAP = new EnumMap<>(TenantRole.class);

    static {
        // OWNER = tudo
        MAP.put(TenantRole.TENANT_OWNER, unmodifiable(EnumSet.allOf(TenantPermission.class)));

        // ADMIN = "admin total" do tenant
        MAP.put(TenantRole.TENANT_ADMIN, unmodifiable(strict(
                // Users
                TEN_USER_READ,
                TEN_USER_CREATE,
                TEN_USER_UPDATE,
                TEN_USER_SUSPEND,
                TEN_USER_RESTORE,
                TEN_USER_DELETE,

                // Transfer ownership/admin
                TEN_ROLE_TRANSFER,

                // Products + Inventory
                TEN_PRODUCT_READ,
                TEN_PRODUCT_WRITE,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE,

                // Catalog
                TEN_CATEGORY_READ,
                TEN_CATEGORY_WRITE,
                TEN_SUPPLIER_READ,
                TEN_SUPPLIER_WRITE,

                // Sales + Issues + Reports
                TEN_SALE_READ,
                TEN_SALE_WRITE,
                TEN_SALE_ISSUES_READ,
                TEN_SALE_ISSUES_WRITE,
                TEN_REPORT_SALES_READ,

                // Billing + Settings
                TEN_BILLING_READ,
                TEN_BILLING_WRITE,
                TEN_SETTINGS_READ,
                TEN_SETTINGS_WRITE
        )));

        /**
         * MANAGER = "admin operacional" (sem poderes sensíveis/destrutivos).
         */
        MAP.put(TenantRole.TENANT_MANAGER, unmodifiable(strict(
                // Users (sem delete)
                TEN_USER_READ,
                TEN_USER_CREATE,
                TEN_USER_UPDATE,
                TEN_USER_SUSPEND,
                TEN_USER_RESTORE,

                // Products + Inventory
                TEN_PRODUCT_READ,
                TEN_PRODUCT_WRITE,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE,

                // Catalog
                TEN_CATEGORY_READ,
                TEN_CATEGORY_WRITE,
                TEN_SUPPLIER_READ,
                TEN_SUPPLIER_WRITE,

                // Sales + Issues + Reports
                TEN_SALE_READ,
                TEN_SALE_WRITE,
                TEN_SALE_ISSUES_READ,
                TEN_SALE_ISSUES_WRITE,
                TEN_REPORT_SALES_READ,

                // Billing + Settings (read-only)
                TEN_BILLING_READ,
                TEN_SETTINGS_READ
        )));

        MAP.put(TenantRole.TENANT_PRODUCT_MANAGER, unmodifiable(strict(
                TEN_PRODUCT_READ,
                TEN_PRODUCT_WRITE,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE
        )));

        MAP.put(TenantRole.TENANT_SALES_MANAGER, unmodifiable(strict(
                TEN_SALE_READ,
                TEN_SALE_WRITE,
                TEN_SALE_ISSUES_READ,
                TEN_SALE_ISSUES_WRITE,
                TEN_REPORT_SALES_READ
        )));

        MAP.put(TenantRole.TENANT_BILLING_MANAGER, unmodifiable(strict(
                TEN_BILLING_READ,
                TEN_BILLING_WRITE
        )));

        // READ_ONLY = auditor/consulta (sem write)
        MAP.put(TenantRole.TENANT_READ_ONLY, unmodifiable(strict(
                TEN_PRODUCT_READ,
                TEN_INVENTORY_READ,
                TEN_CATEGORY_READ,
                TEN_SUPPLIER_READ,
                TEN_SALE_READ,
                TEN_SALE_ISSUES_READ,
                TEN_REPORT_SALES_READ,
                TEN_USER_READ,
                TEN_BILLING_READ,
                TEN_SETTINGS_READ
        )));

        // USER = usuário comum
        MAP.put(TenantRole.TENANT_USER, unmodifiable(strict(
                TEN_PRODUCT_READ,
                TEN_CATEGORY_READ,
                TEN_SUPPLIER_READ,
                TEN_INVENTORY_READ,
                TEN_SALE_READ,
                TEN_SALE_WRITE
        )));

        // OPERATOR operacional
        MAP.put(TenantRole.TENANT_OPERATOR, unmodifiable(strict(
                TEN_PRODUCT_READ,
                TEN_INVENTORY_READ,
                TEN_INVENTORY_WRITE,
                TEN_SALE_READ
        )));

        // SUPPORT (tenant)
        MAP.put(TenantRole.TENANT_SUPPORT, unmodifiable(strict(
                TEN_USER_READ,
                TEN_USER_UPDATE,
                TEN_USER_SUSPEND,
                TEN_USER_RESTORE,

                TEN_PRODUCT_READ,
                TEN_INVENTORY_READ,

                TEN_SALE_READ,
                TEN_SALE_ISSUES_READ,

                TEN_SETTINGS_READ,
                TEN_BILLING_READ
        )));

        // FAIL-FAST: garante que todas as roles do enum estão mapeadas e não vazias.
        assertAllRolesMappedAndNonEmpty();
    }

    private TenantRolePermissions() {}

    /**
     * Obtém permissões base de uma role do Tenant.
     *
     * @param role role do tenant (obrigatória)
     * @return set imutável de permissões
     */
    public static Set<TenantPermission> permissionsFor(TenantRole role) {
        // método: valida parâmetros e devolve set imutável
        if (role == null) {
            throw new IllegalArgumentException("Role do Tenant é obrigatória (null)");
        }

        Set<TenantPermission> set = MAP.get(role);
        if (set == null) {
            throw new IllegalStateException("Role do Tenant sem mapeamento em TenantRolePermissions: " + role);
        }
        if (set.isEmpty()) {
            throw new IllegalStateException("Role do Tenant com set de permissões vazio (role decorativa): " + role);
        }
        return set;
    }

    private static Set<TenantPermission> unmodifiable(EnumSet<TenantPermission> set) {
        return Collections.unmodifiableSet(set);
    }

    /**
     * Constrói um EnumSet com fail-fast para duplicatas.
     */
    @SafeVarargs
    private static EnumSet<TenantPermission> strict(TenantPermission... perms) {
        // método: monta set e explode se houver duplicata por erro humano
        EnumSet<TenantPermission> set = EnumSet.noneOf(TenantPermission.class);
        for (TenantPermission p : perms) {
            if (p == null) continue;
            if (!set.add(p)) {
                throw new IllegalStateException("Permissão duplicada no mapeamento TenantRolePermissions: " + p.name());
            }
        }
        return set;
    }

    private static void assertAllRolesMappedAndNonEmpty() {
        for (TenantRole role : TenantRole.values()) {
            Set<TenantPermission> perms = MAP.get(role);
            if (perms == null) {
                throw new IllegalStateException("Role do Tenant sem mapeamento em TenantRolePermissions: " + role);
            }
            if (perms.isEmpty()) {
                throw new IllegalStateException("Role do Tenant com set de permissões vazio (role decorativa): " + role);
            }
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/security/TenantSecurityWiringVerifier.java
============================================================
package brito.com.multitenancy001.tenant.security;

import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.security.PreAuthorizePermissionReferenceParser;
import brito.com.multitenancy001.shared.security.PreAuthorizePermissionReferenceParser.EnumConstantRef;
import brito.com.multitenancy001.shared.security.PreAuthorizePermissionReferenceParser.ParsedPermissions;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

import java.lang.reflect.Method;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Verificador de wiring de segurança do Tenant.
 *
 * Responsabilidades:
 * - Garantir coerência entre TenantRole, TenantPermission e mapeamentos.
 * - Validar que todas as permissões usadas em @PreAuthorize existem.
 *
 * Benefícios:
 * - Segurança verificável em tempo de startup.
 * - Redução drástica de bugs de autorização.
 *
 * Escopo:
 * - Executado automaticamente durante a inicialização da aplicação.
 */
@Component
public class TenantSecurityWiringVerifier implements ApplicationRunner {

	private final RequestMappingHandlerMapping mapping;

	@Value("${app.security.tenant.enforce-wiring-verifier:true}")
	private boolean enabled;

	public TenantSecurityWiringVerifier(
			@Qualifier("requestMappingHandlerMapping") RequestMappingHandlerMapping mapping) {
		this.mapping = mapping;
	}

	@Override
	public void run(ApplicationArguments args) {
		if (!enabled)
			return;

		List<String> errors = new ArrayList<>();

		// 1) role -> perms: non-empty + scoped
		validateRoleMatrix(errors);

		// 2) @PreAuthorize references -> must exist + must be TEN scoped
		validatePreAuthorizeReferences(errors);

		if (!errors.isEmpty()) {
			String msg = "TenantSecurityWiringVerifier FAIL-FAST:\n"
					+ errors.stream().distinct().sorted().collect(Collectors.joining("\n"));
			throw new IllegalStateException(msg);
		}
	}

	private void validateRoleMatrix(List<String> errors) {
		for (TenantRole role : TenantRole.values()) {
			Set<TenantPermission> perms;
			try {
				perms = TenantRolePermissions.permissionsFor(role);
			} catch (RuntimeException ex) {
				errors.add("[ROLE_MATRIX] role=" + role + " -> erro ao obter permissões: " + ex.getMessage());
				continue;
			}

			if (perms == null || perms.isEmpty()) {
				errors.add("[ROLE_MATRIX] role=" + role + " -> set de permissões vazio (role decorativa)");
				continue;
			}

			// Escopo TEN_ estrito
			try {
				PermissionScopeValidator.validateTenantPermissionsStrict(perms);
			} catch (RuntimeException ex) {
				errors.add("[ROLE_MATRIX] role=" + role + " -> permissões fora do escopo TEN_: " + ex.getMessage());
			}
		}
	}

	private void validatePreAuthorizeReferences(List<String> errors) {
		for (Map.Entry<RequestMappingInfo, HandlerMethod> e : mapping.getHandlerMethods().entrySet()) {
			RequestMappingInfo info = e.getKey();
			HandlerMethod hm = e.getValue();

			Class<?> beanType = hm.getBeanType();
			String pkg = beanType.getPackageName();

			// só TENANT
			if (!pkg.startsWith("brito.com.multitenancy001.tenant"))
				continue;

			Set<String> patterns = extractPatterns(info);
			if (patterns.isEmpty())
				continue;

			// mesmo allowlist do seu verifier de presença
			if (isAllowlisted(patterns))
				continue;

			Method method = hm.getMethod();

			PreAuthorize pa = AnnotatedElementUtils.findMergedAnnotation(method, PreAuthorize.class);
			if (pa == null) {
				pa = AnnotatedElementUtils.findMergedAnnotation(beanType, PreAuthorize.class);
			}

			// se não tiver, o outro verifier já falha
			if (pa == null)
				continue;

			String expr = pa.value();
			ParsedPermissions parsed = PreAuthorizePermissionReferenceParser.parse(expr);
			if (parsed.isEmpty())
				continue;

			String endpoint = describeEndpoint(info, patterns, beanType, method);

			// 2.1) referências via T(Enum).CONST
			for (EnumConstantRef ref : parsed.enumConstantRefs()) {
				String enumFqn = ref.enumFqn();
				String constName = ref.constantName();

				if (!StringUtils.hasText(enumFqn) || !StringUtils.hasText(constName))
					continue;

				if (enumFqn.endsWith(".ControlPlanePermission")) {
					errors.add("[PREAUTH_REF] " + endpoint + " -> referência indevida a ControlPlanePermission: "
							+ enumFqn + "." + constName);
					continue;
				}

				if (!enumFqn.endsWith(".TenantPermission")) {
					errors.add("[PREAUTH_REF] " + endpoint + " -> enum inesperado em @PreAuthorize: " + enumFqn + "."
							+ constName + " (esperado TenantPermission)");
					continue;
				}

				try {
					TenantPermission.valueOf(constName);
				} catch (IllegalArgumentException ex) {
					errors.add("[PREAUTH_REF] " + endpoint + " -> permissão inexistente: TenantPermission." + constName
							+ " (expr=" + expr + ")");
				}
			}

			// 2.2) referências por string literal: 'TEN_...' / 'CP_...'
			for (String code : parsed.stringLiteralCodes()) {
				if (!StringUtils.hasText(code))
					continue;

				errors.add("[PREAUTH_LITERAL] " + endpoint + " -> uso de string literal em @PreAuthorize é proibido: '"
						+ code + "' (expr=" + expr + ")");
			}
		}
	}

	// =========================================================
	// helpers (copiados do estilo do seu verifier atual)
	// =========================================================

	private boolean isAllowlisted(Set<String> patterns) {
		for (String p : patterns) {
			if (!StringUtils.hasText(p))
				continue;

			if (p.startsWith("/api/tenant/auth"))
				return true;
			if (p.startsWith("/api/tenant/password"))
				return true;
			if (p.startsWith("/api/tenant/debug"))
				return true;
		}
		return false;
	}

	private Set<String> extractPatterns(RequestMappingInfo info) {
		try {
			if (info.getPathPatternsCondition() != null) {
				return new LinkedHashSet<>(info.getPathPatternsCondition().getPatternValues());
			}
		} catch (Throwable ignored) {
		}

		try {
			if (info.getPatternsCondition() != null) {
				return new LinkedHashSet<>(info.getPatternsCondition().getPatterns());
			}
		} catch (Throwable ignored) {
		}

		return Set.of();
	}

	private String describeEndpoint(RequestMappingInfo info, Set<String> patterns, Class<?> beanType, Method m) {
		String methods = (info.getMethodsCondition() != null && !info.getMethodsCondition().getMethods().isEmpty())
				? info.getMethodsCondition().getMethods().toString()
				: "[ANY]";
		return methods + " " + patterns + " -> " + beanType.getSimpleName() + "#" + m.getName();
	}
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/api/TenantSupplierController.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.api;

import brito.com.multitenancy001.tenant.suppliers.api.dto.SupplierCreateRequest;
import brito.com.multitenancy001.tenant.suppliers.api.dto.SupplierResponse;
import brito.com.multitenancy001.tenant.suppliers.api.dto.SupplierUpdateRequest;
import brito.com.multitenancy001.tenant.suppliers.api.mapper.SupplierApiMapper;
import brito.com.multitenancy001.tenant.suppliers.app.TenantSupplierService;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

/**
 * Controller HTTP para Suppliers no contexto do Tenant.
 *
 * Regras:
 * - Só HTTP: DTO + Mapper + Service
 * - Nunca receber Entity no @RequestBody
 * - Nunca retornar Entity
 */
@RestController
@RequestMapping("/api/tenant/suppliers")
@RequiredArgsConstructor
public class TenantSupplierController {

    private final TenantSupplierService tenantSupplierService;
    private final SupplierApiMapper supplierApiMapper;

    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.asAuthority())")
    public ResponseEntity<List<SupplierResponse>> listAll() {
        // Comentário do método: lista padrão (não-deletados) e mapeia para DTO.
        List<Supplier> list = tenantSupplierService.findAll();
        return ResponseEntity.ok(supplierApiMapper.toResponseList(list));
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.asAuthority())")
    public ResponseEntity<List<SupplierResponse>> listActive() {
        // Comentário do método: lista apenas ativos (não-deletados) e mapeia para DTO.
        List<Supplier> list = tenantSupplierService.findActive();
        return ResponseEntity.ok(supplierApiMapper.toResponseList(list));
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.asAuthority())")
    public ResponseEntity<SupplierResponse> getById(@PathVariable UUID id) {
        // Comentário do método: busca por id e retorna DTO.
        Supplier s = tenantSupplierService.findById(id);
        return ResponseEntity.ok(supplierApiMapper.toResponse(s));
    }

    @GetMapping("/document/{document}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.asAuthority())")
    public ResponseEntity<SupplierResponse> getByDocument(@PathVariable String document) {
        // Comentário do método: busca por document e retorna DTO.
        Supplier s = tenantSupplierService.findByDocument(document);
        return ResponseEntity.ok(supplierApiMapper.toResponse(s));
    }

    @GetMapping("/search")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.asAuthority())")
    public ResponseEntity<List<SupplierResponse>> searchByName(@RequestParam("name") String name) {
        // Comentário do método: busca por nome e retorna lista DTO.
        List<Supplier> list = tenantSupplierService.searchByName(name);
        return ResponseEntity.ok(supplierApiMapper.toResponseList(list));
    }

    @GetMapping("/email")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.asAuthority())")
    public ResponseEntity<List<SupplierResponse>> getByEmail(@RequestParam("email") String email) {
        // Comentário do método: busca por email (não-deletados) e retorna DTO.
        List<Supplier> list = tenantSupplierService.findByEmail(email);
        return ResponseEntity.ok(supplierApiMapper.toResponseList(list));
    }

    @GetMapping("/email/any")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_READ.asAuthority())")
    public ResponseEntity<List<SupplierResponse>> findAnyByEmail(@RequestParam String email) {
        // Comentário do método: busca por email incluindo deletados (uso administrativo/diagnóstico).
        List<Supplier> list = tenantSupplierService.findAnyByEmail(email);
        return ResponseEntity.ok(supplierApiMapper.toResponseList(list));
    }

    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.asAuthority())")
    public ResponseEntity<SupplierResponse> create(@Valid @RequestBody SupplierCreateRequest req) {
        // Comentário do método: converte DTO -> Command e delega regras ao Service.
        Supplier saved = tenantSupplierService.create(supplierApiMapper.toCreateCommand(req));
        return ResponseEntity.status(HttpStatus.CREATED).body(supplierApiMapper.toResponse(saved));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.asAuthority())")
    public ResponseEntity<SupplierResponse> update(@PathVariable UUID id, @Valid @RequestBody SupplierUpdateRequest req) {
        // Comentário do método: converte DTO -> Command e aplica update com semântica "null não altera".
        Supplier updated = tenantSupplierService.update(id, supplierApiMapper.toUpdateCommand(req));
        return ResponseEntity.ok(supplierApiMapper.toResponse(updated));
    }

    @PatchMapping("/{id}/toggle-active")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.asAuthority())")
    public ResponseEntity<SupplierResponse> toggleActive(@PathVariable UUID id) {
        // Comentário do método: alterna active e retorna DTO.
        Supplier updated = tenantSupplierService.toggleActive(id);
        return ResponseEntity.ok(supplierApiMapper.toResponse(updated));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.asAuthority())")
    public ResponseEntity<Void> softDelete(@PathVariable UUID id) {
        // Comentário do método: soft delete e retorna 204.
        tenantSupplierService.softDelete(id);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{id}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_SUPPLIER_WRITE.asAuthority())")
    public ResponseEntity<SupplierResponse> restore(@PathVariable UUID id) {
        // Comentário do método: restaura e retorna DTO.
        Supplier restored = tenantSupplierService.restore(id);
        return ResponseEntity.ok(supplierApiMapper.toResponse(restored));
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/api/dto/SupplierCreateRequest.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.math.BigDecimal;

/**
 * Request HTTP para criação de Supplier no contexto do Tenant.
 *
 * Regras:
 * - Controller recebe DTO (nunca Entity)
 * - Validações básicas ficam no DTO; regras de negócio ficam no Service/Domain
 */
public record SupplierCreateRequest(

        @NotBlank(message = "name é obrigatório")
        @Size(max = 200, message = "name deve ter no máximo 200 caracteres")
        String name,

        @Size(max = 100, message = "contactPerson deve ter no máximo 100 caracteres")
        String contactPerson,

        @Email(message = "email inválido")
        @Size(max = 150, message = "email deve ter no máximo 150 caracteres")
        String email,

        @Size(max = 20, message = "phone deve ter no máximo 20 caracteres")
        String phone,

        String address,

        @Size(max = 20, message = "document deve ter no máximo 20 caracteres")
        String document,

        @Size(max = 10, message = "documentType deve ter no máximo 10 caracteres")
        String documentType,

        @Size(max = 200, message = "website deve ter no máximo 200 caracteres")
        String website,

        @Size(max = 100, message = "paymentTerms deve ter no máximo 100 caracteres")
        String paymentTerms,

        Integer leadTimeDays,

        BigDecimal rating,

        String notes
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/api/dto/SupplierResponse.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.api.dto;

import java.math.BigDecimal;
import java.util.UUID;

/**
 * Response HTTP de Supplier.
 *
 * Nota:
 * - Expõe "deleted" para suportar endpoints/admin/consultas sem precisar trocar DTO depois.
 */
public record SupplierResponse(
        UUID id,
        String name,
        String contactPerson,
        String email,
        String phone,
        String address,
        String document,
        String documentType,
        String website,
        String paymentTerms,
        Integer leadTimeDays,
        BigDecimal rating,
        boolean active,
        boolean deleted,
        String notes
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/api/dto/SupplierUpdateRequest.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;

import java.math.BigDecimal;

/**
 * Request HTTP para atualização de Supplier no contexto do Tenant.
 *
 * Observação:
 * - Mantém compatibilidade com o comportamento atual do endpoint (campos null não alteram).
 * - Regras de negócio (unicidade de document, bloqueio se deletado, etc.) ficam no Service.
 */
public record SupplierUpdateRequest(

        @Size(max = 200, message = "name deve ter no máximo 200 caracteres")
        String name,

        @Size(max = 100, message = "contactPerson deve ter no máximo 100 caracteres")
        String contactPerson,

        @Email(message = "email inválido")
        @Size(max = 150, message = "email deve ter no máximo 150 caracteres")
        String email,

        @Size(max = 20, message = "phone deve ter no máximo 20 caracteres")
        String phone,

        String address,

        @Size(max = 20, message = "document deve ter no máximo 20 caracteres")
        String document,

        @Size(max = 10, message = "documentType deve ter no máximo 10 caracteres")
        String documentType,

        @Size(max = 200, message = "website deve ter no máximo 200 caracteres")
        String website,

        @Size(max = 100, message = "paymentTerms deve ter no máximo 100 caracteres")
        String paymentTerms,

        Integer leadTimeDays,

        BigDecimal rating,

        String notes
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/api/mapper/SupplierApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.api.mapper;

import brito.com.multitenancy001.tenant.suppliers.api.dto.SupplierCreateRequest;
import brito.com.multitenancy001.tenant.suppliers.api.dto.SupplierResponse;
import brito.com.multitenancy001.tenant.suppliers.api.dto.SupplierUpdateRequest;
import brito.com.multitenancy001.tenant.suppliers.app.command.CreateSupplierCommand;
import brito.com.multitenancy001.tenant.suppliers.app.command.UpdateSupplierCommand;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Mapper HTTP <-> Application <-> Domain para Supplier.
 *
 * Regras:
 * - Controller só usa DTO + Mapper
 * - Service só usa Command + Domain
 */
@Component
public class SupplierApiMapper {

    /**
     * Mapeia request HTTP para Command de criação.
     */
    public CreateSupplierCommand toCreateCommand(SupplierCreateRequest req) {
        // Comentário do método: normalização final (trim/uniqueness) acontece no Service.
        return new CreateSupplierCommand(
                req.name(),
                req.contactPerson(),
                req.email(),
                req.phone(),
                req.address(),
                req.document(),
                req.documentType(),
                req.website(),
                req.paymentTerms(),
                req.leadTimeDays(),
                req.rating(),
                req.notes()
        );
    }

    /**
     * Mapeia request HTTP para Command de atualização.
     */
    public UpdateSupplierCommand toUpdateCommand(SupplierUpdateRequest req) {
        // Comentário do método: campos null significam "não alterar" (compat com comportamento atual).
        return new UpdateSupplierCommand(
                req.name(),
                req.contactPerson(),
                req.email(),
                req.phone(),
                req.address(),
                req.document(),
                req.documentType(),
                req.website(),
                req.paymentTerms(),
                req.leadTimeDays(),
                req.rating(),
                req.notes()
        );
    }

    /**
     * Mapeia Domain para Response HTTP.
     */
    public SupplierResponse toResponse(Supplier s) {
        // Comentário do método: expõe flags active/deleted para suportar listagens e admin.
        return new SupplierResponse(
                s.getId(),
                s.getName(),
                s.getContactPerson(),
                s.getEmail(),
                s.getPhone(),
                s.getAddress(),
                s.getDocument(),
                s.getDocumentType(),
                s.getWebsite(),
                s.getPaymentTerms(),
                s.getLeadTimeDays(),
                s.getRating(),
                s.isActive(),
                s.isDeleted(),
                s.getNotes()
        );
    }

    /**
     * Mapeia lista Domain para lista Response.
     */
    public List<SupplierResponse> toResponseList(List<Supplier> list) {
        // Comentário do método: stream simples, sem regras.
        return list.stream().map(this::toResponse).toList();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/app/TenantSupplierService.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.app;

import brito.com.multitenancy001.infrastructure.persistence.tx.TenantReadOnlyTx;
import brito.com.multitenancy001.infrastructure.persistence.tx.TenantTx;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.tenant.suppliers.app.command.CreateSupplierCommand;
import brito.com.multitenancy001.tenant.suppliers.app.command.UpdateSupplierCommand;
import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import brito.com.multitenancy001.tenant.suppliers.persistence.TenantSupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Application Service para Suppliers (contexto Tenant).
 *
 * Papel:
 * - Orquestrar casos de uso (commands)
 * - Aplicar regras de negócio (unicidade, bloqueios por deleted, etc.)
 * - Delegar regras intrínsecas para o Domain quando aplicável (softDelete/restore)
 *
 * Regras:
 * - Controller chama Service usando Command (não Entity, não DTO)
 * - Repository é usado apenas aqui (não no Controller)
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class TenantSupplierService {

    private final TenantSupplierRepository tenantSupplierRepository;
    

    // =========================================================
    // READ (por padrão: NÃO retorna deletados)
    // =========================================================

    @TenantReadOnlyTx
    public Supplier findById(UUID id) {
        // Comentário do método: busca por id sem retornar deletados.
        if (id == null) throw new ApiException(ApiErrorCode.SUPPLIER_ID_REQUIRED, "id é obrigatório", 400);

        Supplier s = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.SUPPLIER_NOT_FOUND, "Fornecedor não encontrado com ID: " + id, 404));

        if (s.isDeleted()) throw new ApiException(ApiErrorCode.SUPPLIER_DELETED, "Fornecedor removido", 404);
        return s;
    }

    @TenantReadOnlyTx
    public List<Supplier> findAll() {
        // Comentário do método: lista não-deletados.
        return tenantSupplierRepository.findAllNotDeleted();
    }

    @TenantReadOnlyTx
    public List<Supplier> findActive() {
        // Comentário do método: lista ativos e não-deletados.
        return tenantSupplierRepository.findAllActiveNotDeleted();
    }

    @TenantReadOnlyTx
    public Supplier findByDocument(String document) {
        // Comentário do método: busca por document (não-deletado).
        if (!StringUtils.hasText(document)) {
            throw new ApiException(ApiErrorCode.SUPPLIER_DOCUMENT_REQUIRED, "document é obrigatório", 400);
        }
        return tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(document.trim())
                .orElseThrow(() -> new ApiException(ApiErrorCode.SUPPLIER_NOT_FOUND, "Fornecedor não encontrado", 404));
    }

    @TenantReadOnlyTx
    public List<Supplier> searchByName(String name) {
        // Comentário do método: busca por nome (não-deletados).
        if (!StringUtils.hasText(name)) {
            throw new ApiException(ApiErrorCode.SUPPLIER_NAME_REQUIRED, "name é obrigatório", 400);
        }
        return tenantSupplierRepository.searchNotDeletedByName(name.trim());
    }

    @TenantReadOnlyTx
    public List<Supplier> findByEmail(String email) {
        // Comentário do método: busca por email (não-deletados).
        if (!StringUtils.hasText(email)) {
            throw new ApiException(ApiErrorCode.SUPPLIER_EMAIL_REQUIRED, "email é obrigatório", 400);
        }
        return tenantSupplierRepository.findNotDeletedByEmail(email.trim());
    }

    // =========================================================
    // WRITE (Command-based)
    // =========================================================

    @TenantTx
    public Supplier create(CreateSupplierCommand cmd) {
        // Comentário do método: cria Supplier via Command + valida regras (unicidade, normalização).
        Supplier supplier = mapToNewEntity(cmd);

        validateForCreate(supplier);

        if (StringUtils.hasText(supplier.getDocument())) {
            String doc = supplier.getDocument().trim();
            Optional<Supplier> existing = tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(doc);
            if (existing.isPresent()) {
                throw new ApiException(
                        ApiErrorCode.SUPPLIER_DOCUMENT_ALREADY_EXISTS,
                        "Já existe fornecedor com document: " + doc,
                        409
                );
            }
            supplier.setDocument(doc);
        } else {
            supplier.setDocument(null);
        }

        supplier.setDeleted(false);
        supplier.setActive(true);

        return tenantSupplierRepository.save(supplier);
    }

    @TenantTx
    public Supplier update(UUID id, UpdateSupplierCommand cmd) {
        // Comentário do método: atualiza Supplier via Command (campos null não alteram).
        if (id == null) throw new ApiException(ApiErrorCode.SUPPLIER_ID_REQUIRED, "id é obrigatório", 400);
        if (cmd == null) throw new ApiException(ApiErrorCode.SUPPLIER_REQUIRED, "payload é obrigatório", 400);

        Supplier existing = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.SUPPLIER_NOT_FOUND, "Fornecedor não encontrado com ID: " + id, 404));

        if (existing.isDeleted()) {
            throw new ApiException(ApiErrorCode.SUPPLIER_DELETED, "Não é permitido alterar fornecedor deletado", 409);
        }

        if (cmd.name() != null) {
            if (!StringUtils.hasText(cmd.name())) {
                throw new ApiException(ApiErrorCode.SUPPLIER_NAME_REQUIRED, "name é obrigatório", 400);
            }
            existing.setName(cmd.name().trim());
        }

        if (cmd.contactPerson() != null) {
            existing.setContactPerson(StringUtils.hasText(cmd.contactPerson()) ? cmd.contactPerson().trim() : null);
        }

        if (cmd.email() != null) {
            existing.setEmail(StringUtils.hasText(cmd.email()) ? cmd.email().trim() : null);
        }

        if (cmd.phone() != null) {
            existing.setPhone(StringUtils.hasText(cmd.phone()) ? cmd.phone().trim() : null);
        }

        if (cmd.address() != null) {
            existing.setAddress(StringUtils.hasText(cmd.address()) ? cmd.address().trim() : null);
        }

        if (cmd.document() != null) {
            String newDoc = cmd.document();
            if (StringUtils.hasText(newDoc)) {
                newDoc = newDoc.trim();

                Optional<Supplier> other = tenantSupplierRepository.findNotDeletedByDocumentIgnoreCase(newDoc);
                if (other.isPresent() && !other.get().getId().equals(id)) {
                    throw new ApiException(
                            ApiErrorCode.SUPPLIER_DOCUMENT_ALREADY_EXISTS,
                            "Já existe fornecedor com document: " + newDoc,
                            409
                    );
                }

                existing.setDocument(newDoc);
            } else {
                existing.setDocument(null);
            }
        }

        if (cmd.documentType() != null) {
            existing.setDocumentType(StringUtils.hasText(cmd.documentType()) ? cmd.documentType().trim() : null);
        }

        if (cmd.website() != null) {
            existing.setWebsite(StringUtils.hasText(cmd.website()) ? cmd.website().trim() : null);
        }

        if (cmd.paymentTerms() != null) {
            existing.setPaymentTerms(StringUtils.hasText(cmd.paymentTerms()) ? cmd.paymentTerms().trim() : null);
        }

        if (cmd.leadTimeDays() != null) {
            if (cmd.leadTimeDays() < 0) {
                throw new ApiException(ApiErrorCode.INVALID_LEAD_TIME, "leadTimeDays não pode ser negativo", 400);
            }
            existing.setLeadTimeDays(cmd.leadTimeDays());
        }

        if (cmd.rating() != null) {
            validateRating(cmd.rating());
            existing.setRating(cmd.rating());
        }

        if (cmd.notes() != null) {
            existing.setNotes(StringUtils.hasText(cmd.notes()) ? cmd.notes().trim() : null);
        }

        return tenantSupplierRepository.save(existing);
    }

    @TenantTx
    public Supplier toggleActive(UUID id) {
        // Comentário do método: alterna active; bloqueia se deletado.
        if (id == null) throw new ApiException(ApiErrorCode.SUPPLIER_ID_REQUIRED, "id é obrigatório", 400);

        Supplier s = tenantSupplierRepository.findById(id)
                .orElseThrow(() -> new ApiException(ApiErrorCode.SUPPLIER_NOT_FOUND, "Fornecedor não encontrado com ID: " + id, 404));

        if (s.isDeleted()) throw new ApiException(ApiErrorCode.SUPPLIER_DELETED, "Fornecedor removido", 409);

        s.setActive(!s.isActive());
        return tenantSupplierRepository.save(s);
    }

  @TenantTx
public void softDelete(UUID id) {
    // Comentário do método: soft-delete idempotente (204 sempre que existir, mesmo se já deletado).
    if (id == null) throw new ApiException(ApiErrorCode.SUPPLIER_ID_REQUIRED, "id é obrigatório", 400);

    Supplier s = tenantSupplierRepository.findById(id)
            .orElseThrow(() -> new ApiException(ApiErrorCode.SUPPLIER_NOT_FOUND, "Fornecedor não encontrado com ID: " + id, 404));

    // Idempotência: se já está deletado, não faz nada e mantém o contrato (controller retorna 204).
    if (s.isDeleted()) {
        return;
    }

    s.softDelete();
    tenantSupplierRepository.save(s);
}

@TenantTx
public Supplier restore(UUID id) {
    // Comentário do método: restore idempotente (200 com body, mesmo se já estiver restaurado).
    if (id == null) throw new ApiException(ApiErrorCode.SUPPLIER_ID_REQUIRED, "id é obrigatório", 400);

    Supplier s = tenantSupplierRepository.findById(id)
            .orElseThrow(() -> new ApiException(ApiErrorCode.SUPPLIER_NOT_FOUND, "Fornecedor não encontrado com ID: " + id, 404));

    // Idempotência: se não está deletado, retorna como está (200).
    if (!s.isDeleted()) {
        return s;
    }

    s.restore();
    return tenantSupplierRepository.save(s);
}

    @TenantReadOnlyTx
    public List<Supplier> findAnyByEmail(String email) {
        // Comentário do método: consulta "any" (inclui deletados) para diagnósticos/admin.
        if (!StringUtils.hasText(email)) {
            throw new ApiException(ApiErrorCode.SUPPLIER_EMAIL_REQUIRED, "email é obrigatório", 400);
        }
        return tenantSupplierRepository.findAnyByEmail(email.trim());
    }

    // =========================================================
    // Helpers
    // =========================================================

    private Supplier mapToNewEntity(CreateSupplierCommand cmd) {
        // Comentário do método: cria entity "nova" a partir do command (sem persistência).
        if (cmd == null) throw new ApiException(ApiErrorCode.SUPPLIER_REQUIRED, "Fornecedor é obrigatório", 400);

        return Supplier.builder()
                .name(cmd.name())
                .contactPerson(cmd.contactPerson())
                .email(cmd.email())
                .phone(cmd.phone())
                .address(cmd.address())
                .document(cmd.document())
                .documentType(cmd.documentType())
                .website(cmd.website())
                .paymentTerms(cmd.paymentTerms())
                .leadTimeDays(cmd.leadTimeDays())
                .rating(cmd.rating())
                .notes(cmd.notes())
                .active(true)
                .deleted(false)
                .build();
    }

    void validateForCreate(Supplier supplier) {
        // Comentário do método: valida payload de criação + normaliza campos string.
        if (supplier == null) throw new ApiException(ApiErrorCode.SUPPLIER_REQUIRED, "Fornecedor é obrigatório", 400);

        if (!StringUtils.hasText(supplier.getName())) {
            throw new ApiException(ApiErrorCode.SUPPLIER_NAME_REQUIRED, "name é obrigatório", 400);
        }

        supplier.setName(supplier.getName().trim());

        if (supplier.getEmail() != null) {
            supplier.setEmail(StringUtils.hasText(supplier.getEmail()) ? supplier.getEmail().trim() : null);
        }
        if (supplier.getContactPerson() != null) {
            supplier.setContactPerson(StringUtils.hasText(supplier.getContactPerson()) ? supplier.getContactPerson().trim() : null);
        }
        if (supplier.getPhone() != null) {
            supplier.setPhone(StringUtils.hasText(supplier.getPhone()) ? supplier.getPhone().trim() : null);
        }
        if (supplier.getAddress() != null) {
            supplier.setAddress(StringUtils.hasText(supplier.getAddress()) ? supplier.getAddress().trim() : null);
        }
        if (supplier.getDocumentType() != null) {
            supplier.setDocumentType(StringUtils.hasText(supplier.getDocumentType()) ? supplier.getDocumentType().trim() : null);
        }
        if (supplier.getWebsite() != null) {
            supplier.setWebsite(StringUtils.hasText(supplier.getWebsite()) ? supplier.getWebsite().trim() : null);
        }
        if (supplier.getPaymentTerms() != null) {
            supplier.setPaymentTerms(StringUtils.hasText(supplier.getPaymentTerms()) ? supplier.getPaymentTerms().trim() : null);
        }
        if (supplier.getNotes() != null) {
            supplier.setNotes(StringUtils.hasText(supplier.getNotes()) ? supplier.getNotes().trim() : null);
        }

        if (supplier.getLeadTimeDays() != null && supplier.getLeadTimeDays() < 0) {
            throw new ApiException(ApiErrorCode.INVALID_LEAD_TIME, "leadTimeDays não pode ser negativo", 400);
        }

        if (supplier.getRating() != null) {
            validateRating(supplier.getRating());
        }
    }

    private void validateRating(BigDecimal rating) {
        // Comentário do método: valida range permitido do rating.
        if (rating.compareTo(BigDecimal.ZERO) < 0) {
            throw new ApiException(ApiErrorCode.INVALID_RATING, "rating não pode ser negativo", 400);
        }
        if (rating.compareTo(new BigDecimal("9.99")) > 0) {
            throw new ApiException(ApiErrorCode.INVALID_RATING, "rating máximo é 9.99", 400);
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/app/command/CreateSupplierCommand.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.app.command;

import java.math.BigDecimal;

/**
 * Command de criação de Supplier.
 *
 * Nota:
 * - Commands pertencem à camada Application.
 * - Validações de regra (unicidade, bloqueio por deleted, etc.) ficam no Service.
 */
public record CreateSupplierCommand(
        String name,
        String contactPerson,
        String email,
        String phone,
        String address,
        String document,
        String documentType,
        String website,
        String paymentTerms,
        Integer leadTimeDays,
        BigDecimal rating,
        String notes
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/app/command/UpdateSupplierCommand.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.app.command;

import java.math.BigDecimal;

/**
 * Command de atualização de Supplier.
 *
 * Semântica:
 * - Campos null significam "não alterar" (compatível com o comportamento atual do endpoint).
 */
public record UpdateSupplierCommand(
        String name,
        String contactPerson,
        String email,
        String phone,
        String address,
        String document,
        String documentType,
        String website,
        String paymentTerms,
        Integer leadTimeDays,
        BigDecimal rating,
        String notes
) {}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/domain/Supplier.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.domain;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.tenant.products.domain.Product;
import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "suppliers", indexes = {
        @Index(name = "idx_supplier_name", columnList = "name"),
        @Index(name = "idx_supplier_email", columnList = "email")
        // NÃO declare unique index de document aqui (é parcial no DB)
})
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString(exclude = {"products"})
public class Supplier implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", columnDefinition = "uuid", updatable = false, nullable = false)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(name = "contact_person", length = 100)
    private String contactPerson;

    @Column(length = 150)
    private String email;

    @Column(length = 20)
    private String phone;

    @Column(columnDefinition = "TEXT")
    private String address;

    @Column(length = 20)
    private String document;

    @Column(name = "document_type", length = 10)
    private String documentType;

    @Column(name = "website", length = 200)
    private String website;

    @Column(name = "payment_terms", length = 100)
    private String paymentTerms;

    @Column(name = "lead_time_days")
    private Integer leadTimeDays;

    @Column(name = "rating", precision = 3, scale = 2)
    private BigDecimal rating;

    @Builder.Default
    @Column(name = "active", nullable = false)
    private boolean active = true;

    @Builder.Default
    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;

    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @OneToMany(
            mappedBy = "supplier",
            cascade = {CascadeType.PERSIST, CascadeType.MERGE},
            fetch = FetchType.LAZY
    )
    @Builder.Default
    private List<Product> products = new ArrayList<>();

    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    @Override
    public AuditInfo getAudit() {
        return audit;
    }

    @Override
    public boolean isDeleted() {
        return deleted;
    }

    // =====================
    // Regras de domínio
    // =====================

    /**
     * Soft delete padrão do projeto:
     * - marca deleted=true e desativa active
     * - audit.deletedAt/deletedBy são setados pelo AuditEntityListener (AppClock)
     */
    public void softDelete() {
        if (this.deleted) return;
        this.deleted = true;
        this.active = false;
    }

    /**
     * Compat com código antigo que chamava softDelete(Instant).
     * O tempo é responsabilidade do AuditEntityListener, então o parâmetro é ignorado.
     */
    public void softDelete(Instant ignoredNow) {
        softDelete();
    }

    public void restore() {
        if (!this.deleted) return;

        this.deleted = false;
        this.active = true;

        // Política: restore limpa deletedAt/deletedBy
        // (se você preferir manter histórico, remova esta linha)
        if (this.audit != null) {
            this.audit.clearDeleted();
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/suppliers/persistence/TenantSupplierRepository.java
============================================================
package brito.com.multitenancy001.tenant.suppliers.persistence;

import brito.com.multitenancy001.tenant.suppliers.domain.Supplier;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository JPA para Supplier (contexto Tenant).
 *
 * Contratos (padrão Categories/Subcategories):
 * - "NotDeleted": nunca retorna registros soft-deletados (deleted = false)
 * - "ActiveNotDeleted": retorna apenas ativos e não deletados
 * - "Any": pode incluir deleted/inactive (uso admin/diagnóstico)
 *
 * Observação:
 * - O Service deve preferir SEMPRE os métodos NotDeleted/ActiveNotDeleted.
 * - Métodos legados foram mantidos por compatibilidade, mas os recomendados são os padronizados abaixo.
 */
@Repository
public interface TenantSupplierRepository extends JpaRepository<Supplier, UUID> {

    // =========================================================
    // PADRÃO (usados pelo Service / endpoints)
    // =========================================================

    @Query("SELECT s FROM Supplier s WHERE s.deleted = false ORDER BY s.name ASC")
    List<Supplier> findAllNotDeleted();
    // Comentário do método: lista fornecedores não-deletados ordenados por nome.

    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND s.active = true ORDER BY s.name ASC")
    List<Supplier> findAllActiveNotDeleted();
    // Comentário do método: lista fornecedores ativos e não-deletados ordenados por nome.

    @Query("""
            SELECT s FROM Supplier s
            WHERE s.deleted = false
              AND LOWER(s.name) LIKE LOWER(CONCAT('%', :name, '%'))
            ORDER BY s.name ASC
            """)
    List<Supplier> searchNotDeletedByName(@Param("name") String name);
    // Comentário do método: busca por name (contains), não-deletados.

    @Query("""
            SELECT s FROM Supplier s
            WHERE s.deleted = false
              AND s.email = :email
            ORDER BY s.name ASC
            """)
    List<Supplier> findNotDeletedByEmail(@Param("email") String email);
    // Comentário do método: busca por email (exato) em não-deletados.

    @Query("""
            SELECT s FROM Supplier s
            WHERE s.deleted = false
              AND s.document IS NOT NULL
              AND TRIM(s.document) <> ''
              AND LOWER(TRIM(s.document)) = LOWER(TRIM(:document))
            """)
    Optional<Supplier> findNotDeletedByDocumentIgnoreCase(@Param("document") String document);
    // Comentário do método: busca por document (trim + ignoreCase) em não-deletados.

    // =========================================================
    // ANY (admin/relatórios internos) ⚠️ pode incluir deleted/inactive
    // =========================================================

    @Query("""
            SELECT s FROM Supplier s
            WHERE s.email = :email
            ORDER BY s.name ASC
            """)
    List<Supplier> findAnyByEmail(@Param("email") String email);
    // Comentário do método: busca por email incluindo deletados/inativos (uso admin/diagnóstico).

    // =========================================================
    // LEGADOS / COMPATIBILIDADE (podem ser removidos depois)
    // =========================================================

    @Query("SELECT s FROM Supplier s WHERE s.deleted = false ORDER BY s.name ASC")
    List<Supplier> findNotDeleted();
    // Comentário do método: legado (equivalente a findAllNotDeleted).

    @Query("""
            SELECT s FROM Supplier s
            WHERE s.deleted = false
              AND LOWER(s.name) LIKE LOWER(CONCAT('%', :name, '%'))
            ORDER BY s.name ASC
            """)
    List<Supplier> findNotDeletedByNameContainingIgnoreCase(@Param("name") String name);
    // Comentário do método: legado (equivalente a searchNotDeletedByName).

    @Query("SELECT s FROM Supplier s WHERE s.deleted = false AND s.active = true ORDER BY s.name ASC")
    List<Supplier> findActiveNotDeleted();
    // Comentário do método: legado (equivalente a findAllActiveNotDeleted).

    List<Supplier> findByNameContainingIgnoreCase(String name);
    // Comentário do método: legado (pode incluir deletados). Evitar em regra normal.
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/TenantUserController.java
============================================================
package brito.com.multitenancy001.tenant.users.api;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserListItemResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUsersListResponse;
import brito.com.multitenancy001.tenant.users.api.mapper.TenantUserApiMapper;
import brito.com.multitenancy001.tenant.users.app.context.TenantUserCurrentContextCommandService;
import brito.com.multitenancy001.tenant.users.app.context.TenantUserCurrentContextQueryService;
import brito.com.multitenancy001.tenant.users.app.query.TenantUsersListView;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Pattern;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * API REST (Tenant): Usuários.
 *
 * Observação importante sobre roteamento:
 * - Rotas fixas (ex.: /count-enabled) DEVEM existir explicitamente.
 * - Rotas com path variable DEVEM ser restritas por regex (ex.: {userId:\\d+})
 *   para não capturar strings e gerar 500 (TypeMismatch).
 *
 * Compatibilidade E2E/coleções legadas:
 * - Algumas coleções usam PATCH /{id}/soft-delete ao invés de DELETE /{id}.
 *   Mantemos ambos para não quebrar Newman.
 */
@RestController
@RequestMapping("/api/tenant/users")
@RequiredArgsConstructor
public class TenantUserController {

    private final TenantUserCurrentContextQueryService tenantUserQueryService;
    private final TenantUserCurrentContextCommandService tenantUserCommandService;
    private final TenantUserApiMapper tenantUserApiMapper;

    @GetMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.asAuthority())")
    public ResponseEntity<TenantUsersListResponse> listTenantUsers() {
        TenantUsersListView view = tenantUserQueryService.listTenantUsers();

        List<TenantUserListItemResponse> mapped = view.users().stream()
                .map(u -> view.isOwner()
                        ? tenantUserApiMapper.toListItemRich(u)
                        : tenantUserApiMapper.toListItemBasic(u))
                .toList();

        return ResponseEntity.ok(new TenantUsersListResponse(view.entitlements(), mapped));
    }

    @GetMapping("/enabled")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.asAuthority())")
    public ResponseEntity<List<TenantUserSummaryResponse>> listEnabledTenantUsers() {
        List<TenantUser> users = tenantUserQueryService.listEnabledTenantUsers();
        return ResponseEntity.ok(users.stream().map(tenantUserApiMapper::toSummary).toList());
    }

    /**
     * Compat com a coleção E2E v9:
     * GET /api/tenant/users/count-enabled
     */
    @GetMapping("/count-enabled")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.asAuthority())")
    public ResponseEntity<Long> countEnabledTenantUsersCompat() {
        return ResponseEntity.ok(tenantUserQueryService.countEnabledTenantUsers());
    }

    /**
     * Endpoint "oficial" atual:
     * GET /api/tenant/users/enabled/count
     */
    @GetMapping("/enabled/count")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.asAuthority())")
    public ResponseEntity<Long> countEnabledTenantUsers() {
        return ResponseEntity.ok(tenantUserQueryService.countEnabledTenantUsers());
    }

    @GetMapping("/enabled/{userId:\\d+}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.asAuthority())")
    public ResponseEntity<TenantUserDetailsResponse> getEnabledTenantUser(@PathVariable Long userId) {
        TenantUser user = tenantUserQueryService.getEnabledTenantUser(userId);
        return ResponseEntity.ok(tenantUserApiMapper.toDetails(user));
    }

    /**
     * IMPORTANTE: restringe para aceitar somente números.
     */
    @GetMapping("/{userId:\\d+}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_READ.asAuthority())")
    public ResponseEntity<TenantUserDetailsResponse> getTenantUser(@PathVariable Long userId) {
        TenantUser user = tenantUserQueryService.getTenantUser(userId);
        return ResponseEntity.ok(tenantUserApiMapper.toDetails(user));
    }

    @PostMapping
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_CREATE.asAuthority())")
    public ResponseEntity<TenantUserDetailsResponse> createTenantUser(@Valid @RequestBody TenantUserCreateRequest tenantUserCreateRequest) {
        TenantUser created = tenantUserCommandService.createTenantUser(tenantUserCreateRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(tenantUserApiMapper.toDetails(created));
    }

    @PatchMapping("/{userId:\\d+}/transfer-admin")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_ROLE_TRANSFER.asAuthority())")
    public ResponseEntity<Void> transferTenantOwner(@PathVariable Long userId) {
        tenantUserCommandService.transferTenantOwner(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId:\\d+}/status")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_UPDATE.asAuthority())")
    public ResponseEntity<TenantUserSummaryResponse> updateTenantUserStatus(
            @PathVariable Long userId,
            @RequestParam(required = false) Boolean suspendedByAccount,
            @RequestParam(required = false) Boolean suspendedByAdmin
    ) {
        if (suspendedByAccount == null && suspendedByAdmin == null) {
            throw new ApiException(ApiErrorCode.INVALID_STATUS, "Informe suspendedByAccount ou suspendedByAdmin", 400);
        }
        if (suspendedByAccount != null && suspendedByAdmin != null) {
            throw new ApiException(ApiErrorCode.INVALID_STATUS, "Informe apenas um dos parâmetros (suspendedByAccount OU suspendedByAdmin)", 400);
        }

        TenantUser updated =
                (suspendedByAdmin != null)
                        ? tenantUserCommandService.setTenantUserSuspendedByAdmin(userId, suspendedByAdmin)
                        : tenantUserCommandService.setTenantUserSuspendedByAccount(userId, suspendedByAccount);

        return ResponseEntity.ok(tenantUserApiMapper.toSummary(updated));
    }

    @PatchMapping("/{userId:\\d+}/password")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_UPDATE.asAuthority())")
    public ResponseEntity<TenantUserSummaryResponse> resetTenantUserPassword(
            @PathVariable Long userId,
            @RequestParam
            @Pattern(
                    regexp = ValidationPatterns.PASSWORD_PATTERN,
                    message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas e números"
            )
            String newPassword
    ) {
        TenantUser updated = tenantUserCommandService.resetTenantUserPassword(userId, newPassword);
        return ResponseEntity.ok(tenantUserApiMapper.toSummary(updated));
    }

    /**
     * Compat com coleções legadas:
     * PATCH /api/tenant/users/{id}/soft-delete
     */
    @PatchMapping("/{userId:\\d+}/soft-delete")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_DELETE.asAuthority())")
    public ResponseEntity<Void> softDeleteTenantUserCompat(@PathVariable Long userId) {
        tenantUserCommandService.softDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    /**
     * Endpoint "oficial" atual:
     * DELETE /api/tenant/users/{id}
     */
    @DeleteMapping("/{userId:\\d+}")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_DELETE.asAuthority())")
    public ResponseEntity<Void> deleteTenantUser(@PathVariable Long userId) {
        tenantUserCommandService.softDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    @DeleteMapping("/{userId:\\d+}/hard")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_DELETE.asAuthority())")
    public ResponseEntity<Void> hardDeleteTenantUser(@PathVariable Long userId) {
        tenantUserCommandService.hardDeleteTenantUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/{userId:\\d+}/restore")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_RESTORE.asAuthority())")
    public ResponseEntity<TenantUserSummaryResponse> restoreTenantUser(@PathVariable Long userId) {
        TenantUser restored = tenantUserCommandService.restoreTenantUser(userId);
        return ResponseEntity.ok(tenantUserApiMapper.toSummary(restored));
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/admin/TenantUserAdminController.java
============================================================
package brito.com.multitenancy001.tenant.users.api.admin;

import brito.com.multitenancy001.tenant.users.api.dto.admin.TenantUserAdminSuspendRequest;
import brito.com.multitenancy001.tenant.users.app.admin.TenantUserAdminService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

/**
 * Controller ADMIN (Tenant) para ações operacionais sobre usuários.
 *
 * Regras:
 * - Controller NÃO acessa repository.
 * - Payload deve ser validado com @Valid (ControllerComplianceVerifier).
 * - Controller delega para Application Service.
 */
@RestController
@RequestMapping("/api/tenant/admin/users")
@RequiredArgsConstructor
public class TenantUserAdminController {

    private final TenantUserAdminService tenantUserAdminService;

    /**
     * Suspende ou reativa usuário do tenant por ação administrativa.
     */
    @PatchMapping("/{userId}/suspend")
    @PreAuthorize("hasAuthority(T(brito.com.multitenancy001.tenant.security.TenantPermission).TEN_USER_SUSPEND.asAuthority())")
    public ResponseEntity<Void> suspendUser(
            /* Identificador do usuário alvo. */
            @PathVariable Long userId,
            /* Valida o payload (@Valid é obrigatório pelo compliance). */
            @Valid @RequestBody TenantUserAdminSuspendRequest tenantUserAdminSuspendRequest
    ) {
        tenantUserAdminService.setUserSuspendedByAdmin(userId, tenantUserAdminSuspendRequest.suspended());
        return ResponseEntity.noContent().build();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantActorRef.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

public record TenantActorRef(
        Long userId,
        String email
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserCreateRequest.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Builder;

import java.util.LinkedHashSet;

/**
 * Request para criação de usuário no Tenant.
 *
 * Login é por EMAIL
 *
 * Observações:
 * - locale/timezone são opcionais (defaults são aplicados no service).
 * - mustChangePassword é opcional (default false).
 * - ✅ permissions agora são TIPADAS (enum TenantPermission).
 */
@Builder
public record TenantUserCreateRequest(

        @NotBlank(message = "Nome é obrigatório")
        @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
        String name,

        @NotBlank(message = "Email é obrigatório")
        @Email(message = "Email inválido")
        @Size(max = 150, message = "Email não pode exceder 150 caracteres")
        String email,

        @NotBlank(message = "Senha é obrigatória")
        @Pattern(
                regexp = ValidationPatterns.PASSWORD_PATTERN,
                message = "Senha fraca. Use pelo menos 8 caracteres com letras maiúsculas, minúsculas, números e caracteres especiais"
        )
        String password,

        @NotNull(message = "Role é obrigatória")
        TenantRole role,

        // ✅ TIPADO
        LinkedHashSet<@NotNull(message = "Permission não pode ser null") TenantPermission> permissions,

        @Pattern(regexp = ValidationPatterns.PHONE_PATTERN, message = "Telefone inválido")
        @Size(max = 20, message = "Telefone não pode exceder 20 caracteres")
        String phone,

        @Size(max = 500, message = "URL do avatar não pode exceder 500 caracteres")
        String avatarUrl,

        @Size(max = 10, message = "Locale não pode exceder 10 caracteres")
        String locale,

        @Size(max = 50, message = "Timezone não pode exceder 50 caracteres")
        String timezone,

        Boolean mustChangePassword,

        EntityOrigin origin

) {
    public TenantUserCreateRequest {
        if (name != null) name = name.trim();
        if (email != null) email = email.trim();
        if (phone != null) phone = phone.trim();
        if (avatarUrl != null) avatarUrl = avatarUrl.trim();
        if (locale != null) locale = locale.trim();
        if (timezone != null) timezone = timezone.trim();
        if (permissions == null) permissions = new LinkedHashSet<>();
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserDetailsResponse.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.tenant.security.TenantRole;

public record TenantUserDetailsResponse(
        Long id,
        Long accountId,
        String name,
        String email,
        TenantRole role,
        String phone,
        String avatarUrl,
        String timezone,
        String locale,
        boolean mustChangePassword,
        EntityOrigin origin,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean deleted,
        boolean enabled
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserListItemResponse.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.tenant.security.TenantRole;

import java.time.Instant;
import java.util.List;

public record TenantUserListItemResponse(
        Long id,
        String email,
        TenantRole role,
        List<String> permissions,
        boolean mustChangePassword,
        EntityOrigin origin,
        Instant lastLoginAt,
        TenantActorRef createdBy,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUserSummaryResponse.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

public record TenantUserSummaryResponse(
        Long id,
        String email,
        boolean suspendedByAccount,
        boolean suspendedByAdmin,
        boolean enabled
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/TenantUsersListResponse.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto;

import java.util.List;

import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsSnapshot;

public record TenantUsersListResponse(
        AccountEntitlementsSnapshot entitlements, // somente para TENANT_OWNER
        List<TenantUserListItemResponse> users
) {}


============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/dto/admin/TenantUserAdminSuspendRequest.java
============================================================
package brito.com.multitenancy001.tenant.users.api.dto.admin;

public record TenantUserAdminSuspendRequest(boolean suspended) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/api/mapper/TenantUserApiMapper.java
============================================================
package brito.com.multitenancy001.tenant.users.api.mapper;

import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.tenant.me.api.dto.TenantMeResponse;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.api.dto.TenantActorRef;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserDetailsResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserListItemResponse;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserSummaryResponse;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import org.springframework.stereotype.Component;

import java.util.Comparator;
import java.util.List;
import java.util.Locale;

@Component
public class TenantUserApiMapper {

    public TenantUserSummaryResponse toSummary(TenantUser tenantUser) {
        boolean enabled =
                !tenantUser.isDeleted()
                        && !tenantUser.isSuspendedByAccount()
                        && !tenantUser.isSuspendedByAdmin();

        return new TenantUserSummaryResponse(
                tenantUser.getId(),
                tenantUser.getEmail(),
                tenantUser.isSuspendedByAccount(),
                tenantUser.isSuspendedByAdmin(),
                enabled
        );
    }

    public TenantMeResponse toMe(TenantUser u) {
        boolean enabled = u.isEnabled();
        TenantRole role = u.getRole();

        return new TenantMeResponse(
                u.getId(),
                u.getAccountId(),
                u.getName(),
                u.getEmail(),
                role,
                u.getPhone(),
                u.getAvatarUrl(),
                u.getTimezone(),
                u.getLocale(),
                u.isMustChangePassword(),
                u.getOrigin(),
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                u.isDeleted(),
                enabled
        );
    }

    public TenantUserDetailsResponse toDetails(TenantUser u) {
        boolean enabled = u.isEnabled();
        TenantRole role = u.getRole();

        return new TenantUserDetailsResponse(
                u.getId(),
                u.getAccountId(),
                u.getName(),
                u.getEmail(),
                role,
                u.getPhone(),
                u.getAvatarUrl(),
                u.getTimezone(),
                u.getLocale(),
                u.isMustChangePassword(),
                u.getOrigin(),
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                u.isDeleted(),
                enabled
        );
    }

    public TenantUserListItemResponse toListItemBasic(TenantUser u) {
        boolean enabled = u.isEnabled();
        TenantRole role = u.getRole();

        return new TenantUserListItemResponse(
                u.getId(),
                u.getEmail(),
                role,
                List.of(),
                u.isMustChangePassword(),
                u.getOrigin(),
                null,
                null,
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                enabled
        );
    }

    public TenantUserListItemResponse toListItemRich(TenantUser u) {
        boolean enabled = u.isEnabled();

        List<String> perms = u.getPermissions().stream()
                .filter(p -> p != null)
                .map(TenantPermission::name)
                .map(s -> s.trim().toUpperCase(Locale.ROOT))
                .sorted(Comparator.naturalOrder())
                .toList();

        TenantActorRef createdBy = mapCreatedBy(u.getAudit());
        TenantRole role = u.getRole();

        return new TenantUserListItemResponse(
                u.getId(),
                u.getEmail(),
                role,
                perms,
                u.isMustChangePassword(),
                u.getOrigin(),
                u.getLastLoginAt(),
                createdBy,
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                enabled
        );
    }

    private TenantActorRef mapCreatedBy(AuditInfo audit) {
        if (audit == null) return null;
        if (audit.getCreatedBy() == null && audit.getCreatedByEmail() == null) return null;
        return new TenantActorRef(audit.getCreatedBy(), audit.getCreatedByEmail());
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/TenantUserAdminTxService.java
============================================================
package brito.com.multitenancy001.tenant.users.app;

import brito.com.multitenancy001.infrastructure.persistence.TxExecutor;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.contracts.UserSummaryData;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.TenantRoleName;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;

/**
 * Tenant APP: regras e operações administrativas em massa/conta.
 *
 * Importante:
 * - Fica no Tenant (app), porque as regras (ex.: não suspender OWNER) pertencem ao Tenant.
 * - Integração apenas chama isso dentro do schema certo.
 *
 * Pré-condição: este serviço é chamado já dentro do schema do tenant (via TenantExecutor).
 */
@Service
@RequiredArgsConstructor
public class TenantUserAdminTxService {

    private final TxExecutor transactionExecutor;
    private final TenantUserRepository tenantUserRepository;
    private final AppClock appClock;

    /**
     * ✅ (SAFE) Admin bulk: suspende todos MENOS TENANT_OWNER.
     * Regra: precisa existir ao menos 1 TENANT_OWNER não deletado (estado mínimo válido).
     */
    public int suspendAllUsersByAccount(Long accountId) {
        return transactionExecutor.inTenantRequiresNew(() -> {
            requireAccountId(accountId);

            long ownersNotDeleted = tenantUserRepository.countNotDeletedByAccountIdAndRole(accountId, TenantRole.TENANT_OWNER);
            if (ownersNotDeleted <= 0) {
                throw new ApiException(
                        ApiErrorCode.TENANT_OWNER_REQUIRED,
                        "Não é possível suspender usuários: não existe TENANT_OWNER não deletado para esta conta (estado inválido).",
                        409
                );
            }

            return tenantUserRepository.suspendAllByAccountExceptRole(accountId, TenantRole.TENANT_OWNER);
        });
    }

    /**
     * ✅ Reativa todos (inclusive owners).
     */
    public int unsuspendAllUsersByAccount(Long accountId) {
        return transactionExecutor.inTenantRequiresNew(() -> {
            requireAccountId(accountId);
            return tenantUserRepository.unsuspendAllByAccount(accountId);
        });
    }

    /**
     * ✅ (SAFE) Cancelamento / exclusão da conta:
     * soft-delete de todos os usuários MENOS TENANT_OWNER.
     * Regra: precisa existir ao menos 1 TENANT_OWNER não deletado (estado mínimo válido).
     */
    public int softDeleteAllUsersByAccount(Long accountId) {
        return transactionExecutor.inTenantRequiresNew(() -> {
            requireAccountId(accountId);

            long ownersNotDeleted = tenantUserRepository.countNotDeletedByAccountIdAndRole(accountId, TenantRole.TENANT_OWNER);
            if (ownersNotDeleted <= 0) {
                throw new ApiException(
                        ApiErrorCode.TENANT_OWNER_REQUIRED,
                        "Não é possível remover usuários: não existe TENANT_OWNER não deletado para esta conta (estado inválido).",
                        409
                );
            }

            Instant now = appClock.instant();
            return tenantUserRepository.softDeleteAllByAccountExceptRole(accountId, TenantRole.TENANT_OWNER, now);
        });
    }

    public int restoreAllUsersByAccount(Long accountId) {
        return transactionExecutor.inTenantRequiresNew(() -> {
            requireAccountId(accountId);
            return tenantUserRepository.restoreAllByAccount(accountId);
        });
    }

    /**
     * Retorna um summary “contratual” para o Control Plane / integrações.
     *
     * onlyOperational=true:
     *   deleted=false AND suspendedByAccount=false AND suspendedByAdmin=false
     */
    public List<UserSummaryData> listUserSummaries(Long accountId, boolean onlyOperational) {
        return transactionExecutor.inTenantReadOnlyTx(() -> {
            requireAccountId(accountId);

            List<TenantUser> users = onlyOperational
                    ? tenantUserRepository.findEnabledUsersByAccount(accountId)
                    : tenantUserRepository.findByAccountId(accountId);

            return users.stream()
                    .map(this::toSummary)
                    .toList();
        });
    }

    /**
     * Suspensão manual por admin em um único usuário.
     *
     * Regra crítica:
     * - não permitir suspender o ÚLTIMO TENANT_OWNER ativo.
     */
    public void setSuspendedByAdmin(Long accountId, Long userId, boolean suspended) {
        transactionExecutor.inTenantTx(() -> {
            requireAccountId(accountId);
            requireUserId(userId);

            if (suspended) {
                TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado ou removido", 404));

                if (isActiveOwner(user)) {
                    long activeOwners = tenantUserRepository.countActiveOwnersByAccountId(accountId, TenantRole.TENANT_OWNER);
                    if (activeOwners <= 1) {
                        throw new ApiException(
                                ApiErrorCode.TENANT_OWNER_REQUIRED,
                                "Não é permitido suspender o último TENANT_OWNER ativo.",
                                409
                        );
                    }
                }
            }

            int updated = tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended);
            if (updated == 0) {
                throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado ou removido", 404);
            }
            return null;
        });
    }

    // =========================================================
    // Helpers
    // =========================================================

    private UserSummaryData toSummary(TenantUser u) {
        return new UserSummaryData(
                u.getId(),
                u.getAccountId(),
                u.getName(),
                u.getEmail(),
                u.getRole() == null ? null : TenantRoleName.valueOf(u.getRole().name()),
                u.isSuspendedByAccount(),
                u.isSuspendedByAdmin(),
                u.isDeleted()
        );
    }

    private boolean isActiveOwner(TenantUser user) {
        if (user == null) return false;
        if (user.isDeleted()) return false;
        if (user.isSuspendedByAccount()) return false;
        if (user.isSuspendedByAdmin()) return false;
        return user.getRole() != null && user.getRole().isTenantOwner();
    }

    private void requireAccountId(Long accountId) {
        if (accountId == null) {
            throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "AccountId obrigatório", 400);
        }
    }

    private void requireUserId(Long userId) {
        if (userId == null) {
            throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId obrigatório", 400);
        }
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/admin/TenantUserAdminService.java
============================================================
package brito.com.multitenancy001.tenant.users.app.admin;

import brito.com.multitenancy001.integration.security.TenantRequestIdentityService;
import brito.com.multitenancy001.tenant.users.app.command.TenantUserCommandService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

/**
 * Casos de uso administrativos do Tenant para gestão de usuários.
 *
 * Regras:
 * - Resolve accountId + tenantSchema a partir da identidade do request.
 * - Não faz bind de schema nem transação aqui.
 *   (isso é responsabilidade do TenantUserCommandService via TenantSchemaUnitOfWork).
 * - Não implementa regra de negócio: delega para TenantUserCommandService.
 */
@Service
@RequiredArgsConstructor
public class TenantUserAdminService {

    private final TenantUserCommandService tenantUserCommandService;
    private final TenantRequestIdentityService requestIdentity;

    public void setUserSuspendedByAdmin(Long userId, boolean suspended) {
        /* Suspende/reativa usuário por ação administrativa (admin flag). */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        tenantUserCommandService.setSuspendedByAdmin(accountId, tenantSchema, userId, suspended);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/audit/TenantUserSecurityAuditRecorder.java
============================================================
package brito.com.multitenancy001.tenant.users.app.audit;

import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditService;
import brito.com.multitenancy001.integration.security.TenantRequestIdentityService;
import brito.com.multitenancy001.shared.audit.AuditDetails;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.Map;

/**
 * Recorder de auditoria de segurança para operações sensíveis em Users (TENANT).
 *
 * Objetivo:
 * - Centralizar chamadas ao SecurityAuditService (append-only).
 * - Padronizar details em JSON via Map + JsonDetailsMapper.
 * - Garantir campos: actor, target, accountId, tenantSchema, correlationId.
 *
 * Regras:
 * - Deve ser chamado por Application Services (não por controllers).
 * - Não logar segredos (senha/JWT/refresh token).
 */
@Service
@RequiredArgsConstructor
public class TenantUserSecurityAuditRecorder {

    private static final String SCOPE = "tenant.users";

    private final TenantRequestIdentityService requestIdentity;
    private final SecurityAuditService securityAuditService;
    private final JsonDetailsMapper jsonDetailsMapper;

    public void recordAttempt(SecurityAuditActionType type, Long targetUserId, String targetEmail, Map<String, Object> details) {
        /* Registra tentativa (ATTEMPT) para ação sensível em users. */
        record(type, AuditOutcome.ATTEMPT, targetUserId, targetEmail, details);
    }

    public void recordSuccess(SecurityAuditActionType type, Long targetUserId, String targetEmail, Map<String, Object> details) {
        /* Registra sucesso (SUCCESS) para ação sensível em users. */
        record(type, AuditOutcome.SUCCESS, targetUserId, targetEmail, details);
    }

    public void recordDenied(SecurityAuditActionType type, Long targetUserId, String targetEmail, Map<String, Object> details) {
        /* Registra negação (DENIED) para ação sensível em users. */
        record(type, AuditOutcome.DENIED, targetUserId, targetEmail, details);
    }

    public void recordFailure(SecurityAuditActionType type, Long targetUserId, String targetEmail, Map<String, Object> details) {
        /* Registra falha (FAILURE) para ação sensível em users. */
        record(type, AuditOutcome.FAILURE, targetUserId, targetEmail, details);
    }

    public Map<String, Object> baseDetails(String event, Long targetUserId, String targetEmail) {
        /* Cria details base padronizado para users. */
        Long actorUserId = requestIdentity.getCurrentUserId();
        String actorEmail = requestIdentity.getCurrentEmail();

        Map<String, Object> d = AuditDetails.base(SCOPE, event);
        AuditDetails.withActor(d, actorUserId, actorEmail);
        AuditDetails.withTarget(d, targetUserId, targetEmail);
        return d;
    }

    private void record(
            SecurityAuditActionType actionType,
            AuditOutcome outcome,
            Long targetUserId,
            String targetEmail,
            Map<String, Object> details
    ) {
        /* Grava evento append-only no public schema via SecurityAuditService. */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        Long actorUserId = requestIdentity.getCurrentUserId();
        String actorEmail = requestIdentity.getCurrentEmail();

        String detailsJson = toJson(details);

        securityAuditService.record(
                actionType,
                outcome,
                actorEmail,
                actorUserId,
                targetEmail,
                targetUserId,
                accountId,
                tenantSchema,
                detailsJson
        );
    }

    private String toJson(Object details) {
        /* Converte details (Map/record/String) em JSON string compatível com jsonb. */
        if (details == null) return null;
        return jsonDetailsMapper.toJsonNode(details).toString();
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/command/TenantUserCommandService.java
============================================================
package brito.com.multitenancy001.tenant.users.app.command;

import brito.com.multitenancy001.infrastructure.publicschema.audit.PublicAuditDispatcher;
import brito.com.multitenancy001.infrastructure.publicschema.audit.SecurityAuditService;
import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.tenant.TenantSchemaUnitOfWork;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.domain.audit.AuditOutcome;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.json.JsonDetailsMapper;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.shared.time.AppClock;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.security.TenantRolePermissions;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import com.fasterxml.jackson.databind.JsonNode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

/**
 * Casos de uso de comando para usuários do Tenant.
 *
 * Objetivos:
 * - Criar usuário com role e permissões finais (base + requested).
 * - Suspender/restaurar por admin ou por conta.
 * - Atualizar perfil.
 * - Fluxos de senha (reset admin, reset token, change self).
 * - Soft delete / restore / hard delete.
 * - Transferência de ownership (SOC2-like).
 *
 * Auditoria SOC2-like:
 * - ATTEMPT + SUCCESS/FAIL/DENIED (append-only em public schema).
 * - Details estruturado (Map -> JSON) e sem segredos.
 * - tenantSchema propagado para o evento quando disponível.
 *
 * Regras:
 * - Não permitir mutações em BUILT_IN.
 * - Não permitir remover/suspender/excluir o último TENANT_OWNER ativo.
 *
 * Regra arquitetural (multi-tenant):
 * - Este service NÃO usa TxExecutor diretamente.
 * - Toda execução de tenant deve ocorrer via TenantSchemaUnitOfWork (schema + tx em um único contrato).
 *
 * Regra crítica (multi-tx managers):
 * - NUNCA gravar auditoria PUBLIC iniciando uma transação dentro de uma transação TENANT no mesmo thread.
 * - Para evitar: "Pre-bound JDBC Connection found! ...", a gravação PUBLIC é feita via {@link PublicAuditDispatcher},
 *   que grava imediatamente quando não há tx ativa, ou agenda afterCompletion quando há tx ativa.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class TenantUserCommandService {

    private static final String SCOPE = "TENANT";

    private final TenantUserRepository tenantUserRepository;
    private final PasswordEncoder passwordEncoder;
    private final AppClock appClock;

    /** Dispatcher que evita nesting ilegal TENANT->PUBLIC. */
    private final PublicAuditDispatcher publicAuditDispatcher;

    /**
     * Unit of Work que garante:
     * - bind do tenantSchema (TenantExecutor)
     * - transação tenant (TxExecutor)
     */
    private final TenantSchemaUnitOfWork tenantSchemaUnitOfWork;

    /** Mantido por compat (ainda usado para resolver actor). */
    private final SecurityUtils securityUtils;

    /** Auditoria append-only (public schema). */
    private final SecurityAuditService securityAuditService;

    /** Mapper para details (Map/record/String -> JsonNode). */
    private final JsonDetailsMapper jsonDetailsMapper;

    // =========================================================
    // CREATE
    // =========================================================

    public TenantUser createTenantUser(
            Long accountId,
            String tenantSchema,
            String name,
            String email,
            String rawPassword,
            TenantRole role,
            String phone,
            String avatarUrl,
            String locale,
            String timezone,
            LinkedHashSet<TenantPermission> requestedPermissions,
            Boolean mustChangePassword,
            EntityOrigin origin
    ) {
        /* Cria um usuário de tenant, aplicando permissões base + requested (validadas). */
        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {

            if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
            if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);

            if (!StringUtils.hasText(name)) throw new ApiException(ApiErrorCode.INVALID_NAME, "Nome é obrigatório", 400);
            if (!StringUtils.hasText(email)) throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email é obrigatório", 400);
            if (!StringUtils.hasText(rawPassword)) throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Senha é obrigatória", 400);
            if (role == null) throw new ApiException(ApiErrorCode.INVALID_ROLE, "Role é obrigatória", 400);

            String normEmail = EmailNormalizer.normalizeOrNull(email);
            if (!StringUtils.hasText(normEmail) || !normEmail.matches(ValidationPatterns.EMAIL_PATTERN)) {
                throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email inválido", 400);
            }
            if (!rawPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
                throw new ApiException(ApiErrorCode.WEAK_PASSWORD, "Senha fraca", 400);
            }

            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            final int requestedCount = (requestedPermissions == null) ? 0 : requestedPermissions.size();

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "stage", "before_save",
                    "role", role.name(),
                    "requestedPermissionsCount", requestedCount
            );

            TenantUser saved = auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_CREATED,
                    actor,
                    normEmail,
                    null,
                    accountId,
                    tenantSchema,
                    attempt,
                    null,
                    () -> {
                        boolean exists = tenantUserRepository.existsByEmailAndAccountId(normEmail, accountId);
                        if (exists) throw new ApiException(ApiErrorCode.EMAIL_ALREADY_EXISTS, "Email já cadastrado nesta conta", 409);

                        TenantUser user = new TenantUser();
                        user.setAccountId(accountId);

                        user.rename(name);
                        user.changeEmail(normEmail);

                        user.setPassword(passwordEncoder.encode(rawPassword));
                        user.setRole(role);

                        user.setOrigin(origin == null ? EntityOrigin.ADMIN : origin);

                        user.setMustChangePassword(Boolean.TRUE.equals(mustChangePassword));

                        Instant now = appClock.instant();
                        user.setPasswordChangedAt(user.isMustChangePassword() ? null : now);

                        user.setPhone(StringUtils.hasText(phone) ? phone.trim() : null);
                        user.setAvatarUrl(StringUtils.hasText(avatarUrl) ? avatarUrl.trim() : null);

                        user.setLocale(StringUtils.hasText(locale) ? locale.trim() : null);
                        user.setTimezone(StringUtils.hasText(timezone) ? timezone.trim() : null);

                        user.setSuspendedByAccount(false);
                        user.setSuspendedByAdmin(false);

                        Set<TenantPermission> base = new LinkedHashSet<>(TenantRolePermissions.permissionsFor(role));
                        Set<TenantPermission> desired = new LinkedHashSet<>();
                        if (requestedPermissions != null && !requestedPermissions.isEmpty()) desired.addAll(requestedPermissions);

                        desired = PermissionScopeValidator.validateTenantPermissionsStrict(desired);

                        Set<TenantPermission> finalPerms = new LinkedHashSet<>(base);
                        finalPerms.addAll(desired);

                        user.setPermissions(finalPerms);

                        if (!StringUtils.hasText(user.getLocale())) user.setLocale("pt_BR");
                        if (!StringUtils.hasText(user.getTimezone())) user.setTimezone("America/Sao_Paulo");

                        return tenantUserRepository.save(user);
                    }
            );

            // SUCCESS do create com info final (sem segredos)
            recordAudit(
                    SecurityAuditActionType.USER_CREATED,
                    AuditOutcome.SUCCESS,
                    actor,
                    saved.getEmail(),
                    saved.getId(),
                    accountId,
                    tenantSchema,
                    m(
                            "scope", SCOPE,
                            "stage", "after_save",
                            "role", role.name()
                    )
            );

            // Permissions changed (create): base + requested -> final
            Set<TenantPermission> base = new LinkedHashSet<>(TenantRolePermissions.permissionsFor(role));
            Set<TenantPermission> desired = new LinkedHashSet<>();
            if (requestedPermissions != null && !requestedPermissions.isEmpty()) desired.addAll(requestedPermissions);
            desired = PermissionScopeValidator.validateTenantPermissionsStrict(desired);

            Set<TenantPermission> finalPerms = new LinkedHashSet<>(base);
            finalPerms.addAll(desired);

            recordAudit(
                    SecurityAuditActionType.PERMISSIONS_CHANGED,
                    AuditOutcome.SUCCESS,
                    actor,
                    saved.getEmail(),
                    saved.getId(),
                    accountId,
                    tenantSchema,
                    m(
                            "scope", SCOPE,
                            "reason", "create",
                            "baseCount", base.size(),
                            "requestedCount", requestedCount,
                            "finalCount", finalPerms.size()
                    )
            );

            return saved;
        });
    }

    // =========================================================
    // UPDATE: STATUS / PROFILE
    // =========================================================

    public void setSuspendedByAdmin(Long accountId, String tenantSchema, Long userId, boolean suspended) {
        /* Suspende/reativa por administrador (flag suspendedByAdmin). */
        setSuspension(accountId, tenantSchema, userId, suspended, true);
    }

    public void setSuspendedByAccount(Long accountId, String tenantSchema, Long userId, boolean suspended) {
        /* Suspende/reativa por conta (flag suspendedByAccount). */
        setSuspension(accountId, tenantSchema, userId, suspended, false);
    }

    private void setSuspension(Long accountId, String tenantSchema, Long userId, boolean suspended, boolean byAdmin) {
        /* Aplica suspensão com guardrails (owner) e auditoria ATTEMPT+SUCCESS/FAIL. */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

        tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            requireNotBuiltInForMutation(user, "Não é permitido suspender usuário BUILT_IN");

            if (suspended && isActiveOwner(user)) {
                requireWillStillHaveAtLeastOneActiveOwner(accountId, user.getId(),
                        "Não é permitido suspender o último TENANT_OWNER ativo");
            }

            SecurityAuditActionType action = suspended ? SecurityAuditActionType.USER_SUSPENDED : SecurityAuditActionType.USER_RESTORED;

            String reason = byAdmin ? "suspendedByAdmin" : "suspendedByAccount";

            Map<String, Object> details = m(
                    "scope", SCOPE,
                    "reason", reason,
                    "suspended", suspended
            );

            auditAttemptSuccessFail(
                    action,
                    actor,
                    user.getEmail(),
                    user.getId(),
                    accountId,
                    tenantSchema,
                    details,
                    details,
                    () -> {
                        int updated = byAdmin
                                ? tenantUserRepository.setSuspendedByAdmin(accountId, userId, suspended)
                                : tenantUserRepository.setSuspendedByAccount(accountId, userId, suspended);

                        if (updated == 0) throw new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404);
                        return null;
                    }
            );

            return null;
        });
    }

    public TenantUser updateProfile(
            Long userId,
            Long accountId,
            String tenantSchema,
            String name,
            String phone,
            String avatarUrl,
            String locale,
            String timezone,
            Instant now // mantido por compat
    ) {
        /* Atualiza perfil do usuário (sem alterar role/perms). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            requireNotBuiltInForMutation(user, "Não é permitido alterar perfil de usuário BUILT_IN");

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "reason", "updateProfile"
            );

            return auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_UPDATED,
                    actor,
                    user.getEmail(),
                    user.getId(),
                    accountId,
                    tenantSchema,
                    attempt,
                    null,
                    () -> {
                        boolean changed = false;
                        Map<String, Object> changes = new LinkedHashMap<>();

                        if (StringUtils.hasText(name)) {
                            user.rename(name);
                            changed = true;
                            changes.put("name", "changed");
                        }
                        if (StringUtils.hasText(phone)) {
                            user.setPhone(phone.trim());
                            changed = true;
                            changes.put("phone", "changed");
                        }
                        if (StringUtils.hasText(locale)) {
                            user.setLocale(locale.trim());
                            changed = true;
                            changes.put("locale", "changed");
                        }
                        if (StringUtils.hasText(timezone)) {
                            user.setTimezone(timezone.trim());
                            changed = true;
                            changes.put("timezone", "changed");
                        }

                        if (avatarUrl != null) {
                            String trimmed = avatarUrl.trim();
                            user.setAvatarUrl(trimmed.isEmpty() ? null : trimmed);
                            changed = true;
                            changes.put("avatarUrl", trimmed.isEmpty() ? "cleared" : "changed");
                        }

                        TenantUser saved = tenantUserRepository.save(user);

                        recordAudit(
                                SecurityAuditActionType.USER_UPDATED,
                                AuditOutcome.SUCCESS,
                                actor,
                                saved.getEmail(),
                                saved.getId(),
                                accountId,
                                tenantSchema,
                                m(
                                        "scope", SCOPE,
                                        "reason", "updateProfile",
                                        "changed", changed,
                                        "changes", changes
                                )
                        );

                        return saved;
                    }
            );
        });
    }

    // =========================================================
    // PASSWORD
    // =========================================================

    public TenantUser resetPassword(Long userId, Long accountId, String tenantSchema, String newPassword) {
        /* Reset administrativo (sem senha atual), sem auditoria de secrets. */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Senha é obrigatória", 400);

        if (!newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException(ApiErrorCode.WEAK_PASSWORD, "Senha fraca", 400);
        }

        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            Map<String, Object> details = m(
                    "scope", SCOPE,
                    "reason", "admin_reset"
            );

            return auditAttemptSuccessFail(
                    SecurityAuditActionType.PASSWORD_RESET_COMPLETED,
                    actor,
                    user.getEmail(),
                    user.getId(),
                    accountId,
                    tenantSchema,
                    details,
                    details,
                    () -> {
                        Instant now = appClock.instant();

                        user.setPassword(passwordEncoder.encode(newPassword));
                        user.setMustChangePassword(false);
                        user.setPasswordChangedAt(now);
                        user.setPasswordResetToken(null);
                        user.setPasswordResetExpires(null);

                        return tenantUserRepository.save(user);
                    }
            );
        });
    }

    public void resetPasswordWithToken(Long accountId, String tenantSchema, String email, String token, String newPassword) {
        /* Reset via token (self). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (!StringUtils.hasText(token)) throw new ApiException(ApiErrorCode.TOKEN_REQUIRED, "token é obrigatório", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Senha é obrigatória", 400);

        if (!newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) {
            throw new ApiException(ApiErrorCode.WEAK_PASSWORD, "Senha fraca", 400);
        }

        tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            TenantUser user = tenantUserRepository.findByPasswordResetTokenAndAccountId(token, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.TOKEN_INVALID, "Token inválido", 400));

            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            Map<String, Object> attempt = m(
                    "scope", SCOPE,
                    "flow", "token_reset"
            );

            auditAttemptSuccessFail(
                    SecurityAuditActionType.PASSWORD_RESET_COMPLETED,
                    actor,
                    user.getEmail(),
                    user.getId(),
                    accountId,
                    tenantSchema,
                    attempt,
                    attempt,
                    () -> {
                        Instant now = appClock.instant();

                        if (user.getPasswordResetExpires() == null || user.getPasswordResetExpires().isBefore(now)) {
                            throw new ApiException(ApiErrorCode.TOKEN_EXPIRED, "Token expirado", 400);
                        }

                        if (StringUtils.hasText(email) && user.getEmail() != null) {
                            String tokenLogin = EmailNormalizer.normalizeOrNull(email);
                            String userEmail = EmailNormalizer.normalizeOrNull(user.getEmail());

                            if (!StringUtils.hasText(tokenLogin) || !StringUtils.hasText(userEmail) || !userEmail.equals(tokenLogin)) {
                                throw new ApiException(ApiErrorCode.TOKEN_INVALID, "Token inválido", 400);
                            }
                        }

                        user.setPassword(passwordEncoder.encode(newPassword));
                        user.setMustChangePassword(false);
                        user.setPasswordChangedAt(now);

                        user.setPasswordResetToken(null);
                        user.setPasswordResetExpires(null);

                        tenantUserRepository.save(user);
                        return null;
                    }
            );

            return null;
        });
    }

    public void changeMyPassword(Long userId, Long accountId, String tenantSchema, String currentPassword, String newPassword, String confirmNewPassword) {
        /* Troca autenticada (self). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

        if (!StringUtils.hasText(currentPassword)) throw new ApiException(ApiErrorCode.CURRENT_PASSWORD_REQUIRED, "Senha atual é obrigatória", 400);
        if (!StringUtils.hasText(newPassword)) throw new ApiException(ApiErrorCode.NEW_PASSWORD_REQUIRED, "Nova senha é obrigatória", 400);
        if (!StringUtils.hasText(confirmNewPassword)) throw new ApiException(ApiErrorCode.CONFIRM_PASSWORD_REQUIRED, "Confirmar nova senha é obrigatório", 400);

        if (!newPassword.equals(confirmNewPassword)) throw new ApiException(ApiErrorCode.PASSWORD_MISMATCH, "Nova senha e confirmação não conferem", 400);
        if (!newPassword.matches(ValidationPatterns.PASSWORD_PATTERN)) throw new ApiException(ApiErrorCode.WEAK_PASSWORD, "Senha fraca", 400);

        tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            TenantUser user = tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            Map<String, Object> details = m(
                    "scope", SCOPE,
                    "reason", "self_change"
            );

            auditAttemptSuccessFail(
                    SecurityAuditActionType.PASSWORD_CHANGED,
                    actor,
                    user.getEmail(),
                    user.getId(),
                    accountId,
                    tenantSchema,
                    details,
                    details,
                    () -> {
                        if (!passwordEncoder.matches(currentPassword, user.getPassword())) {
                            throw new ApiException(ApiErrorCode.CURRENT_PASSWORD_INVALID, "Senha atual inválida", 400);
                        }

                        Instant now = appClock.instant();

                        user.setPassword(passwordEncoder.encode(newPassword));
                        user.setMustChangePassword(false);
                        user.setPasswordChangedAt(now);

                        user.setPasswordResetToken(null);
                        user.setPasswordResetExpires(null);

                        tenantUserRepository.save(user);
                        return null;
                    }
            );

            return null;
        });
    }

    // =========================================================
    // DELETE / RESTORE
    // =========================================================

    public void softDelete(Long userId, Long accountId, String tenantSchema) {
        /* Soft delete (não suspender; deletar logicamente). */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

        tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            if (user.isDeleted()) return null;

            requireNotBuiltInForMutation(user, "Não é permitido excluir usuário BUILT_IN");

            if (isActiveOwner(user)) {
                requireWillStillHaveAtLeastOneActiveOwner(accountId, user.getId(),
                        "Não é permitido excluir o último TENANT_OWNER ativo");
            }

            Map<String, Object> details = m(
                    "scope", SCOPE,
                    "reason", "softDelete"
            );

            auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_SOFT_DELETED,
                    actor,
                    user.getEmail(),
                    user.getId(),
                    accountId,
                    tenantSchema,
                    details,
                    details,
                    () -> {
                        Instant now = appClock.instant();
                        user.softDelete(now, appClock.epochMillis());
                        tenantUserRepository.save(user);
                        return null;
                    }
            );

            return null;
        });
    }

    public TenantUser restore(Long userId, Long accountId, String tenantSchema) {
        /* Restore após soft delete. */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            Map<String, Object> details = m(
                    "scope", SCOPE,
                    "reason", "softRestore"
            );

            return auditAttemptSuccessFail(
                    SecurityAuditActionType.USER_SOFT_RESTORED,
                    actor,
                    user.getEmail(),
                    user.getId(),
                    accountId,
                    tenantSchema,
                    details,
                    details,
                    () -> {
                        user.restore();
                        return tenantUserRepository.save(user);
                    }
            );
        });
    }

    public void hardDelete(Long userId, Long accountId, String tenantSchema) {
        /* Hard delete (remoção física). Atenção: normalmente não é SOC2-friendly em produção. */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_ID_REQUIRED, "userId é obrigatório", 400);

        tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            TenantUser user = tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404));

            requireNotBuiltInForMutation(user, "Não é permitido hard-delete de usuário BUILT_IN");

            if (!user.isDeleted() && isActiveOwner(user)) {
                requireWillStillHaveAtLeastOneActiveOwner(accountId, user.getId(),
                        "Não é permitido excluir o último TENANT_OWNER ativo");
            }

            tenantUserRepository.delete(user);
            return null;
        });
    }

    public TenantUser save(String tenantSchema, TenantUser user) {
        /* Persiste usuário (guard mínimo). */
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (user == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "Usuário inválido", 400);
        return tenantSchemaUnitOfWork.tx(tenantSchema, () -> tenantUserRepository.save(user));
    }

    // =========================================================
    // ROLE TRANSFER (OWNER)
    // =========================================================

    public void transferTenantOwnerRole(Long accountId, String tenantSchema, Long fromUserId, Long toUserId) {
        /* Transfere ownership (TENANT_OWNER) para outro usuário habilitado. */
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_ID_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(tenantSchema)) throw new ApiException(ApiErrorCode.TENANT_CONTEXT_REQUIRED, "tenantSchema é obrigatório", 400);
        if (fromUserId == null) throw new ApiException(ApiErrorCode.FROM_USER_REQUIRED, "fromUserId é obrigatório", 400);
        if (toUserId == null) throw new ApiException(ApiErrorCode.TO_USER_REQUIRED, "toUserId é obrigatório", 400);
        if (fromUserId.equals(toUserId)) throw new ApiException(ApiErrorCode.INVALID_TRANSFER, "Não é possível transferir para si mesmo", 400);

        tenantSchemaUnitOfWork.tx(tenantSchema, () -> {
            Actor actor = resolveActorOrNull(accountId, tenantSchema);

            TenantUser from = tenantUserRepository.findEnabledByIdAndAccountId(fromUserId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário origem não encontrado/habilitado", 404));
            requireNotBuiltInForMutation(from, "Não é permitido transferir ownership a partir de usuário BUILT_IN");

            if (from.getRole() == null || !from.getRole().isTenantOwner()) {
                throw new ApiException(ApiErrorCode.FORBIDDEN, "Apenas o TENANT_OWNER pode transferir", 403);
            }

            TenantUser to = tenantUserRepository.findEnabledByIdAndAccountId(toUserId, accountId)
                    .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário destino não encontrado/habilitado", 404));
            requireNotBuiltInForMutation(to, "Não é permitido transferir ownership para usuário BUILT_IN");

            TenantRole beforeFrom = from.getRole();
            TenantRole beforeTo = to.getRole();

            // SOC2-like: evento agregado de transferência (alto nível)
            recordAudit(
                    SecurityAuditActionType.OWNERSHIP_TRANSFERRED,
                    AuditOutcome.ATTEMPT,
                    actor,
                    null,
                    null,
                    accountId,
                    tenantSchema,
                    m(
                            "scope", SCOPE,
                            "fromUserId", from.getId(),
                            "fromEmail", from.getEmail(),
                            "toUserId", to.getId(),
                            "toEmail", to.getEmail()
                    )
            );

            // ATTEMPT de role/perms (por alvo) para trilha detalhada
            recordAudit(SecurityAuditActionType.ROLE_CHANGED, AuditOutcome.ATTEMPT, actor, from.getEmail(), from.getId(), accountId, tenantSchema,
                    m("scope", SCOPE, "kind", "transferOwner", "side", "from"));
            recordAudit(SecurityAuditActionType.ROLE_CHANGED, AuditOutcome.ATTEMPT, actor, to.getEmail(), to.getId(), accountId, tenantSchema,
                    m("scope", SCOPE, "kind", "transferOwner", "side", "to"));

            try {
                from.setRole(TenantRole.TENANT_ADMIN);
                to.setRole(TenantRole.TENANT_OWNER);

                from.setPermissions(new LinkedHashSet<>(TenantRolePermissions.permissionsFor(from.getRole())));
                to.setPermissions(new LinkedHashSet<>(TenantRolePermissions.permissionsFor(to.getRole())));

                tenantUserRepository.save(from);
                tenantUserRepository.save(to);

                recordAudit(SecurityAuditActionType.ROLE_CHANGED, AuditOutcome.SUCCESS, actor, from.getEmail(), from.getId(), accountId, tenantSchema,
                        m("scope", SCOPE, "kind", "transferOwner", "side", "from", "from", nameOrNull(beforeFrom), "to", nameOrNull(from.getRole())));
                recordAudit(SecurityAuditActionType.ROLE_CHANGED, AuditOutcome.SUCCESS, actor, to.getEmail(), to.getId(), accountId, tenantSchema,
                        m("scope", SCOPE, "kind", "transferOwner", "side", "to", "from", nameOrNull(beforeTo), "to", nameOrNull(to.getRole())));

                recordAudit(SecurityAuditActionType.PERMISSIONS_CHANGED, AuditOutcome.SUCCESS, actor, from.getEmail(), from.getId(), accountId, tenantSchema,
                        m("scope", SCOPE, "reason", "transferOwner", "side", "from", "finalCount", sizeOrZero(from.getPermissions())));
                recordAudit(SecurityAuditActionType.PERMISSIONS_CHANGED, AuditOutcome.SUCCESS, actor, to.getEmail(), to.getId(), accountId, tenantSchema,
                        m("scope", SCOPE, "reason", "transferOwner", "side", "to", "finalCount", sizeOrZero(to.getPermissions())));

                recordAudit(
                        SecurityAuditActionType.OWNERSHIP_TRANSFERRED,
                        AuditOutcome.SUCCESS,
                        actor,
                        null,
                        null,
                        accountId,
                        tenantSchema,
                        m(
                                "scope", SCOPE,
                                "fromUserId", from.getId(),
                                "fromEmail", from.getEmail(),
                                "toUserId", to.getId(),
                                "toEmail", to.getEmail()
                        )
                );

                return null;
            } catch (ApiException ex) {
                recordAudit(SecurityAuditActionType.OWNERSHIP_TRANSFERRED, outcomeFrom(ex), actor, null, null, accountId, tenantSchema, failureDetails(SCOPE, ex));
                throw ex;
            } catch (Exception ex) {
                recordAudit(SecurityAuditActionType.OWNERSHIP_TRANSFERRED, AuditOutcome.FAILURE, actor, null, null, accountId, tenantSchema, unexpectedFailureDetails(SCOPE, ex));
                throw ex;
            }
        });
    }

    // =========================================================
    // HELPERS / GUARDS
    // =========================================================

    private void requireNotBuiltInForMutation(TenantUser user, String message) {
        /* Impede mutações em BUILT_IN. */
        if (user != null && user.getOrigin() == EntityOrigin.BUILT_IN) {
            throw new ApiException(ApiErrorCode.USER_BUILT_IN_IMMUTABLE, message, 409);
        }
    }

    private boolean isActiveOwner(TenantUser user) {
        /* Define se o usuário conta como OWNER ativo (para guard de último owner). */
        if (user == null) return false;
        if (user.isDeleted()) return false;
        if (user.isSuspendedByAccount()) return false;
        if (user.isSuspendedByAdmin()) return false;
        return user.getRole() != null && user.getRole().isTenantOwner();
    }

    private void requireWillStillHaveAtLeastOneActiveOwner(Long accountId, Long removingUserId, String message) {
        /* Garante que não vai sobrar 0 owners ativos. */
        long owners = tenantUserRepository.countActiveOwnersByAccountId(accountId, TenantRole.TENANT_OWNER);
        if (owners <= 1) throw new ApiException(ApiErrorCode.TENANT_OWNER_REQUIRED, message, 409);
    }

    private static int sizeOrZero(Set<?> s) {
        /* Helper para size null-safe. */
        return s == null ? 0 : s.size();
    }

    private static String nameOrNull(Enum<?> e) {
        /* Helper para enum name null-safe. */
        return e == null ? null : e.name();
    }

    // =========================================================
    // Audit helpers (não vaza senha/token)
    // =========================================================

    @FunctionalInterface
    private interface AuditCallable<T> {
        T call();
    }

    private <T> T auditAttemptSuccessFail(
            SecurityAuditActionType actionType,
            Actor actor,
            String targetEmail,
            Long targetUserId,
            Long accountId,
            String tenantSchema,
            Map<String, Object> attemptDetails,
            Map<String, Object> successDetails,
            AuditCallable<T> block
    ) {
        /* Padroniza trilha ATTEMPT + SUCCESS/FAIL/DENIED. */
        recordAudit(actionType, AuditOutcome.ATTEMPT, actor, targetEmail, targetUserId, accountId, tenantSchema, attemptDetails);

        try {
            T result = block.call();

            Map<String, Object> sd = (successDetails != null ? successDetails : attemptDetails);
            recordAudit(actionType, AuditOutcome.SUCCESS, actor, targetEmail, targetUserId, accountId, tenantSchema, sd);

            return result;
        } catch (ApiException ex) {
            recordAudit(actionType, outcomeFrom(ex), actor, targetEmail, targetUserId, accountId, tenantSchema, failureDetails(SCOPE, ex));
            throw ex;
        } catch (Exception ex) {
            recordAudit(actionType, AuditOutcome.FAILURE, actor, targetEmail, targetUserId, accountId, tenantSchema, unexpectedFailureDetails(SCOPE, ex));
            throw ex;
        }
    }

    private void recordAudit(
            SecurityAuditActionType actionType,
            AuditOutcome outcome,
            Actor actor,
            String targetEmail,
            Long targetUserId,
            Long accountId,
            String tenantSchema,
            Object details
    ) {
        /**
         * Grava evento com details estruturado.
         *
         * IMPORTANTE:
         * Esta chamada NÃO pode iniciar transação PUBLIC dentro de tx TENANT no mesmo thread.
         * Por isso, a gravação é feita via PublicAuditDispatcher:
         * - Se não há tx ativa: grava imediatamente em PUBLIC (REQUIRES_NEW).
         * - Se há tx ativa (TENANT): agenda afterCompletion e grava depois que a tx encerrar.
         */
        final String detailsJson = toJson(details);
        publicAuditDispatcher.dispatch(() -> {
            try {
                securityAuditService.record(
                        actionType,
                        outcome,
                        actor == null ? null : actor.email(),
                        actor == null ? null : actor.userId(),
                        targetEmail,
                        targetUserId,
                        accountId,
                        tenantSchema,
                        detailsJson
                );
            } catch (Exception e) {
                // best-effort: auditoria não derruba o caso de uso
                log.warn("⚠️ Falha ao gravar SecurityAudit (best-effort) | actionType={} outcome={} accountId={} tenantSchema={} msg={}",
                        actionType, outcome, accountId, tenantSchema, e.getMessage(), e);
            }
        });
    }

    private String toJson(Object details) {
        /* Serializa details para JSON string (compatível com detailsJson do evento). */
        if (details == null) return null;

        JsonNode node = jsonDetailsMapper.toJsonNode(details);
        if (node == null || node.isNull()) return null;

        return node.toString();
    }

    private Actor resolveActorOrNull(Long accountId, String tenantSchema) {
        /* Resolve actor do request (best-effort) sem depender de controller. */
        try {
            Long actorUserId = securityUtils.getCurrentUserId();
            Long actorAccountId = securityUtils.getCurrentAccountId();

            if (actorUserId == null || actorAccountId == null) return Actor.anonymous();
            if (!actorAccountId.equals(accountId)) return new Actor(actorUserId, null);

            // Se não tiver tenantSchema, não tenta lookup (evita consulta no schema errado)
            if (!StringUtils.hasText(tenantSchema)) return new Actor(actorUserId, null);

            String actorEmail = tenantSchemaUnitOfWork.readOnly(tenantSchema, () ->
                    tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(actorUserId, accountId)
                            .map(TenantUser::getEmail)
                            .orElse(null)
            );

            return new Actor(actorUserId, actorEmail);
        } catch (Exception ignored) {
            return Actor.anonymous();
        }
    }

    private static AuditOutcome outcomeFrom(ApiException ex) {
        /* Mapeia ApiException para outcome DENIED vs FAILURE. */
        if (ex == null) return AuditOutcome.FAILURE;
        int s = ex.getStatus();
        return (s == 401 || s == 403) ? AuditOutcome.DENIED : AuditOutcome.FAILURE;
    }

    private static Map<String, Object> failureDetails(String scope, ApiException ex) {
        /* Details estruturado de erro (sem segredos). */
        return m(
                "scope", scope,
                "error", ex == null ? null : ex.getError(),
                "status", ex == null ? 0 : ex.getStatus(),
                "message", safeMessage(ex == null ? null : ex.getMessage())
        );
    }

    private static Map<String, Object> unexpectedFailureDetails(String scope, Exception ex) {
        /* Details estruturado para falhas inesperadas. */
        return m(
                "scope", scope,
                "unexpected", ex == null ? null : ex.getClass().getSimpleName(),
                "message", safeMessage(ex == null ? null : ex.getMessage())
        );
    }

    private static String safeMessage(String msg) {
        /* Sanitiza texto para não quebrar JSON e não vazar dados acidentais. */
        if (!StringUtils.hasText(msg)) return null;
        return msg
                .replace("\n", " ")
                .replace("\r", " ")
                .replace("\t", " ")
                .trim();
    }

    private static Map<String, Object> m(Object... kv) {
        /* Cria Map ordenado para JSON estável. */
        Map<String, Object> m = new LinkedHashMap<>();
        if (kv == null) return m;
        for (int i = 0; i + 1 < kv.length; i += 2) {
            Object k = kv[i];
            Object v = kv[i + 1];
            if (k != null) m.put(String.valueOf(k), v);
        }
        return m;
    }

    private record Actor(Long userId, String email) {
        static Actor anonymous() {
            /* Actor desconhecido (best-effort). */
            return new Actor(null, null);
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/context/TenantUserCurrentContextCommandService.java
============================================================
package brito.com.multitenancy001.tenant.users.app.context;

import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.integration.security.TenantRequestIdentityService;
import brito.com.multitenancy001.shared.account.UserLimitPolicy;
import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.shared.domain.audit.SecurityAuditActionType;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsGuard;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.users.api.dto.TenantUserCreateRequest;
import brito.com.multitenancy001.tenant.users.app.audit.TenantUserSecurityAuditRecorder;
import brito.com.multitenancy001.tenant.users.app.command.TenantUserCommandService;
import brito.com.multitenancy001.tenant.users.app.query.TenantUserQueryService;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.LinkedHashSet;
import java.util.Map;

/**
 * Application Service (Tenant): Users no "current context" (identidade do request).
 *
 * Regras:
 * - Resolve accountId/userId/tenantSchema da identidade do request.
 * - Aplica entitlements (limite de usuários) antes de criar.
 * - Auditoria SOC2-like: ATTEMPT + SUCCESS/DENIED/FAILURE (append-only em public schema).
 *
 * Nota arquitetural:
 * - Commands (writes) delegam para TenantUserCommandService, que executa via TenantSchemaUnitOfWork (schema + tx).
 * - Queries continuam usando TenantExecutor quando necessário (read no schema do tenant).
 */
@Service
@RequiredArgsConstructor
public class TenantUserCurrentContextCommandService {

    private final TenantUserCommandService tenantUserCommandService;
    private final TenantUserQueryService tenantUserQueryService;

    private final TenantExecutor tenantExecutor;
    private final TenantRequestIdentityService requestIdentity;
    private final AccountEntitlementsGuard accountEntitlementsGuard;

    private final TenantUserSecurityAuditRecorder securityAudit;

    public void transferTenantOwner(Long toUserId) {
        /* Transfere TENANT_OWNER do usuário autenticado (from) para outro usuário (to). */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();
        Long fromUserId = requestIdentity.getCurrentUserId();

        TenantUser target = tenantExecutor.runInTenantSchema(
                tenantSchema,
                () -> tenantUserQueryService.getUser(toUserId, accountId)
        );

        Map<String, Object> details = securityAudit.baseDetails("ownership_transfer", toUserId, target.getEmail());
        details.put("fromUserId", fromUserId);
        details.put("toUserId", toUserId);

        securityAudit.recordAttempt(SecurityAuditActionType.OWNERSHIP_TRANSFERRED, toUserId, target.getEmail(), details);

        try {
            // ✅ command já executa schema+tx via TenantSchemaUnitOfWork
            tenantUserCommandService.transferTenantOwnerRole(accountId, tenantSchema, fromUserId, toUserId);

            securityAudit.recordSuccess(SecurityAuditActionType.OWNERSHIP_TRANSFERRED, toUserId, target.getEmail(), details);

        } catch (ApiException ex) {
            if (ex.getStatus() == 401 || ex.getStatus() == 403) {
                securityAudit.recordDenied(SecurityAuditActionType.OWNERSHIP_TRANSFERRED, toUserId, target.getEmail(), details);
            } else {
                details.put("error", ex.getError());
                details.put("status", ex.getStatus());
                securityAudit.recordFailure(SecurityAuditActionType.OWNERSHIP_TRANSFERRED, toUserId, target.getEmail(), details);
            }
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            securityAudit.recordFailure(SecurityAuditActionType.OWNERSHIP_TRANSFERRED, toUserId, target.getEmail(), details);
            throw ex;
        }
    }

    public TenantUser createTenantUser(TenantUserCreateRequest req) {
        /* Cria usuário no tenant (respeita limite/entitlements) + audita USER_CREATED. */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        if (req == null) throw new ApiException(ApiErrorCode.INVALID_REQUEST, "Request inválido", 400);

        String name = (req.name() == null) ? null : req.name().trim();
        String email = (req.email() == null) ? null : req.email().trim().toLowerCase();

        String locale = (req.locale() == null) ? null : req.locale().trim();
        if (locale != null && locale.isBlank()) locale = null;

        String timezone = (req.timezone() == null) ? null : req.timezone().trim();
        if (timezone != null && timezone.isBlank()) timezone = null;

        LinkedHashSet<TenantPermission> perms =
                (req.permissions() == null || req.permissions().isEmpty())
                        ? null
                        : new LinkedHashSet<>(req.permissions());

        EntityOrigin origin = (req.origin() != null) ? req.origin() : EntityOrigin.ADMIN;
        if (origin == EntityOrigin.BUILT_IN) {
            throw new ApiException(ApiErrorCode.INVALID_ORIGIN, "Origin BUILT_IN não pode ser criado via API", 400);
        }

        Boolean mustChangePassword = (req.mustChangePassword() == null) ? Boolean.FALSE : req.mustChangePassword();

        long currentUsers = tenantExecutor.runInTenantSchema(tenantSchema, () ->
                tenantUserQueryService.countUsersForLimit(accountId, UserLimitPolicy.SEATS_IN_USE)
        );

        accountEntitlementsGuard.assertCanCreateUser(accountId, currentUsers);

        String finalLocale = locale;
        String finalTimezone = timezone;

        Map<String, Object> details = securityAudit.baseDetails("user_create", null, email);
        details.put("name", name);
        details.put("origin", origin.name());
        details.put("mustChangePassword", mustChangePassword);
        details.put("role", req.role() != null ? req.role().name() : null);
        details.put("permissionsCount", perms != null ? perms.size() : 0);

        securityAudit.recordAttempt(SecurityAuditActionType.USER_CREATED, null, email, details);

        try {
            // ✅ command já executa schema+tx via TenantSchemaUnitOfWork
            TenantUser created = tenantUserCommandService.createTenantUser(
                    accountId,
                    tenantSchema,
                    name,
                    email,
                    req.password(),
                    req.role(),
                    req.phone(),
                    req.avatarUrl(),
                    finalLocale,
                    finalTimezone,
                    perms,
                    mustChangePassword,
                    origin
            );

            details.put("createdUserId", created.getId());
            securityAudit.recordSuccess(SecurityAuditActionType.USER_CREATED, created.getId(), created.getEmail(), details);
            return created;

        } catch (ApiException ex) {
            if (ex.getStatus() == 401 || ex.getStatus() == 403) {
                securityAudit.recordDenied(SecurityAuditActionType.USER_CREATED, null, email, details);
            } else {
                details.put("error", ex.getError());
                details.put("status", ex.getStatus());
                securityAudit.recordFailure(SecurityAuditActionType.USER_CREATED, null, email, details);
            }
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            securityAudit.recordFailure(SecurityAuditActionType.USER_CREATED, null, email, details);
            throw ex;
        }
    }

    public TenantUser setTenantUserSuspendedByAdmin(Long userId, boolean suspended) {
        /* Suspende/reativa usuário por admin (flag suspendedByAdmin) + audita USER_SUSPENDED/USER_RESTORED. */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        TenantUser target = tenantExecutor.runInTenantSchema(
                tenantSchema,
                () -> tenantUserQueryService.getUser(userId, accountId)
        );

        SecurityAuditActionType type = suspended ? SecurityAuditActionType.USER_SUSPENDED : SecurityAuditActionType.USER_RESTORED;

        Map<String, Object> details = securityAudit.baseDetails("user_suspend_by_admin", userId, target.getEmail());
        details.put("suspended", suspended);
        details.put("mode", "by_admin");

        securityAudit.recordAttempt(type, userId, target.getEmail(), details);

        try {
            // ✅ command já executa schema+tx
            tenantUserCommandService.setSuspendedByAdmin(accountId, tenantSchema, userId, suspended);

            TenantUser result = tenantExecutor.runInTenantSchema(
                    tenantSchema,
                    () -> tenantUserQueryService.getUser(userId, accountId)
            );

            securityAudit.recordSuccess(type, userId, target.getEmail(), details);
            return result;

        } catch (ApiException ex) {
            if (ex.getStatus() == 401 || ex.getStatus() == 403) {
                securityAudit.recordDenied(type, userId, target.getEmail(), details);
            } else {
                details.put("error", ex.getError());
                details.put("status", ex.getStatus());
                securityAudit.recordFailure(type, userId, target.getEmail(), details);
            }
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            securityAudit.recordFailure(type, userId, target.getEmail(), details);
            throw ex;
        }
    }

    public TenantUser setTenantUserSuspendedByAccount(Long userId, boolean suspended) {
        /* Suspende/reativa usuário por conta (flag suspendedByAccount) + audita USER_SUSPENDED/USER_RESTORED. */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        TenantUser target = tenantExecutor.runInTenantSchema(
                tenantSchema,
                () -> tenantUserQueryService.getUser(userId, accountId)
        );

        SecurityAuditActionType type = suspended ? SecurityAuditActionType.USER_SUSPENDED : SecurityAuditActionType.USER_RESTORED;

        Map<String, Object> details = securityAudit.baseDetails("user_suspend_by_account", userId, target.getEmail());
        details.put("suspended", suspended);
        details.put("mode", "by_account");

        securityAudit.recordAttempt(type, userId, target.getEmail(), details);

        try {
            // ✅ command já executa schema+tx
            tenantUserCommandService.setSuspendedByAccount(accountId, tenantSchema, userId, suspended);

            TenantUser result = tenantExecutor.runInTenantSchema(
                    tenantSchema,
                    () -> tenantUserQueryService.getUser(userId, accountId)
            );

            securityAudit.recordSuccess(type, userId, target.getEmail(), details);
            return result;

        } catch (ApiException ex) {
            if (ex.getStatus() == 401 || ex.getStatus() == 403) {
                securityAudit.recordDenied(type, userId, target.getEmail(), details);
            } else {
                details.put("error", ex.getError());
                details.put("status", ex.getStatus());
                securityAudit.recordFailure(type, userId, target.getEmail(), details);
            }
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            securityAudit.recordFailure(type, userId, target.getEmail(), details);
            throw ex;
        }
    }

    public void softDeleteTenantUser(Long userId) {
        /* Soft delete do usuário (deleção lógica) + audita USER_SOFT_DELETED. */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        TenantUser target = tenantExecutor.runInTenantSchema(
                tenantSchema,
                () -> tenantUserQueryService.getUser(userId, accountId)
        );

        Map<String, Object> details = securityAudit.baseDetails("user_soft_delete", userId, target.getEmail());
        securityAudit.recordAttempt(SecurityAuditActionType.USER_SOFT_DELETED, userId, target.getEmail(), details);

        try {
            // ✅ command já executa schema+tx
            tenantUserCommandService.softDelete(userId, accountId, tenantSchema);

            securityAudit.recordSuccess(SecurityAuditActionType.USER_SOFT_DELETED, userId, target.getEmail(), details);

        } catch (ApiException ex) {
            if (ex.getStatus() == 401 || ex.getStatus() == 403) {
                securityAudit.recordDenied(SecurityAuditActionType.USER_SOFT_DELETED, userId, target.getEmail(), details);
            } else {
                details.put("error", ex.getError());
                details.put("status", ex.getStatus());
                securityAudit.recordFailure(SecurityAuditActionType.USER_SOFT_DELETED, userId, target.getEmail(), details);
            }
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            securityAudit.recordFailure(SecurityAuditActionType.USER_SOFT_DELETED, userId, target.getEmail(), details);
            throw ex;
        }
    }

    public void hardDeleteTenantUser(Long userId) {
        /* Hard delete do usuário (deleção física). */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        // ✅ assinatura nova exige tenantSchema
        tenantUserCommandService.hardDelete(userId, accountId, tenantSchema);
    }

    public TenantUser restoreTenantUser(Long userId) {
        /* Restaura usuário após soft delete + audita USER_SOFT_RESTORED. */
        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        // ✅ IMPORTANTÍSSIMO: após soft delete, getUser(...) dá 404 (deleted=false).
        // Precisamos enxergar o usuário soft-deleted para restaurar.
        TenantUser target = tenantExecutor.runInTenantSchema(
                tenantSchema,
                () -> tenantUserQueryService.getUserIncludingDeleted(userId, accountId)
        );

        Map<String, Object> details = securityAudit.baseDetails("user_soft_restore", userId, target.getEmail());
        securityAudit.recordAttempt(SecurityAuditActionType.USER_SOFT_RESTORED, userId, target.getEmail(), details);

        try {
            // ✅ command já executa schema+tx
            TenantUser restored = tenantUserCommandService.restore(userId, accountId, tenantSchema);

            securityAudit.recordSuccess(SecurityAuditActionType.USER_SOFT_RESTORED, userId, target.getEmail(), details);
            return restored;

        } catch (ApiException ex) {
            if (ex.getStatus() == 401 || ex.getStatus() == 403) {
                securityAudit.recordDenied(SecurityAuditActionType.USER_SOFT_RESTORED, userId, target.getEmail(), details);
            } else {
                details.put("error", ex.getError());
                details.put("status", ex.getStatus());
                securityAudit.recordFailure(SecurityAuditActionType.USER_SOFT_RESTORED, userId, target.getEmail(), details);
            }
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            securityAudit.recordFailure(SecurityAuditActionType.USER_SOFT_RESTORED, userId, target.getEmail(), details);
            throw ex;
        }
    }

    public TenantUser resetTenantUserPassword(Long userId, String newPassword) {
        /* Reset administrativo de senha (sem senha atual). */
        if (!StringUtils.hasText(newPassword)) throw new ApiException(ApiErrorCode.INVALID_PASSWORD, "Nova senha é obrigatória", 400);

        Long accountId = requestIdentity.getCurrentAccountId();
        String tenantSchema = requestIdentity.getCurrentTenantSchema();

        TenantUser target = tenantExecutor.runInTenantSchema(
                tenantSchema,
                () -> tenantUserQueryService.getUser(userId, accountId)
        );

        Map<String, Object> details = securityAudit.baseDetails("user_password_reset_admin", userId, target.getEmail());
        details.put("mode", "admin_reset");

        // IMPORTANTE: não logar senha.
        securityAudit.recordAttempt(SecurityAuditActionType.PASSWORD_RESET_COMPLETED, userId, target.getEmail(), details);

        try {
            // ✅ command já executa schema+tx
            TenantUser updated = tenantUserCommandService.resetPassword(userId, accountId, tenantSchema, newPassword);

            securityAudit.recordSuccess(SecurityAuditActionType.PASSWORD_RESET_COMPLETED, userId, target.getEmail(), details);
            return updated;

        } catch (ApiException ex) {
            if (ex.getStatus() == 401 || ex.getStatus() == 403) {
                securityAudit.recordDenied(SecurityAuditActionType.PASSWORD_RESET_COMPLETED, userId, target.getEmail(), details);
            } else {
                details.put("error", ex.getError());
                details.put("status", ex.getStatus());
                securityAudit.recordFailure(SecurityAuditActionType.PASSWORD_RESET_COMPLETED, userId, target.getEmail(), details);
            }
            throw ex;
        } catch (Exception ex) {
            details.put("exception", ex.getClass().getSimpleName());
            securityAudit.recordFailure(SecurityAuditActionType.PASSWORD_RESET_COMPLETED, userId, target.getEmail(), details);
            throw ex;
        }
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/context/TenantUserCurrentContextQueryService.java
============================================================
package brito.com.multitenancy001.tenant.users.app.context;

import brito.com.multitenancy001.infrastructure.security.SecurityUtils;
import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsService;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsSnapshot;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.app.query.TenantUserQueryService;
import brito.com.multitenancy001.tenant.users.app.query.TenantUsersListView;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantUserCurrentContextQueryService {

    private final TenantUserQueryService tenantUserQueryService;
    private final TenantExecutor tenantExecutor;
    private final SecurityUtils securityUtils;
    private final AccountEntitlementsService accountEntitlementsService;

    public TenantUsersListView listTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String tenantSchema = securityUtils.getCurrentTenantSchema();

        TenantRole currentRole = securityUtils.getCurrentTenantRole();
        boolean isOwner = currentRole != null && currentRole.isTenantOwner();

        AccountEntitlementsSnapshot entitlements = null;
        if (isOwner) {
            entitlements = accountEntitlementsService.resolveEffectiveByAccountId(accountId);
        }

        AccountEntitlementsSnapshot finalEntitlements = entitlements;

        return tenantExecutor.runInTenantSchema(tenantSchema, () -> {
            List<TenantUser> users = tenantUserQueryService.listUsers(accountId);
            return new TenantUsersListView(isOwner, finalEntitlements, users);
        });
    }

    public List<TenantUser> listEnabledTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String tenantSchema = securityUtils.getCurrentTenantSchema();

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                tenantUserQueryService.listEnabledUsers(accountId)
        );
    }

    public TenantUser getTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String tenantSchema = securityUtils.getCurrentTenantSchema();

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                tenantUserQueryService.getUser(userId, accountId)
        );
    }

    public TenantUser getEnabledTenantUser(Long userId) {
        Long accountId = securityUtils.getCurrentAccountId();
        String tenantSchema = securityUtils.getCurrentTenantSchema();

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                tenantUserQueryService.getEnabledUser(userId, accountId)
        );
    }

    public long countEnabledTenantUsers() {
        Long accountId = securityUtils.getCurrentAccountId();
        String tenantSchema = securityUtils.getCurrentTenantSchema();

        return tenantExecutor.runInTenantSchema(tenantSchema, () ->
                tenantUserQueryService.countEnabledUsersByAccount(accountId)
        );
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/query/TenantUserQueryService.java
============================================================
package brito.com.multitenancy001.tenant.users.app.query;

import brito.com.multitenancy001.shared.api.error.ApiErrorCode;
import brito.com.multitenancy001.infrastructure.persistence.TxExecutor;
import brito.com.multitenancy001.shared.account.UserLimitPolicy;
import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.kernel.error.ApiException;
import brito.com.multitenancy001.shared.validation.ValidationPatterns;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;
import brito.com.multitenancy001.tenant.users.persistence.TenantUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TenantUserQueryService {

    private final TenantUserRepository tenantUserRepository;
    private final TxExecutor transactionExecutor;

    // =========================================================
    // LIMITS / COUNTS
    // =========================================================

    public long countUsersForLimit(Long accountId, UserLimitPolicy policy) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() -> {
            if (policy == null) return tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);

            return switch (policy) {
                case SEATS_IN_USE -> tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);
                case SEATS_ENABLED -> tenantUserRepository.countEnabledUsersByAccount(accountId);
                default -> tenantUserRepository.countByAccountIdAndDeletedFalse(accountId);
            };
        });
    }

    public long countEnabledUsersByAccount(Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        return transactionExecutor.inTenantReadOnlyTx(() -> tenantUserRepository.countEnabledUsersByAccount(accountId));
    }

    public long countActiveOwnersByAccountId(Long accountId, TenantRole ownerRole) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        if (ownerRole == null) throw new ApiException(ApiErrorCode.ROLE_REQUIRED, "role é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.countActiveOwnersByAccountId(accountId, ownerRole)
        );
    }

    // =========================================================
    // READ / LIST
    // =========================================================

    /**
     * Busca usuário por ID no tenant, EXCLUINDO soft-deleted (deleted=false).
     */
    public TenantUser getUser(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_REQUIRED, "userId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findByIdAndAccountIdAndDeletedFalse(userId, accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404))
        );
    }

    /**
     * Busca usuário por ID no tenant, INCLUINDO soft-deleted (deleted=true).
     *
     * Motivação:
     * - Fluxos de RESTORE após soft delete precisam enxergar o usuário deletado.
     * - Evita 404 "prematuro" quando o service de contexto precisa auditar e restaurar.
     */
    public TenantUser getUserIncludingDeleted(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_REQUIRED, "userId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findIncludingDeletedByIdAndAccountId(userId, accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404))
        );
    }

    /**
     * Busca usuário habilitado por ID (regra do repository).
     */
    public TenantUser getEnabledUser(Long userId, Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        if (userId == null) throw new ApiException(ApiErrorCode.USER_REQUIRED, "userId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findEnabledByIdAndAccountId(userId, accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário habilitado não encontrado", 404))
        );
    }

    public TenantUser getUserByEmail(String email, Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);
        if (!StringUtils.hasText(email)) throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email é obrigatório", 400);

        String normEmail = EmailNormalizer.normalizeOrNull(email);
        if (!StringUtils.hasText(normEmail) || !normEmail.matches(ValidationPatterns.EMAIL_PATTERN)) {
            throw new ApiException(ApiErrorCode.INVALID_EMAIL, "Email inválido", 400);
        }

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findByEmailAndAccountIdAndDeletedFalse(normEmail, accountId)
                        .orElseThrow(() -> new ApiException(ApiErrorCode.USER_NOT_FOUND, "Usuário não encontrado", 404))
        );
    }

    public List<TenantUser> listUsers(Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findByAccountIdAndDeletedFalse(accountId)
        );
    }

    public List<TenantUser> listEnabledUsers(Long accountId) {
        if (accountId == null) throw new ApiException(ApiErrorCode.ACCOUNT_REQUIRED, "accountId é obrigatório", 400);

        return transactionExecutor.inTenantReadOnlyTx(() ->
                tenantUserRepository.findEnabledUsersByAccount(accountId)
        );
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/app/query/TenantUsersListView.java
============================================================
package brito.com.multitenancy001.tenant.users.app.query;

import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsSnapshot;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;

import java.util.List;

public record TenantUsersListView(
        boolean isOwner,
        AccountEntitlementsSnapshot entitlements,
        List<TenantUser> users
) {}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/domain/TenantUser.java
============================================================
// src/main/java/brito/com/multitenancy001/tenant/users/domain/TenantUser.java
package brito.com.multitenancy001.tenant.users.domain;

import brito.com.multitenancy001.shared.domain.EmailNormalizer;
import brito.com.multitenancy001.shared.domain.audit.AuditInfo;
import brito.com.multitenancy001.shared.domain.audit.Auditable;
import brito.com.multitenancy001.shared.domain.audit.SoftDeletable;
import brito.com.multitenancy001.shared.domain.audit.jpa.AuditEntityListener;
import brito.com.multitenancy001.shared.domain.common.EntityOrigin;
import brito.com.multitenancy001.shared.security.PermissionScopeValidator;
import brito.com.multitenancy001.tenant.security.TenantPermission;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.permission.TenantUserPermission;
import jakarta.persistence.*;
import lombok.*;

import java.time.Instant;
import java.util.LinkedHashSet;
import java.util.Set;

@Entity
@Table(name = "tenant_users")
@EntityListeners(AuditEntityListener.class)
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TenantUser implements Auditable, SoftDeletable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ==========
    // IDENTITY
    // ==========
    @Column(name = "account_id", nullable = false)
    private Long accountId;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, columnDefinition = "citext")
    private String email;

    // ==========
    // RBAC
    // ==========
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 50)
    private TenantRole role;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
            name = "tenant_user_permissions",
            joinColumns = @JoinColumn(name = "tenant_user_id")
    )
    @Column(name = "permission", nullable = false, length = 120)
    @Enumerated(EnumType.STRING)
    @Builder.Default
    private Set<TenantPermission> permissions = new LinkedHashSet<>();

    // ==========
    // PROFILE
    // ==========
    @Column(length = 20)
    private String phone;

    @Column(name = "avatar_url", length = 500)
    private String avatarUrl;

    @Column(length = 50)
    private String timezone;

    @Column(length = 10)
    private String locale;

    // ==========
    // AUTH
    // ==========
    @Column(nullable = false, length = 200)
    private String password;

    @Column(name = "must_change_password", nullable = false)
    @Builder.Default
    private boolean mustChangePassword = false;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    @Builder.Default
    private EntityOrigin origin = EntityOrigin.ADMIN;

    // ==========
    // SECURITY
    // ==========
    @Column(name = "last_login", columnDefinition = "TIMESTAMPTZ")
    private Instant lastLoginAt;

    @Column(name = "locked_until", columnDefinition = "TIMESTAMPTZ")
    private Instant lockedUntil;

    @Column(name = "password_changed_at", columnDefinition = "TIMESTAMPTZ")
    private Instant passwordChangedAt;

    @Column(name = "password_reset_token", length = 200)
    private String passwordResetToken;

    @Column(name = "password_reset_expires", columnDefinition = "TIMESTAMPTZ")
    private Instant passwordResetExpiresAt;

    // ==========
    // STATUS
    // ==========
    @Column(name = "suspended_by_account", nullable = false)
    @Builder.Default
    private boolean suspendedByAccount = false;

    @Column(name = "suspended_by_admin", nullable = false)
    @Builder.Default
    private boolean suspendedByAdmin = false;

    @Column(name = "deleted", nullable = false)
    @Builder.Default
    private boolean deleted = false;

    // ==========
    // AUDIT
    // ==========
    @Embedded
    @Builder.Default
    private AuditInfo audit = new AuditInfo();

    // ==========
    // DOMAIN HELPERS (DDD puro)
    // ==========

    public void normalizeEmail() {
        /* Normaliza email para login/identidade. */
        this.email = EmailNormalizer.normalizeOrNull(this.email);
    }

    /**
     * Enabled no sentido de domínio (sem considerar lock).
     */
    public boolean isEnabledDomain() {
        /* Enabled = não deletado e não suspenso. */
        return !deleted && !suspendedByAccount && !suspendedByAdmin;
    }

    /**
     * ✅ Regra de lock com "now" explícito (AppClock é a fonte única).
     */
    public boolean isAccountNonLockedAt(Instant now) {
        /* Avalia lock com base no instante informado (AppClock). */
        if (now == null) throw new IllegalArgumentException("now is required");
        return lockedUntil == null || !now.isBefore(lockedUntil);
    }

    /**
     * ✅ Helper de login (enabled + não locked) com "now" explícito.
     */
    public boolean isEnabledForLoginAt(Instant now) {
        /* Regra de login: enabled e não locked no instante informado. */
        return isEnabledDomain() && isAccountNonLockedAt(now);
    }

    public Set<TenantPermission> getPermissions() {
        /* Valida e devolve permissões tipadas no escopo TEN_. */
        if (permissions == null) return Set.of();
        return PermissionScopeValidator.validateTenantPermissionsStrict(permissions);
    }

    public void grantPermission(TenantPermission permission) {
        /* Concede permissão explícita ao usuário (fail-fast no escopo). */
        if (permission == null) return;
        if (this.permissions == null) this.permissions = new LinkedHashSet<>();

        Set<TenantPermission> tmp = new LinkedHashSet<>(this.permissions);
        tmp.add(permission);

        this.permissions = new LinkedHashSet<>(PermissionScopeValidator.validateTenantPermissionsStrict(tmp));
    }

    public void revokePermission(TenantPermission permission) {
        /* Revoga permissão explícita do usuário. */
        if (permission == null) return;
        if (this.permissions == null || this.permissions.isEmpty()) return;
        this.permissions.remove(permission);
    }

    /**
     * ✅ Mantido só para leitura/compat (ex.: DTO legado).
     */
    public Set<TenantUserPermission> getExplicitPermissions() {
        /* Exporta permissões explícitas como "TEN_*" (compat). */
        if (permissions == null || permissions.isEmpty()) return Set.of();
        LinkedHashSet<TenantUserPermission> out = new LinkedHashSet<>();
        for (TenantPermission p : permissions) {
            if (p == null) continue;
            out.add(new TenantUserPermission(p.asAuthority()));
        }
        return out;
    }

    // ==========
    // Password reset (compat com call-sites)
    // ==========

    public void setPasswordResetExpires(Instant expiresAt) {
        /* Define expiração do token de reset. */
        this.passwordResetExpiresAt = expiresAt;
    }

    public Instant getPasswordResetExpires() {
        /* Retorna expiração do token de reset. */
        return this.passwordResetExpiresAt;
    }

    // ==========
    // Soft delete (DDD + compat)
    // ==========

    public void softDelete() {
        /* Soft delete simples (flag). */
        this.deleted = true;
    }

    /**
     * ✅ Canonical no domínio: soft delete com "now" explícito.
     */
    public void softDeleteAt(Instant now) {
        /* Soft delete com marcação no audit (quando disponível). */
        if (this.deleted) return;
        if (now == null) throw new IllegalArgumentException("now is required");

        this.deleted = true;
        if (this.audit != null) this.audit.markDeleted(now);
    }

    public void restore() {
        /* Restaura (remove delete e limpa audit.deletedAt). */
        this.deleted = false;
        if (this.audit != null) this.audit.clearDeleted();
    }

    public void clearSecurityLockState() {
        /* Limpa lock. */
        this.lockedUntil = null;
    }

    // ==========
    // Optional: helpers de normalização
    // ==========

    public void rename(String newName) {
        /* Renomeia com validação mínima. */
        if (newName == null || newName.isBlank()) throw new IllegalArgumentException("name é obrigatório");
        this.name = newName.trim();
    }

    public void changeEmail(String newEmail) {
        /* Altera email com normalização/validação. */
        String normalized = EmailNormalizer.normalizeOrNull(newEmail);
        if (normalized == null) throw new IllegalArgumentException("email inválido");
        this.email = normalized;
    }

    // ==========
    // Contracts
    // ==========

    @Override
    public boolean isDeleted() {
        /* Soft delete flag. */
        return deleted;
    }

    @Override
    public AuditInfo getAudit() {
        /* Audit embutido. */
        return audit;
    }

    // ==========
    // COMPAT LAYER (para não quebrar call-sites existentes)
    // ==========
    // IMPORTANTE:
    // - NÃO usa Instant.now() aqui.
    // - Apenas delega para os métodos canônicos "*At(Instant now)".
    // - Mantém assinaturas que já existem no código (AuthenticatedUserContext, mappers, services).

    /**
     * COMPAT: assinatura antiga usada por AuthenticatedUserContext.
     */
    public boolean isEnabledForLogin(Instant now) {
        /* Compat para call-sites existentes (sem Instant.now). */
        return isEnabledForLoginAt(now);
    }

    /**
     * COMPAT: assinatura antiga usada por AuthenticatedUserContext.
     */
    public boolean isAccountNonLocked(Instant now) {
        /* Compat para call-sites existentes (sem Instant.now). */
        return isAccountNonLockedAt(now);
    }

    /**
     * COMPAT: assinatura antiga usada por TenantUserApiMapper e outros.
     * (Sem necessidade de clock)
     */
    public boolean isEnabled() {
        /* Compat: enabled de domínio (sem lock). */
        return isEnabledDomain();
    }

    /**
     * COMPAT: assinatura antiga usada por TenantUserCommandService.
     * Observação: epochMillis era redundante; mantemos só para compat e ignoramos.
     */
    public void softDelete(Instant now, long epochMillis) {
        /* Compat para call-sites existentes (ignora epochMillis). */
        softDeleteAt(now);
    }
}
============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/domain/permission/TenantUserPermission.java
============================================================
// src/main/java/brito/com/multitenancy001/tenant/users/domain/permission/TenantUserPermission.java
package brito.com.multitenancy001.tenant.users.domain.permission;

import brito.com.multitenancy001.tenant.security.TenantPermission;

import java.util.Locale;

public record TenantUserPermission(String code) {

    public TenantUserPermission {
        if (code == null || code.isBlank()) {
            throw new IllegalArgumentException("Permission code cannot be null/blank");
        }
        String normalized = code.trim().toUpperCase(Locale.ROOT);
        if (!normalized.startsWith("TEN_")) {
            throw new IllegalArgumentException("Tenant permission must start with TEN_: " + normalized);
        }
        code = normalized;
    }

    public static TenantUserPermission from(TenantPermission permission) {
        if (permission == null) {
            throw new IllegalArgumentException("Permission cannot be null");
        }
        return new TenantUserPermission(permission.asAuthority()); // name() -> asAuthority()
    }
}

============================================================
### FILE: src/main/java/brito/com/multitenancy001/tenant/users/persistence/TenantUserRepository.java
============================================================
package brito.com.multitenancy001.tenant.users.persistence;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import brito.com.multitenancy001.infrastructure.persistence.tx.TenantTx;
import brito.com.multitenancy001.tenant.security.TenantRole;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

@Repository
public interface TenantUserRepository extends JpaRepository<TenantUser, Long> {

    // =========================================================
    // LOGIN / IDENTIDADE (email)
    // =========================================================

    Optional<TenantUser> findByEmailAndDeletedFalse(String email);

    Optional<TenantUser> findByEmailAndAccountIdAndDeletedFalse(String email, Long accountId);

    boolean existsByEmailAndAccountId(String email, Long accountId);

    // =========================================================
    // PASSWORD RESET
    // =========================================================

    Optional<TenantUser> findByPasswordResetTokenAndAccountId(String passwordResetToken, Long accountId);

    // =========================================================
    // LISTS
    // =========================================================

    List<TenantUser> findByAccountId(Long accountId);

    List<TenantUser> findByAccountIdAndDeletedFalse(Long accountId);

    /**
     * Enabled = NOT deleted + NOT suspendedByAccount + NOT suspendedByAdmin
     */
    List<TenantUser> findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(Long accountId);

    /**
     * Alias legível (evita nome gigante espalhado no projeto).
     */
    default List<TenantUser> findEnabledUsersByAccount(Long accountId) {
        return findByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId);
    }

    // =========================================================
    // COUNTS / LIMITS
    // =========================================================

    long countByAccountIdAndDeletedFalse(Long accountId);

    long countByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(Long accountId);

    default long countEnabledUsersByAccount(Long accountId) {
        return countByAccountIdAndDeletedFalseAndSuspendedByAccountFalseAndSuspendedByAdminFalse(accountId);
    }

    // =========================================================
    // OWNER COUNTS / INVARIANTS (mínimo 1 OWNER)
    // =========================================================

    @Query("""
        select count(u) from TenantUser u
         where u.accountId = :accountId
           and u.deleted = false
           and u.suspendedByAccount = false
           and u.suspendedByAdmin = false
           and u.role = :ownerRole
    """)
    long countActiveOwnersByAccountId(
            @Param("accountId") Long accountId,
            @Param("ownerRole") TenantRole ownerRole
    );

    @Query("""
        select count(u) from TenantUser u
         where u.accountId = :accountId
           and u.deleted = false
           and u.role = :role
    """)
    long countNotDeletedByAccountIdAndRole(
            @Param("accountId") Long accountId,
            @Param("role") TenantRole role
    );

    // =========================================================
    // SCOPED ID (READ)
    // =========================================================

    Optional<TenantUser> findByIdAndAccountIdAndDeletedFalse(Long id, Long accountId);

    @Query("""
        select u from TenantUser u
        where u.id = :id
          and u.accountId = :accountId
          and u.deleted = false
          and u.suspendedByAccount = false
          and u.suspendedByAdmin = false
    """)
    Optional<TenantUser> findEnabledByIdAndAccountId(
            @Param("id") Long id,
            @Param("accountId") Long accountId
    );

    @Query("""
        select u from TenantUser u
        where u.id = :id
          and u.accountId = :accountId
    """)
    Optional<TenantUser> findIncludingDeletedByIdAndAccountId(
            @Param("id") Long id,
            @Param("accountId") Long accountId
    );

    default Optional<TenantUser> findAnyByIdAndAccountId(Long id, Long accountId) {
        return findIncludingDeletedByIdAndAccountId(id, accountId);
    }

    // =========================================================
    // UPDATE: SUSPENSÕES
    // =========================================================

    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @TenantTx
    @Query("""
        update TenantUser u
           set u.suspendedByAdmin = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAdmin(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @TenantTx
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = :suspended
         where u.id = :userId
           and u.accountId = :accountId
           and u.deleted = false
    """)
    int setSuspendedByAccount(
            @Param("accountId") Long accountId,
            @Param("userId") Long userId,
            @Param("suspended") boolean suspended
    );

    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @TenantTx
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = true
         where u.accountId = :accountId
           and u.deleted = false
           and u.role <> :excludedRole
    """)
    int suspendAllByAccountExceptRole(
            @Param("accountId") Long accountId,
            @Param("excludedRole") TenantRole excludedRole
    );

    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @TenantTx
    @Query("""
        update TenantUser u
           set u.suspendedByAccount = false
         where u.accountId = :accountId
           and u.deleted = false
    """)
    int unsuspendAllByAccount(@Param("accountId") Long accountId);

    /**
     * ✅ NOVO (SAFE): soft-delete em massa por conta, EXCETO uma role (ex: TENANT_OWNER).
     */
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @TenantTx
    @Query("""
        update TenantUser u
           set u.deleted = true,
               u.audit.deletedAt = :deletedAt
         where u.accountId = :accountId
           and u.deleted = false
           and u.role <> :excludedRole
    """)
    int softDeleteAllByAccountExceptRole(
            @Param("accountId") Long accountId,
            @Param("excludedRole") TenantRole excludedRole,
            @Param("deletedAt") Instant deletedAt
    );

    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @TenantTx
    @Query("""
        update TenantUser u
           set u.deleted = false,
               u.audit.deletedAt = null
         where u.accountId = :accountId
           and u.deleted = true
    """)
    int restoreAllByAccount(@Param("accountId") Long accountId);

    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @TenantTx
    @Query("""
        update TenantUser u
           set u.lastLoginAt = :lastLogin
         where u.id = :userId
           and u.deleted = false
    """)
    int updateLastLogin(
            @Param("userId") Long userId,
            @Param("lastLogin") Instant lastLogin
    );
}

============================================================
### FILE: src/main/resources/application-dev.properties
============================================================
# application-dev.properties


# =========================================================
# LOGS - DEV
# =========================================================
logging.level.org.flywaydb=DEBUG
logging.level.org.springframework.jdbc.core=TRACE
logging.level.org.springframework.jdbc.datasource.init=DEBUG

# =========================================================
# SPRINGDOC (DEV ON)
# =========================================================
springdoc.api-docs.enabled=true
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha

springdoc.swagger-ui.urls[0].name=tenant
springdoc.swagger-ui.urls[0].url=/v3/api-docs/tenant

springdoc.swagger-ui.urls[1].name=controlplane
springdoc.swagger-ui.urls[1].url=/v3/api-docs/controlplane

springdoc.swagger-ui.urls[2].name=admin
springdoc.swagger-ui.urls[2].url=/v3/api-docs/admin

springdoc.swagger-ui.urls[3].name=public
springdoc.swagger-ui.urls[3].url=/v3/api-docs/public

springdoc.swagger-ui.urlsPrimaryName=tenant

# Opicional: remove apenas o banner do Spring Boot (no afeta logs)
spring.main.banner-mode=off




============================================================
### FILE: src/main/resources/application.properties
============================================================
# arquivo application.properties

spring.application.name=multitenancy001

# =========================================================
# JWT
# =========================================================
app.jwt.secret=AHJ8d9sj29DKs0923kslaS90sldj1029askd0asdj19203kdls0asdj19203kdas0d9s
app.jwt.expiration=3600000
app.jwt.refresh.expiration=604800000

# =========================================================
# DATABASE
# =========================================================
spring.datasource.url=jdbc:postgresql://localhost:5432/db_multitenancy
spring.datasource.username=postgres
spring.datasource.password=admin
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# IMPORTANTE: DESATIVE criacao automatica do Hibernate
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.open-in-view=false

# =========================================================
# FLYWAY
# =========================================================
# \u2705 Voc controla Flyway via @Bean (PublicFlywayConfig), ento desligue o autoconfig por properties
spring.flyway.enabled=false

# =========================================================
# LOGS (DEFAULT)
# =========================================================
logging.level.org.flywaydb=INFO
logging.level.org.springframework.jdbc.core=OFF
logging.level.org.springframework.jdbc.datasource.init=OFF

logging.level.org.hibernate.SQL=OFF
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=OFF

# =========================================================
# HIKARI
# =========================================================
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.max-lifetime=1200000

# =========================================================
# ACTUATOR
# =========================================================
management.endpoints.web.exposure.include=health
management.endpoint.health.show-details=never
management.endpoints.web.base-path=/actuator

# =========================================================
# SPRINGDOC (default OFF)
# =========================================================
springdoc.api-docs.enabled=false
springdoc.swagger-ui.enabled=false

spring.profiles.active=dev

============================================================
### FILE: src/main/resources/db/migration/accounts/V10__create_table_account_provisioning_events.sql
============================================================
-- V10__create_table_account_provisioning_events.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS public.account_provisioning_events (
    id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    failure_code VARCHAR(50),
    message TEXT,
    details_json TEXT,
    created_at TIMESTAMPTZ NOT NULL,

    CONSTRAINT fk_account_prov_events_account
        FOREIGN KEY (account_id) REFERENCES public.accounts(id)
);

CREATE INDEX IF NOT EXISTS idx_account_prov_events_account_id
    ON public.account_provisioning_events (account_id);

CREATE INDEX IF NOT EXISTS idx_account_prov_events_created_at
    ON public.account_provisioning_events (created_at);


============================================================
### FILE: src/main/resources/db/migration/accounts/V11__create_table_tenant_login_challenges.sql
============================================================
-- V11__create_table_tenant_login_challenges.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS tenant_login_challenges (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    email CITEXT NOT NULL,

    -- CSV simples de accountIds válidos (ex: "1,2,3")
    candidate_account_ids TEXT NOT NULL,

    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    expires_at TIMESTAMPTZ NOT NULL,
    used_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_tenant_login_challenges_email
    ON tenant_login_challenges (email);

CREATE INDEX IF NOT EXISTS idx_tenant_login_challenges_expires_at
    ON tenant_login_challenges (expires_at);

CREATE INDEX IF NOT EXISTS idx_tenant_login_challenges_used_at
    ON tenant_login_challenges (used_at);


============================================================
### FILE: src/main/resources/db/migration/accounts/V12__seed_account_entitlements_for_existing_accounts.sql
============================================================
-- V12__seed_account_entitlements_for_existing_accounts.sql
SET search_path TO public;

INSERT INTO account_entitlements (
    account_id,
    max_users,
    max_products,
    max_storage_mb,
    created_at,
    updated_at
)
SELECT
    a.id,
    5,
    100,
    100,
    now(),
    now()
FROM accounts a
WHERE a.deleted = false
  AND a.account_type = 'TENANT'
  AND a.account_origin <> 'BUILT_IN'
ON CONFLICT (account_id) DO NOTHING;


============================================================
### FILE: src/main/resources/db/migration/accounts/V13__create_table_auth_events.sql
============================================================
-- V13__create_table_auth_events.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS auth_events (
    id BIGSERIAL PRIMARY KEY,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    request_id UUID,
    method TEXT,
    uri TEXT,

    ip INET,
    user_agent TEXT,

    auth_domain TEXT,
    event_type TEXT NOT NULL,
    outcome TEXT NOT NULL,

    principal_email CITEXT,
    principal_user_id BIGINT,

    account_id BIGINT,
    tenant_schema TEXT,

    details JSONB
);

CREATE INDEX IF NOT EXISTS idx_auth_events_occurred_at ON auth_events (occurred_at);
CREATE INDEX IF NOT EXISTS idx_auth_events_request_id ON auth_events (request_id);
CREATE INDEX IF NOT EXISTS idx_auth_events_email ON auth_events (principal_email);
CREATE INDEX IF NOT EXISTS idx_auth_events_account_id ON auth_events (account_id);
CREATE INDEX IF NOT EXISTS idx_auth_events_tenant_schema ON auth_events (tenant_schema);


============================================================
### FILE: src/main/resources/db/migration/accounts/V14__create_table_security_audit_events.sql
============================================================
-- V14__create_table_security_audit_events.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS security_audit_events (
    id BIGSERIAL PRIMARY KEY,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    request_id UUID,
    method TEXT,
    uri TEXT,

    ip INET,
    user_agent TEXT,

    action_type TEXT NOT NULL,
    outcome TEXT NOT NULL,

    actor_email CITEXT,
    actor_user_id BIGINT,

    target_email CITEXT,
    target_user_id BIGINT,

    account_id BIGINT,
    tenant_schema TEXT,

    details JSONB
);

CREATE INDEX IF NOT EXISTS idx_security_audit_occurred_at ON security_audit_events (occurred_at);
CREATE INDEX IF NOT EXISTS idx_security_audit_request_id ON security_audit_events (request_id);
CREATE INDEX IF NOT EXISTS idx_security_audit_action_type ON security_audit_events (action_type);
CREATE INDEX IF NOT EXISTS idx_security_audit_account_id ON security_audit_events (account_id);


============================================================
### FILE: src/main/resources/db/migration/accounts/V15__create_table_account_job_schedules.sql
============================================================
-- V15__create_table_account_job_schedules.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS account_job_schedules (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,
    job_key VARCHAR(80) NOT NULL,

    -- horário civil
    local_time TIME NOT NULL,
    -- timezone IANA (ex: America/Sao_Paulo)
    zone_id VARCHAR(60) NOT NULL,

    enabled BOOLEAN NOT NULL DEFAULT true,

    -- rastreabilidade e controle
    last_run_at TIMESTAMPTZ,
    next_run_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_account_job_schedules_account
        FOREIGN KEY (account_id) REFERENCES public.accounts(id),

    CONSTRAINT uq_account_job_schedules UNIQUE (account_id, job_key)
);

CREATE INDEX IF NOT EXISTS idx_account_job_schedules_next_run
    ON account_job_schedules (enabled, next_run_at);

============================================================
### FILE: src/main/resources/db/migration/accounts/V16__alter_controlplane_users_email_to_citext.sql
============================================================
-- V16__alter_controlplane_users_email_to_citext.sql
SET search_path TO public;


-- email: VARCHAR(150) -> CITEXT (case-insensitive)
ALTER TABLE public.controlplane_users
    ALTER COLUMN email TYPE CITEXT
    USING email::citext;

-- opcional: índice já existe (idx_cp_users_email). Se quiser recriar como citext não precisa.

============================================================
### FILE: src/main/resources/db/migration/accounts/V17__protect_builtin_controlplane_users.sql
============================================================
-- V17__protect_builtin_controlplane_users.sql
SET search_path TO public;

-- =========================================================
-- 1) Protege controlplane_users (BUILT_IN) contra alterações proibidas
-- =========================================================

CREATE OR REPLACE FUNCTION fn_cp_users_protect_builtin()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    -- BLOQUEIA DELETE de BUILT_IN
    IF (TG_OP = 'DELETE') THEN
        IF (OLD.user_origin = 'BUILT_IN') THEN
            RAISE EXCEPTION 'BUILT_IN_USER_IMMUTABLE: cannot delete controlplane user id=%', OLD.id
                USING ERRCODE = '42501'; -- insufficient_privilege (semântica: operação proibida)
        END IF;
        RETURN OLD;
    END IF;

    -- BLOQUEIA UPDATE de campos proibidos em BUILT_IN
    IF (TG_OP = 'UPDATE') THEN
        IF (OLD.user_origin = 'BUILT_IN') THEN

            -- Permitimos apenas campos operacionais/segurança e senha:
            -- password, must_change_password, password_changed_at,
            -- last_login, locked_until,
            -- password_reset_token, password_reset_expires,
            -- audit fields (created_*, updated_*, deleted_*)

            IF (NEW.name IS DISTINCT FROM OLD.name)
               OR (NEW.email IS DISTINCT FROM OLD.email)
               OR (NEW.role IS DISTINCT FROM OLD.role)
               OR (NEW.account_id IS DISTINCT FROM OLD.account_id)
               OR (NEW.user_origin IS DISTINCT FROM OLD.user_origin)
               OR (NEW.deleted IS DISTINCT FROM OLD.deleted)
               OR (NEW.suspended_by_account IS DISTINCT FROM OLD.suspended_by_account)
               OR (NEW.suspended_by_admin IS DISTINCT FROM OLD.suspended_by_admin)
            THEN
                RAISE EXCEPTION 'BUILT_IN_USER_IMMUTABLE: forbidden update on BUILT_IN user id=%', OLD.id
                    USING ERRCODE = '42501';
            END IF;
        END IF;

        RETURN NEW;
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_cp_users_protect_builtin ON controlplane_users;

CREATE TRIGGER trg_cp_users_protect_builtin
BEFORE UPDATE OR DELETE ON controlplane_users
FOR EACH ROW
EXECUTE FUNCTION fn_cp_users_protect_builtin();


-- =========================================================
-- 2) Protege controlplane_user_permissions para BUILT_IN
-- =========================================================

CREATE OR REPLACE FUNCTION fn_cp_user_permissions_protect_builtin()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
    v_origin VARCHAR(20);
    v_user_id BIGINT;
BEGIN
    IF (TG_OP = 'DELETE') THEN
        v_user_id := OLD.user_id;
    ELSE
        v_user_id := NEW.user_id;
    END IF;

    SELECT u.user_origin INTO v_origin
      FROM controlplane_users u
     WHERE u.id = v_user_id;

    IF (v_origin = 'BUILT_IN') THEN
        RAISE EXCEPTION 'BUILT_IN_USER_IMMUTABLE: cannot change permissions for BUILT_IN user id=%', v_user_id
            USING ERRCODE = '42501';
    END IF;

    IF (TG_OP = 'DELETE') THEN
        RETURN OLD;
    END IF;
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_cp_user_permissions_protect_builtin ON controlplane_user_permissions;

CREATE TRIGGER trg_cp_user_permissions_protect_builtin
BEFORE INSERT OR UPDATE OR DELETE ON controlplane_user_permissions
FOR EACH ROW
EXECUTE FUNCTION fn_cp_user_permissions_protect_builtin();

============================================================
### FILE: src/main/resources/db/migration/accounts/V18__create_table_auth_refresh_sessions.sql
============================================================
-- ============================================================
-- V18__create_table_auth_refresh_sessions.sql
--
-- Tabela no PUBLIC schema para suportar:
-- - Refresh com rotação
-- - Logout forte (revogação server-side)
-- - Revogar “all devices”
--
-- Observações:
-- - refresh_token_hash guarda hash (não armazena o token puro)
-- - session_domain indica se a sessão é CONTROLPLANE ou TENANT
-- - tenant_schema é preenchido apenas para TENANT
-- ============================================================

SET search_path TO public;

CREATE TABLE IF NOT EXISTS auth_refresh_sessions (
    id                  UUID PRIMARY KEY,
    session_domain       VARCHAR(32) NOT NULL,     -- CONTROLPLANE | TENANT
    account_id           BIGINT NOT NULL,
    user_id              BIGINT NOT NULL,

    tenant_schema        VARCHAR(128),             -- NULL para CONTROLPLANE

    refresh_token_hash   VARCHAR(128) NOT NULL,    -- hash SHA-256 (hex) do refresh token

    created_at           TIMESTAMPTZ NOT NULL,
    last_used_at         TIMESTAMPTZ,
    rotated_at           TIMESTAMPTZ,
    revoked_at           TIMESTAMPTZ,

    created_request_id   UUID,
    last_request_id      UUID,

    created_ip           VARCHAR(64),
    last_ip              VARCHAR(64),

    created_user_agent   VARCHAR(512),
    last_user_agent      VARCHAR(512),

    revoked_reason_json  TEXT
);

-- 1 sessão “corrente” por refresh hash (hash deve ser único)
CREATE UNIQUE INDEX IF NOT EXISTS ux_auth_refresh_sessions_refresh_hash
    ON auth_refresh_sessions (refresh_token_hash);

-- consultas comuns
CREATE INDEX IF NOT EXISTS ix_auth_refresh_sessions_user_lookup
    ON auth_refresh_sessions (session_domain, account_id, user_id, revoked_at);

CREATE INDEX IF NOT EXISTS ix_auth_refresh_sessions_tenant_lookup
    ON auth_refresh_sessions (tenant_schema, account_id, user_id, revoked_at);

CREATE INDEX IF NOT EXISTS ix_auth_refresh_sessions_last_used
    ON auth_refresh_sessions (last_used_at);

============================================================
### FILE: src/main/resources/db/migration/accounts/V19__add_check_auth_refresh_sessions_domain.sql
============================================================
-- src/main/resources/db/migration/accounts/V19__add_check_auth_refresh_sessions_domain.sql
-- ============================================================
-- Garante domínios válidos e consistência tenant_schema vs session_domain
-- ============================================================

SET search_path TO public;

ALTER TABLE auth_refresh_sessions
    ADD CONSTRAINT ck_auth_refresh_sessions_domain
        CHECK (session_domain IN ('CONTROLPLANE', 'TENANT'));

ALTER TABLE auth_refresh_sessions
    ADD CONSTRAINT ck_auth_refresh_sessions_tenant_schema_consistency
        CHECK (
            (session_domain = 'CONTROLPLANE' AND tenant_schema IS NULL)
            OR
            (session_domain = 'TENANT' AND tenant_schema IS NOT NULL AND length(trim(tenant_schema)) > 0)
        );
============================================================
### FILE: src/main/resources/db/migration/accounts/V1__create_extension.sql
============================================================
-- V1__create_extension.sql
SET search_path TO public;

CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS citext;


============================================================
### FILE: src/main/resources/db/migration/accounts/V20__create_account_job_schedules.sql
============================================================
-- =========================================================
-- Account Job Schedules (Control Plane)
-- =========================================================
-- Responsável por agendamentos internos do sistema
-- (jobs administrativos, billing, manutenção, etc.)
--
-- IMPORTANTE:
-- - Sempre criado no schema PUBLIC
-- - Nunca depende de tenant schema
-- =========================================================

CREATE TABLE IF NOT EXISTS public.account_job_schedules (
    id              BIGSERIAL PRIMARY KEY,

    account_id      BIGINT      NOT NULL,
    job_key         VARCHAR(100) NOT NULL,

    enabled         BOOLEAN     NOT NULL DEFAULT TRUE,

    local_time      TIME        NOT NULL,
    zone_id         VARCHAR(50) NOT NULL,

    next_run_at     TIMESTAMPTZ,
    last_run_at     TIMESTAMPTZ,

    created_at      TIMESTAMPTZ NOT NULL,
    updated_at      TIMESTAMPTZ NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_account_job_schedules_enabled_next_run
    ON public.account_job_schedules (enabled, next_run_at);

CREATE INDEX IF NOT EXISTS idx_account_job_schedules_account
    ON public.account_job_schedules (account_id);

CREATE UNIQUE INDEX IF NOT EXISTS uq_account_job_schedules_account_job
    ON public.account_job_schedules (account_id, job_key);
============================================================
### FILE: src/main/resources/db/migration/accounts/V2__create_table_accounts.sql
============================================================
-- V2__create_table_accounts.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS accounts (
    id BIGSERIAL PRIMARY KEY,

    -- Removido o DEFAULT e o CHECK será gerenciado pela aplicação
    account_type   VARCHAR(20) NOT NULL,
    -- Removido o DEFAULT e o CHECK será gerenciado pela aplicação
    account_origin VARCHAR(20) NOT NULL,

    display_name VARCHAR(150) NOT NULL,
    legal_name   VARCHAR(200),
    legal_entity_type VARCHAR(20) NOT NULL,

    tenant_schema VARCHAR(100) NOT NULL,
    slug        VARCHAR(80)  NOT NULL,

    status            VARCHAR(50) NOT NULL,
    subscription_plan VARCHAR(50) NOT NULL,

    -- emails case-insensitive
    login_email   CITEXT NOT NULL,
    billing_email CITEXT,

    tax_id_type      VARCHAR(20),
    tax_id_number    VARCHAR(40),
    tax_country_code VARCHAR(2)  NOT NULL DEFAULT 'BR',

    phone   VARCHAR(20),
    address VARCHAR(500),
    city    VARCHAR(100),
    state   VARCHAR(50),
    country VARCHAR(60) NOT NULL DEFAULT 'Brasil',

    timezone VARCHAR(60) NOT NULL DEFAULT 'America/Sao_Paulo',
    locale   VARCHAR(20) NOT NULL DEFAULT 'pt_BR',
    currency VARCHAR(3)  NOT NULL DEFAULT 'BRL',

    -- auditoria (instantes reais)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    created_by BIGINT,
    updated_by BIGINT,
    deleted_by BIGINT,

    created_by_email CITEXT,
    updated_by_email CITEXT,
    deleted_by_email CITEXT,

    trial_end_at    TIMESTAMPTZ,
    payment_due_date  DATE,
    next_billing_date DATE,

    settings_json TEXT,
    metadata_json TEXT,

    deleted    BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMPTZ
);

-- =========================
-- Índices/Uniqueness (soft-delete aware)
-- =========================
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_tenant_schema_active
    ON accounts (tenant_schema)
    WHERE deleted = false;

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_slug_active
    ON accounts (slug)
    WHERE deleted = false;

CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_login_email_active
    ON accounts (login_email)
    WHERE deleted = false;

-- tax_id pode ser nulo (permitir múltiplos nulos)
CREATE UNIQUE INDEX IF NOT EXISTS ux_accounts_tax_id_active
    ON accounts (tax_id_type, tax_id_number, tax_country_code)
    WHERE deleted = false AND tax_id_number IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_accounts_status ON accounts (status);
CREATE INDEX IF NOT EXISTS idx_accounts_deleted ON accounts (deleted);
CREATE INDEX IF NOT EXISTS idx_accounts_created_at ON accounts (created_at);
CREATE INDEX IF NOT EXISTS idx_accounts_payment_due_date ON accounts (payment_due_date) WHERE deleted = false;
CREATE INDEX IF NOT EXISTS idx_accounts_trial_end_at ON accounts (trial_end_at) WHERE deleted = false;

-- Adicionar ao final do arquivo V2__create_table_accounts.sql

-- Índices para consultas frequentes por localização
CREATE INDEX IF NOT EXISTS idx_accounts_country ON accounts(country) WHERE deleted = false;
CREATE INDEX IF NOT EXISTS idx_accounts_timezone ON accounts(timezone) WHERE deleted = false;

-- Índice para busca por billing_email (quando usado)
CREATE INDEX IF NOT EXISTS idx_accounts_billing_email ON accounts(billing_email) WHERE deleted = false AND billing_email IS NOT NULL;

-- Índice para consultas de trial expirado (usado em jobs)
CREATE INDEX IF NOT EXISTS idx_accounts_trial_status ON accounts(status, trial_end_at) WHERE deleted = false;

-- Índice para consultas de pagamento atrasado (usado em jobs)
CREATE INDEX IF NOT EXISTS idx_accounts_payment_status ON accounts(status, payment_due_date) WHERE deleted = false;


============================================================
### FILE: src/main/resources/db/migration/accounts/V3__create_table_account_entitlements.sql
============================================================
-- V3__create_table_account_entitlements.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS account_entitlements (
    account_id      BIGINT PRIMARY KEY,
    max_users       INTEGER NOT NULL,
    max_products    INTEGER NOT NULL,
    max_storage_mb  INTEGER NOT NULL DEFAULT 100,

    created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint c
        JOIN pg_class t ON t.oid = c.conrelid
        JOIN pg_namespace n ON n.oid = t.relnamespace
        WHERE c.conname = 'fk_account_entitlements_account'
          AND n.nspname = 'public'
          AND t.relname = 'account_entitlements'
    ) THEN
        ALTER TABLE public.account_entitlements
            ADD CONSTRAINT fk_account_entitlements_account
            FOREIGN KEY (account_id) REFERENCES public.accounts(id)
            ON DELETE CASCADE;
    END IF;
END $$;


============================================================
### FILE: src/main/resources/db/migration/accounts/V4__create_table_controlplane_users.sql
============================================================
-- V4__create_table_controlplane_users.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_users (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL REFERENCES accounts(id),

    user_origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    name VARCHAR(100) NOT NULL,

    -- ✅ padronizado: email case-insensitive
    email CITEXT NOT NULL,

    password VARCHAR(255) NOT NULL,

    role VARCHAR(50),

    -- AUTH / SECURITY (Instant <-> TIMESTAMPTZ)
    must_change_password BOOLEAN NOT NULL DEFAULT FALSE,
    last_login TIMESTAMPTZ NULL,
    locked_until TIMESTAMPTZ NULL,
    password_changed_at TIMESTAMPTZ NULL,
    password_reset_token VARCHAR(200) NULL,
    password_reset_expires TIMESTAMPTZ NULL,

    -- STATUS
    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin BOOLEAN NOT NULL DEFAULT FALSE,
    deleted BOOLEAN NOT NULL DEFAULT FALSE,

    -- AUDIT (fonte única) - ✅ alinhado com a Entity (inclui *_by_email)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by BIGINT NULL,
    created_by_email CITEXT NULL,

    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by BIGINT NULL,
    updated_by_email CITEXT NULL,

    deleted_at TIMESTAMPTZ NULL,
    deleted_by BIGINT NULL,
    deleted_by_email CITEXT NULL
);

CREATE INDEX IF NOT EXISTS idx_cp_users_account_id ON controlplane_users(account_id);
CREATE INDEX IF NOT EXISTS idx_cp_users_email ON controlplane_users(email);

============================================================
### FILE: src/main/resources/db/migration/accounts/V5__insert_controlplane_account.sql
============================================================
-- V5__insert_controlplane_account.sql
SET search_path TO public;

INSERT INTO accounts (
    account_type,
    account_origin,
    display_name,
    legal_name,
    legal_entity_type,
    tenant_schema,
    slug,
    status,
    subscription_plan,
    tax_id_type,
    tax_id_number,
    tax_country_code,
    login_email,
    billing_email,
    country,
    timezone,
    locale,
    currency,
    deleted
)
SELECT
    'PLATFORM',
    'BUILT_IN',
    'Control Plane',
    NULL,
    'COMPANY',
    'public',
    'controlplane',
    'ACTIVE',
    'BUILT_IN_PLAN',
    'CNPJ',
    '00000000000000',
    'BR',
    'admin@controlplane.com',
    NULL,
    'Brasil',
    'America/Sao_Paulo',
    'pt_BR',
    'BRL',
    false
WHERE NOT EXISTS (
    SELECT 1 FROM accounts WHERE slug = 'controlplane'
);


============================================================
### FILE: src/main/resources/db/migration/accounts/V6__insert_controlplane_users.sql
============================================================
-- V6__insert_controlplane_users.sql
SET search_path TO public;

WITH cp_account AS (
    SELECT id
    FROM accounts
    WHERE slug = 'controlplane'
    LIMIT 1
)
INSERT INTO controlplane_users (
    name,
    email,
    password,
    role,
    account_id,
    user_origin,
    suspended_by_account,
    suspended_by_admin,
    must_change_password,
    password_changed_at
)
SELECT
    u.name,
    u.email,
    u.password,
    u.role,
    a.id,
    'BUILT_IN',
    false,
    false,
    u.must_change_password,
    CASE
        WHEN u.must_change_password = false THEN now()
        ELSE NULL
    END
FROM cp_account a
JOIN (
    VALUES
      ('ControlPlane Super Admin', 'superadmin@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OWNER', false),

      ('ControlPlane Billing Manager', 'billing@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_BILLING_MANAGER', true),

      ('ControlPlane Support', 'support@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_SUPPORT', true),

      ('ControlPlane Operator', 'operator@platform.local',
       '$2a$10$NHoV1pUU3gMGp87cYuvtReeq1iMqDOeHknZhrgzAcaygIVSuLFSQy',
       'CONTROLPLANE_OPERATOR', true)

) AS u(name, email, password, role, must_change_password)
ON TRUE
WHERE NOT EXISTS (
    SELECT 1
    FROM controlplane_users existing
    WHERE existing.account_id = a.id
      AND existing.deleted = false
      AND existing.email = u.email
);

============================================================
### FILE: src/main/resources/db/migration/accounts/V7__create_table_controlplane_user_permissions.sql
============================================================
-- V7__create_table_controlplane_user_permissions.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS controlplane_user_permissions (
    user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (user_id, permission),

    CONSTRAINT fk_cp_user_permissions_user
        FOREIGN KEY (user_id)
        REFERENCES controlplane_users(id)
        ON DELETE CASCADE
);


============================================================
### FILE: src/main/resources/db/migration/accounts/V8__create_table_payments.sql
============================================================
-- V8__create_table_payments.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS payments (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL REFERENCES accounts(id),

    -- alinhado com Payment.java
    amount NUMERIC(14,2) NOT NULL,

    -- enums como STRING
    payment_method  VARCHAR(50) NOT NULL,
    payment_gateway VARCHAR(50) NOT NULL,
    status          VARCHAR(20) NOT NULL DEFAULT 'PENDING',

    currency VARCHAR(3) NOT NULL DEFAULT 'BRL',

    transaction_id VARCHAR(100) UNIQUE,
    description VARCHAR(500),

    metadata_json TEXT,
    invoice_url   TEXT,
    receipt_url   TEXT,

    -- instantes reais (Instant <-> TIMESTAMPTZ)
    payment_date TIMESTAMPTZ NOT NULL,
    valid_until  TIMESTAMPTZ,
    refunded_at  TIMESTAMPTZ,

    refund_amount NUMERIC(14,2),
    refund_reason VARCHAR(500),

    -- auditoria (seu padrão AuditInfo)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    created_by BIGINT,
    updated_by BIGINT,
    deleted_by BIGINT,

    created_by_email CITEXT,
    updated_by_email CITEXT,
    deleted_by_email CITEXT,

    deleted    BOOLEAN NOT NULL DEFAULT false,
    deleted_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_payments_account_id ON payments (account_id);
CREATE INDEX IF NOT EXISTS idx_payments_status     ON payments (status);
CREATE INDEX IF NOT EXISTS idx_payments_payment_date ON payments (payment_date);

============================================================
### FILE: src/main/resources/db/migration/accounts/V9__create_table_login_identities.sql
============================================================
-- V9__create_table_login_identities.sql
SET search_path TO public;

CREATE TABLE IF NOT EXISTS login_identities (
    id BIGSERIAL PRIMARY KEY,

    email CITEXT NOT NULL,

    -- "SaaS moderno top": identity aponta para um subject (não para email na tabela do user)
    subject_type VARCHAR(40) NOT NULL,  -- 'CONTROLPLANE_USER' | 'TENANT_ACCOUNT'
    subject_id   BIGINT NOT NULL,

    -- mantém account_id para tenant (seu loginInit lista contas por email)
    account_id BIGINT,

    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT chk_login_identities_subject_type
        CHECK (subject_type IN ('CONTROLPLANE_USER', 'TENANT_ACCOUNT')),

    CONSTRAINT chk_login_identities_shape
        CHECK (
            -- CP: identity global (account_id NULL), subject_id = controlplane_users.id
            (subject_type = 'CONTROLPLANE_USER' AND account_id IS NULL)
            OR
            -- Tenant: identity por conta (account_id NOT NULL), subject_id = account_id (lookup)
            (subject_type = 'TENANT_ACCOUNT' AND account_id IS NOT NULL AND subject_id = account_id)
        ),

    CONSTRAINT fk_login_identities_account
        FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE
);

-- Unicidade CP por email (um email -> um CP user)
CREATE UNIQUE INDEX IF NOT EXISTS ux_login_identity_cp_email
    ON login_identities (email)
    WHERE subject_type = 'CONTROLPLANE_USER';

-- Unicidade CP por subject (um CP user -> um email identity)
CREATE UNIQUE INDEX IF NOT EXISTS ux_login_identity_cp_subject
    ON login_identities (subject_type, subject_id)
    WHERE subject_type = 'CONTROLPLANE_USER';

-- Tenant: mesmo email pode existir em várias contas
CREATE UNIQUE INDEX IF NOT EXISTS ux_login_identity_tenant_email_account
    ON login_identities (email, account_id)
    WHERE subject_type = 'TENANT_ACCOUNT';

CREATE INDEX IF NOT EXISTS idx_login_identities_email
    ON login_identities (email);

CREATE INDEX IF NOT EXISTS idx_login_identities_subject
    ON login_identities (subject_type, subject_id);
    
    
-- Seed: cria login identities para usuários BUILT-IN do Control Plane
-- (necessário para /api/controlplane/auth/login não dar USER_NOT_FOUND)

INSERT INTO public.login_identities (email, subject_type, subject_id, account_id)
SELECT
    cu.email,
    'CONTROLPLANE_USER',
    cu.id,
    NULL
FROM public.controlplane_users cu
WHERE cu.deleted = false
  AND cu.user_origin = 'BUILT_IN'
  -- evita conflito com ux_login_identity_cp_subject
  AND NOT EXISTS (
      SELECT 1
      FROM public.login_identities li
      WHERE li.subject_type = 'CONTROLPLANE_USER'
        AND li.subject_id = cu.id
  )
  -- evita conflito com ux_login_identity_cp_email
  AND NOT EXISTS (
      SELECT 1
      FROM public.login_identities li
      WHERE li.subject_type = 'CONTROLPLANE_USER'
        AND li.email = cu.email
  );
    

============================================================
### FILE: src/main/resources/db/migration/tenants/V1__create_table_tenant_users.sql
============================================================
-- V1__create_table_tenant_users.sql

CREATE TABLE IF NOT EXISTS tenant_users (
    id BIGSERIAL PRIMARY KEY,

    account_id BIGINT NOT NULL,

    name VARCHAR(100) NOT NULL,
    email CITEXT NOT NULL,
    password VARCHAR(200) NOT NULL,

    role VARCHAR(50) NOT NULL,

    phone VARCHAR(20) NULL,
    avatar_url VARCHAR(500) NULL,
    timezone VARCHAR(50) NULL,
    locale VARCHAR(10) NULL,

    must_change_password BOOLEAN NOT NULL DEFAULT FALSE,
    origin VARCHAR(20) NOT NULL DEFAULT 'ADMIN',

    last_login TIMESTAMPTZ NULL,
    locked_until TIMESTAMPTZ NULL,
    password_changed_at TIMESTAMPTZ NULL,

    password_reset_token VARCHAR(200) NULL,
    password_reset_expires TIMESTAMPTZ NULL,

    suspended_by_account BOOLEAN NOT NULL DEFAULT FALSE,
    suspended_by_admin BOOLEAN NOT NULL DEFAULT FALSE,

    deleted BOOLEAN NOT NULL DEFAULT FALSE,

    -- AUDIT (fonte única)
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by BIGINT NULL,
    created_by_email CITEXT  NULL,

    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_by BIGINT NULL,
    updated_by_email CITEXT  NULL,

    deleted_at TIMESTAMPTZ NULL,
    deleted_by BIGINT NULL,
    deleted_by_email CITEXT  NULL
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_tenant_users_email_not_deleted
    ON tenant_users(email)
    WHERE deleted = FALSE;

CREATE INDEX IF NOT EXISTS ix_tenant_users_account_id
    ON tenant_users(account_id);

CREATE INDEX IF NOT EXISTS ix_tenant_users_deleted
    ON tenant_users(deleted);


============================================================
### FILE: src/main/resources/db/migration/tenants/V2__create_table_tenant_user_permissions.sql
============================================================
-- V2__create_table_tenant_user_permissions.sql
CREATE TABLE IF NOT EXISTS tenant_user_permissions (
    tenant_user_id BIGINT NOT NULL,
    permission VARCHAR(120) NOT NULL,

    PRIMARY KEY (tenant_user_id, permission),

    CONSTRAINT fk_tenant_user_permissions_user
        FOREIGN KEY (tenant_user_id)
        REFERENCES tenant_users(id)
        ON DELETE CASCADE
);

============================================================
### FILE: src/main/resources/db/migration/tenants/V3__create_table_categories.sql
============================================================
-- V3__create_table_categories.sql
CREATE TABLE IF NOT EXISTS categories (
  id BIGSERIAL PRIMARY KEY,

  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT,

  CONSTRAINT uk_categories_name UNIQUE (name)
);

CREATE INDEX IF NOT EXISTS idx_categories_active  ON categories(active);
CREATE INDEX IF NOT EXISTS idx_categories_deleted ON categories(deleted) WHERE deleted = false;
CREATE INDEX IF NOT EXISTS idx_categories_created_at ON categories(created_at);


============================================================
### FILE: src/main/resources/db/migration/tenants/V4__create_table_subcategories.sql
============================================================
-- V4__create_table_subcategories.sql

CREATE TABLE IF NOT EXISTS subcategories (
  id BIGSERIAL PRIMARY KEY,

  category_id BIGINT NOT NULL,
  name VARCHAR(100) NOT NULL,

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT,

  CONSTRAINT fk_subcategories_category
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE,

  CONSTRAINT uk_subcategories_name_category UNIQUE (category_id, name)
);

CREATE INDEX IF NOT EXISTS idx_subcategories_active  ON subcategories(active);
CREATE INDEX IF NOT EXISTS idx_subcategories_deleted ON subcategories(deleted) WHERE deleted = false;
CREATE INDEX IF NOT EXISTS idx_subcategories_category_id ON subcategories(category_id);


============================================================
### FILE: src/main/resources/db/migration/tenants/V5__create_table_suppliers.sql
============================================================
-- V5__create_table_suppliers.sql

CREATE TABLE IF NOT EXISTS suppliers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  contact_person VARCHAR(100),

  email VARCHAR(150),
  phone VARCHAR(20),
  address TEXT,

  document VARCHAR(20),
  document_type VARCHAR(10),

  website VARCHAR(200),
  payment_terms VARCHAR(100),

  lead_time_days INTEGER,
  rating NUMERIC(3,2),

  active  BOOLEAN NOT NULL DEFAULT true,
  deleted BOOLEAN NOT NULL DEFAULT false,

  notes TEXT,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_suppliers_document_active
  ON suppliers(document)
  WHERE document IS NOT NULL AND deleted = false;

CREATE INDEX IF NOT EXISTS idx_supplier_name    ON suppliers(name);
CREATE INDEX IF NOT EXISTS idx_supplier_email   ON suppliers(email);
CREATE INDEX IF NOT EXISTS idx_supplier_active  ON suppliers(active);
CREATE INDEX IF NOT EXISTS idx_supplier_deleted ON suppliers(deleted) WHERE deleted = false;


============================================================
### FILE: src/main/resources/db/migration/tenants/V6__create_table_products.sql
============================================================
-- V6__create_table_products.sql
CREATE TABLE IF NOT EXISTS products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name VARCHAR(200) NOT NULL,
  description TEXT,

  sku VARCHAR(100) NOT NULL,
  price NUMERIC(10,2) NOT NULL,

  stock_quantity INT NOT NULL DEFAULT 0,
  min_stock INT,
  max_stock INT,

  cost_price NUMERIC(10,2),
  profit_margin NUMERIC(12,2),

  category_id BIGINT NOT NULL,
  subcategory_id BIGINT NULL,

  brand VARCHAR(100),
  weight_kg NUMERIC(8,3),
  dimensions VARCHAR(50),
  barcode VARCHAR(50),

  active BOOLEAN NOT NULL DEFAULT true,

  images_json TEXT,
  attributes_json TEXT,

  supplier_id UUID NULL,

  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT,

  CONSTRAINT fk_products_category
    FOREIGN KEY (category_id) REFERENCES categories(id),

  CONSTRAINT fk_products_subcategory
    FOREIGN KEY (subcategory_id) REFERENCES subcategories(id),

  CONSTRAINT fk_product_supplier
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id),

  CONSTRAINT ck_products_sku_not_blank
    CHECK (length(trim(sku)) > 0)
);

CREATE UNIQUE INDEX IF NOT EXISTS ux_products_sku_not_deleted
  ON products (sku)
  WHERE deleted = false;

CREATE INDEX IF NOT EXISTS idx_products_name_lower
  ON products (LOWER(name));

CREATE INDEX IF NOT EXISTS idx_products_brand_lower
  ON products (LOWER(brand));

CREATE INDEX IF NOT EXISTS idx_products_active_deleted
  ON products (active, deleted);

CREATE INDEX IF NOT EXISTS idx_products_supplier_id ON products (supplier_id);
CREATE INDEX IF NOT EXISTS idx_products_category_id ON products (category_id);
CREATE INDEX IF NOT EXISTS idx_products_subcategory_id ON products (subcategory_id);
CREATE INDEX IF NOT EXISTS idx_products_created_at ON products (created_at);


============================================================
### FILE: src/main/resources/db/migration/tenants/V7__create_table_sales.sql
============================================================
-- V7__create_table_sales.sql

CREATE TABLE IF NOT EXISTS sales (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_date TIMESTAMPTZ NOT NULL,
  total_amount NUMERIC(12,2) NOT NULL,

  customer_name VARCHAR(200),
  customer_document VARCHAR(20),
  customer_email VARCHAR(150),
  customer_phone VARCHAR(20),

  status VARCHAR(20) NOT NULL,

  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT
);

CREATE INDEX IF NOT EXISTS idx_sales_sale_date ON sales(sale_date);
CREATE INDEX IF NOT EXISTS idx_sales_status ON sales(status);
CREATE INDEX IF NOT EXISTS idx_sales_deleted ON sales(deleted) WHERE deleted = false;


============================================================
### FILE: src/main/resources/db/migration/tenants/V8__create_table_sales_items.sql
============================================================
-- V8__create_table_sales_items.sql

CREATE TABLE IF NOT EXISTS sale_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  sale_id UUID NOT NULL,
  product_id UUID,
  product_name VARCHAR(255) NOT NULL,

  quantity NUMERIC(12,3) NOT NULL,
  unit_price NUMERIC(12,2) NOT NULL,
  total_price NUMERIC(12,2) NOT NULL,

  deleted BOOLEAN NOT NULL DEFAULT false,

  -- AUDIT (fonte única)
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by BIGINT,
  created_by_email CITEXT,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by BIGINT,
  updated_by_email CITEXT,

  deleted_at TIMESTAMPTZ,
  deleted_by BIGINT,
  deleted_by_email CITEXT,

  CONSTRAINT fk_sale_items_sale
    FOREIGN KEY (sale_id) REFERENCES sales(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_sale_items_sale_id ON sale_items(sale_id);
CREATE INDEX IF NOT EXISTS idx_sale_items_product_id ON sale_items(product_id);
CREATE INDEX IF NOT EXISTS idx_sale_items_deleted ON sale_items(deleted) WHERE deleted = false;


============================================================
### FILE: src/test/java/brito/com/multitenancy001/Multitenancy001ApplicationTests.java
============================================================
package brito.com.multitenancy001;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Multitenancy001ApplicationTests {

	@Test
	void contextLoads() {
	}

}


============================================================
### FILE: src/test/java/brito/com/multitenancy001/tenant/users/app/context/TenantUserRestoreVerifierTest.java
============================================================
package brito.com.multitenancy001.tenant.users.app.context;

import brito.com.multitenancy001.infrastructure.tenant.TenantExecutor;
import brito.com.multitenancy001.integration.security.TenantRequestIdentityService;
import brito.com.multitenancy001.shared.persistence.publicschema.AccountEntitlementsGuard;
import brito.com.multitenancy001.tenant.users.app.audit.TenantUserSecurityAuditRecorder;
import brito.com.multitenancy001.tenant.users.app.command.TenantUserCommandService;
import brito.com.multitenancy001.tenant.users.app.query.TenantUserQueryService;
import brito.com.multitenancy001.tenant.users.domain.TenantUser;

import org.junit.jupiter.api.Test;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.function.Supplier;

import static org.junit.jupiter.api.Assertions.assertSame;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

public class TenantUserRestoreVerifierTest {

    @Test
    @SuppressWarnings("unchecked")
    void restoreTenantUser_mustLookupIncludingDeleted_orRestoreWillBreak() {
        // mocks
        TenantUserCommandService commandService = mock(TenantUserCommandService.class);
        TenantUserQueryService queryService = mock(TenantUserQueryService.class);
        TenantExecutor tenantExecutor = mock(TenantExecutor.class);
        TenantRequestIdentityService requestIdentity = mock(TenantRequestIdentityService.class);
        AccountEntitlementsGuard entitlementsGuard = mock(AccountEntitlementsGuard.class);
        TenantUserSecurityAuditRecorder audit = mock(TenantUserSecurityAuditRecorder.class);

        // sut (system under test)
        TenantUserCurrentContextCommandService sut = new TenantUserCurrentContextCommandService(
                commandService,
                queryService,
                tenantExecutor,
                requestIdentity,
                entitlementsGuard,
                audit
        );

        // identity
        Long accountId = 2L;
        String tenantSchema = "t_tenant_x";
        Long userId = 99L;

        when(requestIdentity.getCurrentAccountId()).thenReturn(accountId);
        when(requestIdentity.getCurrentTenantSchema()).thenReturn(tenantSchema);

        // Mock do TenantExecutor - versão simplificada
        when(tenantExecutor.runInTenantSchema(eq(tenantSchema), any(Supplier.class)))
                .thenAnswer(inv -> ((Supplier<?>) inv.getArgument(1)).get());

        // IMPORTANT: restore must lookup including deleted
        TenantUser target = new TenantUser();
        target.setAccountId(accountId);
        target.changeEmail("user@tenant.local");
        target.setId(userId);

        when(queryService.getUserIncludingDeleted(eq(userId), eq(accountId))).thenReturn(target);

        // command restores and returns restored entity (simulate)
        when(commandService.restore(eq(userId), eq(accountId), eq(tenantSchema))).thenReturn(target);

        // audit details stubs (minimal)
        when(audit.baseDetails(anyString(), any(), any())).thenReturn(new LinkedHashMap<>(Map.of()));

        // act
        TenantUser restored = sut.restoreTenantUser(userId);

        // assert
        assertSame(target, restored);

        // regression guard: must call getUserIncludingDeleted (NOT getUser)
        verify(queryService, times(1)).getUserIncludingDeleted(eq(userId), eq(accountId));
        verify(queryService, never()).getUser(eq(userId), eq(accountId));

        verify(commandService, times(1)).restore(eq(userId), eq(accountId), eq(tenantSchema));
    }
}
